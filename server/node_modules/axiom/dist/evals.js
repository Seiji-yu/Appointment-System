import {
  AxiomReporter,
  createAppScope,
  deepEqual,
  dotNotationToNested,
  ensureInstrumentationInitialized,
  findBaseline,
  findEvaluationCases,
  flush,
  getConfigScope,
  getEvalContext,
  getGlobalFlagOverrides,
  setGlobalFlagOverrides,
  startSpan,
  validateCliFlags,
  withEvalContext
} from "./chunk-JOVIRPRL.js";
import {
  AxiomCLIError
} from "./chunk-NV3Y4T4G.js";
import {
  Attr
} from "./chunk-DITIARCU.js";
import {
  __publicField
} from "./chunk-EAWROPGL.js";

// src/evals/eval.ts
import { afterAll, beforeAll, describe, inject, it } from "vitest";
import { context, SpanStatusCode, trace } from "@opentelemetry/api";
import { customAlphabet } from "nanoid";

// src/evals/git-info.ts
import { execSync } from "child_process";
function getGitUserInfo() {
  try {
    const name = execSync("git config --get user.name").toString().trim();
    const email = execSync("git config --get user.email").toString().trim();
    return { name, email };
  } catch {
    return null;
  }
}

// src/evals/eval.ts
var nanoid = customAlphabet("1234567890abcdefghijklmnopqrstuvwxyz", 10);
function Eval(name, params) {
  registerEval(name, params).catch(console.error);
}
function captureFlagConfig(configFlags) {
  if (!configFlags || configFlags.length === 0) {
    return {};
  }
  const scope = getConfigScope();
  const allDefaults = scope?.getAllDefaultFlags?.() ?? {};
  const overrides = getGlobalFlagOverrides();
  const merged = { ...allDefaults, ...overrides };
  const filtered = {};
  for (const [key, value] of Object.entries(merged)) {
    const isInScope = configFlags.some((pattern) => key.startsWith(pattern));
    if (isInScope) {
      filtered[key] = value;
    }
  }
  return dotNotationToNested(filtered);
}
async function registerEval(evalName, opts) {
  const datasetPromise = opts.data();
  const user = getGitUserInfo();
  const baselineId = inject("baseline");
  const isDebug = inject("debug");
  const injectedOverrides = inject("overrides");
  const axiomConfig = inject("axiomConfig");
  if (!axiomConfig) {
    throw new AxiomCLIError("Axiom config not found");
  }
  const instrumentationReady = !isDebug ? ensureInstrumentationInitialized(axiomConfig) : Promise.resolve();
  const result = await describe(
    `evaluate: ${evalName}`,
    async () => {
      const dataset = await datasetPromise;
      const baseline = isDebug ? void 0 : baselineId ? await findEvaluationCases(baselineId, axiomConfig) : await findBaseline(evalName, axiomConfig);
      const evalVersion = nanoid();
      let evalId = "";
      let suiteSpan;
      let suiteContext;
      let instrumentationError = void 0;
      const allOutOfScopeFlags = [];
      let finalConfigSnapshot;
      beforeAll(async (suite) => {
        try {
          await instrumentationReady;
        } catch (error) {
          instrumentationError = error;
          throw error;
        }
        suiteSpan = startSpan(`eval ${evalName}-${evalVersion}`, {
          attributes: {
            [Attr.GenAI.Operation.Name]: "eval",
            [Attr.Eval.Name]: evalName,
            [Attr.Eval.Version]: evalVersion,
            [Attr.Eval.Type]: "regression",
            // TODO: where to get experiment type value from?
            [Attr.Eval.Tags]: [],
            [Attr.Eval.Collection.ID]: "custom",
            // TODO: where to get dataset split value from?
            [Attr.Eval.Collection.Name]: "custom",
            // TODO: where to get dataset name from?
            [Attr.Eval.Collection.Size]: dataset.length,
            // metadata
            "eval.metadata": JSON.stringify(opts.metadata),
            // baseline
            [Attr.Eval.BaselineID]: baseline ? baseline.id : void 0,
            [Attr.Eval.BaselineName]: baseline ? baseline.name : void 0,
            // user info
            [Attr.Eval.User.Name]: user?.name,
            [Attr.Eval.User.Email]: user?.email
          }
        });
        evalId = suiteSpan.spanContext().traceId;
        suiteSpan.setAttribute(Attr.Eval.ID, evalId);
        suiteContext = trace.setSpan(context.active(), suiteSpan);
        if (injectedOverrides && Object.keys(injectedOverrides).length > 0) {
          try {
            setGlobalFlagOverrides(injectedOverrides);
          } catch {
          }
        }
        suite.meta.evaluation = {
          id: evalId,
          name: evalName,
          version: evalVersion,
          baseline: baseline ?? void 0,
          configFlags: opts.configFlags
        };
        const flagConfig = captureFlagConfig(opts.configFlags);
        suite.meta.evaluation.flagConfig = flagConfig;
        const flagConfigJson = JSON.stringify(flagConfig);
        suiteSpan.setAttribute("eval.config.flags", flagConfigJson);
      });
      afterAll(async (suite) => {
        if (instrumentationError) {
          throw instrumentationError;
        }
        const tags = ["offline"];
        suiteSpan?.setAttribute(Attr.Eval.Tags, JSON.stringify(tags));
        const flagSummary = /* @__PURE__ */ new Map();
        for (const flag of allOutOfScopeFlags) {
          if (flagSummary.has(flag.flagPath)) {
            const existing = flagSummary.get(flag.flagPath);
            existing.count++;
            existing.firstAccessedAt = Math.min(existing.firstAccessedAt, flag.accessedAt);
            existing.lastAccessedAt = Math.max(existing.lastAccessedAt, flag.accessedAt);
          } else {
            flagSummary.set(flag.flagPath, {
              flagPath: flag.flagPath,
              count: 1,
              firstAccessedAt: flag.accessedAt,
              lastAccessedAt: flag.accessedAt,
              stackTrace: flag.stackTrace
            });
          }
        }
        if (suite.meta.evaluation && suiteSpan) {
          suite.meta.evaluation.outOfScopeFlags = Array.from(flagSummary.entries()).map(
            ([_flagPath, stats]) => stats
          );
          const allDefaults = getConfigScope()?.getAllDefaultFlags();
          const pickedFlags = finalConfigSnapshot?.pickedFlags;
          const overrides = injectedOverrides ?? getGlobalFlagOverrides();
          suite.meta.evaluation.configEnd = {
            flags: allDefaults,
            pickedFlags,
            overrides
          };
        }
        suiteSpan?.setStatus({ code: SpanStatusCode.OK });
        suiteSpan?.end();
        await flush();
      });
      await it.concurrent.for(
        dataset.map((d, index) => ({ ...d, index }))
      )("case", async (data, { task }) => {
        const start = performance.now();
        if (!suiteContext) {
          throw new Error(
            "[Axiom AI] Suite context not initialized. This is likely a bug \u2013 instrumentation should complete before tests run."
          );
        }
        const caseSpan = startSpan(
          `case ${data.index}`,
          {
            attributes: {
              [Attr.GenAI.Operation.Name]: "eval.case",
              [Attr.Eval.ID]: evalId,
              [Attr.Eval.Name]: evalName,
              [Attr.Eval.Version]: evalVersion,
              [Attr.Eval.Case.Index]: data.index,
              [Attr.Eval.Case.Input]: typeof data.input === "string" ? data.input : JSON.stringify(data.input),
              [Attr.Eval.Case.Expected]: typeof data.expected === "string" ? data.expected : JSON.stringify(data.expected),
              // user info
              [Attr.Eval.User.Name]: user?.name,
              [Attr.Eval.User.Email]: user?.email
            }
          },
          suiteContext
        );
        const caseContext = trace.setSpan(context.active(), caseSpan);
        let outOfScopeFlags = [];
        try {
          const result2 = await runTask(
            caseContext,
            {
              id: evalId,
              version: evalVersion,
              name: evalName
            },
            {
              index: data.index,
              expected: data.expected,
              input: data.input,
              scorers: opts.scorers,
              task: opts.task,
              metadata: opts.metadata,
              configFlags: opts.configFlags
            }
          );
          const { output, duration } = result2;
          outOfScopeFlags = result2.outOfScopeFlags;
          finalConfigSnapshot = {
            flags: result2.finalFlags || {},
            pickedFlags: opts.configFlags,
            overrides: result2.overrides
          };
          const scoreList = await Promise.all(
            opts.scorers.map(async (scorer) => {
              const scorerSpan = startSpan(
                `score ${scorer.name}`,
                {
                  attributes: {
                    [Attr.GenAI.Operation.Name]: "eval.score",
                    [Attr.Eval.ID]: evalId,
                    [Attr.Eval.Name]: evalName,
                    [Attr.Eval.Version]: evalVersion
                  }
                },
                caseContext
              );
              const start2 = performance.now();
              const result3 = await scorer({
                input: data.input,
                output,
                expected: data.expected
              });
              const duration2 = Math.round(performance.now() - start2);
              const scoreValue = result3.score;
              scorerSpan.setAttributes({
                [Attr.Eval.Score.Name]: result3.name,
                [Attr.Eval.Score.Value]: scoreValue
              });
              scorerSpan.setStatus({ code: SpanStatusCode.OK });
              scorerSpan.end();
              return {
                ...result3,
                metadata: { duration: duration2, startedAt: start2, error: null }
              };
            })
          );
          const scores = Object.fromEntries(scoreList.map((s) => [s.name, s]));
          caseSpan.setAttributes({
            [Attr.Eval.Case.Output]: typeof output === "string" ? output : JSON.stringify(output),
            [Attr.Eval.Case.Scores]: JSON.stringify(scores ? scores : {})
          });
          caseSpan.setStatus({ code: SpanStatusCode.OK });
          task.meta.case = {
            index: data.index,
            name: evalName,
            expected: data.expected,
            input: data.input,
            output,
            scores,
            status: "success",
            errors: [],
            duration,
            startedAt: start,
            outOfScopeFlags,
            pickedFlags: opts.configFlags
          };
          allOutOfScopeFlags.push(...outOfScopeFlags);
        } catch (e) {
          console.log(e);
          const error = e;
          caseSpan.recordException(error);
          caseSpan.setStatus({ code: SpanStatusCode.ERROR, message: error.message });
          const ctx = getEvalContext();
          outOfScopeFlags = ctx.outOfScopeFlags || [];
          task.meta.case = {
            name: evalName,
            index: data.index,
            expected: data.expected,
            input: data.input,
            output: String(e),
            scores: {},
            status: "fail",
            errors: [error],
            startedAt: start,
            duration: Math.round(performance.now() - start),
            outOfScopeFlags,
            pickedFlags: opts.configFlags
          };
          allOutOfScopeFlags.push(...outOfScopeFlags);
          throw e;
        } finally {
          try {
            const DEBUG = process.env.AXIOM_DEBUG === "true";
            const accessedFlags = finalConfigSnapshot?.flags || {};
            const accessed = Object.keys(accessedFlags);
            const allDefaults = getConfigScope()?.getAllDefaultFlags?.() ?? {};
            const runtimeFlags = {};
            for (const key of accessed) {
              const value = accessedFlags[key];
              if (key in allDefaults) {
                const replaced = !deepEqual(value, allDefaults[key]);
                if (replaced) {
                  runtimeFlags[key] = { kind: "replaced", value, default: allDefaults[key] };
                }
              } else {
                runtimeFlags[key] = { kind: "introduced", value };
              }
            }
            if (!DEBUG && Object.keys(runtimeFlags).length > 0) {
              const serialized = JSON.stringify(runtimeFlags);
              caseSpan.setAttribute("eval.case.config.runtime_flags", serialized);
            }
            if (task.meta.case) {
              task.meta.case.runtimeFlags = runtimeFlags;
            }
          } catch {
          }
          caseSpan.end();
        }
      });
    },
    axiomConfig?.eval.timeoutMs
  );
  return result;
}
var joinArrayOfUnknownResults = (results) => {
  if (results.length === 0) {
    return "";
  }
  if (results.every((r) => typeof r === "string")) {
    return results.join("");
  }
  return results[results.length - 1];
};
var executeTask = async (task, input, expected) => {
  const taskResultOrStream = await task({ input, expected });
  if (typeof taskResultOrStream === "object" && taskResultOrStream && Symbol.asyncIterator in taskResultOrStream) {
    const chunks = [];
    for await (const chunk of taskResultOrStream) {
      chunks.push(chunk);
    }
    return joinArrayOfUnknownResults(chunks);
  }
  return taskResultOrStream;
};
var runTask = async (caseContext, evaluation, opts) => {
  const taskName = opts.task.name ?? "anonymous";
  const taskSpan = startSpan(
    `task`,
    {
      attributes: {
        [Attr.GenAI.Operation.Name]: "eval.task",
        [Attr.Eval.Task.Name]: taskName,
        [Attr.Eval.Task.Type]: "llm_completion",
        // TODO: How to determine task type?
        [Attr.Eval.ID]: evaluation.id,
        [Attr.Eval.Name]: evaluation.name,
        [Attr.Eval.Version]: evaluation.version
      }
    },
    caseContext
  );
  const { output, duration, outOfScopeFlags, finalFlags, overrides } = await context.with(
    trace.setSpan(context.active(), taskSpan),
    async () => {
      return withEvalContext(
        { pickedFlags: opts.configFlags },
        async () => {
          const start = performance.now();
          const output2 = await executeTask(opts.task, opts.input, opts.expected);
          const duration2 = Math.round(performance.now() - start);
          taskSpan.setAttributes({
            [Attr.Eval.Task.Output]: JSON.stringify(output2)
          });
          taskSpan.setStatus({ code: SpanStatusCode.OK });
          taskSpan.end();
          const ctx = getEvalContext();
          const outOfScopeFlags2 = ctx.outOfScopeFlags || [];
          return {
            output: output2,
            duration: duration2,
            outOfScopeFlags: outOfScopeFlags2,
            finalFlags: ctx.flags || {},
            overrides: ctx.overrides
          };
        }
      );
    }
  );
  return {
    output,
    duration,
    outOfScopeFlags,
    finalFlags,
    overrides
  };
};

// src/evals/builder.ts
var EvalBuilderImpl = class _EvalBuilderImpl {
  // Prevent double registration
  constructor(name, params, overrides = {}) {
    this.name = name;
    this.params = params;
    this.overrides = overrides;
    __publicField(this, "hasRun", false);
  }
  withFlags(flags) {
    return new _EvalBuilderImpl(this.name, this.params, {
      ...this.overrides,
      flags: { ...this.overrides.flags, ...flags }
    });
  }
  withModel(model) {
    return new _EvalBuilderImpl(this.name, this.params, {
      ...this.overrides,
      model
    });
  }
  withTimeout(timeout) {
    return new _EvalBuilderImpl(this.name, this.params, {
      ...this.overrides,
      timeout
    });
  }
  run(suffix = "") {
    if (this.hasRun) {
      throw new Error(`Eval "${this.name}" has already been run. Create a new builder instance.`);
    }
    this.hasRun = true;
    const finalName = suffix ? `${this.name}:${suffix}` : this.name;
    const finalParams = {
      ...this.params,
      ...this.overrides.model && { model: this.overrides.model },
      ...this.overrides.timeout && { timeout: this.overrides.timeout }
    };
    if (this.overrides.flags && Object.keys(this.overrides.flags).length > 0) {
      const originalTask = finalParams.task;
      finalParams.task = (args) => {
        return withEvalContext({ initialFlags: this.overrides.flags }, () => originalTask(args));
      };
    }
    Eval(finalName, finalParams);
  }
};
function defineEval(name, params) {
  return new EvalBuilderImpl(name, params);
}
function createTypedDefineEval() {
  return function defineAppEval(name, params) {
    return defineEval(name, params);
  };
}

// src/evals/scorer.factory.ts
function createScorer(name, fn) {
  const scorer = async (args) => {
    const res = await fn(args);
    if (typeof res === "number") {
      return { name, score: res };
    }
    return { ...res, name };
  };
  return scorer;
}
export {
  createScorer as Scorer,
  createAppScope,
  createTypedDefineEval,
  defineEval,
  AxiomReporter as experimental_AxiomReporter,
  Eval as experimental_Eval,
  getEvalContext,
  validateCliFlags,
  withEvalContext
};
//# sourceMappingURL=evals.js.map