"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/evals.ts
var evals_exports = {};
__export(evals_exports, {
  Scorer: () => createScorer,
  createAppScope: () => createAppScope,
  createTypedDefineEval: () => createTypedDefineEval,
  defineEval: () => defineEval,
  experimental_AxiomReporter: () => AxiomReporter,
  experimental_Eval: () => Eval,
  getEvalContext: () => getEvalContext,
  validateCliFlags: () => validateCliFlags,
  withEvalContext: () => withEvalContext
});
module.exports = __toCommonJS(evals_exports);

// src/evals/eval.ts
var import_vitest = require("vitest");
var import_api11 = require("@opentelemetry/api");
var import_nanoid = require("nanoid");

// src/evals/context/storage.ts
var import_api9 = require("@opentelemetry/api");

// src/evals/context/manager.ts
var import_node_module = require("module");
var import_meta = {};
var CONTEXT_MANAGER_SYMBOL = Symbol.for("axiom.context_manager");
function getGlobalContextManager() {
  return globalThis[CONTEXT_MANAGER_SYMBOL];
}
function setGlobalContextManager(manager) {
  globalThis[CONTEXT_MANAGER_SYMBOL] = manager;
}
var isNodeJS = typeof process !== "undefined" && !!process.versions?.node;
function getContextManager() {
  const existing = getGlobalContextManager();
  if (existing) return existing;
  let manager;
  if (isNodeJS) {
    try {
      let AsyncLocalStorage;
      const req = (0, import_node_module.createRequire)(import_meta.url);
      try {
        AsyncLocalStorage = req("node:async_hooks").AsyncLocalStorage;
      } catch {
        AsyncLocalStorage = req("async_hooks").AsyncLocalStorage;
      }
      manager = new AsyncLocalStorage();
    } catch (error) {
      console.warn("AsyncLocalStorage not available, using fallback context manager:", error);
      manager = createFallbackManager();
    }
  } else {
    console.warn("AsyncLocalStorage not available, using fallback context manager");
    manager = createFallbackManager();
  }
  setGlobalContextManager(manager);
  return manager;
}
function createFallbackManager() {
  let currentContext = null;
  return {
    getStore: () => currentContext,
    run: (value, fn) => {
      const prev = currentContext;
      currentContext = value;
      try {
        return fn();
      } finally {
        currentContext = prev;
      }
    }
  };
}
function createAsyncHook(_name) {
  return {
    get() {
      const manager = getContextManager();
      if (manager.getStore) {
        return manager.getStore();
      }
      return void 0;
    },
    run(value, fn) {
      const manager = getContextManager();
      return manager.run(value, fn);
    }
  };
}

// src/evals/context/global-flags.ts
var GLOBAL_OVERRIDES_SYMBOL = Symbol.for("axiom.global_flag_overrides");
function getRoot() {
  return globalThis[GLOBAL_OVERRIDES_SYMBOL] ?? {};
}
function setRoot(val) {
  globalThis[GLOBAL_OVERRIDES_SYMBOL] = val;
}
function setGlobalFlagOverrides(overrides) {
  setRoot(overrides);
}
function getGlobalFlagOverrides() {
  return getRoot();
}

// src/validate-flags.ts
var import_zod3 = require("zod");

// src/cli/utils/format-zod-errors.ts
var import_zod = require("zod");
function formatZodErrors(error) {
  const issues = error.issues;
  const messages = [];
  for (const issue of issues) {
    const path = issue.path.join(".");
    const message = formatIssueMessage(issue, path);
    messages.push(`  \u2022 ${message}`);
  }
  return messages.join("\n");
}
function formatIssueMessage(issue, path) {
  switch (issue.code) {
    case "invalid_type":
      return `flag '${path}' expected ${issue.expected}, got ${JSON.stringify(issue.received)} (${typeof issue.received})`;
    case "too_small":
      if (issue.type === "number" || issue.origin === "number") {
        return `flag '${path}' must be >= ${issue.minimum}, got ${issue.received}`;
      }
      return `flag '${path}' is too small: ${issue.message}`;
    case "too_big":
      if (issue.type === "number") {
        return `flag '${path}' must be <= ${issue.maximum}, got ${issue.received}`;
      }
      return `flag '${path}' is too big: ${issue.message}`;
    case "invalid_enum_value":
      const options = issue.options.map((opt) => `"${opt}"`).join(", ");
      return `flag '${path}' must be one of: ${options}, got "${issue.received}"`;
    case "invalid_value":
      if (issue.values && Array.isArray(issue.values)) {
        const values = issue.values.map((val) => `"${val}"`).join(", ");
        return `flag '${path}' must be one of: ${values}`;
      }
      return `flag '${path}': ${issue.message}`;
    case "unrecognized_keys":
      const keys = issue.keys || [];
      if (keys.length === 1) {
        return `unrecognized flag '${keys[0]}'`;
      } else if (keys.length > 1) {
        const keysList = keys.map((key) => `'${key}'`).join(", ");
        return `unrecognized flags ${keysList}`;
      }
      return `unrecognized keys in flags`;
    case "custom":
      return `flag '${path}': ${issue.message}`;
    default:
      return `flag '${path}': ${issue.message}`;
  }
}
function generateFlagExamples(error) {
  const examples = [];
  for (const issue of error.issues) {
    const path = issue.path.join(".");
    const example = generateExampleForIssue(issue, path);
    if (example && !examples.includes(example)) {
      examples.push(example);
    }
  }
  return examples.slice(0, 3);
}
function generateExampleForIssue(issue, path) {
  switch (issue.code) {
    case "invalid_type":
      if (issue.expected === "number") {
        return `--flag.${path}=0.7`;
      }
      if (issue.expected === "boolean") {
        return `--flag.${path}=true`;
      }
      if (issue.expected === "string") {
        return `--flag.${path}="value"`;
      }
      break;
    case "too_small":
      if (typeof issue.minimum === "number" || typeof issue.minimum === "bigint") {
        return `--flag.${path}=${issue.minimum}`;
      }
      break;
    case "too_big":
      if (typeof issue.maximum === "number" || typeof issue.maximum === "bigint") {
        return `--flag.${path}=${issue.maximum}`;
      }
      break;
    case "invalid_enum_value":
      if (issue.options.length > 0) {
        return `--flag.${path}=${issue.options[0]}`;
      }
      break;
    case "invalid_value":
      if (issue.values && Array.isArray(issue.values) && issue.values.length > 0) {
        return `--flag.${path}=${String(issue.values[0])}`;
      }
      break;
  }
  return null;
}

// src/util/dot-path.ts
var import_zod2 = require("zod");
function parsePath(path) {
  return path.split(".");
}
function dotNotationToNested(dotNotationObject) {
  const result = {};
  for (const [dotPath, value] of Object.entries(dotNotationObject)) {
    const segments = parsePath(dotPath);
    let current = result;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (i === segments.length - 1) {
        current[segment] = value;
      } else {
        if (!(segment in current) || typeof current[segment] !== "object") {
          current[segment] = {};
        }
        current = current[segment];
      }
    }
  }
  return result;
}
function flattenObject(obj, prefix = "") {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}.${key}` : key;
    if (value && typeof value === "object" && !Array.isArray(value)) {
      Object.assign(result, flattenObject(value, newKey));
    } else {
      result[newKey] = value;
    }
  }
  return result;
}
function isValidPath(schema, segments) {
  let currentSchema = schema;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    if (!currentSchema.shape || !(segment in currentSchema.shape)) {
      return false;
    }
    if (i < segments.length - 1) {
      const nextSchema = currentSchema.shape[segment];
      let unwrappedSchema = nextSchema;
      while (unwrappedSchema?._def?.innerType || unwrappedSchema?._def?.schema) {
        unwrappedSchema = unwrappedSchema._def.innerType || unwrappedSchema._def.schema;
      }
      if (!unwrappedSchema || unwrappedSchema._def?.type !== "object") {
        return false;
      }
      currentSchema = unwrappedSchema;
    }
  }
  return true;
}
function getValueAtPath(obj, segments) {
  let current = obj;
  for (const segment of segments) {
    if (current == null || typeof current !== "object" || !(segment in current)) {
      return void 0;
    }
    current = current[segment];
  }
  return current;
}
function findSchemaAtPath(rootSchema, segments) {
  if (!rootSchema || segments.length === 0) return void 0;
  let current = rootSchema;
  if (segments.length > 0) {
    if (!current.shape || !(segments[0] in current.shape)) {
      return void 0;
    }
    current = current.shape[segments[0]];
    for (let i = 1; i < segments.length; i++) {
      const segment = segments[i];
      if (!current || !current._def) {
        return void 0;
      }
      if (current._def.type === "object" && current.shape) {
        const nextSchema = current.shape[segment];
        if (!nextSchema) {
          return void 0;
        }
        current = nextSchema;
      } else {
        return void 0;
      }
    }
    return current;
  }
  return current;
}
function buildSchemaForPath(rootSchema, segments) {
  const pathKey = segments.join(".");
  const leafSchema = findSchemaAtPath(rootSchema, segments);
  if (!leafSchema) {
    throw new Error(`Cannot find schema for path: ${pathKey}`);
  }
  let currentSchema = leafSchema;
  for (let i = segments.length - 1; i >= 0; i--) {
    const segment = segments[i];
    const objectSchema = import_zod2.z.object({ [segment]: currentSchema });
    currentSchema = objectSchema.partial().strict();
  }
  return currentSchema;
}

// src/validate-flags.ts
function validateCliFlags(flagSchema) {
  const globalOverrides = getGlobalFlagOverrides();
  if (Object.keys(globalOverrides).length === 0) {
    return;
  }
  validateFlags(flagSchema, globalOverrides);
}
function validateFlags(flagSchema, globalOverrides) {
  for (const [dotPath, _value] of Object.entries(globalOverrides)) {
    const segments = parsePath(dotPath);
    if (!isValidPath(flagSchema, segments)) {
      console.error("\u274C Invalid CLI flags:");
      console.error(`  \u2022 flag '${dotPath}': Invalid flag path`);
      console.error("\n\u{1F527} Fix your CLI flags and try again.\n");
      process.exit(1);
    }
  }
  const nestedObject = dotNotationToNested(globalOverrides);
  const result = flagSchema.strict().partial().safeParse(nestedObject);
  if (!result.success) {
    console.error("\u274C Invalid CLI flags:");
    console.error(formatZodErrors(result.error));
    const examples = generateFlagExamples(result.error);
    if (examples.length > 0) {
      console.error("\n\u{1F4A1} Valid examples:");
      examples.forEach((example) => console.error(`  ${example}`));
    }
    console.error("\n\u{1F527} Fix your CLI flags and try again.\n");
    process.exit(1);
  }
}

// src/app-scope.ts
var import_api8 = require("@opentelemetry/api");
var import_zod4 = require("zod");

// src/otel/utils/to-otel-attribute.ts
var import_api = require("@opentelemetry/api");
function toHomogeneousArray(input) {
  if (input.length === 0) return void 0;
  const converted = [];
  const types = /* @__PURE__ */ new Set();
  for (const item of input) {
    const converted_item = toOtelPrimitive(item);
    if (converted_item !== void 0) {
      converted.push(converted_item);
      types.add(typeof converted_item);
    }
  }
  if (converted.length === 0) return void 0;
  if (types.size > 1) {
    return converted.map((item) => String(item));
  }
  return converted;
}
function toOtelPrimitive(v) {
  switch (typeof v) {
    case "string":
      return v;
    case "number":
      return Number.isFinite(v) ? v : void 0;
    case "boolean":
      return v;
    case "bigint":
      if (v >= Number.MIN_SAFE_INTEGER && v <= Number.MAX_SAFE_INTEGER) {
        return Number(v);
      }
      return v.toString();
    case "function":
    case "symbol":
    case "undefined":
      return void 0;
    case "object":
      if (v === null) return void 0;
      if (v instanceof Date) return v.toISOString();
      if (v instanceof Error) return v.message;
      return safeStringify(v);
  }
}
function safeStringify(obj) {
  try {
    const s2 = JSON.stringify(
      obj,
      (_k, val) => typeof val === "bigint" ? Number(val) : val instanceof Date ? val.toISOString() : val
    );
    if (s2 === "{}") {
      if (obj instanceof Map) {
        return JSON.stringify(Object.fromEntries(obj));
      }
      if (obj instanceof Set) {
        return JSON.stringify(Array.from(obj));
      }
    }
    return s2 ?? void 0;
  } catch {
    try {
      const t = obj?.toString?.();
      return typeof t === "string" ? t : void 0;
    } catch {
      return void 0;
    }
  }
}
function toOtelAttribute(input) {
  switch (typeof input) {
    case "string":
      return input;
    case "number":
      return Number.isFinite(input) ? input : void 0;
    case "boolean":
      return input;
    case "bigint":
      if (input >= Number.MIN_SAFE_INTEGER && input <= Number.MAX_SAFE_INTEGER) {
        return Number(input);
      }
      return input.toString();
    case "function":
    case "symbol":
    case "undefined":
      return void 0;
  }
  if (Array.isArray(input)) {
    return toHomogeneousArray(input);
  }
  if (input instanceof Date) {
    return input.toISOString();
  }
  if (input === null) return void 0;
  return safeStringify(input);
}

// src/otel/withSpan.ts
var import_api6 = require("@opentelemetry/api");

// src/otel/utils/wrapperUtils.ts
var import_api5 = require("@opentelemetry/api");

// src/otel/semconv/attributes.ts
var import_semantic_conventions = require("@opentelemetry/semantic-conventions");

// src/otel/semconv/eval_proposal.ts
var ATTR_EVAL_ID = "eval.id";
var ATTR_EVAL_NAME = "eval.name";
var ATTR_EVAL_VERSION = "eval.version";
var ATTR_EVAL_TYPE = "eval.type";
var ATTR_EVAL_TAGS = "eval.tags";
var ATTR_EVAL_BASELINE_ID = "eval.baseline.id";
var ATTR_EVAL_BASELINE_NAME = "eval.baseline.name";
var ATTR_EVAL_COLLECTION_ID = "eval.collection.id";
var ATTR_EVAL_COLLECTION_SIZE = "eval.collection.size";
var ATTR_EVAL_COLLECTION_NAME = "eval.collection.name";
var ATTR_EVAL_CASE_INDEX = "eval.case.index";
var ATTR_EVAL_CASE_INPUT = "eval.case.input";
var ATTR_EVAL_CASE_OUTPUT = "eval.case.output";
var ATTR_EVAL_CASE_EXPECTED = "eval.case.expected";
var ATTR_EVAL_CASE_SCORES = "eval.case.scores";
var ATTR_EVAL_CASE_METADATA = "eval.case.metadata";
var ATTR_EVAL_TASK_OUTPUT = "eval.task.output";
var ATTR_EVAL_TASK_NAME = "eval.task.name";
var ATTR_EVAL_TASK_TYPE = "eval.task.type";
var ATTR_EVAL_SCORE_NAME = "eval.score.name";
var ATTR_EVAL_SCORE_VALUE = "eval.score.value";
var ATTR_EVAL_SCORE_THRESHOLD = "eval.score.threshold";
var ATTR_EVAL_SCORE_PASSED = "eval.score.passed";
var ATTR_EVAL_SCORE_METADATA = "eval.score.metadata";
var ATTR_EVAL_USER_NAME = "eval.user.name";
var ATTR_EVAL_USER_EMAIL = "eval.user.email";

// src/otel/semconv/attributes.ts
var import_incubating = require("@opentelemetry/semantic-conventions/incubating");
var ATTR_AXIOM_GEN_AI_SCHEMA_URL = "axiom.gen_ai.schema_url";
var ATTR_AXIOM_GEN_AI_SDK_NAME = "axiom.gen_ai.sdk.name";
var ATTR_AXIOM_GEN_AI_SDK_VERSION = "axiom.gen_ai.sdk.version";
var ATTR_GEN_AI_CAPABILITY_NAME = "gen_ai.capability.name";
var ATTR_GEN_AI_STEP_NAME = "gen_ai.step.name";
var ATTR_GEN_AI_TOOL_ARGUMENTS = "gen_ai.tool.arguments";
var ATTR_GEN_AI_TOOL_MESSAGE = "gen_ai.tool.message";
var GEN_AI_PROVIDER_NAME_VALUE_ASSEMBLYAI = "assemblyai";
var GEN_AI_PROVIDER_NAME_VALUE_CEREBRAS = "cerebras";
var GEN_AI_PROVIDER_NAME_VALUE_DEEPGRAM = "deepgram";
var GEN_AI_PROVIDER_NAME_VALUE_DEEPINFRA = "deepinfra";
var GEN_AI_PROVIDER_NAME_VALUE_ELEVENLABS = "elevenlabs";
var GEN_AI_PROVIDER_NAME_VALUE_FAL = "fal";
var GEN_AI_PROVIDER_NAME_VALUE_FIREWORKS = "fireworks";
var GEN_AI_PROVIDER_NAME_VALUE_GLADIA = "gladia";
var GEN_AI_PROVIDER_NAME_VALUE_HUME = "hume";
var GEN_AI_PROVIDER_NAME_VALUE_LMNT = "lmnt";
var GEN_AI_PROVIDER_NAME_VALUE_LUMA = "luma";
var GEN_AI_PROVIDER_NAME_VALUE_REPLICATE = "replicate";
var GEN_AI_PROVIDER_NAME_VALUE_REVAI = "revai";
var GEN_AI_PROVIDER_NAME_VALUE_TOGETHERAI = "togetherai";
var GEN_AI_PROVIDER_NAME_VALUE_VERCEL = "vercel";
var Attr = {
  __EXPERIMENTAL_Flag: (flagName) => `flag.${flagName}`,
  __EXPERIMENTAL_Fact: (factName) => `fact.${factName}`,
  Axiom: {
    GenAI: {
      SchemaURL: ATTR_AXIOM_GEN_AI_SCHEMA_URL,
      SDK: {
        Name: ATTR_AXIOM_GEN_AI_SDK_NAME,
        Version: ATTR_AXIOM_GEN_AI_SDK_VERSION
      }
    }
  },
  GenAI: {
    PromptMetadata: {
      ID: "axiom.gen_ai.prompt.id",
      Name: "axiom.gen_ai.prompt.name",
      Slug: "axiom.gen_ai.prompt.slug",
      Version: "axiom.gen_ai.prompt.version"
    },
    /**
     * These two are used to identify the span
     */
    Capability: {
      Name: ATTR_GEN_AI_CAPABILITY_NAME
    },
    Step: {
      Name: ATTR_GEN_AI_STEP_NAME
    },
    Provider: {
      Name: import_incubating.ATTR_GEN_AI_PROVIDER_NAME,
      Name_Values: {
        Anthropic: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_ANTHROPIC,
        AssemblyAI: GEN_AI_PROVIDER_NAME_VALUE_ASSEMBLYAI,
        AWSBedrock: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_AWS_BEDROCK,
        AzureAIInference: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_AZURE_AI_INFERENCE,
        AzureAIOpenAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_AZURE_AI_OPENAI,
        Cerebras: GEN_AI_PROVIDER_NAME_VALUE_CEREBRAS,
        Cohere: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_COHERE,
        Deepgram: GEN_AI_PROVIDER_NAME_VALUE_DEEPGRAM,
        DeepInfra: GEN_AI_PROVIDER_NAME_VALUE_DEEPINFRA,
        Deepseek: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_DEEPSEEK,
        ElevenLabs: GEN_AI_PROVIDER_NAME_VALUE_ELEVENLABS,
        Fal: GEN_AI_PROVIDER_NAME_VALUE_FAL,
        Fireworks: GEN_AI_PROVIDER_NAME_VALUE_FIREWORKS,
        GCPGemini: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_GCP_GEMINI,
        GCPGenAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_GCP_GEN_AI,
        GCPVertexAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_GCP_VERTEX_AI,
        Gladia: GEN_AI_PROVIDER_NAME_VALUE_GLADIA,
        Groq: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_GROQ,
        Hume: GEN_AI_PROVIDER_NAME_VALUE_HUME,
        IBMWatsonxAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_IBM_WATSONX_AI,
        Lmnt: GEN_AI_PROVIDER_NAME_VALUE_LMNT,
        Luma: GEN_AI_PROVIDER_NAME_VALUE_LUMA,
        MistralAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_MISTRAL_AI,
        OpenAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_OPENAI,
        Perplexity: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_PERPLEXITY,
        Replicate: GEN_AI_PROVIDER_NAME_VALUE_REPLICATE,
        RevAI: GEN_AI_PROVIDER_NAME_VALUE_REVAI,
        TogetherAI: GEN_AI_PROVIDER_NAME_VALUE_TOGETHERAI,
        Vercel: GEN_AI_PROVIDER_NAME_VALUE_VERCEL,
        XAI: import_incubating.GEN_AI_PROVIDER_NAME_VALUE_X_AI
      }
    },
    /**
     * Regular attributes
     */
    Agent: {
      Description: import_incubating.ATTR_GEN_AI_AGENT_DESCRIPTION,
      // not yet used by axiom-ai
      ID: import_incubating.ATTR_GEN_AI_AGENT_ID,
      // not yet used by axiom-ai
      Name: import_incubating.ATTR_GEN_AI_AGENT_NAME
      // not yet used by axiom-ai
    },
    Conversation: {
      ID: import_incubating.ATTR_GEN_AI_CONVERSATION_ID
      // not yet used by axiom-ai, anyway probably needs to be provided by user
    },
    Input: {
      Messages: import_incubating.ATTR_GEN_AI_INPUT_MESSAGES
    },
    Operation: {
      Name: import_incubating.ATTR_GEN_AI_OPERATION_NAME,
      Name_Values: {
        /**
         * Note that "text_completion" is deprecated in favor of "chat" for both OpenAI and Anthropic
         */
        Chat: import_incubating.GEN_AI_OPERATION_NAME_VALUE_CHAT,
        CreateAgent: import_incubating.GEN_AI_OPERATION_NAME_VALUE_CREATE_AGENT,
        Embeddings: import_incubating.GEN_AI_OPERATION_NAME_VALUE_EMBEDDINGS,
        ExecuteTool: import_incubating.GEN_AI_OPERATION_NAME_VALUE_EXECUTE_TOOL,
        GenerateContent: import_incubating.GEN_AI_OPERATION_NAME_VALUE_GENERATE_CONTENT,
        InvokeAgent: import_incubating.GEN_AI_OPERATION_NAME_VALUE_INVOKE_AGENT
      }
    },
    Output: {
      Messages: import_incubating.ATTR_GEN_AI_OUTPUT_MESSAGES,
      Type: import_incubating.ATTR_GEN_AI_OUTPUT_TYPE,
      Type_Values: {
        Text: import_incubating.GEN_AI_OUTPUT_TYPE_VALUE_TEXT,
        Json: import_incubating.GEN_AI_OUTPUT_TYPE_VALUE_JSON,
        Image: import_incubating.GEN_AI_OUTPUT_TYPE_VALUE_IMAGE,
        Speech: import_incubating.GEN_AI_OUTPUT_TYPE_VALUE_SPEECH
      }
    },
    /**
     * The provider that is hosting the model, eg AWS Bedrock
     * There doesn't seem to be a semconv for this
     */
    Request: {
      ChoiceCount: import_incubating.ATTR_GEN_AI_REQUEST_CHOICE_COUNT,
      // not yet used by axiom-ai
      EncodingFormats: import_incubating.ATTR_GEN_AI_REQUEST_ENCODING_FORMATS,
      // not yet used by axiom-ai
      FrequencyPenalty: import_incubating.ATTR_GEN_AI_REQUEST_FREQUENCY_PENALTY,
      MaxTokens: import_incubating.ATTR_GEN_AI_REQUEST_MAX_TOKENS,
      /**
       * The model you asked for
       */
      Model: import_incubating.ATTR_GEN_AI_REQUEST_MODEL,
      PresencePenalty: import_incubating.ATTR_GEN_AI_REQUEST_PRESENCE_PENALTY,
      Seed: import_incubating.ATTR_GEN_AI_REQUEST_SEED,
      StopSequences: import_incubating.ATTR_GEN_AI_REQUEST_STOP_SEQUENCES,
      Temperature: import_incubating.ATTR_GEN_AI_REQUEST_TEMPERATURE,
      TopK: import_incubating.ATTR_GEN_AI_REQUEST_TOP_K,
      TopP: import_incubating.ATTR_GEN_AI_REQUEST_TOP_P
    },
    Response: {
      FinishReasons: import_incubating.ATTR_GEN_AI_RESPONSE_FINISH_REASONS,
      ID: import_incubating.ATTR_GEN_AI_RESPONSE_ID,
      /**
       * The model that was actually used (might be different bc routing) - only ever get this from the response, otherwise omit
       */
      Model: import_incubating.ATTR_GEN_AI_RESPONSE_MODEL
      // somehow not landing on the span for google models? check up on this...
    },
    Tool: {
      CallID: import_incubating.ATTR_GEN_AI_TOOL_CALL_ID,
      Description: import_incubating.ATTR_GEN_AI_TOOL_DESCRIPTION,
      Name: import_incubating.ATTR_GEN_AI_TOOL_NAME,
      Type: import_incubating.ATTR_GEN_AI_TOOL_TYPE,
      /**
       * Note, OTel Semantic Convention suggest only putting tool inputs/outputs on the parent chat span
       * But we at least want to give users THE OPTION to put them on the tool spans themselves as well
       * Because it enables a lot of things with querying
       * @see https://github.com/open-telemetry/semantic-conventions/releases/tag/v1.37.0
       */
      Arguments: ATTR_GEN_AI_TOOL_ARGUMENTS,
      /**
       * Note, OTel Semantic Convention suggest only putting tool inputs/outputs on the parent chat span
       * But we at least want to give users THE OPTION to put them on the tool spans themselves as well
       * Because it enables a lot of things with querying
       * @see https://github.com/open-telemetry/semantic-conventions/releases/tag/v1.37.0
       */
      Message: ATTR_GEN_AI_TOOL_MESSAGE
    },
    Usage: {
      InputTokens: import_incubating.ATTR_GEN_AI_USAGE_INPUT_TOKENS,
      OutputTokens: import_incubating.ATTR_GEN_AI_USAGE_OUTPUT_TOKENS
    }
  },
  Eval: {
    ID: ATTR_EVAL_ID,
    Name: ATTR_EVAL_NAME,
    Version: ATTR_EVAL_VERSION,
    Type: ATTR_EVAL_TYPE,
    BaselineID: ATTR_EVAL_BASELINE_ID,
    BaselineName: ATTR_EVAL_BASELINE_NAME,
    Tags: ATTR_EVAL_TAGS,
    Collection: {
      ID: ATTR_EVAL_COLLECTION_ID,
      Name: ATTR_EVAL_COLLECTION_NAME,
      Size: ATTR_EVAL_COLLECTION_SIZE
    },
    Case: {
      Index: ATTR_EVAL_CASE_INDEX,
      Input: ATTR_EVAL_CASE_INPUT,
      Output: ATTR_EVAL_CASE_OUTPUT,
      Expected: ATTR_EVAL_CASE_EXPECTED,
      Scores: ATTR_EVAL_CASE_SCORES,
      Metadata: ATTR_EVAL_CASE_METADATA
    },
    Task: {
      Output: ATTR_EVAL_TASK_OUTPUT,
      Name: ATTR_EVAL_TASK_NAME,
      Type: ATTR_EVAL_TASK_TYPE
    },
    Score: {
      Name: ATTR_EVAL_SCORE_NAME,
      Value: ATTR_EVAL_SCORE_VALUE,
      Threshold: ATTR_EVAL_SCORE_THRESHOLD,
      Passed: ATTR_EVAL_SCORE_PASSED,
      Metadata: ATTR_EVAL_SCORE_METADATA
    },
    User: {
      Name: ATTR_EVAL_USER_NAME,
      Email: ATTR_EVAL_USER_EMAIL
    }
  },
  Error: {
    Type: import_semantic_conventions.ATTR_ERROR_TYPE,
    Message: import_incubating.ATTR_ERROR_MESSAGE
  },
  HTTP: {
    Response: {
      StatusCode: import_semantic_conventions.ATTR_HTTP_RESPONSE_STATUS_CODE
    }
  }
};

// src/otel/startActiveSpan.ts
var import_api2 = require("@opentelemetry/api");

// src/otel/initAxiomAI.ts
var import_api4 = require("@opentelemetry/api");

// package.json
var package_default = {
  name: "axiom",
  version: "0.22.0",
  type: "module",
  author: "Axiom, Inc.",
  contributors: [
    "Islam Shehata <islam@axiom.co>",
    "Chris Ehrlich <chris@axiom.co>",
    "Gabriel de Andrade <gabriel@axiom.co>"
  ],
  scripts: {
    dev: "tsup --watch",
    build: "tsup && chmod +x dist/bin.js",
    format: "prettier --write .",
    "format:check": "prettier --check .",
    lint: "eslint './**/*.{js,ts}'",
    typecheck: "tsc --noEmit",
    test: "vitest run",
    "test:watch": "vitest --watch",
    publint: "npx publint"
  },
  types: "./dist/index.d.ts",
  main: "./dist/index.cjs",
  module: "./dist/index.js",
  bin: {
    axiom: "./dist/bin.js"
  },
  exports: {
    "./ai": {
      import: {
        types: "./dist/index.d.ts",
        default: "./dist/index.js"
      },
      require: {
        types: "./dist/index.d.cts",
        default: "./dist/index.cjs"
      }
    },
    "./ai/evals": {
      import: {
        types: "./dist/evals.d.ts",
        default: "./dist/evals.js"
      },
      require: {
        types: "./dist/evals.d.cts",
        default: "./dist/evals.cjs"
      }
    },
    "./ai/config": {
      import: {
        types: "./dist/config.d.ts",
        default: "./dist/config.js"
      },
      require: {
        types: "./dist/config.d.cts",
        default: "./dist/config.cjs"
      }
    }
  },
  keywords: [
    "axiom",
    "logging",
    "ai",
    "otel",
    "opentelemetry"
  ],
  repository: {
    type: "git",
    url: "git+https://github.com/axiomhq/ai.git",
    directory: "packages/ai"
  },
  license: "MIT",
  dependencies: {
    "@next/env": "^15.4.2",
    "@opentelemetry/auto-instrumentations-node": "^0.60.1",
    "@opentelemetry/context-async-hooks": "^2.0.1",
    "@opentelemetry/exporter-trace-otlp-http": "^0.202.0",
    "@opentelemetry/resources": "^2.0.1",
    "@opentelemetry/sdk-trace-node": "^2.0.1",
    "@opentelemetry/semantic-conventions": "^1.37.0",
    "@sinclair/typebox": "^0.34.37",
    commander: "^14.0.0",
    handlebars: "^4.7.8",
    nanoid: "^5.1.5"
  },
  peerDependencies: {
    "@opentelemetry/api": "^1.9.0",
    zod: "^3.25.0 || ^4.0.0"
  },
  devDependencies: {
    "@ai-sdk/anthropicv1": "npm:@ai-sdk/anthropic@^1.2.12",
    "@ai-sdk/anthropicv2": "npm:@ai-sdk/anthropic@2.0.0-beta.9",
    "@ai-sdk/openaiv1": "npm:@ai-sdk/openai@^1.3.23",
    "@ai-sdk/openaiv2": "npm:@ai-sdk/openai@2.0.0-beta.12",
    "@ai-sdk/providerv1": "npm:@ai-sdk/provider@^1.1.3",
    "@ai-sdk/providerv2": "npm:@ai-sdk/provider@2.0.0-beta.1",
    "@opentelemetry/api": "^1.9.0",
    "@opentelemetry/core": "^2.0.1",
    "@opentelemetry/sdk-trace-base": "^2.0.1",
    "@opentelemetry/sdk-trace-node": "^2.0.1",
    "@repo/eslint-config": "workspace:*",
    "@types/node": "^22.15.29",
    "@vitest/coverage-v8": "^3.2.4",
    aiv4: "npm:ai@^4.3.19",
    aiv5: "npm:ai@^5.0.0",
    c12: "^2.0.4",
    defu: "^6.1.4",
    esbuild: "^0.25.8",
    eslint: "catalog:",
    prettier: "catalog:",
    tinyrainbow: "^2.0.0",
    tsup: "catalog:",
    typescript: "catalog:",
    vitest: "catalog:",
    zod: "catalog:"
  },
  files: [
    "dist"
  ],
  packageManager: "pnpm@10.16.1"
};

// src/otel/utils/redaction.ts
var import_api3 = require("@opentelemetry/api");
var AXIOM_AI_REDACTION_KEY = Symbol.for("__axiom_ai_redaction__");

// src/otel/initAxiomAI.ts
var AXIOM_AI_SCOPE_KEY = Symbol.for("__axiom_ai_scope__");
function extractTracerScope(tracer) {
  const tracerAny = tracer;
  const name = tracerAny._instrumentationScope?.name || tracerAny.instrumentationLibrary?.name || package_default.name;
  const version = tracerAny._instrumentationScope?.version || tracerAny.instrumentationLibrary?.version || package_default.version;
  return { name, version };
}
function initAxiomAI(config) {
  const newScope = extractTracerScope(config.tracer);
  const existingScope = globalThis[AXIOM_AI_SCOPE_KEY];
  if (existingScope && existingScope.name === newScope.name && existingScope.version === newScope.version) {
    return;
  }
  if (existingScope) {
    console.warn(
      `[AxiomAI] initAxiomAI() called multiple times with different scopes. Previous: ${existingScope.name}@${existingScope.version}, New: ${newScope.name}@${newScope.version}`
    );
  }
  globalThis[AXIOM_AI_SCOPE_KEY] = newScope;
  if (config.redactionPolicy) {
    globalThis[AXIOM_AI_REDACTION_KEY] = config.redactionPolicy;
  }
}

// src/otel/middleware.ts
var import_api7 = require("@opentelemetry/api");

// src/app-scope.ts
function isPickedFlag(flagPath, pickedFlags) {
  if (!pickedFlags) {
    return true;
  }
  if (pickedFlags.length === 0) {
    return true;
  }
  return pickedFlags.some((picked) => {
    if (flagPath === picked) {
      return true;
    }
    if (flagPath.startsWith(picked + ".")) {
      return true;
    }
    return false;
  });
}
function assertNoUnions(schema, path = "schema") {
  if (!schema) return;
  const def = schema._zod?.def || schema._def;
  if (!def) return;
  const { type: typeName, innerType } = def;
  if (typeName === "default" || typeName === "optional" || typeName === "nullable") {
    return assertNoUnions(innerType, path);
  }
  if (typeName === "union" || typeName === "discriminatedUnion") {
    throw new Error(`[AxiomAI] Union types are not supported in flag schemas (found at "${path}")`);
  }
  if (typeName === "object") {
    const shape = def.shape || schema.shape;
    if (shape) {
      for (const [k, v] of Object.entries(shape)) {
        assertNoUnions(v, `${path}.${k}`);
      }
    }
  } else if (typeName === "array") {
    const arrayType = def.type || def.innerType || schema._def && schema._def.type;
    if (arrayType) {
      assertNoUnions(arrayType, `${path}[]`);
    }
  } else if (typeName === "record") {
    const valueType = def.valueType || schema._def && schema._def.valueType;
    if (valueType) {
      assertNoUnions(valueType, `${path}{}`);
    }
  }
}
function ensureAllDefaults(schema, path = "") {
  const missingDefaults = [];
  function checkDefaults(current, currentPath) {
    if (!current) return;
    const def = current.def || current._def;
    if (!def) return;
    const { type: typeName, innerType, defaultValue } = def;
    const hasDefault = defaultValue !== void 0;
    if (typeName === "default") {
      return;
    }
    if (typeName === "optional" || typeName === "nullable") {
      return checkDefaults(innerType, currentPath);
    }
    if (typeName === "record") {
      throw new Error(
        `[AxiomAI] ZodRecord is not supported in flag schemas (found at "${currentPath || "root"}")
All flag fields must have known keys and defaults. Consider using z.object() instead.`
      );
    }
    if (typeName === "object") {
      if (hasDefault) {
        return;
      }
      const shape = def.shape || current.shape;
      if (shape) {
        for (const [k, v] of Object.entries(shape)) {
          const nextPath = currentPath ? `${currentPath}.${k}` : k;
          checkDefaults(v, nextPath);
        }
      }
      return;
    }
    if (typeName === "array") {
      if (!hasDefault) {
        missingDefaults.push(currentPath || "root");
      }
      return;
    }
    if (!hasDefault) {
      missingDefaults.push(currentPath || "root");
    }
  }
  checkDefaults(schema, path);
  if (missingDefaults.length > 0) {
    throw new Error(
      `[AxiomAI] All flag fields must have defaults. Missing defaults for:
` + missingDefaults.map((p2) => `  - ${p2}`).join("\n") + `

Add .default(value) to these fields or to their parent objects.`
    );
  }
}
function createAppScope(config) {
  const flagSchemaConfig = config?.flagSchema;
  const factSchemaConfig = config?.factSchema;
  if (flagSchemaConfig) {
    assertNoUnions(flagSchemaConfig, "flagSchema");
  }
  if (flagSchemaConfig) {
    ensureAllDefaults(flagSchemaConfig);
  }
  if (flagSchemaConfig) {
    validateCliFlags(flagSchemaConfig);
  }
  function findSchemaAtPath2(segments) {
    if (!flagSchemaConfig || segments.length === 0) return void 0;
    let current = flagSchemaConfig;
    if (segments.length > 0) {
      if (!current.shape || !(segments[0] in current.shape)) {
        return void 0;
      }
      current = current.shape[segments[0]];
      for (let i = 1; i < segments.length; i++) {
        const segment = segments[i];
        if (!current || !current._def) {
          return void 0;
        }
        if (current._def.type === "object" && current.shape) {
          const nextSchema = current.shape[segment];
          if (!nextSchema) {
            return void 0;
          }
          current = nextSchema;
        } else {
          return void 0;
        }
      }
      return current;
    }
    return current;
  }
  function isNamespaceAccess(segments) {
    if (!flagSchemaConfig || segments.length === 0) return false;
    if (segments.length === 1) {
      return flagSchemaConfig.shape ? segments[0] in flagSchemaConfig.shape : false;
    }
    const schema = findSchemaAtPath2(segments);
    return Boolean(schema?._def?.type === "object");
  }
  function buildObjectWithDefaults(schema) {
    if (!schema) return void 0;
    const def = schema._zod?.def || schema._def;
    if (!def) return void 0;
    const directDefault = extractDefault(schema);
    if (directDefault !== void 0) {
      return directDefault;
    }
    if (def.type === "object") {
      const shape = def.shape || schema.shape;
      if (shape) {
        const result = {};
        for (const [key, fieldSchema] of Object.entries(shape)) {
          const fieldValue = buildObjectWithDefaults(fieldSchema);
          result[key] = fieldValue;
        }
        return result;
      }
    }
    return void 0;
  }
  function extractDefault(schema) {
    if (!schema || !schema._def) return void 0;
    let current = schema;
    while (current) {
      const def = current._zod?.def || current._def;
      if (!def) break;
      if (def.defaultValue !== void 0) {
        return typeof def.defaultValue === "function" ? def.defaultValue() : def.defaultValue;
      }
      if (def.innerType) {
        current = def.innerType;
      } else if (def.schema) {
        current = def.schema;
      } else {
        break;
      }
    }
    return void 0;
  }
  function validateFinalFlagValue(dotPath, value) {
    if (!flagSchemaConfig) return { ok: true, parsed: value };
    const segments = parsePath(dotPath);
    const fieldSchema = findSchemaAtPath2(segments);
    if (fieldSchema) {
      const direct = fieldSchema.safeParse(value);
      if (direct.success) return { ok: true, parsed: direct.data };
      return { ok: false };
    }
    const hasValidNamespace = flagSchemaConfig.shape && segments[0] in flagSchemaConfig.shape;
    if (!hasValidNamespace) {
      return { ok: true, parsed: value };
    }
    const nested = dotNotationToNested({ [dotPath]: value });
    const nestedResult = flagSchemaConfig.strict().partial().safeParse(nested);
    if (nestedResult.success) {
      const parsed = getValueAtPath(nestedResult.data, segments) ?? value;
      return { ok: true, parsed };
    }
    return { ok: true, parsed: value };
  }
  function flag(path) {
    const segments = parsePath(path);
    const ctx = getEvalContext();
    const globalOverrides = getGlobalFlagOverrides();
    if (!isPickedFlag(path, ctx.pickedFlags)) {
      addOutOfScopeFlag(path);
    }
    let finalValue;
    let source;
    if (path in globalOverrides) {
      finalValue = globalOverrides[path];
      source = "cli";
    } else if (path in ctx.flags) {
      finalValue = ctx.flags[path];
      source = "ctx";
    } else {
      if (!flagSchemaConfig) {
        console.error(`[AxiomAI] Invalid flag: "${path}"`);
        return void 0;
      }
      const hasValidNamespace = flagSchemaConfig.shape && segments[0] in flagSchemaConfig.shape;
      if (!hasValidNamespace) {
        console.error(`[AxiomAI] Invalid flag: "${path}"`);
        return void 0;
      }
      const schemaForPath = findSchemaAtPath2(segments);
      if (!schemaForPath) {
        const namespaceSchema = findSchemaAtPath2([segments[0]]);
        if (namespaceSchema) {
          const namespaceObject = buildObjectWithDefaults(namespaceSchema);
          if (namespaceObject && typeof namespaceObject === "object") {
            finalValue = getValueAtPath(namespaceObject, segments.slice(1));
          }
        }
        if (finalValue === void 0) {
          console.error(`[AxiomAI] Invalid flag: "${path}"`);
          return void 0;
        }
      } else if (isNamespaceAccess(segments)) {
        finalValue = buildObjectWithDefaults(schemaForPath);
        if (finalValue === void 0) {
          console.error(`[AxiomAI] Invalid flag: "${path}"`);
          return void 0;
        }
      } else {
        finalValue = extractDefault(schemaForPath);
        if (finalValue === void 0) {
          const nsSchema = findSchemaAtPath2([segments[0]]);
          if (nsSchema) {
            const nsObj = buildObjectWithDefaults(nsSchema);
            if (nsObj && typeof nsObj === "object") {
              finalValue = getValueAtPath(nsObj, segments.slice(1));
            }
          }
          if (finalValue === void 0) {
            console.error(`[AxiomAI] Invalid flag: "${path}"`);
            return void 0;
          }
        }
      }
      source = "schema";
    }
    if (source !== "schema") {
      const validation = validateFinalFlagValue(path, finalValue);
      if (!validation.ok) {
        console.error(`[AxiomAI] Invalid flag: "${path}" - value does not match schema`);
      }
    }
    updateEvalContext({ [path]: finalValue });
    const span = import_api8.trace.getActiveSpan();
    if (span?.isRecording()) {
      const attr = toOtelAttribute(finalValue);
      if (attr) {
        span.setAttribute(Attr.__EXPERIMENTAL_Flag(path), attr);
      }
    }
    return finalValue;
  }
  function fact(name, value) {
    let finalValue = value;
    if (factSchemaConfig) {
      const segments = parsePath(name);
      let success = true;
      if (!isValidPath(factSchemaConfig, segments)) {
        success = false;
      } else {
        try {
          const pathSchema = buildSchemaForPath(factSchemaConfig, segments);
          const nested = dotNotationToNested({ [name]: value });
          const result = pathSchema.safeParse(nested);
          if (!result.success) {
            success = false;
          } else {
            finalValue = getValueAtPath(result.data, segments) ?? value;
          }
        } catch (_error) {
          success = false;
        }
      }
      if (!success) {
        console.error(`[AxiomAI] Invalid fact: "${name}"`);
      }
    }
    updateEvalContext(void 0, { [name]: finalValue });
    const span = import_api8.trace.getActiveSpan();
    if (span?.isRecording()) {
      const attr = toOtelAttribute(finalValue);
      if (attr) {
        span.setAttribute(Attr.__EXPERIMENTAL_Fact(name), attr);
      }
    }
  }
  function overrideFlags(partial) {
    const ctx = getEvalContext();
    Object.assign(ctx.flags, partial);
  }
  function withFlags(overrides, fn) {
    const ctx = getEvalContext();
    const originalFlags = { ...ctx.flags };
    Object.assign(ctx.flags, overrides);
    try {
      return fn();
    } finally {
      Object.keys(ctx.flags).forEach((key) => delete ctx.flags[key]);
      Object.assign(ctx.flags, originalFlags);
    }
  }
  const pickFlags = ((...args) => {
    return args[0] && Array.isArray(args[0]) ? args[0] : args;
  });
  function flattenToDot(obj, prefix = [], out = {}) {
    if (obj && typeof obj === "object" && !Array.isArray(obj)) {
      for (const [k, v] of Object.entries(obj)) {
        flattenToDot(v, [...prefix, k], out);
      }
    } else {
      if (prefix.length > 0) {
        out[prefix.join(".")] = obj;
      }
    }
    return out;
  }
  function getAllDefaultFlags() {
    if (!flagSchemaConfig) return {};
    const defaultsObj = buildObjectWithDefaults(flagSchemaConfig);
    if (defaultsObj && typeof defaultsObj === "object") {
      return flattenToDot(defaultsObj);
    }
    return {};
  }
  const scope = {
    flag,
    fact,
    overrideFlags,
    withFlags,
    pickFlags,
    getAllDefaultFlags
  };
  setConfigScope(scope);
  return scope;
}

// src/evals/context/storage.ts
var CONFIG_SCOPE_SYMBOL = Symbol.for("axiom.eval.configScope");
function getGlobalConfigScope() {
  return globalThis[CONFIG_SCOPE_SYMBOL];
}
function setGlobalConfigScope(scope) {
  globalThis[CONFIG_SCOPE_SYMBOL] = scope;
}
var AXIOM_CONFIG_SYMBOL = Symbol.for("axiom.eval.config");
function getAxiomConfig() {
  return globalThis[AXIOM_CONFIG_SYMBOL];
}
var EVAL_CONTEXT = createAsyncHook("eval-context");
function getEvalContext() {
  const ctx = EVAL_CONTEXT.get();
  if (!ctx) {
    return {
      flags: {},
      facts: {},
      pickedFlags: void 0,
      outOfScopeFlags: void 0
    };
  }
  return {
    flags: ctx.flags,
    facts: ctx.facts,
    pickedFlags: ctx.pickedFlags,
    outOfScopeFlags: ctx.outOfScopeFlags,
    parent: ctx.parent,
    overrides: ctx.overrides,
    accessedFlagKeys: ctx.accessedFlagKeys
  };
}
function updateEvalContext(flags, facts) {
  const current = EVAL_CONTEXT.get();
  if (!current) {
    if (process.env.NODE_ENV !== "test") {
      console.warn("updateEvalContext called outside of evaluation context");
    }
    return;
  }
  if (flags) {
    Object.assign(current.flags, flags);
    if (!current.accessedFlagKeys) current.accessedFlagKeys = [];
    for (const key of Object.keys(flags)) {
      if (!current.accessedFlagKeys.includes(key)) {
        current.accessedFlagKeys.push(key);
      }
    }
  }
  if (facts) {
    Object.assign(current.facts, facts);
  }
}
function parseStackTrace(stack) {
  const lines = stack.split("\n");
  const frames = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || !trimmed.startsWith("at ")) {
      continue;
    }
    if (trimmed.includes("node_modules") || trimmed.includes("node:internal") || trimmed.includes("addOutOfScopeFlag") || trimmed.includes("storage.ts") || // Keep app-scope.ts frames that aren't the flag() function itself
    trimmed.includes("app-scope.ts") && (trimmed.includes("flag (") || trimmed.includes("flag2 ("))) {
      continue;
    }
    frames.push(trimmed.replace("at ", ""));
  }
  return frames.slice(0, 5);
}
function addOutOfScopeFlag(flagPath) {
  const current = EVAL_CONTEXT.get();
  if (!current) {
    console.warn("addOutOfScopeFlag called outside of evaluation context");
    return;
  }
  if (!current.outOfScopeFlags) {
    current.outOfScopeFlags = [];
  }
  const stack = new Error().stack || "";
  const stackTrace = parseStackTrace(stack);
  current.outOfScopeFlags.push({
    flagPath,
    accessedAt: Date.now(),
    stackTrace
  });
}
function withEvalContext(options = {}, fn) {
  const { initialFlags = {}, pickedFlags = [] } = options;
  return EVAL_CONTEXT.run(
    {
      flags: { ...initialFlags },
      facts: {},
      pickedFlags,
      outOfScopeFlags: [],
      accessedFlagKeys: []
    },
    fn
  );
}
function setConfigScope(scope) {
  const current = EVAL_CONTEXT.get();
  if (current) {
    current.configScope = scope;
  }
  setGlobalConfigScope(scope);
}
function getConfigScope() {
  const current = EVAL_CONTEXT.get();
  return current?.configScope ?? getGlobalConfigScope();
}

// src/evals/instrument.ts
var import_sdk_trace_node = require("@opentelemetry/sdk-trace-node");
var import_resources = require("@opentelemetry/resources");
var import_exporter_trace_otlp_http = require("@opentelemetry/exporter-trace-otlp-http");
var import_api10 = require("@opentelemetry/api");

// src/config/resolver.ts
function resolveAxiomConnection(config) {
  return {
    url: config.eval.url,
    token: config.eval.token,
    dataset: config.eval.dataset
  };
}

// src/cli/errors.ts
var AxiomCLIError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AxiomCLIError";
  }
};
function errorToString(error) {
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}

// src/evals/instrument.ts
var axiomProvider;
var axiomTracer;
var userProvider;
var initializationPromise = null;
var initialized = false;
async function runInstrumentationHook(hook, options) {
  try {
    return await hook(options);
  } catch (error) {
    throw new AxiomCLIError(`Failed to execute instrumentation hook: ${errorToString(error)}`);
  }
}
function setupEvalProvider(connection) {
  const headers = {
    "X-Axiom-Dataset": connection.dataset
  };
  if (connection.token) {
    headers.Authorization = `Bearer ${connection.token}`;
  }
  const collectorOptions = {
    url: `${connection.url}/v1/traces`,
    headers,
    concurrencyLimit: 10
  };
  const exporter = new import_exporter_trace_otlp_http.OTLPTraceExporter(collectorOptions);
  const processor = new import_sdk_trace_node.BatchSpanProcessor(exporter, {
    maxQueueSize: 2048,
    maxExportBatchSize: 512,
    scheduledDelayMillis: 5e3,
    exportTimeoutMillis: 3e4
  });
  axiomProvider = new import_sdk_trace_node.NodeTracerProvider({
    resource: (0, import_resources.resourceFromAttributes)({
      ["service.name"]: "axiom",
      ["service.version"]: "0.22.0"
    }),
    spanProcessors: [processor]
  });
  axiomTracer = axiomProvider.getTracer("axiom", "0.22.0");
}
async function initInstrumentation(config) {
  if (initialized) {
    return;
  }
  if (initializationPromise) {
    await initializationPromise;
    return;
  }
  initializationPromise = (async () => {
    if (!config.enabled) {
      axiomTracer = import_api10.trace.getTracer("axiom", "0.22.0");
      initialized = true;
      return;
    }
    const connection = resolveAxiomConnection(config.config);
    const hook = config.config.eval.instrumentation;
    let hookResult = void 0;
    if (hook) {
      config.config.eval.instrumentation = hook;
      hookResult = await runInstrumentationHook(hook, {
        dataset: connection.dataset,
        token: connection.token,
        url: connection.url
      });
      userProvider = hookResult?.provider ?? userProvider;
    }
    setupEvalProvider(connection);
    if (!hook) {
      axiomProvider?.register();
      if (axiomTracer) {
        initAxiomAI({ tracer: axiomTracer });
      }
    }
    initialized = true;
  })();
  try {
    await initializationPromise;
  } finally {
    initializationPromise = null;
  }
}
var flush = async () => {
  if (initializationPromise) {
    await initializationPromise;
  }
  const tasks = [];
  if (axiomProvider) {
    tasks.push(axiomProvider.forceFlush());
  }
  const candidateProviders = /* @__PURE__ */ new Set();
  if (userProvider) {
    candidateProviders.add(userProvider);
  }
  const globalProvider = import_api10.trace.getTracerProvider();
  if (globalProvider) {
    candidateProviders.add(globalProvider);
  }
  for (const provider of candidateProviders) {
    const flushFn = provider.forceFlush;
    if (typeof flushFn === "function") {
      tasks.push(
        flushFn.call(provider).catch((error) => {
          console.warn("[AxiomAI] Failed to flush tracer provider:", errorToString(error));
        })
      );
    }
  }
  if (tasks.length > 0) {
    await Promise.all(tasks);
  }
};
async function ensureInstrumentationInitialized(config) {
  if (initialized) {
    return;
  }
  await initInstrumentation({ enabled: true, config });
}
var getEvalTracer = () => {
  if (!axiomTracer) {
    throw new Error(
      "Eval tracer not initialized. Ensure ensureInstrumentationInitialized() was awaited before starting spans."
    );
  }
  return axiomTracer;
};
var startSpan = (name, opts, context5) => {
  if (!initialized || !axiomTracer) {
    throw new Error(
      "Instrumentation not initialized. This is likely a bug - instrumentation should be initialized before startSpan is called."
    );
  }
  return getEvalTracer().startSpan(name, opts, context5);
};

// src/evals/git-info.ts
var import_node_child_process = require("child_process");
function getGitUserInfo() {
  try {
    const name = (0, import_node_child_process.execSync)("git config --get user.name").toString().trim();
    const email = (0, import_node_child_process.execSync)("git config --get user.email").toString().trim();
    return { name, email };
  } catch {
    return null;
  }
}

// src/evals/eval.service.ts
var findBaseline = async (evalName, config) => {
  const { dataset, url, token } = resolveAxiomConnection(config);
  try {
    const apl = [
      `['${dataset}']`,
      `| where ['attributes.custom']['eval.name'] == "${evalName}" and ['attributes.gen_ai.operation.name'] == 'eval'`,
      `| order by _time desc`,
      `| limit 1`
    ].join("\n");
    const headers = new Headers({
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json"
    });
    const resp = await fetch(`${url}/v1/datasets/_apl?format=legacy`, {
      headers,
      method: "POST",
      body: JSON.stringify({ apl })
    });
    const payload = await resp.json();
    if (!resp.ok) {
      console.log(payload);
      return void 0;
    }
    if (payload.matches.length) {
      return mapSpanToEval(payload.matches[0]);
    }
  } catch (err) {
    console.log(err);
    return void 0;
  }
};
var findEvaluationCases = async (evalId, config) => {
  try {
    const { dataset, url, token } = resolveAxiomConnection(config);
    const apl = `['${dataset}'] | where trace_id == "${evalId}" | order by _time`;
    const headers = new Headers({
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json"
    });
    const resp = await fetch(`${url}/v1/datasets/_apl?format=legacy`, {
      headers,
      method: "POST",
      body: JSON.stringify({ apl })
    });
    const payload = await resp.json();
    if (!resp.ok) {
      console.log(payload);
      return void 0;
    }
    if (payload.matches.length) {
      return buildSpanTree(payload.matches);
    }
  } catch (err) {
    console.log(err);
    return void 0;
  }
};
var mapSpanToEval = (span) => {
  const flagConfigRaw = span.data.attributes["eval.config.flags"] ?? span.data.attributes.custom["eval.config.flags"];
  return {
    id: span.data.attributes.custom["eval.id"],
    name: span.data.attributes.custom["eval.name"],
    type: span.data.attributes.custom["eval.type"],
    version: span.data.attributes.custom["eval.version"],
    collection: {
      name: span.data.attributes.custom["eval.collection.name"],
      size: span.data.attributes.custom["eval.collection.size"]
    },
    baseline: {
      id: span.data.attributes.custom["eval.baseline.id"],
      name: span.data.attributes.custom["eval.baseline.name"]
    },
    prompt: {
      model: span.data.attributes.custom["eval.prompt.model"],
      params: span.data.attributes.custom["eval.prompt.params"]
    },
    duration: span.data.duration,
    status: span.data.status.code,
    traceId: span.data.trace_id,
    runAt: span._time,
    tags: span.data.attributes.custom["eval.tags"].length ? JSON.parse(span.data.attributes.custom["eval.tags"]) : [],
    user: {
      name: span.data.attributes.custom["eval.user.name"],
      email: span.data.attributes.custom["eval.user.email"]
    },
    cases: [],
    flagConfig: flagConfigRaw ? JSON.parse(flagConfigRaw) : void 0
  };
};
var mapSpanToCase = (item) => {
  const data = item.data;
  const d = data.duration;
  let duration = "-";
  if (d.endsWith("s")) {
    duration = `${Number(d.replace("s", "")).toFixed(2)}s`;
  } else {
    duration = d;
  }
  const runtimeFlagsRaw = data.attributes.custom["eval.case.config.runtime_flags"];
  return {
    index: data.attributes.custom["eval.case.index"],
    input: data.attributes.custom["eval.case.input"],
    output: data.attributes.custom["eval.case.output"],
    expected: data.attributes.custom["eval.case.expected"],
    duration,
    status: data.status.code,
    scores: data.attributes.custom["eval.case.scores"] ? JSON.parse(data.attributes.custom["eval.case.scores"]) : {},
    runAt: item._time,
    spanId: data.span_id,
    traceId: data.trace_id,
    runtimeFlags: runtimeFlagsRaw ? JSON.parse(runtimeFlagsRaw) : void 0
  };
};
var buildSpanTree = (spans) => {
  if (!spans.length) {
    return null;
  }
  const evalSpan = spans.find((span) => span.data.attributes.gen_ai.operation.name === "eval");
  if (!evalSpan) {
    return null;
  }
  const rootSpan = mapSpanToEval(evalSpan);
  const caseSpans = spans.filter((span) => span.data.name.startsWith("case"));
  for (const caseSpan of caseSpans) {
    const caseData = mapSpanToCase(caseSpan);
    const taskSpans = spans.filter(
      (span) => span.data.name.startsWith("task") && span.data.parent_span_id === caseSpan.data.span_id
    );
    if (taskSpans.length > 0) {
      const taskSpan = taskSpans[0];
      const chatSpans = spans.filter(
        (span) => span.data.name.startsWith("chat") && span.data.parent_span_id === taskSpan.data.span_id
      );
      const chatData = chatSpans.map((chatSpan) => ({
        operation: chatSpan.data.attributes.custom?.operation || "",
        capability: chatSpan.data.attributes.custom?.capability || "",
        step: chatSpan.data.attributes.custom?.step || "",
        request: {
          max_token: chatSpan.data.attributes.custom?.["request.max_token"] || "",
          model: chatSpan.data.attributes.custom?.["request.model"] || "",
          temperature: chatSpan.data.attributes.custom?.["request.temperature"] || 0
        },
        response: {
          finish_reasons: chatSpan.data.attributes.custom?.["response.finish_reasons"] || ""
        },
        usage: {
          input_tokens: chatSpan.data.attributes.gen_ai?.usage?.input_tokens || 0,
          output_tokens: chatSpan.data.attributes.gen_ai?.usage?.output_tokens || 0
        }
      }));
      const taskData = {
        name: taskSpan.data.name,
        output: taskSpan.data.attributes.custom?.output || "",
        trial: taskSpan.data.attributes.custom?.trial || 0,
        type: taskSpan.data.attributes.custom?.type || "",
        error: taskSpan.data.attributes.custom?.error,
        chat: chatData[0] || {
          operation: "",
          capability: "",
          step: "",
          request: { max_token: "", model: "", temperature: 0 },
          response: { finish_reasons: "" },
          usage: { input_tokens: 0, output_tokens: 0 }
        }
      };
      caseData.task = taskData;
    }
    const scoreSpans = spans.filter(
      (span) => span.data.attributes.gen_ai.operation.name === "eval.score" && span.data.parent_span_id === caseSpan.data.span_id
    );
    caseData.scores = {};
    scoreSpans.forEach((score) => {
      const name = score.data.attributes.custom["eval.score.name"];
      caseData.scores[name] = {
        name,
        value: score.data.attributes.custom["eval.score.value"],
        metadata: {
          error: score.data.attributes.error
        }
      };
    });
    rootSpan.cases.push(caseData);
  }
  rootSpan.cases.sort((a2, b) => a2.index - b.index);
  return rootSpan;
};

// src/util/deep-equal.ts
function deepEqual(data, other) {
  if (data === other) {
    return true;
  }
  if (Object.is(data, other)) {
    return true;
  }
  if (typeof data !== "object" || typeof other !== "object") {
    return false;
  }
  if (data === null || other === null) {
    return false;
  }
  if (Object.getPrototypeOf(data) !== Object.getPrototypeOf(other)) {
    return false;
  }
  if (Array.isArray(data)) {
    return isDeepEqualArrays(data, other);
  }
  if (data instanceof Map) {
    return isDeepEqualMaps(data, other);
  }
  if (data instanceof Set) {
    return isDeepEqualSets(data, other);
  }
  if (data instanceof Date) {
    return data.getTime() === other.getTime();
  }
  if (data instanceof RegExp) {
    return data.toString() === other.toString();
  }
  if (Object.keys(data).length !== Object.keys(other).length) {
    return false;
  }
  for (const [key, value] of Object.entries(data)) {
    if (!(key in other)) {
      return false;
    }
    if (!deepEqual(
      value,
      // @ts-expect-error [ts7053] - We already checked that `other` has `key`
      other[key]
    )) {
      return false;
    }
  }
  return true;
}
function isDeepEqualArrays(data, other) {
  if (data.length !== other.length) {
    return false;
  }
  for (const [index, item] of data.entries()) {
    if (!deepEqual(item, other[index])) {
      return false;
    }
  }
  return true;
}
function isDeepEqualMaps(data, other) {
  if (data.size !== other.size) {
    return false;
  }
  for (const [key, value] of data.entries()) {
    if (!other.has(key)) {
      return false;
    }
    if (!deepEqual(value, other.get(key))) {
      return false;
    }
  }
  return true;
}
function isDeepEqualSets(data, other) {
  if (data.size !== other.size) {
    return false;
  }
  const otherCopy = [...other];
  for (const dataItem of data) {
    let isFound = false;
    for (const [index, otherItem] of otherCopy.entries()) {
      if (deepEqual(dataItem, otherItem)) {
        isFound = true;
        otherCopy.splice(index, 1);
        break;
      }
    }
    if (!isFound) {
      return false;
    }
  }
  return true;
}

// src/evals/eval.ts
var nanoid = (0, import_nanoid.customAlphabet)("1234567890abcdefghijklmnopqrstuvwxyz", 10);
function Eval(name, params) {
  registerEval(name, params).catch(console.error);
}
function captureFlagConfig(configFlags) {
  if (!configFlags || configFlags.length === 0) {
    return {};
  }
  const scope = getConfigScope();
  const allDefaults = scope?.getAllDefaultFlags?.() ?? {};
  const overrides = getGlobalFlagOverrides();
  const merged = { ...allDefaults, ...overrides };
  const filtered = {};
  for (const [key, value] of Object.entries(merged)) {
    const isInScope = configFlags.some((pattern) => key.startsWith(pattern));
    if (isInScope) {
      filtered[key] = value;
    }
  }
  return dotNotationToNested(filtered);
}
async function registerEval(evalName, opts) {
  const datasetPromise = opts.data();
  const user = getGitUserInfo();
  const baselineId = (0, import_vitest.inject)("baseline");
  const isDebug = (0, import_vitest.inject)("debug");
  const injectedOverrides = (0, import_vitest.inject)("overrides");
  const axiomConfig = (0, import_vitest.inject)("axiomConfig");
  if (!axiomConfig) {
    throw new AxiomCLIError("Axiom config not found");
  }
  const instrumentationReady = !isDebug ? ensureInstrumentationInitialized(axiomConfig) : Promise.resolve();
  const result = await (0, import_vitest.describe)(
    `evaluate: ${evalName}`,
    async () => {
      const dataset = await datasetPromise;
      const baseline = isDebug ? void 0 : baselineId ? await findEvaluationCases(baselineId, axiomConfig) : await findBaseline(evalName, axiomConfig);
      const evalVersion = nanoid();
      let evalId = "";
      let suiteSpan;
      let suiteContext;
      let instrumentationError = void 0;
      const allOutOfScopeFlags = [];
      let finalConfigSnapshot;
      (0, import_vitest.beforeAll)(async (suite) => {
        try {
          await instrumentationReady;
        } catch (error) {
          instrumentationError = error;
          throw error;
        }
        suiteSpan = startSpan(`eval ${evalName}-${evalVersion}`, {
          attributes: {
            [Attr.GenAI.Operation.Name]: "eval",
            [Attr.Eval.Name]: evalName,
            [Attr.Eval.Version]: evalVersion,
            [Attr.Eval.Type]: "regression",
            // TODO: where to get experiment type value from?
            [Attr.Eval.Tags]: [],
            [Attr.Eval.Collection.ID]: "custom",
            // TODO: where to get dataset split value from?
            [Attr.Eval.Collection.Name]: "custom",
            // TODO: where to get dataset name from?
            [Attr.Eval.Collection.Size]: dataset.length,
            // metadata
            "eval.metadata": JSON.stringify(opts.metadata),
            // baseline
            [Attr.Eval.BaselineID]: baseline ? baseline.id : void 0,
            [Attr.Eval.BaselineName]: baseline ? baseline.name : void 0,
            // user info
            [Attr.Eval.User.Name]: user?.name,
            [Attr.Eval.User.Email]: user?.email
          }
        });
        evalId = suiteSpan.spanContext().traceId;
        suiteSpan.setAttribute(Attr.Eval.ID, evalId);
        suiteContext = import_api11.trace.setSpan(import_api11.context.active(), suiteSpan);
        if (injectedOverrides && Object.keys(injectedOverrides).length > 0) {
          try {
            setGlobalFlagOverrides(injectedOverrides);
          } catch {
          }
        }
        suite.meta.evaluation = {
          id: evalId,
          name: evalName,
          version: evalVersion,
          baseline: baseline ?? void 0,
          configFlags: opts.configFlags
        };
        const flagConfig = captureFlagConfig(opts.configFlags);
        suite.meta.evaluation.flagConfig = flagConfig;
        const flagConfigJson = JSON.stringify(flagConfig);
        suiteSpan.setAttribute("eval.config.flags", flagConfigJson);
      });
      (0, import_vitest.afterAll)(async (suite) => {
        if (instrumentationError) {
          throw instrumentationError;
        }
        const tags = ["offline"];
        suiteSpan?.setAttribute(Attr.Eval.Tags, JSON.stringify(tags));
        const flagSummary = /* @__PURE__ */ new Map();
        for (const flag of allOutOfScopeFlags) {
          if (flagSummary.has(flag.flagPath)) {
            const existing = flagSummary.get(flag.flagPath);
            existing.count++;
            existing.firstAccessedAt = Math.min(existing.firstAccessedAt, flag.accessedAt);
            existing.lastAccessedAt = Math.max(existing.lastAccessedAt, flag.accessedAt);
          } else {
            flagSummary.set(flag.flagPath, {
              flagPath: flag.flagPath,
              count: 1,
              firstAccessedAt: flag.accessedAt,
              lastAccessedAt: flag.accessedAt,
              stackTrace: flag.stackTrace
            });
          }
        }
        if (suite.meta.evaluation && suiteSpan) {
          suite.meta.evaluation.outOfScopeFlags = Array.from(flagSummary.entries()).map(
            ([_flagPath, stats]) => stats
          );
          const allDefaults = getConfigScope()?.getAllDefaultFlags();
          const pickedFlags = finalConfigSnapshot?.pickedFlags;
          const overrides = injectedOverrides ?? getGlobalFlagOverrides();
          suite.meta.evaluation.configEnd = {
            flags: allDefaults,
            pickedFlags,
            overrides
          };
        }
        suiteSpan?.setStatus({ code: import_api11.SpanStatusCode.OK });
        suiteSpan?.end();
        await flush();
      });
      await import_vitest.it.concurrent.for(
        dataset.map((d, index) => ({ ...d, index }))
      )("case", async (data, { task }) => {
        const start = performance.now();
        if (!suiteContext) {
          throw new Error(
            "[Axiom AI] Suite context not initialized. This is likely a bug \u2013 instrumentation should complete before tests run."
          );
        }
        const caseSpan = startSpan(
          `case ${data.index}`,
          {
            attributes: {
              [Attr.GenAI.Operation.Name]: "eval.case",
              [Attr.Eval.ID]: evalId,
              [Attr.Eval.Name]: evalName,
              [Attr.Eval.Version]: evalVersion,
              [Attr.Eval.Case.Index]: data.index,
              [Attr.Eval.Case.Input]: typeof data.input === "string" ? data.input : JSON.stringify(data.input),
              [Attr.Eval.Case.Expected]: typeof data.expected === "string" ? data.expected : JSON.stringify(data.expected),
              // user info
              [Attr.Eval.User.Name]: user?.name,
              [Attr.Eval.User.Email]: user?.email
            }
          },
          suiteContext
        );
        const caseContext = import_api11.trace.setSpan(import_api11.context.active(), caseSpan);
        let outOfScopeFlags = [];
        try {
          const result2 = await runTask(
            caseContext,
            {
              id: evalId,
              version: evalVersion,
              name: evalName
            },
            {
              index: data.index,
              expected: data.expected,
              input: data.input,
              scorers: opts.scorers,
              task: opts.task,
              metadata: opts.metadata,
              configFlags: opts.configFlags
            }
          );
          const { output, duration } = result2;
          outOfScopeFlags = result2.outOfScopeFlags;
          finalConfigSnapshot = {
            flags: result2.finalFlags || {},
            pickedFlags: opts.configFlags,
            overrides: result2.overrides
          };
          const scoreList = await Promise.all(
            opts.scorers.map(async (scorer) => {
              const scorerSpan = startSpan(
                `score ${scorer.name}`,
                {
                  attributes: {
                    [Attr.GenAI.Operation.Name]: "eval.score",
                    [Attr.Eval.ID]: evalId,
                    [Attr.Eval.Name]: evalName,
                    [Attr.Eval.Version]: evalVersion
                  }
                },
                caseContext
              );
              const start2 = performance.now();
              const result3 = await scorer({
                input: data.input,
                output,
                expected: data.expected
              });
              const duration2 = Math.round(performance.now() - start2);
              const scoreValue = result3.score;
              scorerSpan.setAttributes({
                [Attr.Eval.Score.Name]: result3.name,
                [Attr.Eval.Score.Value]: scoreValue
              });
              scorerSpan.setStatus({ code: import_api11.SpanStatusCode.OK });
              scorerSpan.end();
              return {
                ...result3,
                metadata: { duration: duration2, startedAt: start2, error: null }
              };
            })
          );
          const scores = Object.fromEntries(scoreList.map((s2) => [s2.name, s2]));
          caseSpan.setAttributes({
            [Attr.Eval.Case.Output]: typeof output === "string" ? output : JSON.stringify(output),
            [Attr.Eval.Case.Scores]: JSON.stringify(scores ? scores : {})
          });
          caseSpan.setStatus({ code: import_api11.SpanStatusCode.OK });
          task.meta.case = {
            index: data.index,
            name: evalName,
            expected: data.expected,
            input: data.input,
            output,
            scores,
            status: "success",
            errors: [],
            duration,
            startedAt: start,
            outOfScopeFlags,
            pickedFlags: opts.configFlags
          };
          allOutOfScopeFlags.push(...outOfScopeFlags);
        } catch (e) {
          console.log(e);
          const error = e;
          caseSpan.recordException(error);
          caseSpan.setStatus({ code: import_api11.SpanStatusCode.ERROR, message: error.message });
          const ctx = getEvalContext();
          outOfScopeFlags = ctx.outOfScopeFlags || [];
          task.meta.case = {
            name: evalName,
            index: data.index,
            expected: data.expected,
            input: data.input,
            output: String(e),
            scores: {},
            status: "fail",
            errors: [error],
            startedAt: start,
            duration: Math.round(performance.now() - start),
            outOfScopeFlags,
            pickedFlags: opts.configFlags
          };
          allOutOfScopeFlags.push(...outOfScopeFlags);
          throw e;
        } finally {
          try {
            const DEBUG = process.env.AXIOM_DEBUG === "true";
            const accessedFlags = finalConfigSnapshot?.flags || {};
            const accessed = Object.keys(accessedFlags);
            const allDefaults = getConfigScope()?.getAllDefaultFlags?.() ?? {};
            const runtimeFlags = {};
            for (const key of accessed) {
              const value = accessedFlags[key];
              if (key in allDefaults) {
                const replaced = !deepEqual(value, allDefaults[key]);
                if (replaced) {
                  runtimeFlags[key] = { kind: "replaced", value, default: allDefaults[key] };
                }
              } else {
                runtimeFlags[key] = { kind: "introduced", value };
              }
            }
            if (!DEBUG && Object.keys(runtimeFlags).length > 0) {
              const serialized = JSON.stringify(runtimeFlags);
              caseSpan.setAttribute("eval.case.config.runtime_flags", serialized);
            }
            if (task.meta.case) {
              task.meta.case.runtimeFlags = runtimeFlags;
            }
          } catch {
          }
          caseSpan.end();
        }
      });
    },
    axiomConfig?.eval.timeoutMs
  );
  return result;
}
var joinArrayOfUnknownResults = (results) => {
  if (results.length === 0) {
    return "";
  }
  if (results.every((r2) => typeof r2 === "string")) {
    return results.join("");
  }
  return results[results.length - 1];
};
var executeTask = async (task, input, expected) => {
  const taskResultOrStream = await task({ input, expected });
  if (typeof taskResultOrStream === "object" && taskResultOrStream && Symbol.asyncIterator in taskResultOrStream) {
    const chunks = [];
    for await (const chunk of taskResultOrStream) {
      chunks.push(chunk);
    }
    return joinArrayOfUnknownResults(chunks);
  }
  return taskResultOrStream;
};
var runTask = async (caseContext, evaluation, opts) => {
  const taskName = opts.task.name ?? "anonymous";
  const taskSpan = startSpan(
    `task`,
    {
      attributes: {
        [Attr.GenAI.Operation.Name]: "eval.task",
        [Attr.Eval.Task.Name]: taskName,
        [Attr.Eval.Task.Type]: "llm_completion",
        // TODO: How to determine task type?
        [Attr.Eval.ID]: evaluation.id,
        [Attr.Eval.Name]: evaluation.name,
        [Attr.Eval.Version]: evaluation.version
      }
    },
    caseContext
  );
  const { output, duration, outOfScopeFlags, finalFlags, overrides } = await import_api11.context.with(
    import_api11.trace.setSpan(import_api11.context.active(), taskSpan),
    async () => {
      return withEvalContext(
        { pickedFlags: opts.configFlags },
        async () => {
          const start = performance.now();
          const output2 = await executeTask(opts.task, opts.input, opts.expected);
          const duration2 = Math.round(performance.now() - start);
          taskSpan.setAttributes({
            [Attr.Eval.Task.Output]: JSON.stringify(output2)
          });
          taskSpan.setStatus({ code: import_api11.SpanStatusCode.OK });
          taskSpan.end();
          const ctx = getEvalContext();
          const outOfScopeFlags2 = ctx.outOfScopeFlags || [];
          return {
            output: output2,
            duration: duration2,
            outOfScopeFlags: outOfScopeFlags2,
            finalFlags: ctx.flags || {},
            overrides: ctx.overrides
          };
        }
      );
    }
  );
  return {
    output,
    duration,
    outOfScopeFlags,
    finalFlags,
    overrides
  };
};

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js
var f = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
var h = Object.entries(f);
function a(n) {
  return String(n);
}
a.open = "";
a.close = "";
function C(n = false) {
  let e = typeof process != "undefined" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];
  return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (e == null ? void 0 : e.platform) === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window != "undefined" && !!window.chrome;
}
function p(n = false) {
  let e = C(n), i = (r2, t, c, o) => {
    let l = "", s2 = 0;
    do
      l += r2.substring(s2, o) + c, s2 = o + t.length, o = r2.indexOf(t, s2);
    while (~o);
    return l + r2.substring(s2);
  }, g = (r2, t, c = r2) => {
    let o = (l) => {
      let s2 = String(l), b = s2.indexOf(t, r2.length);
      return ~b ? r2 + i(s2, t, c, b) + t : r2 + s2 + t;
    };
    return o.open = r2, o.close = t, o;
  }, u2 = {
    isColorSupported: e
  }, d = (r2) => `\x1B[${r2}m`;
  for (let [r2, t] of h)
    u2[r2] = e ? g(
      d(t[0]),
      d(t[1]),
      t[2]
    ) : a;
  return u2;
}

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js
var import_tty = require("tty");
var r = process.env.FORCE_TTY !== void 0 || (0, import_tty.isatty)(1);
var u = p(r);

// src/evals/reporter.console-utils.ts
function truncate(str, max) {
  return str.length > max ? str.slice(0, max) + "\u2026" : str;
}
function stringify(value) {
  try {
    if (typeof value === "string") return value;
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}
function printEvalNameAndFileName(testSuite, meta) {
  const cwd = process.cwd();
  console.log(
    " ",
    u.bgCyan(u.black(` ${testSuite.project.name} `)),
    u.bgBlue(u.black(` ${meta.evaluation.name}-${meta.evaluation.version} `)),
    u.dim(`(${testSuite.children.size} cases)`)
  );
  console.log(" ", u.dim(testSuite.module.moduleId.replace(cwd, "")));
}
function printBaselineNameAndVersion(testMeta) {
  if (testMeta.evaluation.baseline) {
    console.log(
      " ",
      " baseline ",
      u.bgMagenta(
        u.black(` ${testMeta.evaluation.baseline.name}-${testMeta.evaluation.baseline.version} `)
      )
    );
  } else {
    console.log(" ", u.bgWhite(u.blackBright(" baseline: ")), "none");
  }
  console.log("");
}
function printRuntimeFlags(testMeta) {
  if (testMeta.case.runtimeFlags && Object.keys(testMeta.case.runtimeFlags).length > 0) {
    const entries = Object.entries(testMeta.case.runtimeFlags);
    console.log("   ", u.dim("runtime flags"));
    for (const [k, v] of entries) {
      switch (v.kind) {
        case "replaced": {
          const valText = truncate(stringify(v.value), 80);
          const defText = truncate(stringify(v.default), 80);
          console.log("     ", `${k}: ${valText} (default: ${defText})`);
          break;
        }
        case "introduced": {
          const valText = truncate(stringify(v.value), 80);
          console.log("     ", `${k}: ${valText} (no default)`);
          break;
        }
      }
    }
  }
}
function printTestCaseCountStartDuration(testSuite, startTime, duration) {
  console.log(" ");
  console.log(" ", u.dim("Cases"), testSuite.children.size);
  console.log(" ", u.dim("Start at"), new Date(startTime).toTimeString());
  console.log(" ", u.dim("Duration"), `${duration}s`);
}
function printTestCaseSuccessOrFailed(testMeta, ok) {
  const index = testMeta.case.index;
  if (ok) {
    console.log(" ", u.yellow(` \u2714 case ${index}:`));
  } else {
    console.log(" ", u.red(` \u2716 case ${index}: failed`));
    for (const e of testMeta.case.errors ?? []) {
      console.log("", e.message);
    }
  }
}
function printTestCaseScores(testMeta, baseline) {
  const index = testMeta.case.index;
  Object.keys(testMeta.case.scores).forEach((k) => {
    const v = testMeta.case.scores[k].score ? testMeta.case.scores[k].score : 0;
    const scoreValue = Number(v * 100).toFixed(2) + "%";
    if (baseline?.cases[index]?.scores[k]) {
      const baselineScoreValue = baseline.cases[index].scores[k].value;
      const diff = v - baselineScoreValue;
      const diffText = Number(diff * 100).toFixed(2) + "%";
      const blScoreText = Number(baselineScoreValue * 100).toFixed(2) + "%";
      console.log(
        "   ",
        k,
        u.magentaBright(blScoreText),
        "->",
        u.blueBright(scoreValue),
        diff > 0 ? u.green("+" + diffText) : diff < 0 ? u.red(diffText) : diffText
      );
    } else {
      console.log("   ", k, u.blueBright(scoreValue));
    }
    return [k, scoreValue];
  });
}
function printOutOfScopeFlags(testMeta) {
  if (testMeta.case.outOfScopeFlags && testMeta.case.outOfScopeFlags.length > 0) {
    const pickedFlagsText = testMeta.case.pickedFlags ? `(picked: ${testMeta.case.pickedFlags.map((f2) => `'${f2}'`).join(", ")})` : "(none)";
    console.log("   ", u.yellow(`\u26A0 Out-of-scope flags: ${pickedFlagsText}`));
    testMeta.case.outOfScopeFlags.forEach((flag) => {
      const timeStr = new Date(flag.accessedAt).toLocaleTimeString();
      console.log("     ", `${flag.flagPath} (at ${timeStr})`);
      if (flag.stackTrace && flag.stackTrace.length > 0) {
        flag.stackTrace.forEach((frame, i) => {
          const prefix = i === flag.stackTrace.length - 1 ? " \u2514\u2500" : " \u251C\u2500";
          console.log("     ", u.dim(`${prefix} ${frame}`));
        });
      }
    });
  }
}
function printConfigHeader() {
  console.log("");
  console.log(" ", u.bgWhite(u.blackBright(" Config ")));
}
function maybePrintFlags(configEnd) {
  const defaults = configEnd?.flags ?? {};
  const overrides = configEnd?.overrides ?? {};
  const defaultKeys = Object.keys(defaults);
  const overrideKeys = Object.keys(overrides);
  const allKeys = Array.from(/* @__PURE__ */ new Set([...defaultKeys, ...overrideKeys])).sort();
  if (allKeys.length === 0) {
    return;
  }
  for (const key of allKeys) {
    const hasDefault = key in defaults;
    const hasOverride = key in overrides;
    if (hasDefault && hasOverride) {
      const defVal = defaults[key];
      const ovVal = overrides[key];
      const changed = !deepEqual(ovVal, defVal);
      const ovText = truncate(stringify(ovVal), 80);
      const defText = truncate(stringify(defVal), 80);
      if (changed) {
        console.log(
          "   ",
          `${key}: ${ovText} ${u.dim(`(overridden by CLI, original: ${defText})`)}`
        );
      } else {
        console.log("   ", `${key}: ${defText}`);
      }
    } else if (hasOverride) {
      const ovText = truncate(stringify(overrides[key]), 80);
      console.log("   ", `${key}: ${ovText} ${u.dim("(added by CLI)")}`);
    } else if (hasDefault) {
      const defText = truncate(stringify(defaults[key]), 80);
      console.log("   ", `${key}: ${defText}`);
    }
  }
  console.log("");
}
var reporterDate = (d) => {
  const date = d.toISOString().slice(0, 10);
  const hours = d.getUTCHours().toString().padStart(2, "0");
  const minutes = d.getUTCMinutes().toString().padStart(2, "0");
  return `${date}, ${hours}:${minutes} UTC`;
};
function printGlobalFlagOverrides(overrides, defaults) {
  if (Object.keys(overrides).length === 0) {
    console.log("");
    console.log(u.dim("Flag overrides: (none)"));
    console.log("");
    return;
  }
  console.log("");
  console.log("Flag overrides:");
  for (const [key, value] of Object.entries(overrides)) {
    const defaultValue = defaults[key];
    const valueStr = JSON.stringify(value);
    const defaultStr = defaultValue !== void 0 ? JSON.stringify(defaultValue) : "none";
    console.log(`  \u2022 ${key}: ${valueStr} ${u.dim(`(default: ${defaultStr})`)}`);
  }
  console.log("");
}
function printSuiteBox({
  suite,
  scorerAverages,
  calculateBaselineScorerAverage,
  flagDiff
}) {
  const filename = suite.file.split("/").pop();
  console.log("\u250C\u2500");
  console.log(`\u2502  ${u.blue(suite.name)} ${u.gray(`(${filename})`)}`);
  console.log("\u251C\u2500");
  const scorerNames = Object.keys(scorerAverages);
  const maxNameLength = Math.max(...scorerNames.map((name) => name.length));
  for (const scorerName of scorerNames) {
    const avg = scorerAverages[scorerName];
    const paddedName = scorerName.padEnd(maxNameLength);
    if (suite.baseline) {
      const baselineAvg = calculateBaselineScorerAverage(suite.baseline, scorerName);
      if (baselineAvg !== null) {
        const currentPercent = (avg * 100).toFixed(2) + "%";
        const baselinePercent = (baselineAvg * 100).toFixed(2) + "%";
        const diff = avg - baselineAvg;
        const diffText = (diff >= 0 ? "+" : "") + (diff * 100).toFixed(2) + "%";
        const diffColor = diff > 0 ? u.green : diff < 0 ? u.red : u.dim;
        const paddedBaseline = baselinePercent.padStart(7);
        const paddedCurrent = currentPercent.padStart(7);
        const paddedDiff = diffText.padStart(8);
        console.log(
          `\u2502  ${paddedName}  ${u.blueBright(paddedBaseline)} \u2192 ${u.magentaBright(paddedCurrent)}  (${diffColor(paddedDiff)})`
        );
      } else {
        const currentPercent = (avg * 100).toFixed(2) + "%";
        console.log(`\u2502   \u2022 ${paddedName}  ${currentPercent}`);
      }
    } else {
      const currentPercent = (avg * 100).toFixed(2) + "%";
      console.log(`\u2502   \u2022 ${paddedName}  ${currentPercent}`);
    }
  }
  console.log("\u251C\u2500");
  if (suite.baseline) {
    const baselineTimestamp = suite.baseline.runAt ? reporterDate(new Date(suite.baseline.runAt)) : "unknown time";
    console.log(
      `\u2502  Baseline: ${suite.baseline.name}-${suite.baseline.version} ${u.gray(`(${baselineTimestamp})`)}`
    );
  } else {
    console.log(`\u2502  Baseline: ${u.gray("(none)")}`);
  }
  if (suite.baseline) {
    const hasConfigChanges = flagDiff.length > 0;
    console.log("\u2502  Config changes:", hasConfigChanges ? "" : u.gray("(none)"));
    if (hasConfigChanges) {
      for (const { flag, current, baseline } of flagDiff) {
        console.log(
          `\u2502   \u2022 ${flag}: ${current ?? "<not set>"} ${u.gray(`(baseline: ${baseline ?? "<not set>"})`)}`
        );
      }
    }
  }
  if (suite.outOfScopeFlags && suite.outOfScopeFlags.length > 0) {
    const pickedFlagsText = suite.configFlags && suite.configFlags.length > 0 ? suite.configFlags.map((f2) => `'${f2}'`).join(", ") : "none";
    console.log("\u2502");
    console.log(
      `\u2502  ${u.yellow("\u26A0 Out-of-scope flags")} ${u.gray(`(picked: ${pickedFlagsText})`)}:`
    );
    for (const flag of suite.outOfScopeFlags) {
      const lastStackTraceFrame = flag.stackTrace[0];
      const lastStackTraceFnName = lastStackTraceFrame.split(" ").shift();
      const lastStackTraceFile = lastStackTraceFrame.split("/").pop()?.slice(0, -1);
      console.log(
        `\u2502   \u2022 ${flag.flagPath} ${u.gray(`at ${lastStackTraceFnName} (${lastStackTraceFile})`)}`
      );
    }
  }
  console.log("\u2514\u2500");
}
function printFinalReport({
  suiteData,
  calculateScorerAverages,
  calculateBaselineScorerAverage,
  calculateFlagDiff
}) {
  console.log("");
  console.log(u.bgBlue(u.white(" FINAL EVALUATION REPORT ")));
  console.log("");
  for (const suite of suiteData) {
    const scorerAverages = calculateScorerAverages(suite);
    const flagDiff = suite.baseline ? calculateFlagDiff(suite) : [];
    printSuiteBox({ suite, scorerAverages, calculateBaselineScorerAverage, flagDiff });
    console.log("");
  }
  console.log("View full report:");
  console.log("https://app.axiom.co/evaluations/run/<run-id>");
}

// src/evals/reporter.ts
var AxiomReporter = class {
  constructor() {
    __publicField(this, "startTime", 0);
    __publicField(this, "start", 0);
    __publicField(this, "_endOfRunConfigEnd");
    __publicField(this, "_suiteData", []);
    __publicField(this, "_baselines", /* @__PURE__ */ new Map());
  }
  onTestRunStart() {
    this.start = performance.now();
    this.startTime = (/* @__PURE__ */ new Date()).getTime();
    const overrides = getGlobalFlagOverrides();
    const defaults = getConfigScope()?.getAllDefaultFlags?.() ?? {};
    printGlobalFlagOverrides(overrides, defaults);
  }
  async onTestSuiteReady(_testSuite) {
    const meta = _testSuite.meta();
    if (_testSuite.state() === "skipped") {
      return;
    }
    const baseline = meta.evaluation.baseline;
    if (baseline) {
      const config = getAxiomConfig();
      if (!config) {
        throw new AxiomCLIError("Axiom config not available in reporter");
      }
      const baselineData = await findEvaluationCases(baseline.id, config);
      this._baselines.set(meta.evaluation.name, baselineData || null);
    } else {
      this._baselines.set(meta.evaluation.name, null);
    }
    if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {
      this._endOfRunConfigEnd = meta.evaluation.configEnd;
    }
  }
  onTestCaseReady(test) {
    const meta = test.meta();
    if (!meta.case) return;
  }
  async onTestSuiteResult(testSuite) {
    const meta = testSuite.meta();
    if (testSuite.state() === "skipped") {
      return;
    }
    const durationSeconds = Number((performance.now() - this.start) / 1e3).toFixed(2);
    const cases = [];
    for (const test of testSuite.children) {
      if (test.type !== "test") continue;
      const testMeta = test.meta();
      if (!testMeta?.case) continue;
      cases.push({
        index: testMeta.case.index,
        scores: testMeta.case.scores,
        outOfScopeFlags: testMeta.case.outOfScopeFlags,
        errors: testMeta.case.errors,
        runtimeFlags: testMeta.case.runtimeFlags
      });
    }
    const cwd = process.cwd();
    const relativePath = testSuite.module.moduleId.replace(cwd, "").replace(/^\//, "");
    let suiteBaseline = this._baselines.get(meta.evaluation.name);
    if (suiteBaseline === void 0 && meta.evaluation.baseline) {
      const config = getAxiomConfig();
      if (!config) {
        throw new AxiomCLIError("Axiom config not available in reporter");
      }
      const baselineData = await findEvaluationCases(meta.evaluation.baseline.id, config);
      suiteBaseline = baselineData || null;
      this._baselines.set(meta.evaluation.name, suiteBaseline);
    }
    this._suiteData.push({
      name: meta.evaluation.name,
      file: relativePath,
      duration: durationSeconds + "s",
      baseline: suiteBaseline || null,
      configFlags: meta.evaluation.configFlags,
      flagConfig: meta.evaluation.flagConfig,
      cases,
      outOfScopeFlags: meta.evaluation.outOfScopeFlags
    });
    printEvalNameAndFileName(testSuite, meta);
    printBaselineNameAndVersion(meta);
    printTestCaseCountStartDuration(testSuite, this.startTime, durationSeconds);
    for (const test of testSuite.children) {
      if (test.type !== "test") continue;
      this.printCaseResult(test, suiteBaseline || null);
    }
    console.log("");
  }
  async onTestRunEnd(_testModules, _errors, _reason) {
    const shouldClear = !process.env.CI && process.stdout.isTTY !== false;
    if (shouldClear) {
      process.stdout.write("\x1B[2J\x1B[0f");
    }
    printFinalReport({
      suiteData: this._suiteData,
      calculateScorerAverages: this.calculateScorerAverages.bind(this),
      calculateBaselineScorerAverage: this.calculateBaselineScorerAverage.bind(this),
      calculateFlagDiff: this.calculateFlagDiff.bind(this)
    });
    const DEBUG = process.env.AXIOM_DEBUG === "true";
    if (DEBUG && this._endOfRunConfigEnd) {
      this.printConfigEnd(this._endOfRunConfigEnd);
    }
  }
  printCaseResult(test, baseline) {
    const ok = test.ok();
    const testMeta = test.meta();
    if (!testMeta?.case) {
      return;
    }
    printTestCaseSuccessOrFailed(testMeta, ok);
    printTestCaseScores(testMeta, baseline);
    printRuntimeFlags(testMeta);
    printOutOfScopeFlags(testMeta);
  }
  /**
   * Calculate average scores per scorer for a suite
   */
  calculateScorerAverages(suite) {
    const scorerTotals = {};
    for (const caseData of suite.cases) {
      for (const [scorerName, score] of Object.entries(caseData.scores)) {
        if (!scorerTotals[scorerName]) {
          scorerTotals[scorerName] = { sum: 0, count: 0 };
        }
        scorerTotals[scorerName].sum += score.score || 0;
        scorerTotals[scorerName].count += 1;
      }
    }
    const averages = {};
    for (const [scorerName, totals] of Object.entries(scorerTotals)) {
      averages[scorerName] = totals.count > 0 ? totals.sum / totals.count : 0;
    }
    return averages;
  }
  /**
   * Calculate average score for a specific scorer from baseline data
   */
  calculateBaselineScorerAverage(baseline, scorerName) {
    const scores = [];
    for (const caseData of baseline.cases) {
      if (caseData.scores[scorerName]) {
        scores.push(caseData.scores[scorerName].value);
      }
    }
    if (scores.length === 0) return null;
    const sum = scores.reduce((acc, val) => acc + val, 0);
    return sum / scores.length;
  }
  /**
   * Calculate flag diff between current run and baseline (filtered by configFlags)
   */
  calculateFlagDiff(suite) {
    if (!suite.baseline || !suite.configFlags || suite.configFlags.length === 0) {
      return [];
    }
    const diffs = [];
    const currentConfig = suite.flagConfig || {};
    const baselineConfig = suite.baseline.flagConfig || {};
    const currentFlat = flattenObject(currentConfig);
    const baselineFlat = flattenObject(baselineConfig);
    const allKeys = /* @__PURE__ */ new Set([...Object.keys(currentFlat), ...Object.keys(baselineFlat)]);
    for (const key of allKeys) {
      const isInScope = suite.configFlags.some((pattern) => key.startsWith(pattern));
      if (!isInScope) continue;
      const currentValue = currentFlat[key];
      const baselineValue = baselineFlat[key];
      if (JSON.stringify(currentValue) !== JSON.stringify(baselineValue)) {
        diffs.push({
          flag: key,
          current: currentValue ? JSON.stringify(currentValue) : void 0,
          baseline: baselineValue ? JSON.stringify(baselineValue) : void 0
        });
      }
    }
    return diffs;
  }
  /**
   * End-of-suite config summary (console only)
   */
  printConfigEnd(configEnd) {
    printConfigHeader();
    maybePrintFlags(configEnd);
  }
};

// src/evals/builder.ts
var EvalBuilderImpl = class _EvalBuilderImpl {
  // Prevent double registration
  constructor(name, params, overrides = {}) {
    this.name = name;
    this.params = params;
    this.overrides = overrides;
    __publicField(this, "hasRun", false);
  }
  withFlags(flags) {
    return new _EvalBuilderImpl(this.name, this.params, {
      ...this.overrides,
      flags: { ...this.overrides.flags, ...flags }
    });
  }
  withModel(model) {
    return new _EvalBuilderImpl(this.name, this.params, {
      ...this.overrides,
      model
    });
  }
  withTimeout(timeout) {
    return new _EvalBuilderImpl(this.name, this.params, {
      ...this.overrides,
      timeout
    });
  }
  run(suffix = "") {
    if (this.hasRun) {
      throw new Error(`Eval "${this.name}" has already been run. Create a new builder instance.`);
    }
    this.hasRun = true;
    const finalName = suffix ? `${this.name}:${suffix}` : this.name;
    const finalParams = {
      ...this.params,
      ...this.overrides.model && { model: this.overrides.model },
      ...this.overrides.timeout && { timeout: this.overrides.timeout }
    };
    if (this.overrides.flags && Object.keys(this.overrides.flags).length > 0) {
      const originalTask = finalParams.task;
      finalParams.task = (args) => {
        return withEvalContext({ initialFlags: this.overrides.flags }, () => originalTask(args));
      };
    }
    Eval(finalName, finalParams);
  }
};
function defineEval(name, params) {
  return new EvalBuilderImpl(name, params);
}
function createTypedDefineEval() {
  return function defineAppEval(name, params) {
    return defineEval(name, params);
  };
}

// src/evals/scorer.factory.ts
function createScorer(name, fn) {
  const scorer = async (args) => {
    const res = await fn(args);
    if (typeof res === "number") {
      return { name, score: res };
    }
    return { ...res, name };
  };
  return scorer;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Scorer,
  createAppScope,
  createTypedDefineEval,
  defineEval,
  experimental_AxiomReporter,
  experimental_Eval,
  getEvalContext,
  validateCliFlags,
  withEvalContext
});
//# sourceMappingURL=evals.cjs.map