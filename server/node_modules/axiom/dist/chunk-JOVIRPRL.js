import {
  AxiomCLIError,
  errorToString
} from "./chunk-NV3Y4T4G.js";
import {
  Attr,
  initAxiomAI
} from "./chunk-DITIARCU.js";
import {
  __publicField
} from "./chunk-EAWROPGL.js";

// src/validate-flags.ts
import "zod";

// src/evals/context/global-flags.ts
var GLOBAL_OVERRIDES_SYMBOL = Symbol.for("axiom.global_flag_overrides");
function getRoot() {
  return globalThis[GLOBAL_OVERRIDES_SYMBOL] ?? {};
}
function setRoot(val) {
  globalThis[GLOBAL_OVERRIDES_SYMBOL] = val;
}
function setGlobalFlagOverrides(overrides) {
  setRoot(overrides);
}
function getGlobalFlagOverrides() {
  return getRoot();
}

// src/cli/utils/format-zod-errors.ts
import "zod";
function formatZodErrors(error) {
  const issues = error.issues;
  const messages = [];
  for (const issue of issues) {
    const path = issue.path.join(".");
    const message = formatIssueMessage(issue, path);
    messages.push(`  \u2022 ${message}`);
  }
  return messages.join("\n");
}
function formatIssueMessage(issue, path) {
  switch (issue.code) {
    case "invalid_type":
      return `flag '${path}' expected ${issue.expected}, got ${JSON.stringify(issue.received)} (${typeof issue.received})`;
    case "too_small":
      if (issue.type === "number" || issue.origin === "number") {
        return `flag '${path}' must be >= ${issue.minimum}, got ${issue.received}`;
      }
      return `flag '${path}' is too small: ${issue.message}`;
    case "too_big":
      if (issue.type === "number") {
        return `flag '${path}' must be <= ${issue.maximum}, got ${issue.received}`;
      }
      return `flag '${path}' is too big: ${issue.message}`;
    case "invalid_enum_value":
      const options = issue.options.map((opt) => `"${opt}"`).join(", ");
      return `flag '${path}' must be one of: ${options}, got "${issue.received}"`;
    case "invalid_value":
      if (issue.values && Array.isArray(issue.values)) {
        const values = issue.values.map((val) => `"${val}"`).join(", ");
        return `flag '${path}' must be one of: ${values}`;
      }
      return `flag '${path}': ${issue.message}`;
    case "unrecognized_keys":
      const keys = issue.keys || [];
      if (keys.length === 1) {
        return `unrecognized flag '${keys[0]}'`;
      } else if (keys.length > 1) {
        const keysList = keys.map((key) => `'${key}'`).join(", ");
        return `unrecognized flags ${keysList}`;
      }
      return `unrecognized keys in flags`;
    case "custom":
      return `flag '${path}': ${issue.message}`;
    default:
      return `flag '${path}': ${issue.message}`;
  }
}
function generateFlagExamples(error) {
  const examples = [];
  for (const issue of error.issues) {
    const path = issue.path.join(".");
    const example = generateExampleForIssue(issue, path);
    if (example && !examples.includes(example)) {
      examples.push(example);
    }
  }
  return examples.slice(0, 3);
}
function generateExampleForIssue(issue, path) {
  switch (issue.code) {
    case "invalid_type":
      if (issue.expected === "number") {
        return `--flag.${path}=0.7`;
      }
      if (issue.expected === "boolean") {
        return `--flag.${path}=true`;
      }
      if (issue.expected === "string") {
        return `--flag.${path}="value"`;
      }
      break;
    case "too_small":
      if (typeof issue.minimum === "number" || typeof issue.minimum === "bigint") {
        return `--flag.${path}=${issue.minimum}`;
      }
      break;
    case "too_big":
      if (typeof issue.maximum === "number" || typeof issue.maximum === "bigint") {
        return `--flag.${path}=${issue.maximum}`;
      }
      break;
    case "invalid_enum_value":
      if (issue.options.length > 0) {
        return `--flag.${path}=${issue.options[0]}`;
      }
      break;
    case "invalid_value":
      if (issue.values && Array.isArray(issue.values) && issue.values.length > 0) {
        return `--flag.${path}=${String(issue.values[0])}`;
      }
      break;
  }
  return null;
}

// src/util/dot-path.ts
import { z } from "zod";
function parsePath(path) {
  return path.split(".");
}
function dotNotationToNested(dotNotationObject) {
  const result = {};
  for (const [dotPath, value] of Object.entries(dotNotationObject)) {
    const segments = parsePath(dotPath);
    let current = result;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      if (i === segments.length - 1) {
        current[segment] = value;
      } else {
        if (!(segment in current) || typeof current[segment] !== "object") {
          current[segment] = {};
        }
        current = current[segment];
      }
    }
  }
  return result;
}
function flattenObject(obj, prefix = "") {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}.${key}` : key;
    if (value && typeof value === "object" && !Array.isArray(value)) {
      Object.assign(result, flattenObject(value, newKey));
    } else {
      result[newKey] = value;
    }
  }
  return result;
}
function isValidPath(schema, segments) {
  let currentSchema = schema;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    if (!currentSchema.shape || !(segment in currentSchema.shape)) {
      return false;
    }
    if (i < segments.length - 1) {
      const nextSchema = currentSchema.shape[segment];
      let unwrappedSchema = nextSchema;
      while (unwrappedSchema?._def?.innerType || unwrappedSchema?._def?.schema) {
        unwrappedSchema = unwrappedSchema._def.innerType || unwrappedSchema._def.schema;
      }
      if (!unwrappedSchema || unwrappedSchema._def?.type !== "object") {
        return false;
      }
      currentSchema = unwrappedSchema;
    }
  }
  return true;
}
function getValueAtPath(obj, segments) {
  let current = obj;
  for (const segment of segments) {
    if (current == null || typeof current !== "object" || !(segment in current)) {
      return void 0;
    }
    current = current[segment];
  }
  return current;
}
function findSchemaAtPath(rootSchema, segments) {
  if (!rootSchema || segments.length === 0) return void 0;
  let current = rootSchema;
  if (segments.length > 0) {
    if (!current.shape || !(segments[0] in current.shape)) {
      return void 0;
    }
    current = current.shape[segments[0]];
    for (let i = 1; i < segments.length; i++) {
      const segment = segments[i];
      if (!current || !current._def) {
        return void 0;
      }
      if (current._def.type === "object" && current.shape) {
        const nextSchema = current.shape[segment];
        if (!nextSchema) {
          return void 0;
        }
        current = nextSchema;
      } else {
        return void 0;
      }
    }
    return current;
  }
  return current;
}
function buildSchemaForPath(rootSchema, segments) {
  const pathKey = segments.join(".");
  const leafSchema = findSchemaAtPath(rootSchema, segments);
  if (!leafSchema) {
    throw new Error(`Cannot find schema for path: ${pathKey}`);
  }
  let currentSchema = leafSchema;
  for (let i = segments.length - 1; i >= 0; i--) {
    const segment = segments[i];
    const objectSchema = z.object({ [segment]: currentSchema });
    currentSchema = objectSchema.partial().strict();
  }
  return currentSchema;
}

// src/validate-flags.ts
function validateCliFlags(flagSchema) {
  const globalOverrides = getGlobalFlagOverrides();
  if (Object.keys(globalOverrides).length === 0) {
    return;
  }
  validateFlags(flagSchema, globalOverrides);
}
function validateFlags(flagSchema, globalOverrides) {
  for (const [dotPath, _value] of Object.entries(globalOverrides)) {
    const segments = parsePath(dotPath);
    if (!isValidPath(flagSchema, segments)) {
      console.error("\u274C Invalid CLI flags:");
      console.error(`  \u2022 flag '${dotPath}': Invalid flag path`);
      console.error("\n\u{1F527} Fix your CLI flags and try again.\n");
      process.exit(1);
    }
  }
  const nestedObject = dotNotationToNested(globalOverrides);
  const result = flagSchema.strict().partial().safeParse(nestedObject);
  if (!result.success) {
    console.error("\u274C Invalid CLI flags:");
    console.error(formatZodErrors(result.error));
    const examples = generateFlagExamples(result.error);
    if (examples.length > 0) {
      console.error("\n\u{1F4A1} Valid examples:");
      examples.forEach((example) => console.error(`  ${example}`));
    }
    console.error("\n\u{1F527} Fix your CLI flags and try again.\n");
    process.exit(1);
  }
}

// src/evals/context/storage.ts
import { trace } from "@opentelemetry/api";

// src/evals/context/manager.ts
import { createRequire } from "module";
var CONTEXT_MANAGER_SYMBOL = Symbol.for("axiom.context_manager");
function getGlobalContextManager() {
  return globalThis[CONTEXT_MANAGER_SYMBOL];
}
function setGlobalContextManager(manager) {
  globalThis[CONTEXT_MANAGER_SYMBOL] = manager;
}
var isNodeJS = typeof process !== "undefined" && !!process.versions?.node;
function getContextManager() {
  const existing = getGlobalContextManager();
  if (existing) return existing;
  let manager;
  if (isNodeJS) {
    try {
      let AsyncLocalStorage;
      const req = createRequire(import.meta.url);
      try {
        AsyncLocalStorage = req("node:async_hooks").AsyncLocalStorage;
      } catch {
        AsyncLocalStorage = req("async_hooks").AsyncLocalStorage;
      }
      manager = new AsyncLocalStorage();
    } catch (error) {
      console.warn("AsyncLocalStorage not available, using fallback context manager:", error);
      manager = createFallbackManager();
    }
  } else {
    console.warn("AsyncLocalStorage not available, using fallback context manager");
    manager = createFallbackManager();
  }
  setGlobalContextManager(manager);
  return manager;
}
function createFallbackManager() {
  let currentContext = null;
  return {
    getStore: () => currentContext,
    run: (value, fn) => {
      const prev = currentContext;
      currentContext = value;
      try {
        return fn();
      } finally {
        currentContext = prev;
      }
    }
  };
}
function createAsyncHook(_name) {
  return {
    get() {
      const manager = getContextManager();
      if (manager.getStore) {
        return manager.getStore();
      }
      return void 0;
    },
    run(value, fn) {
      const manager = getContextManager();
      return manager.run(value, fn);
    }
  };
}

// src/evals/context/storage.ts
var CONFIG_SCOPE_SYMBOL = Symbol.for("axiom.eval.configScope");
function getGlobalConfigScope() {
  return globalThis[CONFIG_SCOPE_SYMBOL];
}
function setGlobalConfigScope(scope) {
  globalThis[CONFIG_SCOPE_SYMBOL] = scope;
}
var AXIOM_CONFIG_SYMBOL = Symbol.for("axiom.eval.config");
function getAxiomConfig() {
  return globalThis[AXIOM_CONFIG_SYMBOL];
}
function setAxiomConfig(config) {
  globalThis[AXIOM_CONFIG_SYMBOL] = config;
}
var EVAL_CONTEXT = createAsyncHook("eval-context");
function getEvalContext() {
  const ctx = EVAL_CONTEXT.get();
  if (!ctx) {
    return {
      flags: {},
      facts: {},
      pickedFlags: void 0,
      outOfScopeFlags: void 0
    };
  }
  return {
    flags: ctx.flags,
    facts: ctx.facts,
    pickedFlags: ctx.pickedFlags,
    outOfScopeFlags: ctx.outOfScopeFlags,
    parent: ctx.parent,
    overrides: ctx.overrides,
    accessedFlagKeys: ctx.accessedFlagKeys
  };
}
function updateEvalContext(flags, facts) {
  const current = EVAL_CONTEXT.get();
  if (!current) {
    if (process.env.NODE_ENV !== "test") {
      console.warn("updateEvalContext called outside of evaluation context");
    }
    return;
  }
  if (flags) {
    Object.assign(current.flags, flags);
    if (!current.accessedFlagKeys) current.accessedFlagKeys = [];
    for (const key of Object.keys(flags)) {
      if (!current.accessedFlagKeys.includes(key)) {
        current.accessedFlagKeys.push(key);
      }
    }
  }
  if (facts) {
    Object.assign(current.facts, facts);
  }
}
function parseStackTrace(stack) {
  const lines = stack.split("\n");
  const frames = [];
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || !trimmed.startsWith("at ")) {
      continue;
    }
    if (trimmed.includes("node_modules") || trimmed.includes("node:internal") || trimmed.includes("addOutOfScopeFlag") || trimmed.includes("storage.ts") || // Keep app-scope.ts frames that aren't the flag() function itself
    trimmed.includes("app-scope.ts") && (trimmed.includes("flag (") || trimmed.includes("flag2 ("))) {
      continue;
    }
    frames.push(trimmed.replace("at ", ""));
  }
  return frames.slice(0, 5);
}
function addOutOfScopeFlag(flagPath) {
  const current = EVAL_CONTEXT.get();
  if (!current) {
    console.warn("addOutOfScopeFlag called outside of evaluation context");
    return;
  }
  if (!current.outOfScopeFlags) {
    current.outOfScopeFlags = [];
  }
  const stack = new Error().stack || "";
  const stackTrace = parseStackTrace(stack);
  current.outOfScopeFlags.push({
    flagPath,
    accessedAt: Date.now(),
    stackTrace
  });
}
function putOnSpan(kind, key, value) {
  const span = trace.getActiveSpan();
  if (span?.isRecording()) {
    span.setAttributes({ [`${kind}.${key}`]: value });
  }
}
function withEvalContext(options = {}, fn) {
  const { initialFlags = {}, pickedFlags = [] } = options;
  return EVAL_CONTEXT.run(
    {
      flags: { ...initialFlags },
      facts: {},
      pickedFlags,
      outOfScopeFlags: [],
      accessedFlagKeys: []
    },
    fn
  );
}
function setConfigScope(scope) {
  const current = EVAL_CONTEXT.get();
  if (current) {
    current.configScope = scope;
  }
  setGlobalConfigScope(scope);
}
function getConfigScope() {
  const current = EVAL_CONTEXT.get();
  return current?.configScope ?? getGlobalConfigScope();
}

// src/app-scope.ts
import { trace as trace2 } from "@opentelemetry/api";
import "zod";

// src/otel/utils/to-otel-attribute.ts
import "@opentelemetry/api";
function toHomogeneousArray(input) {
  if (input.length === 0) return void 0;
  const converted = [];
  const types = /* @__PURE__ */ new Set();
  for (const item of input) {
    const converted_item = toOtelPrimitive(item);
    if (converted_item !== void 0) {
      converted.push(converted_item);
      types.add(typeof converted_item);
    }
  }
  if (converted.length === 0) return void 0;
  if (types.size > 1) {
    return converted.map((item) => String(item));
  }
  return converted;
}
function toOtelPrimitive(v) {
  switch (typeof v) {
    case "string":
      return v;
    case "number":
      return Number.isFinite(v) ? v : void 0;
    case "boolean":
      return v;
    case "bigint":
      if (v >= Number.MIN_SAFE_INTEGER && v <= Number.MAX_SAFE_INTEGER) {
        return Number(v);
      }
      return v.toString();
    case "function":
    case "symbol":
    case "undefined":
      return void 0;
    case "object":
      if (v === null) return void 0;
      if (v instanceof Date) return v.toISOString();
      if (v instanceof Error) return v.message;
      return safeStringify(v);
  }
}
function safeStringify(obj) {
  try {
    const s2 = JSON.stringify(
      obj,
      (_k, val) => typeof val === "bigint" ? Number(val) : val instanceof Date ? val.toISOString() : val
    );
    if (s2 === "{}") {
      if (obj instanceof Map) {
        return JSON.stringify(Object.fromEntries(obj));
      }
      if (obj instanceof Set) {
        return JSON.stringify(Array.from(obj));
      }
    }
    return s2 ?? void 0;
  } catch {
    try {
      const t = obj?.toString?.();
      return typeof t === "string" ? t : void 0;
    } catch {
      return void 0;
    }
  }
}
function toOtelAttribute(input) {
  switch (typeof input) {
    case "string":
      return input;
    case "number":
      return Number.isFinite(input) ? input : void 0;
    case "boolean":
      return input;
    case "bigint":
      if (input >= Number.MIN_SAFE_INTEGER && input <= Number.MAX_SAFE_INTEGER) {
        return Number(input);
      }
      return input.toString();
    case "function":
    case "symbol":
    case "undefined":
      return void 0;
  }
  if (Array.isArray(input)) {
    return toHomogeneousArray(input);
  }
  if (input instanceof Date) {
    return input.toISOString();
  }
  if (input === null) return void 0;
  return safeStringify(input);
}

// src/app-scope.ts
function isPickedFlag(flagPath, pickedFlags) {
  if (!pickedFlags) {
    return true;
  }
  if (pickedFlags.length === 0) {
    return true;
  }
  return pickedFlags.some((picked) => {
    if (flagPath === picked) {
      return true;
    }
    if (flagPath.startsWith(picked + ".")) {
      return true;
    }
    return false;
  });
}
function assertNoUnions(schema, path = "schema") {
  if (!schema) return;
  const def = schema._zod?.def || schema._def;
  if (!def) return;
  const { type: typeName, innerType } = def;
  if (typeName === "default" || typeName === "optional" || typeName === "nullable") {
    return assertNoUnions(innerType, path);
  }
  if (typeName === "union" || typeName === "discriminatedUnion") {
    throw new Error(`[AxiomAI] Union types are not supported in flag schemas (found at "${path}")`);
  }
  if (typeName === "object") {
    const shape = def.shape || schema.shape;
    if (shape) {
      for (const [k, v] of Object.entries(shape)) {
        assertNoUnions(v, `${path}.${k}`);
      }
    }
  } else if (typeName === "array") {
    const arrayType = def.type || def.innerType || schema._def && schema._def.type;
    if (arrayType) {
      assertNoUnions(arrayType, `${path}[]`);
    }
  } else if (typeName === "record") {
    const valueType = def.valueType || schema._def && schema._def.valueType;
    if (valueType) {
      assertNoUnions(valueType, `${path}{}`);
    }
  }
}
function ensureAllDefaults(schema, path = "") {
  const missingDefaults = [];
  function checkDefaults(current, currentPath) {
    if (!current) return;
    const def = current.def || current._def;
    if (!def) return;
    const { type: typeName, innerType, defaultValue } = def;
    const hasDefault = defaultValue !== void 0;
    if (typeName === "default") {
      return;
    }
    if (typeName === "optional" || typeName === "nullable") {
      return checkDefaults(innerType, currentPath);
    }
    if (typeName === "record") {
      throw new Error(
        `[AxiomAI] ZodRecord is not supported in flag schemas (found at "${currentPath || "root"}")
All flag fields must have known keys and defaults. Consider using z.object() instead.`
      );
    }
    if (typeName === "object") {
      if (hasDefault) {
        return;
      }
      const shape = def.shape || current.shape;
      if (shape) {
        for (const [k, v] of Object.entries(shape)) {
          const nextPath = currentPath ? `${currentPath}.${k}` : k;
          checkDefaults(v, nextPath);
        }
      }
      return;
    }
    if (typeName === "array") {
      if (!hasDefault) {
        missingDefaults.push(currentPath || "root");
      }
      return;
    }
    if (!hasDefault) {
      missingDefaults.push(currentPath || "root");
    }
  }
  checkDefaults(schema, path);
  if (missingDefaults.length > 0) {
    throw new Error(
      `[AxiomAI] All flag fields must have defaults. Missing defaults for:
` + missingDefaults.map((p2) => `  - ${p2}`).join("\n") + `

Add .default(value) to these fields or to their parent objects.`
    );
  }
}
function createAppScope(config) {
  const flagSchemaConfig = config?.flagSchema;
  const factSchemaConfig = config?.factSchema;
  if (flagSchemaConfig) {
    assertNoUnions(flagSchemaConfig, "flagSchema");
  }
  if (flagSchemaConfig) {
    ensureAllDefaults(flagSchemaConfig);
  }
  if (flagSchemaConfig) {
    validateCliFlags(flagSchemaConfig);
  }
  function findSchemaAtPath2(segments) {
    if (!flagSchemaConfig || segments.length === 0) return void 0;
    let current = flagSchemaConfig;
    if (segments.length > 0) {
      if (!current.shape || !(segments[0] in current.shape)) {
        return void 0;
      }
      current = current.shape[segments[0]];
      for (let i = 1; i < segments.length; i++) {
        const segment = segments[i];
        if (!current || !current._def) {
          return void 0;
        }
        if (current._def.type === "object" && current.shape) {
          const nextSchema = current.shape[segment];
          if (!nextSchema) {
            return void 0;
          }
          current = nextSchema;
        } else {
          return void 0;
        }
      }
      return current;
    }
    return current;
  }
  function isNamespaceAccess(segments) {
    if (!flagSchemaConfig || segments.length === 0) return false;
    if (segments.length === 1) {
      return flagSchemaConfig.shape ? segments[0] in flagSchemaConfig.shape : false;
    }
    const schema = findSchemaAtPath2(segments);
    return Boolean(schema?._def?.type === "object");
  }
  function buildObjectWithDefaults(schema) {
    if (!schema) return void 0;
    const def = schema._zod?.def || schema._def;
    if (!def) return void 0;
    const directDefault = extractDefault(schema);
    if (directDefault !== void 0) {
      return directDefault;
    }
    if (def.type === "object") {
      const shape = def.shape || schema.shape;
      if (shape) {
        const result = {};
        for (const [key, fieldSchema] of Object.entries(shape)) {
          const fieldValue = buildObjectWithDefaults(fieldSchema);
          result[key] = fieldValue;
        }
        return result;
      }
    }
    return void 0;
  }
  function extractDefault(schema) {
    if (!schema || !schema._def) return void 0;
    let current = schema;
    while (current) {
      const def = current._zod?.def || current._def;
      if (!def) break;
      if (def.defaultValue !== void 0) {
        return typeof def.defaultValue === "function" ? def.defaultValue() : def.defaultValue;
      }
      if (def.innerType) {
        current = def.innerType;
      } else if (def.schema) {
        current = def.schema;
      } else {
        break;
      }
    }
    return void 0;
  }
  function validateFinalFlagValue(dotPath, value) {
    if (!flagSchemaConfig) return { ok: true, parsed: value };
    const segments = parsePath(dotPath);
    const fieldSchema = findSchemaAtPath2(segments);
    if (fieldSchema) {
      const direct = fieldSchema.safeParse(value);
      if (direct.success) return { ok: true, parsed: direct.data };
      return { ok: false };
    }
    const hasValidNamespace = flagSchemaConfig.shape && segments[0] in flagSchemaConfig.shape;
    if (!hasValidNamespace) {
      return { ok: true, parsed: value };
    }
    const nested = dotNotationToNested({ [dotPath]: value });
    const nestedResult = flagSchemaConfig.strict().partial().safeParse(nested);
    if (nestedResult.success) {
      const parsed = getValueAtPath(nestedResult.data, segments) ?? value;
      return { ok: true, parsed };
    }
    return { ok: true, parsed: value };
  }
  function flag(path) {
    const segments = parsePath(path);
    const ctx = getEvalContext();
    const globalOverrides = getGlobalFlagOverrides();
    if (!isPickedFlag(path, ctx.pickedFlags)) {
      addOutOfScopeFlag(path);
    }
    let finalValue;
    let source;
    if (path in globalOverrides) {
      finalValue = globalOverrides[path];
      source = "cli";
    } else if (path in ctx.flags) {
      finalValue = ctx.flags[path];
      source = "ctx";
    } else {
      if (!flagSchemaConfig) {
        console.error(`[AxiomAI] Invalid flag: "${path}"`);
        return void 0;
      }
      const hasValidNamespace = flagSchemaConfig.shape && segments[0] in flagSchemaConfig.shape;
      if (!hasValidNamespace) {
        console.error(`[AxiomAI] Invalid flag: "${path}"`);
        return void 0;
      }
      const schemaForPath = findSchemaAtPath2(segments);
      if (!schemaForPath) {
        const namespaceSchema = findSchemaAtPath2([segments[0]]);
        if (namespaceSchema) {
          const namespaceObject = buildObjectWithDefaults(namespaceSchema);
          if (namespaceObject && typeof namespaceObject === "object") {
            finalValue = getValueAtPath(namespaceObject, segments.slice(1));
          }
        }
        if (finalValue === void 0) {
          console.error(`[AxiomAI] Invalid flag: "${path}"`);
          return void 0;
        }
      } else if (isNamespaceAccess(segments)) {
        finalValue = buildObjectWithDefaults(schemaForPath);
        if (finalValue === void 0) {
          console.error(`[AxiomAI] Invalid flag: "${path}"`);
          return void 0;
        }
      } else {
        finalValue = extractDefault(schemaForPath);
        if (finalValue === void 0) {
          const nsSchema = findSchemaAtPath2([segments[0]]);
          if (nsSchema) {
            const nsObj = buildObjectWithDefaults(nsSchema);
            if (nsObj && typeof nsObj === "object") {
              finalValue = getValueAtPath(nsObj, segments.slice(1));
            }
          }
          if (finalValue === void 0) {
            console.error(`[AxiomAI] Invalid flag: "${path}"`);
            return void 0;
          }
        }
      }
      source = "schema";
    }
    if (source !== "schema") {
      const validation = validateFinalFlagValue(path, finalValue);
      if (!validation.ok) {
        console.error(`[AxiomAI] Invalid flag: "${path}" - value does not match schema`);
      }
    }
    updateEvalContext({ [path]: finalValue });
    const span = trace2.getActiveSpan();
    if (span?.isRecording()) {
      const attr = toOtelAttribute(finalValue);
      if (attr) {
        span.setAttribute(Attr.__EXPERIMENTAL_Flag(path), attr);
      }
    }
    return finalValue;
  }
  function fact(name, value) {
    let finalValue = value;
    if (factSchemaConfig) {
      const segments = parsePath(name);
      let success = true;
      if (!isValidPath(factSchemaConfig, segments)) {
        success = false;
      } else {
        try {
          const pathSchema = buildSchemaForPath(factSchemaConfig, segments);
          const nested = dotNotationToNested({ [name]: value });
          const result = pathSchema.safeParse(nested);
          if (!result.success) {
            success = false;
          } else {
            finalValue = getValueAtPath(result.data, segments) ?? value;
          }
        } catch (_error) {
          success = false;
        }
      }
      if (!success) {
        console.error(`[AxiomAI] Invalid fact: "${name}"`);
      }
    }
    updateEvalContext(void 0, { [name]: finalValue });
    const span = trace2.getActiveSpan();
    if (span?.isRecording()) {
      const attr = toOtelAttribute(finalValue);
      if (attr) {
        span.setAttribute(Attr.__EXPERIMENTAL_Fact(name), attr);
      }
    }
  }
  function overrideFlags(partial) {
    const ctx = getEvalContext();
    Object.assign(ctx.flags, partial);
  }
  function withFlags(overrides, fn) {
    const ctx = getEvalContext();
    const originalFlags = { ...ctx.flags };
    Object.assign(ctx.flags, overrides);
    try {
      return fn();
    } finally {
      Object.keys(ctx.flags).forEach((key) => delete ctx.flags[key]);
      Object.assign(ctx.flags, originalFlags);
    }
  }
  const pickFlags = ((...args) => {
    return args[0] && Array.isArray(args[0]) ? args[0] : args;
  });
  function flattenToDot(obj, prefix = [], out = {}) {
    if (obj && typeof obj === "object" && !Array.isArray(obj)) {
      for (const [k, v] of Object.entries(obj)) {
        flattenToDot(v, [...prefix, k], out);
      }
    } else {
      if (prefix.length > 0) {
        out[prefix.join(".")] = obj;
      }
    }
    return out;
  }
  function getAllDefaultFlags() {
    if (!flagSchemaConfig) return {};
    const defaultsObj = buildObjectWithDefaults(flagSchemaConfig);
    if (defaultsObj && typeof defaultsObj === "object") {
      return flattenToDot(defaultsObj);
    }
    return {};
  }
  const scope = {
    flag,
    fact,
    overrideFlags,
    withFlags,
    pickFlags,
    getAllDefaultFlags
  };
  setConfigScope(scope);
  return scope;
}

// src/config/resolver.ts
function resolveAxiomConnection(config) {
  return {
    url: config.eval.url,
    token: config.eval.token,
    dataset: config.eval.dataset
  };
}

// src/evals/eval.service.ts
var findBaseline = async (evalName, config) => {
  const { dataset, url, token } = resolveAxiomConnection(config);
  try {
    const apl = [
      `['${dataset}']`,
      `| where ['attributes.custom']['eval.name'] == "${evalName}" and ['attributes.gen_ai.operation.name'] == 'eval'`,
      `| order by _time desc`,
      `| limit 1`
    ].join("\n");
    const headers = new Headers({
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json"
    });
    const resp = await fetch(`${url}/v1/datasets/_apl?format=legacy`, {
      headers,
      method: "POST",
      body: JSON.stringify({ apl })
    });
    const payload = await resp.json();
    if (!resp.ok) {
      console.log(payload);
      return void 0;
    }
    if (payload.matches.length) {
      return mapSpanToEval(payload.matches[0]);
    }
  } catch (err) {
    console.log(err);
    return void 0;
  }
};
var findEvaluationCases = async (evalId, config) => {
  try {
    const { dataset, url, token } = resolveAxiomConnection(config);
    const apl = `['${dataset}'] | where trace_id == "${evalId}" | order by _time`;
    const headers = new Headers({
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json"
    });
    const resp = await fetch(`${url}/v1/datasets/_apl?format=legacy`, {
      headers,
      method: "POST",
      body: JSON.stringify({ apl })
    });
    const payload = await resp.json();
    if (!resp.ok) {
      console.log(payload);
      return void 0;
    }
    if (payload.matches.length) {
      return buildSpanTree(payload.matches);
    }
  } catch (err) {
    console.log(err);
    return void 0;
  }
};
var mapSpanToEval = (span) => {
  const flagConfigRaw = span.data.attributes["eval.config.flags"] ?? span.data.attributes.custom["eval.config.flags"];
  return {
    id: span.data.attributes.custom["eval.id"],
    name: span.data.attributes.custom["eval.name"],
    type: span.data.attributes.custom["eval.type"],
    version: span.data.attributes.custom["eval.version"],
    collection: {
      name: span.data.attributes.custom["eval.collection.name"],
      size: span.data.attributes.custom["eval.collection.size"]
    },
    baseline: {
      id: span.data.attributes.custom["eval.baseline.id"],
      name: span.data.attributes.custom["eval.baseline.name"]
    },
    prompt: {
      model: span.data.attributes.custom["eval.prompt.model"],
      params: span.data.attributes.custom["eval.prompt.params"]
    },
    duration: span.data.duration,
    status: span.data.status.code,
    traceId: span.data.trace_id,
    runAt: span._time,
    tags: span.data.attributes.custom["eval.tags"].length ? JSON.parse(span.data.attributes.custom["eval.tags"]) : [],
    user: {
      name: span.data.attributes.custom["eval.user.name"],
      email: span.data.attributes.custom["eval.user.email"]
    },
    cases: [],
    flagConfig: flagConfigRaw ? JSON.parse(flagConfigRaw) : void 0
  };
};
var mapSpanToCase = (item) => {
  const data = item.data;
  const d = data.duration;
  let duration = "-";
  if (d.endsWith("s")) {
    duration = `${Number(d.replace("s", "")).toFixed(2)}s`;
  } else {
    duration = d;
  }
  const runtimeFlagsRaw = data.attributes.custom["eval.case.config.runtime_flags"];
  return {
    index: data.attributes.custom["eval.case.index"],
    input: data.attributes.custom["eval.case.input"],
    output: data.attributes.custom["eval.case.output"],
    expected: data.attributes.custom["eval.case.expected"],
    duration,
    status: data.status.code,
    scores: data.attributes.custom["eval.case.scores"] ? JSON.parse(data.attributes.custom["eval.case.scores"]) : {},
    runAt: item._time,
    spanId: data.span_id,
    traceId: data.trace_id,
    runtimeFlags: runtimeFlagsRaw ? JSON.parse(runtimeFlagsRaw) : void 0
  };
};
var buildSpanTree = (spans) => {
  if (!spans.length) {
    return null;
  }
  const evalSpan = spans.find((span) => span.data.attributes.gen_ai.operation.name === "eval");
  if (!evalSpan) {
    return null;
  }
  const rootSpan = mapSpanToEval(evalSpan);
  const caseSpans = spans.filter((span) => span.data.name.startsWith("case"));
  for (const caseSpan of caseSpans) {
    const caseData = mapSpanToCase(caseSpan);
    const taskSpans = spans.filter(
      (span) => span.data.name.startsWith("task") && span.data.parent_span_id === caseSpan.data.span_id
    );
    if (taskSpans.length > 0) {
      const taskSpan = taskSpans[0];
      const chatSpans = spans.filter(
        (span) => span.data.name.startsWith("chat") && span.data.parent_span_id === taskSpan.data.span_id
      );
      const chatData = chatSpans.map((chatSpan) => ({
        operation: chatSpan.data.attributes.custom?.operation || "",
        capability: chatSpan.data.attributes.custom?.capability || "",
        step: chatSpan.data.attributes.custom?.step || "",
        request: {
          max_token: chatSpan.data.attributes.custom?.["request.max_token"] || "",
          model: chatSpan.data.attributes.custom?.["request.model"] || "",
          temperature: chatSpan.data.attributes.custom?.["request.temperature"] || 0
        },
        response: {
          finish_reasons: chatSpan.data.attributes.custom?.["response.finish_reasons"] || ""
        },
        usage: {
          input_tokens: chatSpan.data.attributes.gen_ai?.usage?.input_tokens || 0,
          output_tokens: chatSpan.data.attributes.gen_ai?.usage?.output_tokens || 0
        }
      }));
      const taskData = {
        name: taskSpan.data.name,
        output: taskSpan.data.attributes.custom?.output || "",
        trial: taskSpan.data.attributes.custom?.trial || 0,
        type: taskSpan.data.attributes.custom?.type || "",
        error: taskSpan.data.attributes.custom?.error,
        chat: chatData[0] || {
          operation: "",
          capability: "",
          step: "",
          request: { max_token: "", model: "", temperature: 0 },
          response: { finish_reasons: "" },
          usage: { input_tokens: 0, output_tokens: 0 }
        }
      };
      caseData.task = taskData;
    }
    const scoreSpans = spans.filter(
      (span) => span.data.attributes.gen_ai.operation.name === "eval.score" && span.data.parent_span_id === caseSpan.data.span_id
    );
    caseData.scores = {};
    scoreSpans.forEach((score) => {
      const name = score.data.attributes.custom["eval.score.name"];
      caseData.scores[name] = {
        name,
        value: score.data.attributes.custom["eval.score.value"],
        metadata: {
          error: score.data.attributes.error
        }
      };
    });
    rootSpan.cases.push(caseData);
  }
  rootSpan.cases.sort((a2, b) => a2.index - b.index);
  return rootSpan;
};

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js
var f = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
var h = Object.entries(f);
function a(n) {
  return String(n);
}
a.open = "";
a.close = "";
function C(n = false) {
  let e = typeof process != "undefined" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];
  return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || (e == null ? void 0 : e.platform) === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window != "undefined" && !!window.chrome;
}
function p(n = false) {
  let e = C(n), i = (r2, t, c, o) => {
    let l = "", s2 = 0;
    do
      l += r2.substring(s2, o) + c, s2 = o + t.length, o = r2.indexOf(t, s2);
    while (~o);
    return l + r2.substring(s2);
  }, g = (r2, t, c = r2) => {
    let o = (l) => {
      let s2 = String(l), b = s2.indexOf(t, r2.length);
      return ~b ? r2 + i(s2, t, c, b) + t : r2 + s2 + t;
    };
    return o.open = r2, o.close = t, o;
  }, u2 = {
    isColorSupported: e
  }, d = (r2) => `\x1B[${r2}m`;
  for (let [r2, t] of h)
    u2[r2] = e ? g(
      d(t[0]),
      d(t[1]),
      t[2]
    ) : a;
  return u2;
}

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js
import { isatty as s } from "tty";
var r = process.env.FORCE_TTY !== void 0 || s(1);
var u = p(r);

// src/util/deep-equal.ts
function deepEqual(data, other) {
  if (data === other) {
    return true;
  }
  if (Object.is(data, other)) {
    return true;
  }
  if (typeof data !== "object" || typeof other !== "object") {
    return false;
  }
  if (data === null || other === null) {
    return false;
  }
  if (Object.getPrototypeOf(data) !== Object.getPrototypeOf(other)) {
    return false;
  }
  if (Array.isArray(data)) {
    return isDeepEqualArrays(data, other);
  }
  if (data instanceof Map) {
    return isDeepEqualMaps(data, other);
  }
  if (data instanceof Set) {
    return isDeepEqualSets(data, other);
  }
  if (data instanceof Date) {
    return data.getTime() === other.getTime();
  }
  if (data instanceof RegExp) {
    return data.toString() === other.toString();
  }
  if (Object.keys(data).length !== Object.keys(other).length) {
    return false;
  }
  for (const [key, value] of Object.entries(data)) {
    if (!(key in other)) {
      return false;
    }
    if (!deepEqual(
      value,
      // @ts-expect-error [ts7053] - We already checked that `other` has `key`
      other[key]
    )) {
      return false;
    }
  }
  return true;
}
function isDeepEqualArrays(data, other) {
  if (data.length !== other.length) {
    return false;
  }
  for (const [index, item] of data.entries()) {
    if (!deepEqual(item, other[index])) {
      return false;
    }
  }
  return true;
}
function isDeepEqualMaps(data, other) {
  if (data.size !== other.size) {
    return false;
  }
  for (const [key, value] of data.entries()) {
    if (!other.has(key)) {
      return false;
    }
    if (!deepEqual(value, other.get(key))) {
      return false;
    }
  }
  return true;
}
function isDeepEqualSets(data, other) {
  if (data.size !== other.size) {
    return false;
  }
  const otherCopy = [...other];
  for (const dataItem of data) {
    let isFound = false;
    for (const [index, otherItem] of otherCopy.entries()) {
      if (deepEqual(dataItem, otherItem)) {
        isFound = true;
        otherCopy.splice(index, 1);
        break;
      }
    }
    if (!isFound) {
      return false;
    }
  }
  return true;
}

// src/evals/reporter.console-utils.ts
function truncate(str, max) {
  return str.length > max ? str.slice(0, max) + "\u2026" : str;
}
function stringify(value) {
  try {
    if (typeof value === "string") return value;
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}
function printEvalNameAndFileName(testSuite, meta) {
  const cwd = process.cwd();
  console.log(
    " ",
    u.bgCyan(u.black(` ${testSuite.project.name} `)),
    u.bgBlue(u.black(` ${meta.evaluation.name}-${meta.evaluation.version} `)),
    u.dim(`(${testSuite.children.size} cases)`)
  );
  console.log(" ", u.dim(testSuite.module.moduleId.replace(cwd, "")));
}
function printBaselineNameAndVersion(testMeta) {
  if (testMeta.evaluation.baseline) {
    console.log(
      " ",
      " baseline ",
      u.bgMagenta(
        u.black(` ${testMeta.evaluation.baseline.name}-${testMeta.evaluation.baseline.version} `)
      )
    );
  } else {
    console.log(" ", u.bgWhite(u.blackBright(" baseline: ")), "none");
  }
  console.log("");
}
function printRuntimeFlags(testMeta) {
  if (testMeta.case.runtimeFlags && Object.keys(testMeta.case.runtimeFlags).length > 0) {
    const entries = Object.entries(testMeta.case.runtimeFlags);
    console.log("   ", u.dim("runtime flags"));
    for (const [k, v] of entries) {
      switch (v.kind) {
        case "replaced": {
          const valText = truncate(stringify(v.value), 80);
          const defText = truncate(stringify(v.default), 80);
          console.log("     ", `${k}: ${valText} (default: ${defText})`);
          break;
        }
        case "introduced": {
          const valText = truncate(stringify(v.value), 80);
          console.log("     ", `${k}: ${valText} (no default)`);
          break;
        }
      }
    }
  }
}
function printTestCaseCountStartDuration(testSuite, startTime, duration) {
  console.log(" ");
  console.log(" ", u.dim("Cases"), testSuite.children.size);
  console.log(" ", u.dim("Start at"), new Date(startTime).toTimeString());
  console.log(" ", u.dim("Duration"), `${duration}s`);
}
function printTestCaseSuccessOrFailed(testMeta, ok) {
  const index = testMeta.case.index;
  if (ok) {
    console.log(" ", u.yellow(` \u2714 case ${index}:`));
  } else {
    console.log(" ", u.red(` \u2716 case ${index}: failed`));
    for (const e of testMeta.case.errors ?? []) {
      console.log("", e.message);
    }
  }
}
function printTestCaseScores(testMeta, baseline) {
  const index = testMeta.case.index;
  Object.keys(testMeta.case.scores).forEach((k) => {
    const v = testMeta.case.scores[k].score ? testMeta.case.scores[k].score : 0;
    const scoreValue = Number(v * 100).toFixed(2) + "%";
    if (baseline?.cases[index]?.scores[k]) {
      const baselineScoreValue = baseline.cases[index].scores[k].value;
      const diff = v - baselineScoreValue;
      const diffText = Number(diff * 100).toFixed(2) + "%";
      const blScoreText = Number(baselineScoreValue * 100).toFixed(2) + "%";
      console.log(
        "   ",
        k,
        u.magentaBright(blScoreText),
        "->",
        u.blueBright(scoreValue),
        diff > 0 ? u.green("+" + diffText) : diff < 0 ? u.red(diffText) : diffText
      );
    } else {
      console.log("   ", k, u.blueBright(scoreValue));
    }
    return [k, scoreValue];
  });
}
function printOutOfScopeFlags(testMeta) {
  if (testMeta.case.outOfScopeFlags && testMeta.case.outOfScopeFlags.length > 0) {
    const pickedFlagsText = testMeta.case.pickedFlags ? `(picked: ${testMeta.case.pickedFlags.map((f2) => `'${f2}'`).join(", ")})` : "(none)";
    console.log("   ", u.yellow(`\u26A0 Out-of-scope flags: ${pickedFlagsText}`));
    testMeta.case.outOfScopeFlags.forEach((flag) => {
      const timeStr = new Date(flag.accessedAt).toLocaleTimeString();
      console.log("     ", `${flag.flagPath} (at ${timeStr})`);
      if (flag.stackTrace && flag.stackTrace.length > 0) {
        flag.stackTrace.forEach((frame, i) => {
          const prefix = i === flag.stackTrace.length - 1 ? " \u2514\u2500" : " \u251C\u2500";
          console.log("     ", u.dim(`${prefix} ${frame}`));
        });
      }
    });
  }
}
function printConfigHeader() {
  console.log("");
  console.log(" ", u.bgWhite(u.blackBright(" Config ")));
}
function maybePrintFlags(configEnd) {
  const defaults = configEnd?.flags ?? {};
  const overrides = configEnd?.overrides ?? {};
  const defaultKeys = Object.keys(defaults);
  const overrideKeys = Object.keys(overrides);
  const allKeys = Array.from(/* @__PURE__ */ new Set([...defaultKeys, ...overrideKeys])).sort();
  if (allKeys.length === 0) {
    return;
  }
  for (const key of allKeys) {
    const hasDefault = key in defaults;
    const hasOverride = key in overrides;
    if (hasDefault && hasOverride) {
      const defVal = defaults[key];
      const ovVal = overrides[key];
      const changed = !deepEqual(ovVal, defVal);
      const ovText = truncate(stringify(ovVal), 80);
      const defText = truncate(stringify(defVal), 80);
      if (changed) {
        console.log(
          "   ",
          `${key}: ${ovText} ${u.dim(`(overridden by CLI, original: ${defText})`)}`
        );
      } else {
        console.log("   ", `${key}: ${defText}`);
      }
    } else if (hasOverride) {
      const ovText = truncate(stringify(overrides[key]), 80);
      console.log("   ", `${key}: ${ovText} ${u.dim("(added by CLI)")}`);
    } else if (hasDefault) {
      const defText = truncate(stringify(defaults[key]), 80);
      console.log("   ", `${key}: ${defText}`);
    }
  }
  console.log("");
}
var reporterDate = (d) => {
  const date = d.toISOString().slice(0, 10);
  const hours = d.getUTCHours().toString().padStart(2, "0");
  const minutes = d.getUTCMinutes().toString().padStart(2, "0");
  return `${date}, ${hours}:${minutes} UTC`;
};
function printGlobalFlagOverrides(overrides, defaults) {
  if (Object.keys(overrides).length === 0) {
    console.log("");
    console.log(u.dim("Flag overrides: (none)"));
    console.log("");
    return;
  }
  console.log("");
  console.log("Flag overrides:");
  for (const [key, value] of Object.entries(overrides)) {
    const defaultValue = defaults[key];
    const valueStr = JSON.stringify(value);
    const defaultStr = defaultValue !== void 0 ? JSON.stringify(defaultValue) : "none";
    console.log(`  \u2022 ${key}: ${valueStr} ${u.dim(`(default: ${defaultStr})`)}`);
  }
  console.log("");
}
function printSuiteBox({
  suite,
  scorerAverages,
  calculateBaselineScorerAverage,
  flagDiff
}) {
  const filename = suite.file.split("/").pop();
  console.log("\u250C\u2500");
  console.log(`\u2502  ${u.blue(suite.name)} ${u.gray(`(${filename})`)}`);
  console.log("\u251C\u2500");
  const scorerNames = Object.keys(scorerAverages);
  const maxNameLength = Math.max(...scorerNames.map((name) => name.length));
  for (const scorerName of scorerNames) {
    const avg = scorerAverages[scorerName];
    const paddedName = scorerName.padEnd(maxNameLength);
    if (suite.baseline) {
      const baselineAvg = calculateBaselineScorerAverage(suite.baseline, scorerName);
      if (baselineAvg !== null) {
        const currentPercent = (avg * 100).toFixed(2) + "%";
        const baselinePercent = (baselineAvg * 100).toFixed(2) + "%";
        const diff = avg - baselineAvg;
        const diffText = (diff >= 0 ? "+" : "") + (diff * 100).toFixed(2) + "%";
        const diffColor = diff > 0 ? u.green : diff < 0 ? u.red : u.dim;
        const paddedBaseline = baselinePercent.padStart(7);
        const paddedCurrent = currentPercent.padStart(7);
        const paddedDiff = diffText.padStart(8);
        console.log(
          `\u2502  ${paddedName}  ${u.blueBright(paddedBaseline)} \u2192 ${u.magentaBright(paddedCurrent)}  (${diffColor(paddedDiff)})`
        );
      } else {
        const currentPercent = (avg * 100).toFixed(2) + "%";
        console.log(`\u2502   \u2022 ${paddedName}  ${currentPercent}`);
      }
    } else {
      const currentPercent = (avg * 100).toFixed(2) + "%";
      console.log(`\u2502   \u2022 ${paddedName}  ${currentPercent}`);
    }
  }
  console.log("\u251C\u2500");
  if (suite.baseline) {
    const baselineTimestamp = suite.baseline.runAt ? reporterDate(new Date(suite.baseline.runAt)) : "unknown time";
    console.log(
      `\u2502  Baseline: ${suite.baseline.name}-${suite.baseline.version} ${u.gray(`(${baselineTimestamp})`)}`
    );
  } else {
    console.log(`\u2502  Baseline: ${u.gray("(none)")}`);
  }
  if (suite.baseline) {
    const hasConfigChanges = flagDiff.length > 0;
    console.log("\u2502  Config changes:", hasConfigChanges ? "" : u.gray("(none)"));
    if (hasConfigChanges) {
      for (const { flag, current, baseline } of flagDiff) {
        console.log(
          `\u2502   \u2022 ${flag}: ${current ?? "<not set>"} ${u.gray(`(baseline: ${baseline ?? "<not set>"})`)}`
        );
      }
    }
  }
  if (suite.outOfScopeFlags && suite.outOfScopeFlags.length > 0) {
    const pickedFlagsText = suite.configFlags && suite.configFlags.length > 0 ? suite.configFlags.map((f2) => `'${f2}'`).join(", ") : "none";
    console.log("\u2502");
    console.log(
      `\u2502  ${u.yellow("\u26A0 Out-of-scope flags")} ${u.gray(`(picked: ${pickedFlagsText})`)}:`
    );
    for (const flag of suite.outOfScopeFlags) {
      const lastStackTraceFrame = flag.stackTrace[0];
      const lastStackTraceFnName = lastStackTraceFrame.split(" ").shift();
      const lastStackTraceFile = lastStackTraceFrame.split("/").pop()?.slice(0, -1);
      console.log(
        `\u2502   \u2022 ${flag.flagPath} ${u.gray(`at ${lastStackTraceFnName} (${lastStackTraceFile})`)}`
      );
    }
  }
  console.log("\u2514\u2500");
}
function printFinalReport({
  suiteData,
  calculateScorerAverages,
  calculateBaselineScorerAverage,
  calculateFlagDiff
}) {
  console.log("");
  console.log(u.bgBlue(u.white(" FINAL EVALUATION REPORT ")));
  console.log("");
  for (const suite of suiteData) {
    const scorerAverages = calculateScorerAverages(suite);
    const flagDiff = suite.baseline ? calculateFlagDiff(suite) : [];
    printSuiteBox({ suite, scorerAverages, calculateBaselineScorerAverage, flagDiff });
    console.log("");
  }
  console.log("View full report:");
  console.log("https://app.axiom.co/evaluations/run/<run-id>");
}

// src/evals/reporter.ts
var AxiomReporter = class {
  constructor() {
    __publicField(this, "startTime", 0);
    __publicField(this, "start", 0);
    __publicField(this, "_endOfRunConfigEnd");
    __publicField(this, "_suiteData", []);
    __publicField(this, "_baselines", /* @__PURE__ */ new Map());
  }
  onTestRunStart() {
    this.start = performance.now();
    this.startTime = (/* @__PURE__ */ new Date()).getTime();
    const overrides = getGlobalFlagOverrides();
    const defaults = getConfigScope()?.getAllDefaultFlags?.() ?? {};
    printGlobalFlagOverrides(overrides, defaults);
  }
  async onTestSuiteReady(_testSuite) {
    const meta = _testSuite.meta();
    if (_testSuite.state() === "skipped") {
      return;
    }
    const baseline = meta.evaluation.baseline;
    if (baseline) {
      const config = getAxiomConfig();
      if (!config) {
        throw new AxiomCLIError("Axiom config not available in reporter");
      }
      const baselineData = await findEvaluationCases(baseline.id, config);
      this._baselines.set(meta.evaluation.name, baselineData || null);
    } else {
      this._baselines.set(meta.evaluation.name, null);
    }
    if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {
      this._endOfRunConfigEnd = meta.evaluation.configEnd;
    }
  }
  onTestCaseReady(test) {
    const meta = test.meta();
    if (!meta.case) return;
  }
  async onTestSuiteResult(testSuite) {
    const meta = testSuite.meta();
    if (testSuite.state() === "skipped") {
      return;
    }
    const durationSeconds = Number((performance.now() - this.start) / 1e3).toFixed(2);
    const cases = [];
    for (const test of testSuite.children) {
      if (test.type !== "test") continue;
      const testMeta = test.meta();
      if (!testMeta?.case) continue;
      cases.push({
        index: testMeta.case.index,
        scores: testMeta.case.scores,
        outOfScopeFlags: testMeta.case.outOfScopeFlags,
        errors: testMeta.case.errors,
        runtimeFlags: testMeta.case.runtimeFlags
      });
    }
    const cwd = process.cwd();
    const relativePath = testSuite.module.moduleId.replace(cwd, "").replace(/^\//, "");
    let suiteBaseline = this._baselines.get(meta.evaluation.name);
    if (suiteBaseline === void 0 && meta.evaluation.baseline) {
      const config = getAxiomConfig();
      if (!config) {
        throw new AxiomCLIError("Axiom config not available in reporter");
      }
      const baselineData = await findEvaluationCases(meta.evaluation.baseline.id, config);
      suiteBaseline = baselineData || null;
      this._baselines.set(meta.evaluation.name, suiteBaseline);
    }
    this._suiteData.push({
      name: meta.evaluation.name,
      file: relativePath,
      duration: durationSeconds + "s",
      baseline: suiteBaseline || null,
      configFlags: meta.evaluation.configFlags,
      flagConfig: meta.evaluation.flagConfig,
      cases,
      outOfScopeFlags: meta.evaluation.outOfScopeFlags
    });
    printEvalNameAndFileName(testSuite, meta);
    printBaselineNameAndVersion(meta);
    printTestCaseCountStartDuration(testSuite, this.startTime, durationSeconds);
    for (const test of testSuite.children) {
      if (test.type !== "test") continue;
      this.printCaseResult(test, suiteBaseline || null);
    }
    console.log("");
  }
  async onTestRunEnd(_testModules, _errors, _reason) {
    const shouldClear = !process.env.CI && process.stdout.isTTY !== false;
    if (shouldClear) {
      process.stdout.write("\x1B[2J\x1B[0f");
    }
    printFinalReport({
      suiteData: this._suiteData,
      calculateScorerAverages: this.calculateScorerAverages.bind(this),
      calculateBaselineScorerAverage: this.calculateBaselineScorerAverage.bind(this),
      calculateFlagDiff: this.calculateFlagDiff.bind(this)
    });
    const DEBUG = process.env.AXIOM_DEBUG === "true";
    if (DEBUG && this._endOfRunConfigEnd) {
      this.printConfigEnd(this._endOfRunConfigEnd);
    }
  }
  printCaseResult(test, baseline) {
    const ok = test.ok();
    const testMeta = test.meta();
    if (!testMeta?.case) {
      return;
    }
    printTestCaseSuccessOrFailed(testMeta, ok);
    printTestCaseScores(testMeta, baseline);
    printRuntimeFlags(testMeta);
    printOutOfScopeFlags(testMeta);
  }
  /**
   * Calculate average scores per scorer for a suite
   */
  calculateScorerAverages(suite) {
    const scorerTotals = {};
    for (const caseData of suite.cases) {
      for (const [scorerName, score] of Object.entries(caseData.scores)) {
        if (!scorerTotals[scorerName]) {
          scorerTotals[scorerName] = { sum: 0, count: 0 };
        }
        scorerTotals[scorerName].sum += score.score || 0;
        scorerTotals[scorerName].count += 1;
      }
    }
    const averages = {};
    for (const [scorerName, totals] of Object.entries(scorerTotals)) {
      averages[scorerName] = totals.count > 0 ? totals.sum / totals.count : 0;
    }
    return averages;
  }
  /**
   * Calculate average score for a specific scorer from baseline data
   */
  calculateBaselineScorerAverage(baseline, scorerName) {
    const scores = [];
    for (const caseData of baseline.cases) {
      if (caseData.scores[scorerName]) {
        scores.push(caseData.scores[scorerName].value);
      }
    }
    if (scores.length === 0) return null;
    const sum = scores.reduce((acc, val) => acc + val, 0);
    return sum / scores.length;
  }
  /**
   * Calculate flag diff between current run and baseline (filtered by configFlags)
   */
  calculateFlagDiff(suite) {
    if (!suite.baseline || !suite.configFlags || suite.configFlags.length === 0) {
      return [];
    }
    const diffs = [];
    const currentConfig = suite.flagConfig || {};
    const baselineConfig = suite.baseline.flagConfig || {};
    const currentFlat = flattenObject(currentConfig);
    const baselineFlat = flattenObject(baselineConfig);
    const allKeys = /* @__PURE__ */ new Set([...Object.keys(currentFlat), ...Object.keys(baselineFlat)]);
    for (const key of allKeys) {
      const isInScope = suite.configFlags.some((pattern) => key.startsWith(pattern));
      if (!isInScope) continue;
      const currentValue = currentFlat[key];
      const baselineValue = baselineFlat[key];
      if (JSON.stringify(currentValue) !== JSON.stringify(baselineValue)) {
        diffs.push({
          flag: key,
          current: currentValue ? JSON.stringify(currentValue) : void 0,
          baseline: baselineValue ? JSON.stringify(baselineValue) : void 0
        });
      }
    }
    return diffs;
  }
  /**
   * End-of-suite config summary (console only)
   */
  printConfigEnd(configEnd) {
    printConfigHeader();
    maybePrintFlags(configEnd);
  }
};

// src/evals/instrument.ts
import { BatchSpanProcessor, NodeTracerProvider } from "@opentelemetry/sdk-trace-node";
import { resourceFromAttributes } from "@opentelemetry/resources";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import {
  trace as trace3
} from "@opentelemetry/api";
var axiomProvider;
var axiomTracer;
var userProvider;
var initializationPromise = null;
var initialized = false;
async function runInstrumentationHook(hook, options) {
  try {
    return await hook(options);
  } catch (error) {
    throw new AxiomCLIError(`Failed to execute instrumentation hook: ${errorToString(error)}`);
  }
}
function setupEvalProvider(connection) {
  const headers = {
    "X-Axiom-Dataset": connection.dataset
  };
  if (connection.token) {
    headers.Authorization = `Bearer ${connection.token}`;
  }
  const collectorOptions = {
    url: `${connection.url}/v1/traces`,
    headers,
    concurrencyLimit: 10
  };
  const exporter = new OTLPTraceExporter(collectorOptions);
  const processor = new BatchSpanProcessor(exporter, {
    maxQueueSize: 2048,
    maxExportBatchSize: 512,
    scheduledDelayMillis: 5e3,
    exportTimeoutMillis: 3e4
  });
  axiomProvider = new NodeTracerProvider({
    resource: resourceFromAttributes({
      ["service.name"]: "axiom",
      ["service.version"]: "0.22.0"
    }),
    spanProcessors: [processor]
  });
  axiomTracer = axiomProvider.getTracer("axiom", "0.22.0");
}
async function initInstrumentation(config) {
  if (initialized) {
    return;
  }
  if (initializationPromise) {
    await initializationPromise;
    return;
  }
  initializationPromise = (async () => {
    if (!config.enabled) {
      axiomTracer = trace3.getTracer("axiom", "0.22.0");
      initialized = true;
      return;
    }
    const connection = resolveAxiomConnection(config.config);
    const hook = config.config.eval.instrumentation;
    let hookResult = void 0;
    if (hook) {
      config.config.eval.instrumentation = hook;
      hookResult = await runInstrumentationHook(hook, {
        dataset: connection.dataset,
        token: connection.token,
        url: connection.url
      });
      userProvider = hookResult?.provider ?? userProvider;
    }
    setupEvalProvider(connection);
    if (!hook) {
      axiomProvider?.register();
      if (axiomTracer) {
        initAxiomAI({ tracer: axiomTracer });
      }
    }
    initialized = true;
  })();
  try {
    await initializationPromise;
  } finally {
    initializationPromise = null;
  }
}
var flush = async () => {
  if (initializationPromise) {
    await initializationPromise;
  }
  const tasks = [];
  if (axiomProvider) {
    tasks.push(axiomProvider.forceFlush());
  }
  const candidateProviders = /* @__PURE__ */ new Set();
  if (userProvider) {
    candidateProviders.add(userProvider);
  }
  const globalProvider = trace3.getTracerProvider();
  if (globalProvider) {
    candidateProviders.add(globalProvider);
  }
  for (const provider of candidateProviders) {
    const flushFn = provider.forceFlush;
    if (typeof flushFn === "function") {
      tasks.push(
        flushFn.call(provider).catch((error) => {
          console.warn("[AxiomAI] Failed to flush tracer provider:", errorToString(error));
        })
      );
    }
  }
  if (tasks.length > 0) {
    await Promise.all(tasks);
  }
};
async function ensureInstrumentationInitialized(config) {
  if (initialized) {
    return;
  }
  await initInstrumentation({ enabled: true, config });
}
var getEvalTracer = () => {
  if (!axiomTracer) {
    throw new Error(
      "Eval tracer not initialized. Ensure ensureInstrumentationInitialized() was awaited before starting spans."
    );
  }
  return axiomTracer;
};
var startSpan = (name, opts, context) => {
  if (!initialized || !axiomTracer) {
    throw new Error(
      "Instrumentation not initialized. This is likely a bug - instrumentation should be initialized before startSpan is called."
    );
  }
  return getEvalTracer().startSpan(name, opts, context);
};

export {
  u,
  setGlobalFlagOverrides,
  getGlobalFlagOverrides,
  dotNotationToNested,
  validateCliFlags,
  createAppScope,
  setAxiomConfig,
  EVAL_CONTEXT,
  getEvalContext,
  putOnSpan,
  withEvalContext,
  getConfigScope,
  findBaseline,
  findEvaluationCases,
  deepEqual,
  AxiomReporter,
  initInstrumentation,
  flush,
  ensureInstrumentationInitialized,
  startSpan
};
//# sourceMappingURL=chunk-JOVIRPRL.js.map