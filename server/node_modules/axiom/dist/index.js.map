{"version":3,"sources":["../src/otel/wrapTool.ts","../src/util/typedEntries.ts","../src/template.ts","../src/prompt/index.ts"],"sourcesContent":["import { type Span } from '@opentelemetry/api';\nimport { type Tool as ToolV4 } from 'aiv4';\nimport { type Tool as ToolV5 } from 'aiv5';\nimport { createStartActiveSpan } from './startActiveSpan';\nimport { Attr } from './semconv/attributes';\nimport { typedEntries } from '../util/typedEntries';\nimport {\n  setAxiomBaseAttributes,\n  getTracer,\n  classifyToolError,\n  setScopeAttributes,\n} from './utils/wrapperUtils';\nimport { getRedactionPolicy, handleMaybeRedactedAttribute } from './utils/redaction';\n\ntype Tool = ToolV4 | ToolV5;\ntype WrappedTool<T> = T extends Tool ? T : never;\n\ninterface ToolLike {\n  execute?: (...args: any[]) => any;\n  description?: string;\n  [key: string]: any;\n}\n\n/**\n * Wraps a tool to create child spans when the tool's execute method is called.\n *\n * @param toolName The name of the tool (key from the tools object) - span name will be `execute_tool <toolName>`\n * @param tool The tool to wrap\n * @returns The same tool but with a wrapped execute method that creates spans\n */\nexport function wrapTool<T extends ToolLike>(toolName: string, tool: T): T {\n  if (!tool || typeof tool !== 'object') {\n    console.error('Invalid tool provided to wrapTool, returning unwrapped tool');\n    return tool as T;\n  }\n\n  if (!('execute' in tool) || typeof tool.execute !== 'function') {\n    console.error(\n      'Cannot wrap a tool that does not have an execute method, returning unwrapped tool',\n    );\n    return tool as T;\n  }\n\n  // After the type guard, we know execute exists and is a function\n  const originalExecute = tool.execute as (...args: any[]) => any;\n\n  return {\n    ...tool,\n    execute: async (...executeArgs: Parameters<typeof originalExecute>) => {\n      const [args, opts] = executeArgs;\n      const tracer = getTracer();\n      const startActiveSpan = createStartActiveSpan(tracer);\n      const spanName = `${Attr.GenAI.Operation.Name_Values.ExecuteTool} ${toolName}`;\n\n      return startActiveSpan(spanName, null, async (span: Span) => {\n        const redactionPolicy = getRedactionPolicy();\n\n        setAxiomBaseAttributes(span);\n        setScopeAttributes(span);\n\n        // Handle different opts structures between AI SDK versions\n        const toolCallId =\n          opts && typeof opts === 'object'\n            ? opts.toolCallId || opts.toolCall?.toolCallId\n            : undefined;\n\n        if (toolCallId) {\n          span.setAttribute(Attr.GenAI.Tool.CallID, toolCallId);\n        }\n\n        span.setAttribute(Attr.GenAI.Operation.Name, Attr.GenAI.Operation.Name_Values.ExecuteTool);\n        span.setAttribute(Attr.GenAI.Tool.Name, toolName);\n\n        const type = args && typeof args === 'object' && 'type' in args ? args.type : 'function';\n        span.setAttribute(Attr.GenAI.Tool.Type, type);\n\n        if (tool.description) {\n          span.setAttribute(Attr.GenAI.Tool.Description, tool.description);\n        }\n\n        if (redactionPolicy.mirrorToolPayloadOnToolSpan) {\n          try {\n            handleMaybeRedactedAttribute(\n              span,\n              Attr.GenAI.Tool.Arguments,\n              JSON.stringify(args),\n              redactionPolicy.captureMessageContent,\n            );\n          } catch (_error) {\n            // Handle circular references or other JSON serialization errors\n            span.setAttribute(Attr.GenAI.Tool.Arguments, '[Unable to serialize arguments]');\n          }\n        }\n\n        try {\n          // Execute the original tool function\n          const result = await originalExecute(args, opts);\n\n          // Conditionally set tool result message if mirroring is enabled\n          if (redactionPolicy.mirrorToolPayloadOnToolSpan) {\n            try {\n              handleMaybeRedactedAttribute(\n                span,\n                Attr.GenAI.Tool.Message,\n                JSON.stringify(result),\n                redactionPolicy.captureMessageContent,\n              );\n            } catch (_error) {\n              // Handle circular references or other JSON serialization errors\n              span.setAttribute(Attr.GenAI.Tool.Message, '[Unable to serialize result]');\n            }\n          }\n\n          return result;\n        } catch (err) {\n          classifyToolError(err, span);\n\n          // Always re-throw tool errors to allow the calling code/AI SDK to decide\n          // whether to handle gracefully or fail the parent span.\n          throw err;\n        }\n      });\n    },\n  } as WrappedTool<T>;\n}\n\n/**\n * Wraps multiple tools to create child spans when their execute methods are called.\n *\n * @param tools An object containing tools to wrap\n * @returns The same object with all tools wrapped\n */\nexport function wrapTools<T extends Record<string, ToolLike>>(tools: T): T {\n  if (!tools || typeof tools !== 'object') {\n    console.error('Invalid tools object provided to wrapTools');\n    return tools;\n  }\n\n  const wrappedTools = {} as T;\n\n  for (const [toolName, tool] of typedEntries(tools)) {\n    wrappedTools[toolName] = wrapTool(toolName as string, tool);\n  }\n\n  return wrappedTools;\n}\n","export function typedEntries<T extends object>(obj: T): [keyof T, T[keyof T]][] {\n  return Object.entries(obj) as [keyof T, T[keyof T]][];\n}\n","import { Type as TypeBox, type TSchema as TypeBoxSchema, type Static } from '@sinclair/typebox';\n\n/**\n * Template-friendly TypeBox types for use with Handlebars.\n *\n * These types are designed to be easily serializable and work well in template contexts\n * where data needs to be rendered as strings or used in conditionals and loops.\n *\n * All composite types (Array, Object, etc.) only accept other Template types.\n */\n\n// Brand to distinguish Template types from raw TypeBox types\ndeclare const SchemaBrand: unique symbol;\ntype TSchema<T extends TypeBoxSchema = TypeBoxSchema> = T & { [SchemaBrand]: true };\n\n/**\n * Utility type to infer TypeScript types from {@link TSchema}.\n */\nexport type InferSchema<T extends TSchema> = Static<T>;\n\n/**\n * Utility type to infer context types from {@link Prompt} arguments.\n *\n * Used with {@link parse} function to ensure type safety when providing context values.\n */\nexport type InferContext<T extends Record<string, TSchema>> = Static<\n  ReturnType<typeof createObject<T>>\n>;\n\ntype OmitFirst<T extends any[]> = T extends [any, ...infer R] ? R : never;\n\n// Helper to create branded Template types\nconst createTemplateType = <T extends TypeBoxSchema>(schema: T): TSchema<T> => schema as TSchema<T>;\n\n// Primitive type creators\nconst createString = (...args: Parameters<typeof TypeBox.String>) =>\n  createTemplateType(TypeBox.String(...args));\nconst createNumber = (...args: Parameters<typeof TypeBox.Number>) =>\n  createTemplateType(TypeBox.Number(...args));\nconst createInteger = (...args: Parameters<typeof TypeBox.Integer>) =>\n  createTemplateType(TypeBox.Integer(...args));\nconst createBoolean = (...args: Parameters<typeof TypeBox.Boolean>) =>\n  createTemplateType(TypeBox.Boolean(...args));\nconst createNull = (...args: Parameters<typeof TypeBox.Null>) =>\n  createTemplateType(TypeBox.Null(...args));\nconst createLiteral = <T extends string | number | boolean>(\n  value: T,\n  ...args: OmitFirst<Parameters<typeof TypeBox.Literal>>\n) => createTemplateType(TypeBox.Literal(value, ...args));\nconst createUndefined = (...args: Parameters<typeof TypeBox.Undefined>) =>\n  createTemplateType(TypeBox.Undefined(...args));\n\n// Collection type creators - only accept Template types\nconst createArray = <T extends TSchema>(\n  items: T,\n  ...args: OmitFirst<Parameters<typeof TypeBox.Array>>\n) => createTemplateType(TypeBox.Array(items, ...args));\n\nconst createObject = <T extends Record<string, TSchema>>(\n  properties: T,\n  ...args: OmitFirst<Parameters<typeof TypeBox.Object>>\n) => createTemplateType(TypeBox.Object(properties, ...args));\n\nconst createRecord = <V extends TSchema>(\n  value: V,\n  ...args: OmitFirst<OmitFirst<Parameters<typeof TypeBox.Record>>>\n) => createTemplateType(TypeBox.Record(TypeBox.String(), value, ...args));\n\nconst createTuple = <T extends TSchema[]>(\n  types: [...T],\n  ...args: OmitFirst<Parameters<typeof TypeBox.Tuple>>\n) => {\n  return createTemplateType(TypeBox.Tuple(types, ...args));\n};\n\n// Modifier type creators - only accept Template types\nconst createOptional = <T extends TSchema>(\n  schema: T,\n  ...args: OmitFirst<Parameters<typeof TypeBox.Optional>>\n) => createTemplateType(TypeBox.Optional(schema, true, ...args));\n\nconst createUnion = <T extends TSchema[]>(\n  schemas: [...T],\n  ...args: OmitFirst<Parameters<typeof TypeBox.Union>>\n) => createTemplateType(TypeBox.Union(schemas, ...args));\n\n// Export all template-friendly types as a namespace\nexport const Type = {\n  // Primitives\n  String: createString,\n  Number: createNumber,\n  Integer: createInteger,\n  Boolean: createBoolean,\n  Null: createNull,\n  Undefined: createUndefined,\n\n  // Literals\n  Literal: createLiteral,\n\n  // Collections - only accept Template types\n  Array: createArray,\n  Object: createObject,\n  Record: createRecord,\n  Tuple: createTuple,\n\n  // Modifiers - only accept Template types\n  Optional: createOptional,\n  Union: createUnion,\n} as const;\n\n// Export the branded type for advanced usage\nexport type { TSchema };\n\n// Default export for convenience\nexport default Type;\n","import type { Prompt } from '../types';\nimport type { InferContext } from '../template';\nimport type { AxiomPromptMetadata, ParsedMessage, ParsedMessagesArray } from '../types/metadata';\n\nconst getParser = async () => {\n  const handlebars = await import('./parsers/handlebars').then((m) => m.handlebarsParse);\n  return handlebars;\n};\n\n/**\n * Parses a prompt template by replacing variables with provided context values.\n *\n * This function processes Handlebars templates in prompt messages and attaches metadata\n * for instrumentation and tracking.\n *\n * @experimental This API is experimental and may change in future versions.\n *\n * @param prompt - The {@link Prompt} template to parse\n * @param options - Parsing options\n * @param options.context - Context values to substitute into the template\n * @returns Promise that resolves to the parsed prompt with processed messages;\n */\nexport const parse = async <\n  TPrompt extends Prompt,\n  TMessages extends TPrompt['messages'] = TPrompt['messages'],\n>(\n  prompt: TPrompt & { messages: TMessages },\n  {\n    context,\n  }: {\n    context: InferContext<TPrompt['arguments']>;\n  },\n): Promise<Omit<TPrompt, 'messages'> & { messages: ParsedMessagesArray<TMessages> }> => {\n  const messagesPromises = prompt.messages.map(async (message) => {\n    const parser = await getParser();\n    return {\n      ...message,\n      content: await parser(message.content, { context }),\n    };\n  });\n\n  const parsedMessages: ParsedMessage[] = await Promise.all(messagesPromises);\n\n  // Create metadata object from prompt\n  const promptMetadata: AxiomPromptMetadata = {\n    id: prompt.promptId,\n    name: prompt.name,\n    slug: prompt.slug,\n    version: prompt.version,\n  };\n\n  // Attach metadata to the last message's providerOptions for detection in the wrapper\n  // The Vercel SDK converts providerOptions -> providerMetadata in convertToLanguageModelMessage\n  if (parsedMessages.length > 0) {\n    const lastMessage = parsedMessages[parsedMessages.length - 1];\n    lastMessage.providerOptions = {\n      ...lastMessage.providerOptions,\n      _axiomMeta: promptMetadata,\n    };\n    lastMessage.providerMetadata = {\n      ...lastMessage.providerMetadata,\n      _axiomMeta: promptMetadata,\n    };\n  }\n\n  // Also create a Proxy for direct access in tests\n  const messages = new Proxy(parsedMessages, {\n    get(target: ParsedMessage[], prop: string | symbol, receiver: unknown): any {\n      // Special metadata access\n      if (prop === '_axiomMeta') {\n        return promptMetadata;\n      }\n      // All other properties (array methods, indices, etc.)\n      return Reflect.get(target, prop, receiver) as ParsedMessage | undefined;\n    },\n  }) as ParsedMessagesArray<TMessages>;\n\n  return {\n    ...prompt,\n    messages: messages,\n  };\n};\n\n// Re-export template types for convenience\nexport { Type as Template, type InferContext } from '../template';\n"],"mappings":"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","names":[]}