{"version":3,"sources":["../src/validate-flags.ts","../src/evals/context/global-flags.ts","../src/cli/utils/format-zod-errors.ts","../src/util/dot-path.ts","../src/evals/context/storage.ts","../src/evals/context/manager.ts","../src/app-scope.ts","../src/otel/utils/to-otel-attribute.ts","../src/config/resolver.ts","../src/evals/eval.service.ts","../../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js","../../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js","../src/util/deep-equal.ts","../src/evals/reporter.console-utils.ts","../src/evals/reporter.ts","../src/evals/instrument.ts"],"sourcesContent":["import { type ZodObject } from 'zod';\nimport { getGlobalFlagOverrides } from './evals/context/global-flags';\nimport { formatZodErrors, generateFlagExamples } from './cli/utils/format-zod-errors';\nimport { dotNotationToNested, isValidPath, parsePath } from './util/dot-path';\n\n/**\n * Validate CLI flag overrides against a schema early in eval execution.\n * Call this at the top of your eval file to fail fast on invalid flags.\n *\n * @param flagSchema - Zod schema to validate CLI flags against\n * @throws Error with helpful message if validation fails\n */\nexport function validateCliFlags(flagSchema: ZodObject<any>): void {\n  const globalOverrides = getGlobalFlagOverrides();\n\n  if (Object.keys(globalOverrides).length === 0) {\n    // No CLI flags provided, nothing to validate\n    return;\n  }\n\n  validateFlags(flagSchema, globalOverrides);\n}\n\nfunction validateFlags(flagSchema: ZodObject<any>, globalOverrides: Record<string, any>): void {\n  // First pass: check all paths exist in schema\n  for (const [dotPath, _value] of Object.entries(globalOverrides)) {\n    const segments = parsePath(dotPath);\n    if (!isValidPath(flagSchema, segments)) {\n      console.error('âŒ Invalid CLI flags:');\n      console.error(`  â€¢ flag '${dotPath}': Invalid flag path`);\n      console.error('\\nðŸ”§ Fix your CLI flags and try again.\\n');\n      process.exit(1);\n    }\n  }\n\n  // Second pass: validate values using nested object approach\n  const nestedObject = dotNotationToNested(globalOverrides);\n  const result = flagSchema.strict().partial().safeParse(nestedObject);\n\n  if (!result.success) {\n    console.error('âŒ Invalid CLI flags:');\n    console.error(formatZodErrors(result.error));\n\n    const examples = generateFlagExamples(result.error);\n    if (examples.length > 0) {\n      console.error('\\nðŸ’¡ Valid examples:');\n      examples.forEach((example) => console.error(`  ${example}`));\n    }\n\n    console.error('\\nðŸ”§ Fix your CLI flags and try again.\\n');\n    process.exit(1);\n  }\n}\n","/**\n * Global flag overrides storage for CLI flag functionality.\n * Uses globalThis for process-wide flag persistence.\n */\n\nconst GLOBAL_OVERRIDES_SYMBOL = Symbol.for('axiom.global_flag_overrides');\n\nfunction getRoot(): Record<string, any> {\n  return (globalThis as any)[GLOBAL_OVERRIDES_SYMBOL] ?? {};\n}\n\nfunction setRoot(val: Record<string, any>): void {\n  (globalThis as any)[GLOBAL_OVERRIDES_SYMBOL] = val;\n}\n\n/**\n * Set global flag overrides (called by CLI) - persists until cleared\n */\nexport function setGlobalFlagOverrides(overrides: Record<string, any>): void {\n  setRoot(overrides);\n}\n\n/**\n * Get global flag overrides (called by flag functions)\n */\nexport function getGlobalFlagOverrides(): Record<string, any> {\n  return getRoot();\n}\n\n/**\n * Clear global flag overrides (for testing)\n */\nexport function clearGlobalFlagOverrides(): void {\n  setRoot({});\n}\n","import { type ZodError } from 'zod';\nimport type { ZodIssue } from 'zod/v3';\nimport type { $ZodIssue } from 'zod/v4/core';\n\n/**\n * Format ZodError issues into user-friendly CLI error messages\n */\nexport function formatZodErrors(error: ZodError): string {\n  const issues = error.issues;\n  const messages: string[] = [];\n\n  for (const issue of issues) {\n    const path = issue.path.join('.');\n    const message = formatIssueMessage(issue, path);\n    messages.push(`  â€¢ ${message}`);\n  }\n\n  return messages.join('\\n');\n}\n\nfunction formatIssueMessage(issue: any, path: string): string {\n  switch (issue.code) {\n    case 'invalid_type':\n      return `flag '${path}' expected ${issue.expected}, got ${JSON.stringify(issue.received)} (${typeof issue.received})`;\n\n    case 'too_small':\n      if (issue.type === 'number' || issue.origin === 'number') {\n        return `flag '${path}' must be >= ${issue.minimum}, got ${issue.received}`;\n      }\n      return `flag '${path}' is too small: ${issue.message}`;\n\n    case 'too_big':\n      if (issue.type === 'number') {\n        return `flag '${path}' must be <= ${issue.maximum}, got ${issue.received}`;\n      }\n      return `flag '${path}' is too big: ${issue.message}`;\n\n    case 'invalid_enum_value':\n      const options = issue.options.map((opt: any) => `\"${opt}\"`).join(', ');\n      return `flag '${path}' must be one of: ${options}, got \"${issue.received}\"`;\n\n    case 'invalid_value':\n      // Handle enum validation errors\n      if (issue.values && Array.isArray(issue.values)) {\n        const values = issue.values.map((val: any) => `\"${val}\"`).join(', ');\n        return `flag '${path}' must be one of: ${values}`;\n      }\n      return `flag '${path}': ${issue.message}`;\n\n    case 'unrecognized_keys':\n      // Handle unrecognized keys properly, especially when path is empty\n      const keys = issue.keys || [];\n      if (keys.length === 1) {\n        return `unrecognized flag '${keys[0]}'`;\n      } else if (keys.length > 1) {\n        const keysList = keys.map((key: string) => `'${key}'`).join(', ');\n        return `unrecognized flags ${keysList}`;\n      }\n      return `unrecognized keys in flags`;\n\n    case 'custom':\n      return `flag '${path}': ${issue.message}`;\n\n    default:\n      return `flag '${path}': ${issue.message}`;\n  }\n}\n\n/**\n * Create helpful examples for CLI usage based on validation errors\n */\nexport function generateFlagExamples(error: ZodError): string[] {\n  const examples: string[] = [];\n\n  for (const issue of error.issues) {\n    const path = issue.path.join('.');\n    const example = generateExampleForIssue(issue, path);\n    if (example && !examples.includes(example)) {\n      examples.push(example);\n    }\n  }\n\n  return examples.slice(0, 3); // Limit to 3 examples\n}\n\nfunction generateExampleForIssue(issue: ZodIssue | $ZodIssue, path: string): string | null {\n  switch (issue.code) {\n    case 'invalid_type':\n      if (issue.expected === 'number') {\n        return `--flag.${path}=0.7`;\n      }\n      if (issue.expected === 'boolean') {\n        return `--flag.${path}=true`;\n      }\n      if (issue.expected === 'string') {\n        return `--flag.${path}=\"value\"`;\n      }\n      break;\n\n    case 'too_small':\n      if (typeof issue.minimum === 'number' || typeof issue.minimum === 'bigint') {\n        return `--flag.${path}=${issue.minimum}`;\n      }\n      break;\n\n    case 'too_big':\n      if (typeof issue.maximum === 'number' || typeof issue.maximum === 'bigint') {\n        return `--flag.${path}=${issue.maximum}`;\n      }\n      break;\n\n    case 'invalid_enum_value':\n      if (issue.options.length > 0) {\n        return `--flag.${path}=${issue.options[0]}`;\n      }\n      break;\n\n    case 'invalid_value':\n      if (issue.values && Array.isArray(issue.values) && issue.values.length > 0) {\n        return `--flag.${path}=${String(issue.values[0])}`;\n      }\n      break;\n  }\n\n  return null;\n}\n","import { type ZodObject, type ZodSchema, z } from 'zod';\n\n/**\n * Parse a dot notation path into segments.\n * @param path - Dot notation path like \"ui.theme\" or \"api.timeout\"\n * @returns Array of path segments\n */\nexport function parsePath(path: string): string[] {\n  return path.split('.');\n}\n\n/**\n * Transform dot notation object to nested object structure.\n * Example: {\"ui.theme\": \"dark\", \"config.name\": \"test\"}\n * -> {ui: {theme: \"dark\"}, config: {name: \"test\"}}\n */\nexport function dotNotationToNested(dotNotationObject: Record<string, any>): Record<string, any> {\n  const result: Record<string, any> = {};\n\n  for (const [dotPath, value] of Object.entries(dotNotationObject)) {\n    const segments = parsePath(dotPath);\n    let current = result;\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n\n      if (i === segments.length - 1) {\n        // Last segment - set the value\n        current[segment] = value;\n      } else {\n        // Intermediate segment - ensure object exists\n        if (!(segment in current) || typeof current[segment] !== 'object') {\n          current[segment] = {};\n        }\n        current = current[segment];\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Flatten nested object to dot notation.\n * Example: {ui: {theme: \"dark\"}, config: {name: \"test\"}}\n * -> {\"ui.theme\": \"dark\", \"config.name\": \"test\"}\n */\nexport function flattenObject(obj: Record<string, any>, prefix = ''): Record<string, any> {\n  const result: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const newKey = prefix ? `${prefix}.${key}` : key;\n\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\n      Object.assign(result, flattenObject(value, newKey));\n    } else {\n      result[newKey] = value;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Check if a dot notation path exists in the schema.\n */\nexport function isValidPath(schema: ZodObject<any>, segments: string[]): boolean {\n  let currentSchema = schema;\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n\n    if (!currentSchema.shape || !(segment in currentSchema.shape)) {\n      return false;\n    }\n\n    if (i < segments.length - 1) {\n      // Not the last segment, should be a ZodObject\n      const nextSchema = currentSchema.shape[segment];\n\n      // Handle wrapped schemas (ZodDefault, ZodOptional, etc.)\n      let unwrappedSchema = nextSchema;\n      while (unwrappedSchema?._def?.innerType || unwrappedSchema?._def?.schema) {\n        unwrappedSchema = unwrappedSchema._def.innerType || unwrappedSchema._def.schema;\n      }\n\n      if (!unwrappedSchema || unwrappedSchema._def?.type !== 'object') {\n        return false;\n      }\n\n      currentSchema = unwrappedSchema;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Get value at a specific path in a nested object.\n */\nexport function getValueAtPath(obj: any, segments: string[]): any {\n  let current = obj;\n  for (const segment of segments) {\n    if (current == null || typeof current !== 'object' || !(segment in current)) {\n      return undefined;\n    }\n    current = current[segment];\n  }\n  return current;\n}\n\n/**\n * Helper function to traverse schema object to find the field schema at a specific path.\n */\nexport function findSchemaAtPath(\n  rootSchema: ZodObject<any> | undefined,\n  segments: string[],\n): ZodSchema<any> | undefined {\n  if (!rootSchema || segments.length === 0) return undefined;\n\n  let current: any = rootSchema;\n\n  // ZodObject root - start with the shape\n  if (segments.length > 0) {\n    if (!current.shape || !(segments[0] in current.shape)) {\n      return undefined;\n    }\n    current = current.shape[segments[0]];\n    // Continue with remaining segments starting from index 1\n    for (let i = 1; i < segments.length; i++) {\n      const segment = segments[i];\n      if (!current || !current._def) {\n        return undefined;\n      }\n\n      // Handle ZodObject by accessing its shape\n      if (current._def.type === 'object' && current.shape) {\n        const nextSchema = current.shape[segment];\n        if (!nextSchema) {\n          return undefined;\n        }\n        current = nextSchema;\n      } else {\n        return undefined;\n      }\n    }\n    return current;\n  }\n\n  return current;\n}\n\n/**\n * Build a schema that validates only a specific path within a larger schema structure.\n * This allows validation of partial nested objects where only the target field is required.\n *\n * For example, for path \"ui.theme.colors.primary\":\n * - Creates: z.object({ ui: z.object({ theme: z.object({ colors: z.object({ primary: leafSchema }).partial() }).partial() }).partial() }).strict()\n * - This allows recording just { ui: { theme: { colors: { primary: value } } } } without requiring siblings\n *\n * @param rootSchema - The root ZodObject schema\n * @param segments - Path segments (e.g. ['ui', 'theme', 'colors', 'primary'])\n * @returns A schema that validates the specific path with partial validation for siblings\n */\nexport function buildSchemaForPath(rootSchema: ZodObject<any>, segments: string[]): ZodSchema<any> {\n  const pathKey = segments.join('.');\n\n  // Find the leaf schema for the target field\n  const leafSchema = findSchemaAtPath(rootSchema, segments);\n  if (!leafSchema) {\n    throw new Error(`Cannot find schema for path: ${pathKey}`);\n  }\n\n  // Build the schema from leaf back to root, making siblings optional at each level\n  let currentSchema = leafSchema;\n\n  // Work backwards through the segments\n  for (let i = segments.length - 1; i >= 0; i--) {\n    const segment = segments[i];\n\n    // Create an object schema with just this segment\n    const objectSchema = z.object({ [segment]: currentSchema });\n\n    // Make it partial (so siblings aren't required) and strict (so unknown keys are rejected)\n    currentSchema = objectSchema.partial().strict();\n  }\n\n  return currentSchema;\n}\n","import { trace } from '@opentelemetry/api';\nimport { createAsyncHook } from './manager';\nimport { type createAppScope } from '../../app-scope';\nimport type { ResolvedAxiomConfig } from '../../config/index';\n\n// Global fallback for config scope when called outside of eval context (e.g., module import time)\nconst CONFIG_SCOPE_SYMBOL = Symbol.for('axiom.eval.configScope');\nfunction getGlobalConfigScope(): ReturnType<typeof createAppScope> | undefined {\n  return (globalThis as any)[CONFIG_SCOPE_SYMBOL];\n}\nfunction setGlobalConfigScope(scope: ReturnType<typeof createAppScope>) {\n  (globalThis as any)[CONFIG_SCOPE_SYMBOL] = scope;\n}\n\n// Global storage for axiom config (accessible from reporters)\nconst AXIOM_CONFIG_SYMBOL = Symbol.for('axiom.eval.config');\nexport function getAxiomConfig(): ResolvedAxiomConfig | undefined {\n  return (globalThis as any)[AXIOM_CONFIG_SYMBOL];\n}\nexport function setAxiomConfig(config: ResolvedAxiomConfig) {\n  (globalThis as any)[AXIOM_CONFIG_SYMBOL] = config;\n}\n\n// Mini-context for in-process access\nexport const EVAL_CONTEXT = createAsyncHook<{\n  flags: Record<string, any>;\n  facts: Record<string, any>;\n  configScope?: ReturnType<typeof createAppScope>;\n  pickedFlags?: string[];\n  outOfScopeFlags?: { flagPath: string; accessedAt: number; stackTrace: string[] }[];\n  parent?: EvalContextData<any, any>;\n  overrides?: Record<string, any>;\n  accessedFlagKeys?: string[];\n}>('eval-context');\n\nexport interface EvalContextData<Flags = any, Facts = any> {\n  flags: Partial<Flags>;\n  facts: Partial<Facts>;\n  configScope?: ReturnType<typeof createAppScope>;\n  pickedFlags?: string[];\n  outOfScopeFlags?: { flagPath: string; accessedAt: number; stackTrace: string[] }[];\n  parent?: EvalContextData<Flags, Facts>;\n  overrides?: Record<string, any>;\n  accessedFlagKeys?: string[];\n}\n\nexport function getEvalContext<\n  Flags extends Record<string, unknown> = any,\n  Facts extends Record<string, unknown> = any,\n>(): EvalContextData<Flags, Facts> {\n  const ctx = EVAL_CONTEXT.get();\n  if (!ctx) {\n    // Return empty context if none exists\n    return {\n      flags: {} as Partial<Flags>,\n      facts: {} as Partial<Facts>,\n      pickedFlags: undefined,\n      outOfScopeFlags: undefined,\n    };\n  }\n  return {\n    flags: ctx.flags as Partial<Flags>,\n    facts: ctx.facts as Partial<Facts>,\n    pickedFlags: ctx.pickedFlags,\n    outOfScopeFlags: ctx.outOfScopeFlags,\n    parent: ctx.parent,\n    overrides: ctx.overrides,\n    accessedFlagKeys: ctx.accessedFlagKeys,\n  };\n}\n\nexport function updateEvalContext(flags?: Record<string, any>, facts?: Record<string, any>) {\n  const current = EVAL_CONTEXT.get();\n  if (!current) {\n    if (process.env.NODE_ENV !== 'test') {\n      console.warn('updateEvalContext called outside of evaluation context');\n    }\n    return;\n  }\n\n  // Mutate the existing context (safe within the same async context)\n  if (flags) {\n    Object.assign(current.flags, flags);\n    // Track accessed flag keys for runtime reporting\n    if (!current.accessedFlagKeys) current.accessedFlagKeys = [];\n    for (const key of Object.keys(flags)) {\n      if (!current.accessedFlagKeys.includes(key)) {\n        current.accessedFlagKeys.push(key);\n      }\n    }\n  }\n  if (facts) {\n    Object.assign(current.facts, facts);\n  }\n}\n\n/**\n * Parse stack trace to extract relevant frames, filtering out internal/framework frames\n */\nfunction parseStackTrace(stack: string): string[] {\n  const lines = stack.split('\\n');\n  const frames: string[] = [];\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    if (!trimmed || !trimmed.startsWith('at ')) {\n      continue;\n    }\n\n    // filter out frames that users likely don't care about\n    if (\n      trimmed.includes('node_modules') ||\n      trimmed.includes('node:internal') ||\n      trimmed.includes('addOutOfScopeFlag') ||\n      trimmed.includes('storage.ts') ||\n      // Keep app-scope.ts frames that aren't the flag() function itself\n      (trimmed.includes('app-scope.ts') &&\n        (trimmed.includes('flag (') || trimmed.includes('flag2 (')))\n    ) {\n      continue;\n    }\n\n    frames.push(trimmed.replace('at ', ''));\n  }\n\n  return frames.slice(0, 5);\n}\n\nexport function addOutOfScopeFlag(flagPath: string) {\n  const current = EVAL_CONTEXT.get();\n  if (!current) {\n    console.warn('addOutOfScopeFlag called outside of evaluation context');\n    return;\n  }\n\n  if (!current.outOfScopeFlags) {\n    current.outOfScopeFlags = [];\n  }\n\n  const stack = new Error().stack || '';\n  const stackTrace = parseStackTrace(stack);\n\n  current.outOfScopeFlags.push({\n    flagPath,\n    accessedAt: Date.now(),\n    stackTrace,\n  });\n}\n\n// Helper: write to current span + context\nexport function putOnSpan(kind: 'flag' | 'fact', key: string, value: any) {\n  const span = trace.getActiveSpan();\n  if (span?.isRecording()) {\n    span.setAttributes({ [`${kind}.${key}`]: value });\n  }\n}\n\n/**\n * Resolve a flag value by walking the parent chain, checking overrides first\n */\nexport function resolveFlagValue<V>(ctx: EvalContextData<any, any>, key: string): V {\n  // First check current context overrides\n  if (ctx.overrides && key in ctx.overrides) {\n    return ctx.overrides[key] as V;\n  }\n\n  // Then check current context flags\n  if (key in ctx.flags) {\n    return ctx.flags[key] as V;\n  }\n\n  // Walk up the parent chain\n  if (ctx.parent) {\n    return resolveFlagValue(ctx.parent, key);\n  }\n\n  // This should not happen\n  // Return undefined as a fallback\n  console.error(`[AxiomAI] Flag \"${key}\" not found in context, returning undefined`);\n  return undefined as V;\n}\n\n/**\n * Create an overlay context that inherits from the current context\n * but isolates overrides to this specific execution context.\n */\nfunction createOverlayContext(overrides: Record<string, any>): any {\n  const current = EVAL_CONTEXT.get();\n  if (!current) {\n    if (process.env.NODE_ENV !== 'test') {\n      console.warn('createOverlayContext called outside of evaluation context');\n    }\n    return {\n      flags: { ...overrides },\n      facts: {},\n      pickedFlags: [],\n      outOfScopeFlags: [],\n      overrides: { ...overrides },\n    };\n  }\n\n  // Create merged flags for backwards compatibility\n  const mergedFlags = { ...current.flags, ...overrides };\n\n  return {\n    ...current,\n    flags: mergedFlags,\n    parent: current,\n    overrides: { ...overrides },\n  };\n}\n\n/**\n * Execute a function with flag overrides that are isolated to the execution context.\n * This creates an overlay context that inherits from the current context but isolates\n * the overrides to prevent them from leaking to sibling operations.\n */\nexport function withFlagOverrides<T>(overrides: Record<string, any>, fn: () => T): T {\n  const overlayContext = createOverlayContext(overrides);\n\n  // Write overridden flags to span for observability\n  for (const [key, value] of Object.entries(overrides)) {\n    putOnSpan('flag', key, value);\n  }\n\n  return EVAL_CONTEXT.run(overlayContext, fn);\n}\n\nexport function withEvalContext<T>(\n  options: {\n    initialFlags?: Record<string, any>;\n    pickedFlags?: string[];\n  } = {},\n  fn: () => T,\n): T {\n  const { initialFlags = {}, pickedFlags = [] } = options;\n  return EVAL_CONTEXT.run(\n    {\n      flags: { ...initialFlags },\n      facts: {},\n      pickedFlags,\n      outOfScopeFlags: [],\n      accessedFlagKeys: [],\n    },\n    fn,\n  );\n}\n\n/**\n * Set the config scope for the current evaluation context.\n * This makes the scope available for global flag/fact access.\n *\n * Also stores a global fallback so suite-end summary can access schema defaults\n * even if createAppScope ran outside the active async context.\n */\nexport function setConfigScope(scope: ReturnType<typeof createAppScope>) {\n  const current = EVAL_CONTEXT.get();\n  if (current) {\n    current.configScope = scope;\n  }\n  // Always set global fallback\n  setGlobalConfigScope(scope);\n}\n\n/**\n * Get the config scope from the current evaluation context.\n * Falls back to global scope when no context is active.\n */\nexport function getConfigScope(): ReturnType<typeof createAppScope> | undefined {\n  const current = EVAL_CONTEXT.get();\n  return current?.configScope ?? getGlobalConfigScope();\n}\n\n/**\n * Get the picked flags from the current evaluation context.\n * Returns undefined if no picked flags are set or if called outside eval context.\n */\nexport function getPickedFlags(): string[] | undefined {\n  return EVAL_CONTEXT.get()?.pickedFlags;\n}\n","import { createRequire } from 'node:module';\n\ninterface ContextManager<T = any> {\n  getStore(): T | undefined;\n  run<R>(value: T, fn: () => R): R;\n}\n\nconst CONTEXT_MANAGER_SYMBOL = Symbol.for('axiom.context_manager');\n\nfunction getGlobalContextManager(): ContextManager | undefined {\n  return (globalThis as any)[CONTEXT_MANAGER_SYMBOL];\n}\n\nfunction setGlobalContextManager(manager: ContextManager): void {\n  (globalThis as any)[CONTEXT_MANAGER_SYMBOL] = manager;\n}\n\nconst isNodeJS = typeof process !== 'undefined' && !!process.versions?.node;\n\nfunction getContextManager(): ContextManager {\n  // Check global Symbol registry cache first (shared across VM contexts)\n  const existing = getGlobalContextManager();\n  if (existing) return existing;\n\n  let manager: ContextManager;\n\n  if (isNodeJS) {\n    try {\n      // Resolve AsyncLocalStorage in both ESM and CJS Node contexts without bundler interference\n      let AsyncLocalStorage: any;\n\n      // Use createRequire to obtain a require in ESM\n      const req = createRequire(import.meta.url);\n      try {\n        AsyncLocalStorage = req('node:async_hooks').AsyncLocalStorage;\n      } catch {\n        AsyncLocalStorage = req('async_hooks').AsyncLocalStorage;\n      }\n\n      manager = new AsyncLocalStorage();\n    } catch (error) {\n      // Fallback if AsyncLocalStorage cannot be loaded\n      console.warn('AsyncLocalStorage not available, using fallback context manager:', error);\n      manager = createFallbackManager();\n    }\n  } else {\n    // Browser/CF Workers - simple fallback (no warning needed here)\n    console.warn('AsyncLocalStorage not available, using fallback context manager');\n    manager = createFallbackManager();\n  }\n\n  // Cache using Symbol to share across VM contexts\n  setGlobalContextManager(manager);\n\n  return manager;\n}\n\nfunction createFallbackManager(): ContextManager {\n  let currentContext: any = null;\n  return {\n    getStore: () => currentContext,\n    run: <R>(value: any, fn: () => R): R => {\n      const prev = currentContext;\n      currentContext = value;\n      try {\n        return fn();\n      } finally {\n        currentContext = prev;\n      }\n    },\n  };\n}\n\nexport function createAsyncHook<T>(_name: string) {\n  return {\n    get(): T | undefined {\n      const manager = getContextManager();\n      if (manager.getStore) {\n        return manager.getStore();\n      }\n      return undefined;\n    },\n    run<R>(value: T, fn: () => R): R {\n      const manager = getContextManager();\n      return manager.run(value, fn);\n    },\n  };\n}\n\n/**\n * Reset the context manager singleton for tests.\n * This clears the global cache and forces a new AsyncLocalStorage instance to be created.\n * Useful for test isolation when needed.\n */\nexport function __resetContextManagerForTests(): void {\n  delete (globalThis as any)[CONTEXT_MANAGER_SYMBOL];\n}\n","import { getGlobalFlagOverrides } from './evals/context/global-flags';\nimport {\n  getEvalContext,\n  updateEvalContext,\n  addOutOfScopeFlag,\n  setConfigScope,\n} from './evals/context/storage';\nimport { validateCliFlags } from './validate-flags';\nimport {\n  parsePath,\n  dotNotationToNested,\n  isValidPath,\n  getValueAtPath,\n  buildSchemaForPath,\n} from './util/dot-path';\nimport { trace } from '@opentelemetry/api';\nimport { type z, type ZodObject, type ZodDefault, type ZodSchema } from 'zod';\nimport type { $ZodObject } from 'zod/v4/core';\nimport { toOtelAttribute } from './otel/utils/to-otel-attribute';\nimport { Attr } from './otel';\n\ntype DefaultMaxDepth = 8;\n\n// Helper to recursively check if a schema has defaults (including nested objects)\ntype HasDefaults<S> = S extends { _zod: { def: { defaultValue: unknown } } }\n  ? true\n  : // v4 | v3\n    S extends $ZodObject<infer Shape> | ZodObject<infer Shape>\n    ? {\n        [K in keyof Shape]: HasDefaults<Shape[K]>;\n      } extends Record<keyof Shape, true>\n      ? true\n      : false\n    : false;\n\n// Helper type to extract the underlying ZodObject from ZodDefault wrapper\ntype UnwrapSchema<T> = T extends ZodDefault<infer U> ? U : T;\n\n// Helper to check if ALL fields in a schema have defaults\ntype AllFieldsHaveDefaults<Schema> =\n  // First check if the schema itself has an object-level default\n  Schema extends { _zod: { def: { defaultValue: unknown } } }\n    ? true\n    : // Otherwise recursively check if all fields have defaults\n      HasDefaults<UnwrapSchema<Schema>>;\n\ninterface AppScopeConfig<\n  FlagSchema extends ZodObject<any> | undefined = undefined,\n  FactSchema extends ZodObject<any> | undefined = undefined,\n> {\n  flagSchema: FlagSchema;\n  factSchema?: FactSchema;\n}\n\n/**\n * Recursive type to extract all possible paths from an object type.\n * Uses stack-based depth limiting for better performance.\n *\n * @template T - The object type to extract paths from\n * @template Stack - Internal stack counter (do not set manually)\n * @template MaxDepth - Maximum recursion depth (default: 8 for good balance)\n */\ntype ObjectPaths<\n  T,\n  Stack extends unknown[] = [],\n  MaxDepth extends number = DefaultMaxDepth,\n> = Stack['length'] extends MaxDepth\n  ? never\n  : T extends object\n    ? {\n        [K in keyof T]-?: K extends string | number\n          ? `${K}` | `${K}.${ObjectPaths<T[K], [1, ...Stack], MaxDepth>}`\n          : never;\n      }[keyof T]\n    : never;\n\n// Type to get value at a specific path in an object\ntype ObjectPathValue<T, P extends string> = P extends keyof T\n  ? T[P]\n  : P extends `${infer K}.${infer Rest}`\n    ? K extends keyof T\n      ? ObjectPathValue<T[K], Rest>\n      : never\n    : never;\n\n/**\n * Generate deep nested paths from flag schema.\n *\n * @template T - ZodObject to extract paths from\n * @template MaxDepth - Maximum recursion depth (default: 8, override for deeper nesting)\n * @example\n * // Default 8-level depth\n * type Paths = DotPaths<MySchema>\n *\n * // Custom depth for deeper nesting (impacts performance)\n * type DeepPaths = DotPaths<MySchema, 12>\n */\nexport type DotPaths<T extends ZodObject<any>, MaxDepth extends number = DefaultMaxDepth> = {\n  [NS in keyof T['shape']]:\n    | (string & NS) // Include the namespace itself\n    | {\n        [P in ObjectPaths<\n          z.output<UnwrapSchema<T['shape'][NS]>>,\n          [],\n          MaxDepth\n        >]: `${string & NS}.${P}`;\n      }[ObjectPaths<z.output<UnwrapSchema<T['shape'][NS]>>, [], MaxDepth>];\n}[keyof T['shape']];\n\ntype PathValue<T extends ZodObject<any>, P extends string> = P extends `${infer NS}.${infer Rest}`\n  ? NS extends keyof T['shape']\n    ? ObjectPathValue<z.output<UnwrapSchema<T['shape'][NS]>>, Rest>\n    : never\n  : P extends keyof T['shape']\n    ? z.output<UnwrapSchema<T['shape'][P]>>\n    : never;\n\ntype DotNotationFlagFunction<FS extends ZodObject<any> | undefined> =\n  FS extends ZodObject<any> ? <P extends DotPaths<FS>>(path: P) => PathValue<FS, P> : never;\n\ntype FactFunction<SC extends ZodObject<any> | undefined> =\n  SC extends ZodObject<any>\n    ? <P extends DotPaths<SC> & string>(name: P, value: PathValue<SC, P>) => void\n    : never;\n\ntype OverrideFlagsFunction<FS extends ZodObject<any> | undefined> =\n  FS extends ZodObject<any>\n    ? (partial: { [K in DotPaths<FS>]?: PathValue<FS, K> }) => void\n    : (partial: Record<string, any>) => void;\n\ntype WithFlagsFunction<FS extends ZodObject<any> | undefined> =\n  FS extends ZodObject<any>\n    ? <T>(overrides: { [K in DotPaths<FS>]?: PathValue<FS, K> }, fn: () => T) => T\n    : <T>(overrides: Record<string, any>, fn: () => T) => T;\n\ntype PickFlagsFunction<FS extends ZodObject<any> | undefined> =\n  FS extends ZodObject<any>\n    ? {\n        // Spread arguments: pickFlags2('foo', 'bar')\n        <K extends ReadonlyArray<DotPaths<FS> & string>>(...paths: K): K;\n        // Array argument: pickFlags2(['foo', 'bar'])\n        <K extends ReadonlyArray<DotPaths<FS> & string>>(paths: K): K;\n      }\n    : never;\n\nexport interface AppScope<\n  FS extends ZodObject<any> | undefined,\n  SC extends ZodObject<any> | undefined,\n> {\n  flag: DotNotationFlagFunction<FS>;\n  fact: FactFunction<SC>;\n  overrideFlags: OverrideFlagsFunction<FS>;\n  withFlags: WithFlagsFunction<FS>;\n  pickFlags: PickFlagsFunction<FS>;\n  getAllDefaultFlags: () => Record<string, any>;\n}\n\n/**\n * Check if a flag path is covered by the picked flags.\n * @param flagPath - The flag path to check (e.g., 'foo', 'foo.bar')\n * @param pickedFlags - Array of picked flag paths\n * @returns true if the flag is covered by picked flags\n */\nexport function isPickedFlag(flagPath: string, pickedFlags?: string[]): boolean {\n  if (!pickedFlags) {\n    // If no picked flags are provided, all flags are allowed\n    return true;\n  }\n\n  if (pickedFlags.length === 0) {\n    // If no flags are picked, all flags are allowed\n    return true;\n  }\n\n  return pickedFlags.some((picked) => {\n    // Exact match\n    if (flagPath === picked) {\n      return true;\n    }\n    // Nested match: flagPath starts with picked flag followed by a dot\n    if (flagPath.startsWith(picked + '.')) {\n      return true;\n    }\n    return false;\n  });\n}\n\n// Helper to recursively validate that schemas don't contain union types\nfunction assertNoUnions(schema: any, path = 'schema'): void {\n  if (!schema) return;\n\n  // Handle both Zod v4 (_zod.def) and v3 (_def) structures\n  const def = schema._zod?.def || schema._def;\n\n  if (!def) return;\n\n  // Unwrap transparent containers\n  const { type: typeName, innerType } = def;\n\n  if (\n    typeName === 'default' ||\n    typeName === 'optional' ||\n    typeName === 'nullable' // ||\n    // typeName === 'effects'\n  ) {\n    return assertNoUnions(innerType, path);\n  }\n\n  // Hard-fail on unions\n  if (typeName === 'union' || typeName === 'discriminatedUnion') {\n    throw new Error(`[AxiomAI] Union types are not supported in flag schemas (found at \"${path}\")`);\n  }\n\n  // Recurse into compound types\n  if (typeName === 'object') {\n    // Handle both v3 (.shape) and v4 (def.shape) structures\n    const shape = def.shape || schema.shape;\n    if (shape) {\n      for (const [k, v] of Object.entries(shape)) {\n        assertNoUnions(v, `${path}.${k}`);\n      }\n    }\n  } else if (typeName === 'array') {\n    const arrayType = def.type || def.innerType || (schema._def && schema._def.type);\n    if (arrayType) {\n      assertNoUnions(arrayType, `${path}[]`);\n    }\n  } else if (typeName === 'record') {\n    const valueType = def.valueType || (schema._def && schema._def.valueType);\n    if (valueType) {\n      assertNoUnions(valueType, `${path}{}`);\n    }\n  }\n}\n\n/**\n * Recursively verify that all leaf fields in the schema have defaults.\n * Throws with a detailed error message listing all paths missing defaults.\n * TODO: this should probably be in an adapter, not the core lib...\n */\nfunction ensureAllDefaults(schema: any, path = ''): void {\n  const missingDefaults: string[] = [];\n\n  function checkDefaults(current: any, currentPath: string): void {\n    if (!current) return;\n\n    const def = current.def || current._def;\n    if (!def) return;\n\n    const { type: typeName, innerType, defaultValue } = def;\n\n    // Check if this schema has a default at this level\n    const hasDefault = defaultValue !== undefined;\n\n    // Unwrap transparent containers and check their inner type\n    if (typeName === 'default') {\n      // This has a default, we're done - no need to check inner type\n      return;\n    }\n\n    if (typeName === 'optional' || typeName === 'nullable') {\n      // Transparent wrappers - check inner type\n      return checkDefaults(innerType, currentPath);\n    }\n\n    // ZodRecord is not allowed\n    if (typeName === 'record') {\n      throw new Error(\n        `[AxiomAI] ZodRecord is not supported in flag schemas (found at \"${currentPath || 'root'}\")\\n` +\n          `All flag fields must have known keys and defaults. Consider using z.object() instead.`,\n      );\n    }\n\n    // For objects: if there's an object-level default, we're good\n    // Otherwise, recursively check all fields\n    if (typeName === 'object') {\n      if (hasDefault) {\n        // Object-level default covers all nested fields\n        return;\n      }\n\n      const shape = def.shape || current.shape;\n      if (shape) {\n        for (const [k, v] of Object.entries(shape)) {\n          const nextPath = currentPath ? `${currentPath}.${k}` : k;\n          checkDefaults(v, nextPath);\n        }\n      }\n      return;\n    }\n\n    // For arrays: arrays are leaf types (no per-index access)\n    // Just check if the array schema itself has a default\n    if (typeName === 'array') {\n      if (!hasDefault) {\n        missingDefaults.push(currentPath || 'root');\n      }\n      return;\n    }\n\n    // For all other types (primitives, etc): must have a default\n    if (!hasDefault) {\n      missingDefaults.push(currentPath || 'root');\n    }\n  }\n\n  checkDefaults(schema, path);\n\n  if (missingDefaults.length > 0) {\n    throw new Error(\n      `[AxiomAI] All flag fields must have defaults. Missing defaults for:\\n` +\n        missingDefaults.map((p) => `  - ${p}`).join('\\n') +\n        `\\n\\nAdd .default(value) to these fields or to their parent objects.`,\n    );\n  }\n}\n\n/**\n * Create a new application-level evaluation scope.\n *\n * @param config.flagSchema A zod object describing the schema for flags **(required)**\n * @param config.factSchema A zod object describing the schema for facts (optional)\n *\n * @example\n * import { z } from 'zod';\n *\n * const { flag, fact, withFlags, pickFlags, overrideFlags } = createAppScope({\n *   flagSchema: z.object({\n *     ui: z.object({\n *       darkMode: z.boolean().default(false),\n *       theme:    z.object({\n *         primary: z.string().default('#00f'),\n *       }),\n *     }),\n *     api: z.object({ \n       endpoint: z.string().default('/api') \n     }),\n *   }),\n *   factSchema: z.object({\n *     userAction: z.string(),\n *     timing: z.number(),\n *   }),\n * });\n *\n * // Typed flag access\n * const dark = flag('ui.darkMode'); // inferred boolean\n * const theme = flag('ui.theme'); // entire object\n * const primary = flag('ui.theme.primary'); // '#00f'\n * const endpoint = flag('api.endpoint'); // uses schema default\n *\n * // Typed fact recording\n * fact('userAction', 'clicked_button');\n * fact('timing', 1250);\n *\n * // Temporarily override flags for a block of code\n * withFlags({ 'ui.darkMode': true }, () => {\n *   // code here, `ui.darkMode` will be true in this block and reset after\n * });\n *\n * // Override flags globally for the current evaluation run\n * overrideFlags({ 'api.endpoint': '/custom' });\n */\n// Overload: Require all fields to have defaults (compile-time check)\nexport function createAppScope<\n  FlagSchema extends ZodObject<any>,\n  FactSchema extends ZodObject<any> | undefined = undefined,\n>(\n  config: AllFieldsHaveDefaults<FlagSchema> extends true\n    ? AppScopeConfig<FlagSchema, FactSchema>\n    : {\n        flagSchema: FlagSchema;\n        factSchema?: FactSchema;\n        __error__: 'createAppScope: flagSchema must have .default() for all leaf fields';\n      },\n): AppScope<FlagSchema, FactSchema>;\n\n// Implementation signature: Keep broad for internal use\nexport function createAppScope<\n  FlagSchema extends ZodObject<any> | undefined = undefined,\n  FactSchema extends ZodObject<any> | undefined = undefined,\n>(config: AppScopeConfig<FlagSchema, FactSchema>): AppScope<FlagSchema, FactSchema> {\n  // Store schemas for runtime validation\n  const flagSchemaConfig = config?.flagSchema;\n  const factSchemaConfig = config?.factSchema;\n\n  // reject union types\n  if (flagSchemaConfig) {\n    assertNoUnions(flagSchemaConfig, 'flagSchema');\n  }\n\n  // Ensure all fields have defaults\n  if (flagSchemaConfig) {\n    ensureAllDefaults(flagSchemaConfig);\n  }\n\n  // CLI validation with dot notation support\n  if (flagSchemaConfig) {\n    validateCliFlags(flagSchemaConfig);\n  }\n\n  // Helper function to traverse schema object to find the field schema at a specific path\n  function findSchemaAtPath(segments: string[]): ZodSchema<any> | undefined {\n    if (!flagSchemaConfig || segments.length === 0) return undefined;\n\n    let current: any = flagSchemaConfig;\n\n    // ZodObject root - start with the shape\n    if (segments.length > 0) {\n      if (!current.shape || !(segments[0] in current.shape)) {\n        return undefined;\n      }\n      current = current.shape[segments[0]];\n      // Continue with remaining segments starting from index 1\n      for (let i = 1; i < segments.length; i++) {\n        const segment = segments[i];\n        if (!current || !current._def) {\n          return undefined;\n        }\n\n        // Handle ZodObject by accessing its shape\n        if (current._def.type === 'object' && current.shape) {\n          const nextSchema = current.shape[segment];\n          if (!nextSchema) {\n            return undefined;\n          }\n          current = nextSchema;\n        } else {\n          return undefined;\n        }\n      }\n      return current;\n    }\n\n    return current;\n  }\n\n  // Helper to check if a path represents a namespace access (no dots after first segment)\n  function isNamespaceAccess(segments: string[]): boolean {\n    if (!flagSchemaConfig || segments.length === 0) return false;\n\n    // For root namespace (like 'ui'), check if it exists in the ZodObject shape\n    if (segments.length === 1) {\n      return flagSchemaConfig.shape ? segments[0] in flagSchemaConfig.shape : false;\n    }\n\n    // For nested paths (like 'app.ui.layout'), need to check if the path points to an object schema\n    const schema = findSchemaAtPath(segments);\n    return Boolean(schema?._def?.type === 'object');\n  }\n\n  // Helper function to check if a schema has complete defaults at runtime\n  // This mirrors the compile-time AllFieldsHaveDefaults<> type\n\n  // Recursively build object with all defaults from a Zod schema\n  function buildObjectWithDefaults(schema: any): unknown {\n    if (!schema) return undefined;\n\n    // Handle both v3 and v4 structures\n    const def = schema._zod?.def || schema._def;\n    if (!def) return undefined;\n\n    // `directDefault`: default for the entire object\n    // If this is not present, we try to construct the defaults from child fields (recursively)\n    const directDefault = extractDefault(schema);\n    if (directDefault !== undefined) {\n      return directDefault;\n    }\n\n    // We can only collect defaults from child fields if we're dealing with an object (for a scalar, there are no children)\n    if (def.type === 'object') {\n      const shape = def.shape || schema.shape;\n      if (shape) {\n        const result: Record<string, unknown> = {};\n\n        for (const [key, fieldSchema] of Object.entries(shape)) {\n          const fieldValue = buildObjectWithDefaults(fieldSchema);\n          result[key] = fieldValue;\n        }\n\n        return result;\n      }\n    }\n\n    // No direct default, and it's not an object\n    return undefined;\n  }\n\n  function extractDefault(schema: any): unknown {\n    if (!schema || !schema._def) return undefined;\n\n    // Unwrap transparent containers first, checking for defaults at each level\n    let current: any = schema;\n\n    while (current) {\n      // Handle both v3 and v4 structures\n      const def = current._zod?.def || current._def;\n      if (!def) break;\n\n      // Check for default value at current level\n      if (def.defaultValue !== undefined) {\n        return typeof def.defaultValue === 'function' ? def.defaultValue() : def.defaultValue;\n      }\n\n      // Unwrap one level if possible\n      if (def.innerType) {\n        current = def.innerType;\n      } else if (def.schema) {\n        current = def.schema;\n      } else {\n        // No more wrapping, stop here\n        break;\n      }\n    }\n\n    return undefined;\n  }\n\n  function validateFinalFlagValue(\n    dotPath: string,\n    value: unknown,\n  ): { ok: true; parsed: unknown } | { ok: false } {\n    if (!flagSchemaConfig) return { ok: true, parsed: value };\n\n    const segments = parsePath(dotPath);\n\n    // 1. Fast-path: validate directly with field-level schema\n    const fieldSchema = findSchemaAtPath(segments);\n    if (fieldSchema) {\n      const direct = (fieldSchema as ZodSchema<any>).safeParse(value);\n      if (direct.success) return { ok: true, parsed: direct.data };\n      // If we have a field schema but validation failed, this is a real error\n      return { ok: false };\n    }\n\n    // 2. If we don't have a field schema, check if the path is even valid in our schema\n    // Don't validate values for paths that don't exist in the schema - just pass them through\n    const hasValidNamespace = flagSchemaConfig.shape && segments[0] in flagSchemaConfig.shape;\n    if (!hasValidNamespace) {\n      // Invalid namespace - pass through without validation (for backward compatibility with fallback values)\n      return { ok: true, parsed: value };\n    }\n\n    // 3. For valid namespaces but invalid paths, try nested object validation\n    const nested = dotNotationToNested({ [dotPath]: value });\n    const nestedResult = flagSchemaConfig.strict().partial().safeParse(nested);\n    if (nestedResult.success) {\n      const parsed = getValueAtPath(nestedResult.data, segments) ?? value;\n      return { ok: true, parsed };\n    }\n\n    // 4. If nested validation failed but the namespace is valid, allow it for backward compatibility\n    return { ok: true, parsed: value };\n  }\n\n  /**\n   * Get flag value with dot notation path support and schema validation.\n   * All flag fields must have .default() values in the schema.\n   * Precedence: CLI overrides -> Context overrides -> Schema defaults â†’ Error\n   *\n   * @param path - Dot notation path to the flag (e.g., 'ui.theme' or 'api.timeout')\n   * @returns The flag value or undefined if path is invalid\n   */\n  function flag<P extends string>(path: P): unknown {\n    const segments = parsePath(path);\n\n    const ctx = getEvalContext();\n    const globalOverrides = getGlobalFlagOverrides();\n\n    if (!isPickedFlag(path, ctx.pickedFlags)) {\n      addOutOfScopeFlag(path);\n    }\n\n    let finalValue: any;\n    let source: 'cli' | 'ctx' | 'schema' | undefined;\n\n    // Flag precedence order:\n    // 1. CLI overrides (getGlobalFlagOverrides)\n    // 2. Eval context overrides (getEvalContext().flags)\n    // 3. Schema/object defaults\n    // 4. undefined + console.error\n\n    // 1. Check CLI overrides first (highest priority)\n    if (path in globalOverrides) {\n      finalValue = globalOverrides[path];\n      source = 'cli';\n    }\n    // 2. Check context overrides (from withFlags() or overrideFlags)\n    else if (path in ctx.flags) {\n      finalValue = ctx.flags[path];\n      source = 'ctx';\n    }\n    // 3. Resolve from schema\n    else {\n      if (!flagSchemaConfig) {\n        console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n        return undefined;\n      }\n\n      // Check valid namespace\n      const hasValidNamespace = flagSchemaConfig.shape && segments[0] in flagSchemaConfig.shape;\n      if (!hasValidNamespace) {\n        console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n        return undefined;\n      }\n\n      const schemaForPath = findSchemaAtPath(segments);\n\n      // If schema path doesn't exist, try extracting from parent object-level defaults\n      if (!schemaForPath) {\n        const namespaceSchema = findSchemaAtPath([segments[0]]);\n        if (namespaceSchema) {\n          const namespaceObject = buildObjectWithDefaults(namespaceSchema);\n          if (namespaceObject && typeof namespaceObject === 'object') {\n            finalValue = getValueAtPath(namespaceObject, segments.slice(1));\n          }\n        }\n\n        if (finalValue === undefined) {\n          console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n          return undefined;\n        }\n      }\n      // Check if this is a namespace access (returning whole objects)\n      else if (isNamespaceAccess(segments)) {\n        finalValue = buildObjectWithDefaults(schemaForPath);\n        if (finalValue === undefined) {\n          console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n          return undefined;\n        }\n      }\n      // Leaf access: try field-level default first\n      else {\n        finalValue = extractDefault(schemaForPath);\n\n        // If no field-level default, try extracting from parent object-level default\n        if (finalValue === undefined) {\n          const nsSchema = findSchemaAtPath([segments[0]]);\n          if (nsSchema) {\n            const nsObj = buildObjectWithDefaults(nsSchema);\n            if (nsObj && typeof nsObj === 'object') {\n              finalValue = getValueAtPath(nsObj, segments.slice(1));\n            }\n          }\n\n          if (finalValue === undefined) {\n            console.error(`[AxiomAI] Invalid flag: \"${path}\"`);\n            return undefined;\n          }\n        }\n      }\n\n      source = 'schema';\n    }\n\n    // Validate only overrides (schema values are pre-validated)\n    if (source !== 'schema') {\n      const validation = validateFinalFlagValue(path, finalValue);\n      if (!validation.ok) {\n        console.error(`[AxiomAI] Invalid flag: \"${path}\" - value does not match schema`);\n      }\n    }\n\n    updateEvalContext({ [path]: finalValue });\n\n    const span = trace.getActiveSpan();\n    if (span?.isRecording()) {\n      const attr = toOtelAttribute(finalValue);\n      if (attr) {\n        span.setAttribute(Attr.__EXPERIMENTAL_Flag(path), attr);\n      }\n    }\n\n    return finalValue;\n  }\n\n  /**\n   * Record a typed fact value for tracking and telemetry with dot notation support.\n   * @param name - The fact name/key\n   */\n  function fact<N extends string>(name: N, value: unknown): void {\n    let finalValue = value;\n\n    // Validate with schema if provided (but only log errors for now to match tests)\n    if (factSchemaConfig) {\n      const segments = parsePath(name);\n\n      let success = true;\n      // Fast path check - validate path exists in schema before creating nested object\n      if (!isValidPath(factSchemaConfig, segments)) {\n        success = false;\n      } else {\n        try {\n          // Build a schema specific to this path that makes sibling fields optional\n          const pathSchema = buildSchemaForPath(factSchemaConfig, segments);\n\n          // Convert dot notation to nested object for validation\n          const nested = dotNotationToNested({ [name]: value });\n          const result = pathSchema.safeParse(nested);\n\n          if (!result.success) {\n            success = false;\n          } else {\n            finalValue = getValueAtPath(result.data, segments) ?? value;\n          }\n        } catch (_error) {\n          // buildSchemaForPath can throw if schema structure is invalid\n          success = false;\n        }\n      }\n\n      if (!success) {\n        console.error(`[AxiomAI] Invalid fact: \"${name}\"`);\n      }\n    }\n\n    updateEvalContext(undefined, { [name]: finalValue });\n\n    const span = trace.getActiveSpan();\n    if (span?.isRecording()) {\n      const attr = toOtelAttribute(finalValue);\n      if (attr) {\n        span.setAttribute(Attr.__EXPERIMENTAL_Fact(name), attr);\n      }\n    }\n  }\n\n  /**\n   * Override flag values for the current evaluation context with type safety.\n   * @param partial - Typed flag overrides that must match the flag schema paths and types\n   */\n  function overrideFlags(partial: Record<string, any>): void {\n    const ctx = getEvalContext();\n    Object.assign(ctx.flags, partial);\n  }\n\n  /**\n   * Execute code with temporary flag overrides, automatically restoring original values.\n   * @param overrides - Typed flag overrides that must match the flag schema paths and types\n   * @param fn - Function to execute with the overridden flags\n   * @returns The return value of the executed function\n   */\n  function withFlags<T>(overrides: Record<string, any>, fn: () => T): T {\n    const ctx = getEvalContext();\n    const originalFlags = { ...ctx.flags };\n\n    // Apply overrides\n    Object.assign(ctx.flags, overrides);\n\n    try {\n      return fn();\n    } finally {\n      // Restore original flags by clearing and reassigning\n      Object.keys(ctx.flags).forEach((key) => delete ctx.flags[key]);\n      Object.assign(ctx.flags, originalFlags);\n    }\n  }\n\n  const pickFlags = ((...args: any[]) => {\n    // Handle both array and spread arguments\n    return args[0] && Array.isArray(args[0]) ? args[0] : args;\n  }) as PickFlagsFunction<FlagSchema>;\n\n  function flattenToDot(obj: any, prefix: string[] = [], out: Record<string, any> = {}) {\n    if (obj && typeof obj === 'object' && !Array.isArray(obj)) {\n      for (const [k, v] of Object.entries(obj)) {\n        flattenToDot(v, [...prefix, k], out);\n      }\n    } else {\n      if (prefix.length > 0) {\n        out[prefix.join('.')] = obj;\n      }\n    }\n    return out;\n  }\n\n  function getAllDefaultFlags(): Record<string, any> {\n    if (!flagSchemaConfig) return {};\n    const defaultsObj = buildObjectWithDefaults(flagSchemaConfig);\n    if (defaultsObj && typeof defaultsObj === 'object') {\n      return flattenToDot(defaultsObj as Record<string, any>);\n    }\n    return {};\n  }\n\n  const scope = {\n    flag: flag as any as DotNotationFlagFunction<FlagSchema>,\n    fact: fact as any as FactFunction<FactSchema>,\n    overrideFlags: overrideFlags as any as OverrideFlagsFunction<FlagSchema>,\n    withFlags: withFlags as any as WithFlagsFunction<FlagSchema>,\n    pickFlags,\n    getAllDefaultFlags,\n  } as AppScope<FlagSchema, FactSchema>;\n\n  // Expose scope to current eval context for downstream collection (suite-end summaries)\n  setConfigScope(scope as any);\n\n  return scope;\n}\n","import { type AttributeValue } from '@opentelemetry/api';\n\nfunction toHomogeneousArray(input: unknown[]): AttributeValue | undefined {\n  if (input.length === 0) return undefined;\n\n  const converted: (string | number | boolean)[] = [];\n  const types = new Set<string>();\n\n  for (const item of input) {\n    const converted_item = toOtelPrimitive(item);\n    if (converted_item !== undefined) {\n      converted.push(converted_item);\n      types.add(typeof converted_item);\n    }\n  }\n\n  if (converted.length === 0) return undefined;\n\n  if (types.size > 1) {\n    return converted.map((item) => String(item)) as AttributeValue;\n  }\n\n  return converted as AttributeValue;\n}\n\nfunction toOtelPrimitive(v: unknown): string | number | boolean | undefined {\n  switch (typeof v) {\n    case 'string':\n      return v;\n    case 'number':\n      return Number.isFinite(v) ? v : undefined;\n    case 'boolean':\n      return v;\n    case 'bigint':\n      if (v >= Number.MIN_SAFE_INTEGER && v <= Number.MAX_SAFE_INTEGER) {\n        return Number(v);\n      }\n      return v.toString();\n    case 'function':\n    case 'symbol':\n    case 'undefined':\n      return undefined;\n    case 'object':\n      if (v === null) return undefined;\n      if (v instanceof Date) return v.toISOString();\n      if (v instanceof Error) return v.message;\n      // fallback: stringify object-ish values\n      return safeStringify(v);\n  }\n}\n\nfunction safeStringify(obj: unknown): string | undefined {\n  try {\n    // Convert BigInt -> Number inside objects so JSON.stringify won't throw.\n    // Functions/undefined are dropped by JSON rules.\n    const s = JSON.stringify(obj, (_k, val) =>\n      typeof val === 'bigint' ? Number(val) : val instanceof Date ? val.toISOString() : val,\n    );\n    // Avoid empty/meaningless \"{}\" for Map/Setâ€”stringify those explicitly\n    if (s === '{}') {\n      if (obj instanceof Map) {\n        return JSON.stringify(Object.fromEntries(obj));\n      }\n      if (obj instanceof Set) {\n        return JSON.stringify(Array.from(obj));\n      }\n    }\n    return s ?? undefined;\n  } catch {\n    // As a last resort, use toString() if present\n    try {\n      const t = (obj as any)?.toString?.();\n      return typeof t === 'string' ? t : undefined;\n    } catch {\n      return undefined;\n    }\n  }\n}\n\nexport function toOtelAttribute(input: unknown): AttributeValue | undefined {\n  // primitives fast-path\n  switch (typeof input) {\n    case 'string':\n      return input;\n    case 'number':\n      return Number.isFinite(input) ? input : undefined;\n    case 'boolean':\n      return input;\n    case 'bigint':\n      if (input >= Number.MIN_SAFE_INTEGER && input <= Number.MAX_SAFE_INTEGER) {\n        return Number(input);\n      }\n      return input.toString();\n    case 'function':\n    case 'symbol':\n    case 'undefined':\n      return undefined;\n  }\n\n  // arrays -> homogeneous array of primitives\n  if (Array.isArray(input)) {\n    return toHomogeneousArray(input);\n  }\n\n  // date -> ISO string\n  if (input instanceof Date) {\n    return input.toISOString();\n  }\n\n  // null / objects -> JSON string\n  if (input === null) return undefined;\n  return safeStringify(input);\n}\n","import type { AxiomEvalInstrumentationOptions, ResolvedAxiomConfig } from './index';\n\n/**\n * Resolve Axiom connection settings from resolved config.\n *\n * Since the config is already resolved with defaults merged, we can directly\n * access the properties without fallback chains.\n *\n * @param config - The resolved configuration\n * @returns Resolved connection settings\n */\nexport function resolveAxiomConnection(\n  config: ResolvedAxiomConfig,\n): AxiomEvalInstrumentationOptions {\n  return {\n    url: config.eval.url,\n    token: config.eval.token,\n    dataset: config.eval.dataset,\n  };\n}\n","import type { Case, Chat, Evaluation, Task } from './eval.types';\nimport type { ResolvedAxiomConfig } from '../config/index';\nimport { resolveAxiomConnection } from '../config/resolver';\n\n/** Query axiom to find a baseline for an Eval */\nexport const findBaseline = async (evalName: string, config: ResolvedAxiomConfig) => {\n  const { dataset, url, token } = resolveAxiomConnection(config);\n\n  try {\n    const apl = [\n      `['${dataset}']`,\n      `| where ['attributes.custom']['eval.name'] == \"${evalName}\" and ['attributes.gen_ai.operation.name'] == 'eval'`,\n      `| order by _time desc`,\n      `| limit 1`,\n    ].join('\\n');\n\n    const headers = new Headers({\n      Authorization: `Bearer ${token}`,\n      'Content-Type': 'application/json',\n    });\n\n    const resp = await fetch(`${url}/v1/datasets/_apl?format=legacy`, {\n      headers: headers,\n      method: 'POST',\n      body: JSON.stringify({ apl }),\n    });\n    const payload = await resp.json();\n    if (!resp.ok) {\n      console.log(payload);\n      return undefined;\n    }\n    if (payload.matches.length) {\n      return mapSpanToEval(payload.matches[0]);\n    }\n  } catch (err) {\n    console.log(err);\n    return undefined;\n  }\n};\n\nexport const findEvaluationCases = async (evalId: string, config: ResolvedAxiomConfig) => {\n  try {\n    const { dataset, url, token } = resolveAxiomConnection(config);\n\n    const apl = `['${dataset}'] | where trace_id == \"${evalId}\" | order by _time`;\n\n    const headers = new Headers({\n      Authorization: `Bearer ${token}`,\n      'Content-Type': 'application/json',\n    });\n\n    const resp = await fetch(`${url}/v1/datasets/_apl?format=legacy`, {\n      headers: headers,\n      method: 'POST',\n      body: JSON.stringify({ apl }),\n    });\n    const payload = await resp.json();\n    if (!resp.ok) {\n      console.log(payload);\n      return undefined;\n    }\n    if (payload.matches.length) {\n      return buildSpanTree(payload.matches);\n    }\n  } catch (err) {\n    console.log(err);\n    return undefined;\n  }\n};\n\nexport const mapSpanToEval = (span: any): Evaluation => {\n  const flagConfigRaw =\n    span.data.attributes['eval.config.flags'] ?? span.data.attributes.custom['eval.config.flags'];\n\n  return {\n    id: span.data.attributes.custom['eval.id'],\n    name: span.data.attributes.custom['eval.name'],\n    type: span.data.attributes.custom['eval.type'],\n    version: span.data.attributes.custom['eval.version'],\n    collection: {\n      name: span.data.attributes.custom['eval.collection.name'],\n      size: span.data.attributes.custom['eval.collection.size'],\n    },\n    baseline: {\n      id: span.data.attributes.custom['eval.baseline.id'],\n      name: span.data.attributes.custom['eval.baseline.name'],\n    },\n    prompt: {\n      model: span.data.attributes.custom['eval.prompt.model'],\n      params: span.data.attributes.custom['eval.prompt.params'],\n    },\n    duration: span.data.duration,\n    status: span.data.status.code,\n    traceId: span.data.trace_id,\n    runAt: span._time,\n    tags: span.data.attributes.custom['eval.tags'].length\n      ? JSON.parse(span.data.attributes.custom['eval.tags'])\n      : [],\n    user: {\n      name: span.data.attributes.custom['eval.user.name'],\n      email: span.data.attributes.custom['eval.user.email'],\n    },\n    cases: [],\n    flagConfig: flagConfigRaw ? JSON.parse(flagConfigRaw) : undefined,\n  };\n};\n\nexport const mapSpanToCase = (item: { _time: string; data: any }): Case => {\n  const data = item.data;\n  // round duration\n  const d = data.duration as string;\n  let duration = '-';\n  if (d.endsWith('s')) {\n    duration = `${Number(d.replace('s', '')).toFixed(2)}s`;\n  } else {\n    duration = d;\n  }\n\n  const runtimeFlagsRaw = data.attributes.custom['eval.case.config.runtime_flags'];\n\n  return {\n    index: data.attributes.custom['eval.case.index'],\n    input: data.attributes.custom['eval.case.input'],\n    output: data.attributes.custom['eval.case.output'],\n    expected: data.attributes.custom['eval.case.expected'],\n    duration: duration,\n    status: data.status.code,\n    scores: data.attributes.custom['eval.case.scores']\n      ? JSON.parse(data.attributes.custom['eval.case.scores'])\n      : {},\n    runAt: item._time,\n    spanId: data.span_id,\n    traceId: data.trace_id,\n    runtimeFlags: runtimeFlagsRaw ? JSON.parse(runtimeFlagsRaw) : undefined,\n  };\n};\n\n// compute a root eval with its children spans, results in a usable object of eval, cases, scores and chats\nexport const buildSpanTree = (spans: any[]): Evaluation | null => {\n  if (!spans.length) {\n    return null;\n  }\n\n  // Find the root eval span\n  const evalSpan = spans.find((span) => span.data.attributes.gen_ai.operation.name === 'eval');\n\n  if (!evalSpan) {\n    return null;\n  }\n\n  // Create the root eval structure\n  const rootSpan: Evaluation = mapSpanToEval(evalSpan);\n\n  // Find all case spans and build the tree structure\n  const caseSpans = spans.filter((span) => span.data.name.startsWith('case'));\n\n  for (const caseSpan of caseSpans) {\n    // Convert case data\n    const caseData = mapSpanToCase(caseSpan);\n\n    // Find task spans that belong to this case\n    const taskSpans = spans.filter(\n      (span) =>\n        span.data.name.startsWith('task') && span.data.parent_span_id === caseSpan.data.span_id,\n    );\n\n    if (taskSpans.length > 0) {\n      const taskSpan = taskSpans[0]; // Assuming one task per case\n\n      // Find chat spans that belong to this task\n      const chatSpans = spans.filter(\n        (span) =>\n          span.data.name.startsWith('chat') && span.data.parent_span_id === taskSpan.data.span_id,\n      );\n\n      const chatData: Chat[] = chatSpans.map((chatSpan) => ({\n        operation: chatSpan.data.attributes.custom?.operation || '',\n        capability: chatSpan.data.attributes.custom?.capability || '',\n        step: chatSpan.data.attributes.custom?.step || '',\n        request: {\n          max_token: chatSpan.data.attributes.custom?.['request.max_token'] || '',\n          model: chatSpan.data.attributes.custom?.['request.model'] || '',\n          temperature: chatSpan.data.attributes.custom?.['request.temperature'] || 0,\n        },\n        response: {\n          finish_reasons: chatSpan.data.attributes.custom?.['response.finish_reasons'] || '',\n        },\n        usage: {\n          input_tokens: chatSpan.data.attributes.gen_ai?.usage?.input_tokens || 0,\n          output_tokens: chatSpan.data.attributes.gen_ai?.usage?.output_tokens || 0,\n        },\n      }));\n\n      // Create task data with chat information\n      const taskData: Task = {\n        name: taskSpan.data.name,\n        output: taskSpan.data.attributes.custom?.output || '',\n        trial: taskSpan.data.attributes.custom?.trial || 0,\n        type: taskSpan.data.attributes.custom?.type || '',\n        error: taskSpan.data.attributes.custom?.error,\n        chat: chatData[0] || {\n          operation: '',\n          capability: '',\n          step: '',\n          request: { max_token: '', model: '', temperature: 0 },\n          response: { finish_reasons: '' },\n          usage: { input_tokens: 0, output_tokens: 0 },\n        },\n      };\n\n      caseData.task = taskData;\n    }\n\n    // Find task spans that belong to this case\n    const scoreSpans = spans.filter(\n      (span) =>\n        span.data.attributes.gen_ai.operation.name === 'eval.score' &&\n        span.data.parent_span_id === caseSpan.data.span_id,\n    );\n\n    caseData.scores = {};\n\n    scoreSpans.forEach((score) => {\n      const name = score.data.attributes.custom['eval.score.name'];\n      caseData.scores[name] = {\n        name,\n        value: score.data.attributes.custom['eval.score.value'],\n        metadata: {\n          error: score.data.attributes.error,\n        },\n      };\n    });\n\n    rootSpan.cases.push(caseData);\n  }\n\n  rootSpan.cases.sort((a, b) => a.index - b.index);\n\n  return rootSpan;\n};\n","// src/index.ts\nvar f = {\n  reset: [0, 0],\n  bold: [1, 22, \"\\x1B[22m\\x1B[1m\"],\n  dim: [2, 22, \"\\x1B[22m\\x1B[2m\"],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n  blackBright: [90, 39],\n  redBright: [91, 39],\n  greenBright: [92, 39],\n  yellowBright: [93, 39],\n  blueBright: [94, 39],\n  magentaBright: [95, 39],\n  cyanBright: [96, 39],\n  whiteBright: [97, 39],\n  bgBlackBright: [100, 49],\n  bgRedBright: [101, 49],\n  bgGreenBright: [102, 49],\n  bgYellowBright: [103, 49],\n  bgBlueBright: [104, 49],\n  bgMagentaBright: [105, 49],\n  bgCyanBright: [106, 49],\n  bgWhiteBright: [107, 49]\n}, h = Object.entries(f);\nfunction a(n) {\n  return String(n);\n}\na.open = \"\";\na.close = \"\";\nvar B = /* @__PURE__ */ h.reduce(\n  (n, [e]) => (n[e] = a, n),\n  { isColorSupported: !1 }\n);\nfunction m() {\n  return { ...B };\n}\nfunction C(n = !1) {\n  let e = typeof process != \"undefined\" ? process : void 0, i = (e == null ? void 0 : e.env) || {}, g = (e == null ? void 0 : e.argv) || [];\n  return !(\"NO_COLOR\" in i || g.includes(\"--no-color\")) && (\"FORCE_COLOR\" in i || g.includes(\"--color\") || (e == null ? void 0 : e.platform) === \"win32\" || n && i.TERM !== \"dumb\" || \"CI\" in i) || typeof window != \"undefined\" && !!window.chrome;\n}\nfunction p(n = !1) {\n  let e = C(n), i = (r, t, c, o) => {\n    let l = \"\", s = 0;\n    do\n      l += r.substring(s, o) + c, s = o + t.length, o = r.indexOf(t, s);\n    while (~o);\n    return l + r.substring(s);\n  }, g = (r, t, c = r) => {\n    let o = (l) => {\n      let s = String(l), b = s.indexOf(t, r.length);\n      return ~b ? r + i(s, t, c, b) + t : r + s + t;\n    };\n    return o.open = r, o.close = t, o;\n  }, u = {\n    isColorSupported: e\n  }, d = (r) => `\\x1B[${r}m`;\n  for (let [r, t] of h)\n    u[r] = e ? g(\n      d(t[0]),\n      d(t[1]),\n      t[2]\n    ) : a;\n  return u;\n}\n\nexport {\n  m as a,\n  C as b,\n  p as c\n};\n","import {\n  a as e,\n  b as t,\n  c as o\n} from \"./chunk-BVHSVHOK.js\";\n\n// src/node.ts\nimport { isatty as s } from \"tty\";\nvar r = process.env.FORCE_TTY !== void 0 || s(1);\nfunction n() {\n  return t(r);\n}\nfunction a() {\n  return o(r);\n}\nvar u = o(r);\nexport {\n  a as createColors,\n  u as default,\n  e as getDefaultColors,\n  n as isSupported\n};\n","/**\n * Copied from Remeda - https://github.com/remeda/remeda/blob/v2.32.0/packages/remeda/src/isDeepEqual.ts\n */\n\nexport function deepEqual<T>(data: unknown, other: T): data is T {\n  if (data === other) {\n    return true;\n  }\n\n  if (Object.is(data, other)) {\n    // We want to ignore the slight differences between `===` and `Object.is` as\n    // both of them largely define equality from a semantic point-of-view.\n    return true;\n  }\n\n  if (typeof data !== 'object' || typeof other !== 'object') {\n    return false;\n  }\n\n  if (data === null || other === null) {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(data) !== Object.getPrototypeOf(other)) {\n    // If the objects don't share a prototype it's unlikely that they are\n    // semantically equal. It is technically possible to build 2 prototypes that\n    // act the same but are not equal (at the reference level, checked via\n    // `===`) and then create 2 objects that are equal although we would fail on\n    // them. Because this is so unlikely, the optimization we gain here for the\n    // rest of the function by assuming that `other` is of the same type as\n    // `data` is more than worth it.\n    return false;\n  }\n\n  if (Array.isArray(data)) {\n    return isDeepEqualArrays(data, other as unknown as ReadonlyArray<unknown>);\n  }\n\n  if (data instanceof Map) {\n    return isDeepEqualMaps(data, other as unknown as Map<unknown, unknown>);\n  }\n\n  if (data instanceof Set) {\n    return isDeepEqualSets(data, other as unknown as Set<unknown>);\n  }\n\n  if (data instanceof Date) {\n    return data.getTime() === (other as unknown as Date).getTime();\n  }\n\n  if (data instanceof RegExp) {\n    return data.toString() === (other as unknown as RegExp).toString();\n  }\n\n  // At this point we only know that the 2 objects share a prototype and are not\n  // any of the previous types. They could be plain objects (Object.prototype),\n  // they could be classes, they could be other built-ins, or they could be\n  // something weird. We assume that comparing values by keys is enough to judge\n  // their equality.\n\n  if (Object.keys(data).length !== Object.keys(other).length) {\n    return false;\n  }\n\n  for (const [key, value] of Object.entries(data)) {\n    if (!(key in other)) {\n      return false;\n    }\n\n    if (\n      !deepEqual(\n        value,\n        // @ts-expect-error [ts7053] - We already checked that `other` has `key`\n        other[key],\n      )\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isDeepEqualArrays(data: ReadonlyArray<unknown>, other: ReadonlyArray<unknown>): boolean {\n  if (data.length !== other.length) {\n    return false;\n  }\n\n  for (const [index, item] of data.entries()) {\n    if (!deepEqual(item, other[index])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isDeepEqualMaps(\n  data: ReadonlyMap<unknown, unknown>,\n  other: ReadonlyMap<unknown, unknown>,\n): boolean {\n  if (data.size !== other.size) {\n    return false;\n  }\n\n  for (const [key, value] of data.entries()) {\n    if (!other.has(key)) {\n      return false;\n    }\n\n    if (!deepEqual(value, other.get(key))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isDeepEqualSets(data: ReadonlySet<unknown>, other: ReadonlySet<unknown>): boolean {\n  if (data.size !== other.size) {\n    return false;\n  }\n\n  // To ensure we only count each item once we need to \"remember\" which items of\n  // the other set we've already matched against. We do this by creating a copy\n  // of the other set and removing items from it as we find them in the data\n  // set.\n  const otherCopy = [...other];\n\n  for (const dataItem of data) {\n    let isFound = false;\n\n    for (const [index, otherItem] of otherCopy.entries()) {\n      if (deepEqual(dataItem, otherItem)) {\n        isFound = true;\n        otherCopy.splice(index, 1);\n        break;\n      }\n    }\n\n    if (!isFound) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import c from 'tinyrainbow';\n\nimport type {\n  Evaluation,\n  EvaluationReport,\n  FlagDiff,\n  MetaWithCase,\n  MetaWithEval,\n  OutOfScopeFlag,\n} from './eval.types';\nimport type { TestSuite } from 'vitest/node.js';\nimport type { Score } from './scorers';\nimport { deepEqual } from '../util/deep-equal';\n\nexport type SuiteData = {\n  name: string;\n  file: string;\n  duration: string;\n  baseline: Evaluation | undefined | null;\n  configFlags?: string[];\n  flagConfig?: Record<string, any>;\n  cases: Array<{\n    index: number;\n    scores: Record<string, Score>;\n    outOfScopeFlags?: { flagPath: string; accessedAt: number; stackTrace: string[] }[];\n    errors?: Error[] | null;\n    runtimeFlags?: any;\n  }>;\n  outOfScopeFlags?: OutOfScopeFlag[];\n};\n\nexport function truncate(str: string, max: number): string {\n  return str.length > max ? str.slice(0, max) + 'â€¦' : str;\n}\n\nexport function stringify(value: any): string {\n  try {\n    if (typeof value === 'string') return value;\n    return JSON.stringify(value);\n  } catch {\n    return String(value);\n  }\n}\n\nexport function printEvalNameAndFileName(testSuite: TestSuite, meta: MetaWithEval) {\n  const cwd = process.cwd();\n\n  console.log(\n    ' ',\n    c.bgCyan(c.black(` ${testSuite.project.name} `)),\n    c.bgBlue(c.black(` ${meta.evaluation.name}-${meta.evaluation.version} `)),\n    c.dim(`(${testSuite.children.size} cases)`),\n  );\n\n  console.log(' ', c.dim(testSuite.module.moduleId.replace(cwd, '')));\n}\n\nexport function printBaselineNameAndVersion(testMeta: MetaWithEval) {\n  if (testMeta.evaluation.baseline) {\n    console.log(\n      ' ',\n      ' baseline ',\n      c.bgMagenta(\n        c.black(` ${testMeta.evaluation.baseline.name}-${testMeta.evaluation.baseline.version} `),\n      ),\n    );\n  } else {\n    console.log(' ', c.bgWhite(c.blackBright(' baseline: ')), 'none');\n  }\n\n  console.log('');\n}\n\nexport function printRuntimeFlags(testMeta: MetaWithCase) {\n  if (testMeta.case.runtimeFlags && Object.keys(testMeta.case.runtimeFlags).length > 0) {\n    const entries = Object.entries(testMeta.case.runtimeFlags);\n    console.log('   ', c.dim('runtime flags'));\n    for (const [k, v] of entries) {\n      switch (v.kind) {\n        case 'replaced': {\n          const valText = truncate(stringify(v.value), 80);\n          const defText = truncate(stringify(v.default), 80);\n          console.log('     ', `${k}: ${valText} (default: ${defText})`);\n          break;\n        }\n        case 'introduced': {\n          const valText = truncate(stringify(v.value), 80);\n          console.log('     ', `${k}: ${valText} (no default)`);\n          break;\n        }\n      }\n    }\n  }\n}\n\nexport function printTestCaseCountStartDuration(\n  testSuite: TestSuite,\n  startTime: number,\n  duration: string,\n) {\n  console.log(' ');\n  console.log(' ', c.dim('Cases'), testSuite.children.size);\n  console.log(' ', c.dim('Start at'), new Date(startTime).toTimeString());\n  console.log(' ', c.dim('Duration'), `${duration}s`);\n}\n\nexport function printTestCaseSuccessOrFailed(testMeta: MetaWithCase, ok: boolean) {\n  const index = testMeta.case.index;\n\n  if (ok) {\n    console.log(' ', c.yellow(` \\u2714 case ${index}:`));\n  } else {\n    console.log(' ', c.red(` \\u2716 case ${index}: failed`));\n    for (const e of testMeta.case.errors ?? []) {\n      console.log('', e.message);\n    }\n  }\n}\n\nexport function printTestCaseScores(\n  testMeta: MetaWithCase,\n  baseline: Evaluation | null | undefined,\n) {\n  const index = testMeta.case.index;\n\n  Object.keys(testMeta.case.scores).forEach((k) => {\n    const v = testMeta.case.scores[k].score ? testMeta.case.scores[k].score : 0;\n    const scoreValue = Number(v * 100).toFixed(2) + '%';\n\n    if (baseline?.cases[index]?.scores[k]) {\n      const baselineScoreValue = baseline.cases[index].scores[k].value;\n      const diff = v - baselineScoreValue;\n      const diffText = Number(diff * 100).toFixed(2) + '%';\n      const blScoreText = Number(baselineScoreValue * 100).toFixed(2) + '%';\n      console.log(\n        '   ',\n        k,\n        c.magentaBright(blScoreText),\n        '->',\n        c.blueBright(scoreValue),\n        diff > 0 ? c.green('+' + diffText) : diff < 0 ? c.red(diffText) : diffText,\n      );\n    } else {\n      console.log('   ', k, c.blueBright(scoreValue));\n    }\n\n    return [k, scoreValue];\n  });\n}\n\nexport function printOutOfScopeFlags(testMeta: MetaWithCase) {\n  if (testMeta.case.outOfScopeFlags && testMeta.case.outOfScopeFlags.length > 0) {\n    const pickedFlagsText = testMeta.case.pickedFlags\n      ? `(picked: ${testMeta.case.pickedFlags.map((f) => `'${f}'`).join(', ')})`\n      : '(none)';\n    console.log('   ', c.yellow(`âš  Out-of-scope flags: ${pickedFlagsText}`));\n    testMeta.case.outOfScopeFlags.forEach((flag) => {\n      const timeStr = new Date(flag.accessedAt).toLocaleTimeString();\n      console.log('     ', `${flag.flagPath} (at ${timeStr})`);\n\n      // Show top stack trace frames\n      if (flag.stackTrace && flag.stackTrace.length > 0) {\n        flag.stackTrace.forEach((frame, i) => {\n          const prefix = i === flag.stackTrace.length - 1 ? ' â””â”€' : ' â”œâ”€';\n          console.log('     ', c.dim(`${prefix} ${frame}`));\n        });\n      }\n    });\n  }\n}\n\nexport function printConfigHeader() {\n  console.log('');\n  console.log(' ', c.bgWhite(c.blackBright(' Config ')));\n}\n\nexport function maybePrintFlags(configEnd: EvaluationReport['configEnd']) {\n  const defaults = configEnd?.flags ?? {};\n  const overrides = configEnd?.overrides ?? {};\n\n  const defaultKeys = Object.keys(defaults);\n  const overrideKeys = Object.keys(overrides);\n\n  const allKeys = Array.from(new Set([...defaultKeys, ...overrideKeys])).sort();\n  if (allKeys.length === 0) {\n    return;\n  }\n\n  for (const key of allKeys) {\n    const hasDefault = key in defaults;\n    const hasOverride = key in overrides;\n\n    if (hasDefault && hasOverride) {\n      const defVal = defaults[key];\n      const ovVal = overrides[key];\n      const changed = !deepEqual(ovVal, defVal);\n      const ovText = truncate(stringify(ovVal), 80);\n      const defText = truncate(stringify(defVal), 80);\n      if (changed) {\n        console.log(\n          '   ',\n          `${key}: ${ovText} ${c.dim(`(overridden by CLI, original: ${defText})`)}`,\n        );\n      } else {\n        console.log('   ', `${key}: ${defText}`);\n      }\n    } else if (hasOverride) {\n      const ovText = truncate(stringify(overrides[key]), 80);\n      console.log('   ', `${key}: ${ovText} ${c.dim('(added by CLI)')}`);\n    } else if (hasDefault) {\n      const defText = truncate(stringify(defaults[key]), 80);\n      console.log('   ', `${key}: ${defText}`);\n    }\n  }\n\n  console.log('');\n}\n\nexport function printResultLink(testMeta: MetaWithCase, axiomUrl: string) {\n  const url = `${axiomUrl}/evaluations/${testMeta.evaluation.name}/${testMeta.evaluation.id}`;\n  console.log(\n    ' ',\n    `see results for ${testMeta.evaluation.name}-${testMeta.evaluation.version} at ${url}`,\n  );\n}\n\nexport const reporterDate = (d: Date) => {\n  const date = d.toISOString().slice(0, 10); // \"2025-10-03\"\n  const hours = d.getUTCHours().toString().padStart(2, '0');\n  const minutes = d.getUTCMinutes().toString().padStart(2, '0');\n  return `${date}, ${hours}:${minutes} UTC`;\n};\n\nexport function printGlobalFlagOverrides(\n  overrides: Record<string, any>,\n  defaults: Record<string, any>,\n) {\n  if (Object.keys(overrides).length === 0) {\n    console.log('');\n    console.log(c.dim('Flag overrides: (none)'));\n    console.log('');\n    return;\n  }\n\n  console.log('');\n  console.log('Flag overrides:');\n  for (const [key, value] of Object.entries(overrides)) {\n    const defaultValue = defaults[key];\n    const valueStr = JSON.stringify(value);\n    const defaultStr = defaultValue !== undefined ? JSON.stringify(defaultValue) : 'none';\n    console.log(`  â€¢ ${key}: ${valueStr} ${c.dim(`(default: ${defaultStr})`)}`);\n  }\n  console.log('');\n}\n\nexport function printSuiteBox({\n  suite,\n  scorerAverages,\n  calculateBaselineScorerAverage,\n  flagDiff,\n}: {\n  suite: SuiteData;\n  scorerAverages: Record<string, number>;\n  calculateBaselineScorerAverage: (baseline: Evaluation, scorerName: string) => number | null;\n  flagDiff: Array<FlagDiff>;\n}) {\n  const filename = suite.file.split('/').pop();\n\n  console.log('â”Œâ”€');\n  console.log(`â”‚  ${c.blue(suite.name)} ${c.gray(`(${filename})`)}`);\n  console.log('â”œâ”€');\n\n  const scorerNames = Object.keys(scorerAverages);\n  const maxNameLength = Math.max(...scorerNames.map((name) => name.length));\n\n  for (const scorerName of scorerNames) {\n    const avg = scorerAverages[scorerName];\n    const paddedName = scorerName.padEnd(maxNameLength);\n\n    if (suite.baseline) {\n      const baselineAvg = calculateBaselineScorerAverage(suite.baseline, scorerName);\n      if (baselineAvg !== null) {\n        const currentPercent = (avg * 100).toFixed(2) + '%';\n        const baselinePercent = (baselineAvg * 100).toFixed(2) + '%';\n        const diff = avg - baselineAvg;\n        const diffText = (diff >= 0 ? '+' : '') + (diff * 100).toFixed(2) + '%';\n        const diffColor = diff > 0 ? c.green : diff < 0 ? c.red : c.dim;\n\n        const paddedBaseline = baselinePercent.padStart(7);\n        const paddedCurrent = currentPercent.padStart(7);\n        const paddedDiff = diffText.padStart(8);\n\n        console.log(\n          `â”‚  ${paddedName}  ${c.blueBright(paddedBaseline)} â†’ ${c.magentaBright(paddedCurrent)}  (${diffColor(paddedDiff)})`,\n        );\n      } else {\n        const currentPercent = (avg * 100).toFixed(2) + '%';\n        console.log(`â”‚   â€¢ ${paddedName}  ${currentPercent}`);\n      }\n    } else {\n      const currentPercent = (avg * 100).toFixed(2) + '%';\n      console.log(`â”‚   â€¢ ${paddedName}  ${currentPercent}`);\n    }\n  }\n\n  console.log('â”œâ”€');\n\n  if (suite.baseline) {\n    const baselineTimestamp = suite.baseline.runAt\n      ? reporterDate(new Date(suite.baseline.runAt))\n      : 'unknown time';\n    console.log(\n      `â”‚  Baseline: ${suite.baseline.name}-${suite.baseline.version} ${c.gray(`(${baselineTimestamp})`)}`,\n    );\n  } else {\n    console.log(`â”‚  Baseline: ${c.gray('(none)')}`);\n  }\n\n  if (suite.baseline) {\n    const hasConfigChanges = flagDiff.length > 0;\n\n    console.log('â”‚  Config changes:', hasConfigChanges ? '' : c.gray('(none)'));\n    if (hasConfigChanges) {\n      for (const { flag, current, baseline } of flagDiff) {\n        console.log(\n          `â”‚   â€¢ ${flag}: ${current ?? '<not set>'} ${c.gray(`(baseline: ${baseline ?? '<not set>'})`)}`,\n        );\n      }\n    }\n  }\n\n  if (suite.outOfScopeFlags && suite.outOfScopeFlags.length > 0) {\n    const pickedFlagsText =\n      suite.configFlags && suite.configFlags.length > 0\n        ? suite.configFlags.map((f) => `'${f}'`).join(', ')\n        : 'none';\n    console.log('â”‚');\n    console.log(\n      `â”‚  ${c.yellow('âš  Out-of-scope flags')} ${c.gray(`(picked: ${pickedFlagsText})`)}:`,\n    );\n    for (const flag of suite.outOfScopeFlags) {\n      const lastStackTraceFrame = flag.stackTrace[0];\n      const lastStackTraceFnName = lastStackTraceFrame.split(' ').shift();\n      const lastStackTraceFile = lastStackTraceFrame.split('/').pop()?.slice(0, -1);\n      console.log(\n        `â”‚   â€¢ ${flag.flagPath} ${c.gray(`at ${lastStackTraceFnName} (${lastStackTraceFile})`)}`,\n      );\n    }\n  }\n\n  console.log('â””â”€');\n}\n\nexport function printFinalReport({\n  suiteData,\n  calculateScorerAverages,\n  calculateBaselineScorerAverage,\n  calculateFlagDiff,\n}: {\n  suiteData: SuiteData[];\n  calculateScorerAverages: (suite: SuiteData) => Record<string, number>;\n  calculateBaselineScorerAverage: (baseline: Evaluation, scorerName: string) => number | null;\n  calculateFlagDiff: (suite: SuiteData) => Array<FlagDiff>;\n}) {\n  console.log('');\n  console.log(c.bgBlue(c.white(' FINAL EVALUATION REPORT ')));\n  console.log('');\n\n  for (const suite of suiteData) {\n    const scorerAverages = calculateScorerAverages(suite);\n    const flagDiff = suite.baseline ? calculateFlagDiff(suite) : [];\n    printSuiteBox({ suite, scorerAverages, calculateBaselineScorerAverage, flagDiff });\n    console.log('');\n  }\n\n  console.log('View full report:');\n  console.log('https://app.axiom.co/evaluations/run/<run-id>');\n}\n","import type { SerializedError } from 'vitest';\nimport type { Reporter, TestCase, TestModule, TestRunEndReason, TestSuite } from 'vitest/node.js';\n\nimport { getGlobalFlagOverrides } from './context/global-flags';\nimport { getAxiomConfig, getConfigScope } from './context/storage';\nimport { findEvaluationCases } from './eval.service';\nimport type {\n  Evaluation,\n  EvaluationReport,\n  FlagDiff,\n  MetaWithCase,\n  MetaWithEval,\n} from './eval.types';\nimport {\n  maybePrintFlags,\n  printBaselineNameAndVersion,\n  printConfigHeader,\n  printEvalNameAndFileName,\n  printFinalReport,\n  printGlobalFlagOverrides,\n  printOutOfScopeFlags,\n  printRuntimeFlags,\n  printTestCaseCountStartDuration,\n  printTestCaseScores,\n  printTestCaseSuccessOrFailed,\n  type SuiteData,\n} from './reporter.console-utils';\nimport { flattenObject } from '../util/dot-path';\nimport { AxiomCLIError } from '../cli/errors';\n\n/**\n * Custom Vitest reporter for Axiom AI evaluations.\n *\n * This reporter collects evaluation results and scores from tests\n * and processes them for further analysis and reporting.\n *\n */\nexport class AxiomReporter implements Reporter {\n  startTime: number = 0;\n  start: number = 0;\n  private _endOfRunConfigEnd: EvaluationReport['configEnd'] | undefined;\n  private _suiteData: SuiteData[] = [];\n  private _baselines: Map<string, Evaluation | null> = new Map();\n\n  onTestRunStart() {\n    this.start = performance.now();\n    this.startTime = new Date().getTime();\n\n    // Print global flag overrides at start\n    const overrides = getGlobalFlagOverrides();\n    const defaults = getConfigScope()?.getAllDefaultFlags?.() ?? {};\n    printGlobalFlagOverrides(overrides, defaults);\n  }\n\n  async onTestSuiteReady(_testSuite: TestSuite) {\n    const meta = _testSuite.meta() as MetaWithEval;\n    if (_testSuite.state() === 'skipped') {\n      return;\n    }\n    const baseline = meta.evaluation.baseline;\n    if (baseline) {\n      // load baseline data per suite\n      const config = getAxiomConfig();\n      if (!config) {\n        throw new AxiomCLIError('Axiom config not available in reporter');\n      }\n      const baselineData = await findEvaluationCases(baseline.id, config);\n      this._baselines.set(meta.evaluation.name, baselineData || null);\n    } else {\n      this._baselines.set(meta.evaluation.name, null);\n    }\n\n    // capture end-of-run config snapshot (first non-empty wins)\n    if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {\n      this._endOfRunConfigEnd = meta.evaluation.configEnd;\n    }\n  }\n\n  onTestCaseReady(test: TestCase) {\n    const meta = test.meta() as MetaWithCase;\n\n    // TODO: there seem to be some cases where `meta` is undefined\n    // maybe we get here to early?\n    if (!meta.case) return;\n  }\n\n  async onTestSuiteResult(testSuite: TestSuite) {\n    const meta = testSuite.meta() as MetaWithEval;\n    // test suite won't have any meta because its skipped\n    if (testSuite.state() === 'skipped') {\n      return;\n    }\n\n    const durationSeconds = Number((performance.now() - this.start) / 1000).toFixed(2);\n\n    const cases: SuiteData['cases'] = [];\n    for (const test of testSuite.children) {\n      if (test.type !== 'test') continue;\n\n      const testMeta = test.meta() as MetaWithCase;\n      if (!testMeta?.case) continue;\n\n      cases.push({\n        index: testMeta.case.index,\n        scores: testMeta.case.scores,\n        outOfScopeFlags: testMeta.case.outOfScopeFlags,\n        errors: testMeta.case.errors,\n        runtimeFlags: testMeta.case.runtimeFlags,\n      });\n    }\n\n    const cwd = process.cwd();\n    const relativePath = testSuite.module.moduleId.replace(cwd, '').replace(/^\\//, '');\n\n    // Collect suite data for final report\n    // Ensure baseline is loaded\n    let suiteBaseline = this._baselines.get(meta.evaluation.name);\n    if (suiteBaseline === undefined && meta.evaluation.baseline) {\n      // Baseline wasn't loaded yet, load it now\n      const config = getAxiomConfig();\n      if (!config) {\n        throw new AxiomCLIError('Axiom config not available in reporter');\n      }\n      const baselineData = await findEvaluationCases(meta.evaluation.baseline.id, config);\n      suiteBaseline = baselineData || null;\n      this._baselines.set(meta.evaluation.name, suiteBaseline);\n    }\n    this._suiteData.push({\n      name: meta.evaluation.name,\n      file: relativePath,\n      duration: durationSeconds + 's',\n      baseline: suiteBaseline || null,\n      configFlags: meta.evaluation.configFlags,\n      flagConfig: meta.evaluation.flagConfig,\n      cases,\n      outOfScopeFlags: meta.evaluation.outOfScopeFlags,\n    });\n\n    printEvalNameAndFileName(testSuite, meta);\n    printBaselineNameAndVersion(meta);\n\n    printTestCaseCountStartDuration(testSuite, this.startTime, durationSeconds);\n\n    for (const test of testSuite.children) {\n      if (test.type !== 'test') continue;\n      this.printCaseResult(test, suiteBaseline || null);\n    }\n\n    console.log('');\n  }\n\n  async onTestRunEnd(\n    _testModules: ReadonlyArray<TestModule>,\n    _errors: ReadonlyArray<SerializedError>,\n    _reason: TestRunEndReason,\n  ) {\n    const shouldClear = !process.env.CI && process.stdout.isTTY !== false;\n\n    if (shouldClear) {\n      process.stdout.write('\\x1b[2J\\x1b[0f'); // Clear screen and move cursor to top\n    }\n\n    printFinalReport({\n      suiteData: this._suiteData,\n      calculateScorerAverages: this.calculateScorerAverages.bind(this),\n      calculateBaselineScorerAverage: this.calculateBaselineScorerAverage.bind(this),\n      calculateFlagDiff: this.calculateFlagDiff.bind(this),\n    });\n\n    const DEBUG = process.env.AXIOM_DEBUG === 'true';\n    if (DEBUG && this._endOfRunConfigEnd) {\n      this.printConfigEnd(this._endOfRunConfigEnd);\n    }\n  }\n\n  private printCaseResult(test: TestCase, baseline: Evaluation | null) {\n    const ok = test.ok();\n    const testMeta = test.meta() as MetaWithCase;\n\n    if (!testMeta?.case) {\n      return;\n    }\n\n    printTestCaseSuccessOrFailed(testMeta, ok);\n\n    printTestCaseScores(testMeta, baseline);\n\n    printRuntimeFlags(testMeta);\n\n    printOutOfScopeFlags(testMeta);\n  }\n\n  /**\n   * Calculate average scores per scorer for a suite\n   */\n  private calculateScorerAverages(suite: SuiteData): Record<string, number> {\n    const scorerTotals: Record<string, { sum: number; count: number }> = {};\n\n    for (const caseData of suite.cases) {\n      for (const [scorerName, score] of Object.entries(caseData.scores)) {\n        if (!scorerTotals[scorerName]) {\n          scorerTotals[scorerName] = { sum: 0, count: 0 };\n        }\n        scorerTotals[scorerName].sum += score.score || 0;\n        scorerTotals[scorerName].count += 1;\n      }\n    }\n\n    const averages: Record<string, number> = {};\n    for (const [scorerName, totals] of Object.entries(scorerTotals)) {\n      averages[scorerName] = totals.count > 0 ? totals.sum / totals.count : 0;\n    }\n\n    return averages;\n  }\n\n  /**\n   * Calculate average score for a specific scorer from baseline data\n   */\n  private calculateBaselineScorerAverage(baseline: Evaluation, scorerName: string): number | null {\n    const scores: number[] = [];\n\n    for (const caseData of baseline.cases) {\n      if (caseData.scores[scorerName]) {\n        scores.push(caseData.scores[scorerName].value);\n      }\n    }\n\n    if (scores.length === 0) return null;\n\n    const sum = scores.reduce((acc, val) => acc + val, 0);\n    return sum / scores.length;\n  }\n\n  /**\n   * Calculate flag diff between current run and baseline (filtered by configFlags)\n   */\n  private calculateFlagDiff(suite: SuiteData): Array<FlagDiff> {\n    if (!suite.baseline || !suite.configFlags || suite.configFlags.length === 0) {\n      return [];\n    }\n\n    const diffs: Array<FlagDiff> = [];\n\n    const currentConfig = suite.flagConfig || {};\n    const baselineConfig = suite.baseline.flagConfig || {};\n\n    const currentFlat = flattenObject(currentConfig);\n    const baselineFlat = flattenObject(baselineConfig);\n\n    const allKeys = new Set([...Object.keys(currentFlat), ...Object.keys(baselineFlat)]);\n\n    for (const key of allKeys) {\n      const isInScope = suite.configFlags.some((pattern) => key.startsWith(pattern));\n      if (!isInScope) continue;\n\n      const currentValue = currentFlat[key];\n      const baselineValue = baselineFlat[key];\n\n      if (JSON.stringify(currentValue) !== JSON.stringify(baselineValue)) {\n        diffs.push({\n          flag: key,\n          current: currentValue ? JSON.stringify(currentValue) : undefined,\n          baseline: baselineValue ? JSON.stringify(baselineValue) : undefined,\n        });\n      }\n    }\n\n    return diffs;\n  }\n\n  /**\n   * End-of-suite config summary (console only)\n   */\n  private printConfigEnd(configEnd: EvaluationReport['configEnd']) {\n    printConfigHeader();\n    maybePrintFlags(configEnd);\n  }\n}\n","import { BatchSpanProcessor, NodeTracerProvider } from '@opentelemetry/sdk-trace-node';\nimport { resourceFromAttributes } from '@opentelemetry/resources';\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';\nimport {\n  trace,\n  type Context,\n  type SpanOptions,\n  type Tracer,\n  type TracerProvider,\n} from '@opentelemetry/api';\nimport { initAxiomAI } from '../../src/otel/initAxiomAI';\nimport type {\n  AxiomEvalInstrumentationHook,\n  AxiomEvalInstrumentationOptions,\n  AxiomEvalInstrumentationResult,\n  ResolvedAxiomConfig,\n} from '../config/index';\nimport { resolveAxiomConnection } from '../config/resolver';\nimport { AxiomCLIError, errorToString } from '../cli/errors';\n\n// Lazily initialized tracer provider and exporter\nlet axiomProvider: NodeTracerProvider | undefined;\nlet axiomTracer: Tracer | undefined;\nlet userProvider: TracerProvider | undefined;\n\nlet initializationPromise: Promise<void> | null = null;\nlet initialized = false;\n\nasync function runInstrumentationHook(\n  hook: AxiomEvalInstrumentationHook,\n  options: AxiomEvalInstrumentationOptions,\n): Promise<AxiomEvalInstrumentationResult | void> {\n  try {\n    return await hook(options);\n  } catch (error) {\n    throw new AxiomCLIError(`Failed to execute instrumentation hook: ${errorToString(error)}`);\n  }\n}\n\nfunction setupEvalProvider(connection: ReturnType<typeof resolveAxiomConnection>) {\n  const headers: Record<string, string> = {\n    'X-Axiom-Dataset': connection.dataset,\n  };\n\n  if (connection.token) {\n    headers.Authorization = `Bearer ${connection.token}`;\n  }\n\n  const collectorOptions = {\n    url: `${connection.url}/v1/traces`,\n    headers,\n    concurrencyLimit: 10,\n  };\n\n  const exporter = new OTLPTraceExporter(collectorOptions);\n\n  const processor = new BatchSpanProcessor(exporter, {\n    maxQueueSize: 2048,\n    maxExportBatchSize: 512,\n    scheduledDelayMillis: 5000,\n    exportTimeoutMillis: 30000,\n  });\n\n  axiomProvider = new NodeTracerProvider({\n    resource: resourceFromAttributes({\n      ['service.name']: 'axiom',\n      ['service.version']: __SDK_VERSION__,\n    }),\n    spanProcessors: [processor],\n  });\n\n  axiomTracer = axiomProvider.getTracer('axiom', __SDK_VERSION__);\n}\n\nexport async function initInstrumentation(config: {\n  enabled: boolean;\n  config: ResolvedAxiomConfig;\n}): Promise<void> {\n  if (initialized) {\n    return;\n  }\n\n  if (initializationPromise) {\n    await initializationPromise;\n    return;\n  }\n\n  initializationPromise = (async () => {\n    if (!config.enabled) {\n      axiomTracer = trace.getTracer('axiom', __SDK_VERSION__);\n      initialized = true;\n      return;\n    }\n\n    const connection = resolveAxiomConnection(config.config);\n    const hook = config.config.eval.instrumentation;\n    let hookResult: AxiomEvalInstrumentationResult | void = undefined;\n\n    if (hook) {\n      config.config.eval.instrumentation = hook;\n      hookResult = await runInstrumentationHook(hook, {\n        dataset: connection.dataset,\n        token: connection.token,\n        url: connection.url,\n      });\n\n      userProvider = hookResult?.provider ?? userProvider;\n    }\n\n    setupEvalProvider(connection);\n\n    if (!hook) {\n      // Fall back to default behaviour by registering our provider globally\n      axiomProvider?.register();\n      if (axiomTracer) {\n        initAxiomAI({ tracer: axiomTracer });\n      }\n    }\n\n    initialized = true;\n  })();\n\n  try {\n    await initializationPromise;\n  } finally {\n    initializationPromise = null;\n  }\n}\n\nexport const flush = async () => {\n  if (initializationPromise) {\n    await initializationPromise;\n  }\n\n  const tasks: Array<Promise<unknown>> = [];\n\n  if (axiomProvider) {\n    tasks.push(axiomProvider.forceFlush());\n  }\n\n  const candidateProviders = new Set<TracerProvider>();\n  if (userProvider) {\n    candidateProviders.add(userProvider);\n  }\n\n  const globalProvider = trace.getTracerProvider();\n  if (globalProvider) {\n    candidateProviders.add(globalProvider);\n  }\n\n  for (const provider of candidateProviders) {\n    const flushFn = (provider as any).forceFlush;\n    if (typeof flushFn === 'function') {\n      tasks.push(\n        flushFn.call(provider).catch((error: unknown) => {\n          console.warn('[AxiomAI] Failed to flush tracer provider:', errorToString(error));\n        }),\n      );\n    }\n  }\n\n  if (tasks.length > 0) {\n    await Promise.all(tasks);\n  }\n};\n\n/**\n * Ensure instrumentation is initialized with the given config.\n * Call this from within test context before using startSpan.\n */\nexport async function ensureInstrumentationInitialized(config: ResolvedAxiomConfig): Promise<void> {\n  if (initialized) {\n    return;\n  }\n\n  await initInstrumentation({ enabled: true, config });\n}\n\nconst getEvalTracer = (): Tracer => {\n  if (!axiomTracer) {\n    throw new Error(\n      'Eval tracer not initialized. Ensure ensureInstrumentationInitialized() was awaited before starting spans.',\n    );\n  }\n\n  return axiomTracer;\n};\n\nexport const startSpan = (name: string, opts: SpanOptions, context?: Context) => {\n  if (!initialized || !axiomTracer) {\n    throw new Error(\n      'Instrumentation not initialized. This is likely a bug - instrumentation should be initialized before startSpan is called.',\n    );\n  }\n  return getEvalTracer().startSpan(name, opts, context);\n};\n"],"mappings":"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","names":["trace","s","p","findSchemaAtPath","trace","a","r","s","u","f","f","trace","trace"]}