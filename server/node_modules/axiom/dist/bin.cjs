#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);

// ../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/shared/pathe.M-eThtNZ.mjs
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r6) => r6.toUpperCase());
}
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
function normalizeString(path4, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path4.length; ++index) {
    if (index < path4.length) {
      char = path4[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path4.slice(lastSlash + 1, index)}`;
        } else {
          res = path4.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var _DRIVE_LETTER_START_RE, _UNC_REGEX, _IS_ABSOLUTE_RE, _DRIVE_LETTER_RE, _ROOT_FOLDER_RE, _EXTNAME_RE, normalize, join, resolve2, isAbsolute, extname, relative, dirname, basename2;
var init_pathe_M_eThtNZ = __esm({
  "../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/shared/pathe.M-eThtNZ.mjs"() {
    "use strict";
    _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
    _UNC_REGEX = /^[/\\]{2}/;
    _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
    _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
    _ROOT_FOLDER_RE = /^\/([A-Za-z]:)?$/;
    _EXTNAME_RE = /.(\.[^./]+|\.)$/;
    normalize = function(path4) {
      if (path4.length === 0) {
        return ".";
      }
      path4 = normalizeWindowsPath(path4);
      const isUNCPath = path4.match(_UNC_REGEX);
      const isPathAbsolute = isAbsolute(path4);
      const trailingSeparator = path4[path4.length - 1] === "/";
      path4 = normalizeString(path4, !isPathAbsolute);
      if (path4.length === 0) {
        if (isPathAbsolute) {
          return "/";
        }
        return trailingSeparator ? "./" : ".";
      }
      if (trailingSeparator) {
        path4 += "/";
      }
      if (_DRIVE_LETTER_RE.test(path4)) {
        path4 += "/";
      }
      if (isUNCPath) {
        if (!isPathAbsolute) {
          return `//./${path4}`;
        }
        return `//${path4}`;
      }
      return isPathAbsolute && !isAbsolute(path4) ? `/${path4}` : path4;
    };
    join = function(...segments) {
      let path4 = "";
      for (const seg of segments) {
        if (!seg) {
          continue;
        }
        if (path4.length > 0) {
          const pathTrailing = path4[path4.length - 1] === "/";
          const segLeading = seg[0] === "/";
          const both = pathTrailing && segLeading;
          if (both) {
            path4 += seg.slice(1);
          } else {
            path4 += pathTrailing || segLeading ? seg : `/${seg}`;
          }
        } else {
          path4 += seg;
        }
      }
      return normalize(path4);
    };
    resolve2 = function(...arguments_) {
      arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
      let resolvedPath = "";
      let resolvedAbsolute = false;
      for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
        const path4 = index >= 0 ? arguments_[index] : cwd();
        if (!path4 || path4.length === 0) {
          continue;
        }
        resolvedPath = `${path4}/${resolvedPath}`;
        resolvedAbsolute = isAbsolute(path4);
      }
      resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
        return `/${resolvedPath}`;
      }
      return resolvedPath.length > 0 ? resolvedPath : ".";
    };
    isAbsolute = function(p3) {
      return _IS_ABSOLUTE_RE.test(p3);
    };
    extname = function(p3) {
      if (p3 === "..") return "";
      const match = _EXTNAME_RE.exec(normalizeWindowsPath(p3));
      return match && match[1] || "";
    };
    relative = function(from, to) {
      const _from = resolve2(from).replace(_ROOT_FOLDER_RE, "$1").split("/");
      const _to = resolve2(to).replace(_ROOT_FOLDER_RE, "$1").split("/");
      if (_to[0][1] === ":" && _from[0][1] === ":" && _from[0] !== _to[0]) {
        return _to.join("/");
      }
      const _fromCopy = [..._from];
      for (const segment of _fromCopy) {
        if (_to[0] !== segment) {
          break;
        }
        _from.shift();
        _to.shift();
      }
      return [..._from.map(() => ".."), ..._to].join("/");
    };
    dirname = function(p3) {
      const segments = normalizeWindowsPath(p3).replace(/\/$/, "").split("/").slice(0, -1);
      if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
        segments[0] += "/";
      }
      return segments.join("/") || (isAbsolute(p3) ? "/" : ".");
    };
    basename2 = function(p3, extension) {
      const segments = normalizeWindowsPath(p3).split("/");
      let lastSegment = "";
      for (let i2 = segments.length - 1; i2 >= 0; i2--) {
        const val = segments[i2];
        if (val) {
          lastSegment = val;
          break;
        }
      }
      return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
    };
  }
});

// ../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/index.mjs
var init_dist = __esm({
  "../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/index.mjs"() {
    "use strict";
    init_pathe_M_eThtNZ();
  }
});

// ../../node_modules/.pnpm/jiti@2.6.1/node_modules/jiti/dist/jiti.cjs
var require_jiti = __commonJS({
  "../../node_modules/.pnpm/jiti@2.6.1/node_modules/jiti/dist/jiti.cjs"(exports2, module2) {
    "use strict";
    (() => {
      var e3 = { "./node_modules/.pnpm/mlly@1.8.0/node_modules/mlly/dist lazy recursive": function(e4) {
        function webpackEmptyAsyncContext(e5) {
          return Promise.resolve().then(function() {
            var t3 = new Error("Cannot find module '" + e5 + "'");
            throw t3.code = "MODULE_NOT_FOUND", t3;
          });
        }
        webpackEmptyAsyncContext.keys = () => [], webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = "./node_modules/.pnpm/mlly@1.8.0/node_modules/mlly/dist lazy recursive", e4.exports = webpackEmptyAsyncContext;
      } }, t2 = {};
      function __webpack_require__(i3) {
        var s4 = t2[i3];
        if (void 0 !== s4) return s4.exports;
        var r6 = t2[i3] = { exports: {} };
        return e3[i3](r6, r6.exports, __webpack_require__), r6.exports;
      }
      __webpack_require__.n = (e4) => {
        var t3 = e4 && e4.__esModule ? () => e4.default : () => e4;
        return __webpack_require__.d(t3, { a: t3 }), t3;
      }, __webpack_require__.d = (e4, t3) => {
        for (var i3 in t3) __webpack_require__.o(t3, i3) && !__webpack_require__.o(e4, i3) && Object.defineProperty(e4, i3, { enumerable: true, get: t3[i3] });
      }, __webpack_require__.o = (e4, t3) => Object.prototype.hasOwnProperty.call(e4, t3);
      var i2 = {};
      (() => {
        "use strict";
        __webpack_require__.d(i2, { default: () => createJiti2 });
        const e4 = require("os");
        var t3 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], s4 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], r6 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", n = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, a3 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", o = { 5: a3, "5module": a3 + " export import", 6: a3 + " const class extends export import super" }, h8 = /^in(stanceof)?$/, c2 = new RegExp("[" + r6 + "]"), p3 = new RegExp("[" + r6 + "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65]");
        function isInAstralSet2(e5, t4) {
          for (var i3 = 65536, s5 = 0; s5 < t4.length; s5 += 2) {
            if ((i3 += t4[s5]) > e5) return false;
            if ((i3 += t4[s5 + 1]) >= e5) return true;
          }
          return false;
        }
        function isIdentifierStart2(e5, t4) {
          return e5 < 65 ? 36 === e5 : e5 < 91 || (e5 < 97 ? 95 === e5 : e5 < 123 || (e5 <= 65535 ? e5 >= 170 && c2.test(String.fromCharCode(e5)) : false !== t4 && isInAstralSet2(e5, s4)));
        }
        function isIdentifierChar2(e5, i3) {
          return e5 < 48 ? 36 === e5 : e5 < 58 || !(e5 < 65) && (e5 < 91 || (e5 < 97 ? 95 === e5 : e5 < 123 || (e5 <= 65535 ? e5 >= 170 && p3.test(String.fromCharCode(e5)) : false !== i3 && (isInAstralSet2(e5, s4) || isInAstralSet2(e5, t3)))));
        }
        var acorn_TokenType = function(e5, t4) {
          void 0 === t4 && (t4 = {}), this.label = e5, this.keyword = t4.keyword, this.beforeExpr = !!t4.beforeExpr, this.startsExpr = !!t4.startsExpr, this.isLoop = !!t4.isLoop, this.isAssign = !!t4.isAssign, this.prefix = !!t4.prefix, this.postfix = !!t4.postfix, this.binop = t4.binop || null, this.updateContext = null;
        };
        function binop2(e5, t4) {
          return new acorn_TokenType(e5, { beforeExpr: true, binop: t4 });
        }
        var l3 = { beforeExpr: true }, u4 = { startsExpr: true }, d4 = {};
        function kw2(e5, t4) {
          return void 0 === t4 && (t4 = {}), t4.keyword = e5, d4[e5] = new acorn_TokenType(e5, t4);
        }
        var f3 = { num: new acorn_TokenType("num", u4), regexp: new acorn_TokenType("regexp", u4), string: new acorn_TokenType("string", u4), name: new acorn_TokenType("name", u4), privateId: new acorn_TokenType("privateId", u4), eof: new acorn_TokenType("eof"), bracketL: new acorn_TokenType("[", { beforeExpr: true, startsExpr: true }), bracketR: new acorn_TokenType("]"), braceL: new acorn_TokenType("{", { beforeExpr: true, startsExpr: true }), braceR: new acorn_TokenType("}"), parenL: new acorn_TokenType("(", { beforeExpr: true, startsExpr: true }), parenR: new acorn_TokenType(")"), comma: new acorn_TokenType(",", l3), semi: new acorn_TokenType(";", l3), colon: new acorn_TokenType(":", l3), dot: new acorn_TokenType("."), question: new acorn_TokenType("?", l3), questionDot: new acorn_TokenType("?."), arrow: new acorn_TokenType("=>", l3), template: new acorn_TokenType("template"), invalidTemplate: new acorn_TokenType("invalidTemplate"), ellipsis: new acorn_TokenType("...", l3), backQuote: new acorn_TokenType("`", u4), dollarBraceL: new acorn_TokenType("${", { beforeExpr: true, startsExpr: true }), eq: new acorn_TokenType("=", { beforeExpr: true, isAssign: true }), assign: new acorn_TokenType("_=", { beforeExpr: true, isAssign: true }), incDec: new acorn_TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }), prefix: new acorn_TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: binop2("||", 1), logicalAND: binop2("&&", 2), bitwiseOR: binop2("|", 3), bitwiseXOR: binop2("^", 4), bitwiseAND: binop2("&", 5), equality: binop2("==/!=/===/!==", 6), relational: binop2("</>/<=/>=", 7), bitShift: binop2("<</>>/>>>", 8), plusMin: new acorn_TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: binop2("%", 10), star: binop2("*", 10), slash: binop2("/", 10), starstar: new acorn_TokenType("**", { beforeExpr: true }), coalesce: binop2("??", 1), _break: kw2("break"), _case: kw2("case", l3), _catch: kw2("catch"), _continue: kw2("continue"), _debugger: kw2("debugger"), _default: kw2("default", l3), _do: kw2("do", { isLoop: true, beforeExpr: true }), _else: kw2("else", l3), _finally: kw2("finally"), _for: kw2("for", { isLoop: true }), _function: kw2("function", u4), _if: kw2("if"), _return: kw2("return", l3), _switch: kw2("switch"), _throw: kw2("throw", l3), _try: kw2("try"), _var: kw2("var"), _const: kw2("const"), _while: kw2("while", { isLoop: true }), _with: kw2("with"), _new: kw2("new", { beforeExpr: true, startsExpr: true }), _this: kw2("this", u4), _super: kw2("super", u4), _class: kw2("class", u4), _extends: kw2("extends", l3), _export: kw2("export"), _import: kw2("import", u4), _null: kw2("null", u4), _true: kw2("true", u4), _false: kw2("false", u4), _in: kw2("in", { beforeExpr: true, binop: 7 }), _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }), _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true }) }, m4 = /\r\n?|\n|\u2028|\u2029/, g4 = new RegExp(m4.source, "g");
        function isNewLine2(e5) {
          return 10 === e5 || 13 === e5 || 8232 === e5 || 8233 === e5;
        }
        function nextLineBreak2(e5, t4, i3) {
          void 0 === i3 && (i3 = e5.length);
          for (var s5 = t4; s5 < i3; s5++) {
            var r7 = e5.charCodeAt(s5);
            if (isNewLine2(r7)) return s5 < i3 - 1 && 13 === r7 && 10 === e5.charCodeAt(s5 + 1) ? s5 + 2 : s5 + 1;
          }
          return -1;
        }
        var x5 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, v4 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, y3 = Object.prototype, _5 = y3.hasOwnProperty, E3 = y3.toString, b6 = Object.hasOwn || function(e5, t4) {
          return _5.call(e5, t4);
        }, S6 = Array.isArray || function(e5) {
          return "[object Array]" === E3.call(e5);
        }, k4 = /* @__PURE__ */ Object.create(null);
        function wordsRegexp2(e5) {
          return k4[e5] || (k4[e5] = new RegExp("^(?:" + e5.replace(/ /g, "|") + ")$"));
        }
        function codePointToString2(e5) {
          return e5 <= 65535 ? String.fromCharCode(e5) : (e5 -= 65536, String.fromCharCode(55296 + (e5 >> 10), 56320 + (1023 & e5)));
        }
        var w5 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, acorn_Position = function(e5, t4) {
          this.line = e5, this.column = t4;
        };
        acorn_Position.prototype.offset = function(e5) {
          return new acorn_Position(this.line, this.column + e5);
        };
        var acorn_SourceLocation = function(e5, t4, i3) {
          this.start = t4, this.end = i3, null !== e5.sourceFile && (this.source = e5.sourceFile);
        };
        function getLineInfo2(e5, t4) {
          for (var i3 = 1, s5 = 0; ; ) {
            var r7 = nextLineBreak2(e5, s5, t4);
            if (r7 < 0) return new acorn_Position(i3, t4 - s5);
            ++i3, s5 = r7;
          }
        }
        var I5 = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: false, checkPrivateFields: true, locations: false, onToken: null, onComment: null, ranges: false, program: null, sourceFile: null, directSourceFile: null, preserveParens: false }, C5 = false;
        function getOptions2(e5) {
          var t4 = {};
          for (var i3 in I5) t4[i3] = e5 && b6(e5, i3) ? e5[i3] : I5[i3];
          if ("latest" === t4.ecmaVersion ? t4.ecmaVersion = 1e8 : null == t4.ecmaVersion ? (!C5 && "object" == typeof console && console.warn && (C5 = true, console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), t4.ecmaVersion = 11) : t4.ecmaVersion >= 2015 && (t4.ecmaVersion -= 2009), null == t4.allowReserved && (t4.allowReserved = t4.ecmaVersion < 5), e5 && null != e5.allowHashBang || (t4.allowHashBang = t4.ecmaVersion >= 14), S6(t4.onToken)) {
            var s5 = t4.onToken;
            t4.onToken = function(e6) {
              return s5.push(e6);
            };
          }
          return S6(t4.onComment) && (t4.onComment = /* @__PURE__ */ (function(e6, t5) {
            return function(i4, s6, r7, n2, a4, o2) {
              var h9 = { type: i4 ? "Block" : "Line", value: s6, start: r7, end: n2 };
              e6.locations && (h9.loc = new acorn_SourceLocation(this, a4, o2)), e6.ranges && (h9.range = [r7, n2]), t5.push(h9);
            };
          })(t4, t4.onComment)), t4;
        }
        var R4 = 256, P5 = 259;
        function functionFlags2(e5, t4) {
          return 2 | (e5 ? 4 : 0) | (t4 ? 8 : 0);
        }
        var acorn_Parser = function(e5, t4, i3) {
          this.options = e5 = getOptions2(e5), this.sourceFile = e5.sourceFile, this.keywords = wordsRegexp2(o[e5.ecmaVersion >= 6 ? 6 : "module" === e5.sourceType ? "5module" : 5]);
          var s5 = "";
          true !== e5.allowReserved && (s5 = n[e5.ecmaVersion >= 6 ? 6 : 5 === e5.ecmaVersion ? 5 : 3], "module" === e5.sourceType && (s5 += " await")), this.reservedWords = wordsRegexp2(s5);
          var r7 = (s5 ? s5 + " " : "") + n.strict;
          this.reservedWordsStrict = wordsRegexp2(r7), this.reservedWordsStrictBind = wordsRegexp2(r7 + " " + n.strictBind), this.input = String(t4), this.containsEsc = false, i3 ? (this.pos = i3, this.lineStart = this.input.lastIndexOf("\n", i3 - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(m4).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = f3.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = "module" === e5.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = false, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), 0 === this.pos && e5.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
        }, T5 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
        acorn_Parser.prototype.parse = function() {
          var e5 = this.options.program || this.startNode();
          return this.nextToken(), this.parseTopLevel(e5);
        }, T5.inFunction.get = function() {
          return (2 & this.currentVarScope().flags) > 0;
        }, T5.inGenerator.get = function() {
          return (8 & this.currentVarScope().flags) > 0;
        }, T5.inAsync.get = function() {
          return (4 & this.currentVarScope().flags) > 0;
        }, T5.canAwait.get = function() {
          for (var e5 = this.scopeStack.length - 1; e5 >= 0; e5--) {
            var t4 = this.scopeStack[e5].flags;
            if (768 & t4) return false;
            if (2 & t4) return (4 & t4) > 0;
          }
          return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
        }, T5.allowSuper.get = function() {
          return (64 & this.currentThisScope().flags) > 0 || this.options.allowSuperOutsideMethod;
        }, T5.allowDirectSuper.get = function() {
          return (128 & this.currentThisScope().flags) > 0;
        }, T5.treatFunctionsAsVar.get = function() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }, T5.allowNewDotTarget.get = function() {
          for (var e5 = this.scopeStack.length - 1; e5 >= 0; e5--) {
            var t4 = this.scopeStack[e5].flags;
            if (768 & t4 || 2 & t4 && !(16 & t4)) return true;
          }
          return false;
        }, T5.inClassStaticBlock.get = function() {
          return (this.currentVarScope().flags & R4) > 0;
        }, acorn_Parser.extend = function() {
          for (var e5 = [], t4 = arguments.length; t4--; ) e5[t4] = arguments[t4];
          for (var i3 = this, s5 = 0; s5 < e5.length; s5++) i3 = e5[s5](i3);
          return i3;
        }, acorn_Parser.parse = function(e5, t4) {
          return new this(t4, e5).parse();
        }, acorn_Parser.parseExpressionAt = function(e5, t4, i3) {
          var s5 = new this(i3, e5, t4);
          return s5.nextToken(), s5.parseExpression();
        }, acorn_Parser.tokenizer = function(e5, t4) {
          return new this(t4, e5);
        }, Object.defineProperties(acorn_Parser.prototype, T5);
        var A2 = acorn_Parser.prototype, N6 = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
        A2.strictDirective = function(e5) {
          if (this.options.ecmaVersion < 5) return false;
          for (; ; ) {
            v4.lastIndex = e5, e5 += v4.exec(this.input)[0].length;
            var t4 = N6.exec(this.input.slice(e5));
            if (!t4) return false;
            if ("use strict" === (t4[1] || t4[2])) {
              v4.lastIndex = e5 + t4[0].length;
              var i3 = v4.exec(this.input), s5 = i3.index + i3[0].length, r7 = this.input.charAt(s5);
              return ";" === r7 || "}" === r7 || m4.test(i3[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(r7) || "!" === r7 && "=" === this.input.charAt(s5 + 1));
            }
            e5 += t4[0].length, v4.lastIndex = e5, e5 += v4.exec(this.input)[0].length, ";" === this.input[e5] && e5++;
          }
        }, A2.eat = function(e5) {
          return this.type === e5 && (this.next(), true);
        }, A2.isContextual = function(e5) {
          return this.type === f3.name && this.value === e5 && !this.containsEsc;
        }, A2.eatContextual = function(e5) {
          return !!this.isContextual(e5) && (this.next(), true);
        }, A2.expectContextual = function(e5) {
          this.eatContextual(e5) || this.unexpected();
        }, A2.canInsertSemicolon = function() {
          return this.type === f3.eof || this.type === f3.braceR || m4.test(this.input.slice(this.lastTokEnd, this.start));
        }, A2.insertSemicolon = function() {
          if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
        }, A2.semicolon = function() {
          this.eat(f3.semi) || this.insertSemicolon() || this.unexpected();
        }, A2.afterTrailingComma = function(e5, t4) {
          if (this.type === e5) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t4 || this.next(), true;
        }, A2.expect = function(e5) {
          this.eat(e5) || this.unexpected();
        }, A2.unexpected = function(e5) {
          this.raise(null != e5 ? e5 : this.start, "Unexpected token");
        };
        var acorn_DestructuringErrors = function() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
        };
        A2.checkPatternErrors = function(e5, t4) {
          if (e5) {
            e5.trailingComma > -1 && this.raiseRecoverable(e5.trailingComma, "Comma is not permitted after the rest element");
            var i3 = t4 ? e5.parenthesizedAssign : e5.parenthesizedBind;
            i3 > -1 && this.raiseRecoverable(i3, t4 ? "Assigning to rvalue" : "Parenthesized pattern");
          }
        }, A2.checkExpressionErrors = function(e5, t4) {
          if (!e5) return false;
          var i3 = e5.shorthandAssign, s5 = e5.doubleProto;
          if (!t4) return i3 >= 0 || s5 >= 0;
          i3 >= 0 && this.raise(i3, "Shorthand property assignments are valid only in destructuring patterns"), s5 >= 0 && this.raiseRecoverable(s5, "Redefinition of __proto__ property");
        }, A2.checkYieldAwaitInDefaultParams = function() {
          this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
        }, A2.isSimpleAssignTarget = function(e5) {
          return "ParenthesizedExpression" === e5.type ? this.isSimpleAssignTarget(e5.expression) : "Identifier" === e5.type || "MemberExpression" === e5.type;
        };
        var L4 = acorn_Parser.prototype;
        L4.parseTopLevel = function(e5) {
          var t4 = /* @__PURE__ */ Object.create(null);
          for (e5.body || (e5.body = []); this.type !== f3.eof; ) {
            var i3 = this.parseStatement(null, true, t4);
            e5.body.push(i3);
          }
          if (this.inModule) for (var s5 = 0, r7 = Object.keys(this.undefinedExports); s5 < r7.length; s5 += 1) {
            var n2 = r7[s5];
            this.raiseRecoverable(this.undefinedExports[n2].start, "Export '" + n2 + "' is not defined");
          }
          return this.adaptDirectivePrologue(e5.body), this.next(), e5.sourceType = this.options.sourceType, this.finishNode(e5, "Program");
        };
        var O4 = { kind: "loop" }, D3 = { kind: "switch" };
        L4.isLet = function(e5) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
          v4.lastIndex = this.pos;
          var t4 = v4.exec(this.input), i3 = this.pos + t4[0].length, s5 = this.input.charCodeAt(i3);
          if (91 === s5 || 92 === s5) return true;
          if (e5) return false;
          if (123 === s5 || s5 > 55295 && s5 < 56320) return true;
          if (isIdentifierStart2(s5, true)) {
            for (var r7 = i3 + 1; isIdentifierChar2(s5 = this.input.charCodeAt(r7), true); ) ++r7;
            if (92 === s5 || s5 > 55295 && s5 < 56320) return true;
            var n2 = this.input.slice(i3, r7);
            if (!h8.test(n2)) return true;
          }
          return false;
        }, L4.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
          v4.lastIndex = this.pos;
          var e5, t4 = v4.exec(this.input), i3 = this.pos + t4[0].length;
          return !(m4.test(this.input.slice(this.pos, i3)) || "function" !== this.input.slice(i3, i3 + 8) || i3 + 8 !== this.input.length && (isIdentifierChar2(e5 = this.input.charCodeAt(i3 + 8)) || e5 > 55295 && e5 < 56320));
        }, L4.isUsingKeyword = function(e5, t4) {
          if (this.options.ecmaVersion < 17 || !this.isContextual(e5 ? "await" : "using")) return false;
          v4.lastIndex = this.pos;
          var i3 = v4.exec(this.input), s5 = this.pos + i3[0].length;
          if (m4.test(this.input.slice(this.pos, s5))) return false;
          if (e5) {
            var r7, n2 = s5 + 5;
            if ("using" !== this.input.slice(s5, n2) || n2 === this.input.length || isIdentifierChar2(r7 = this.input.charCodeAt(n2)) || r7 > 55295 && r7 < 56320) return false;
            v4.lastIndex = n2;
            var a4 = v4.exec(this.input);
            if (a4 && m4.test(this.input.slice(n2, n2 + a4[0].length))) return false;
          }
          if (t4) {
            var o2, h9 = s5 + 2;
            if (!("of" !== this.input.slice(s5, h9) || h9 !== this.input.length && (isIdentifierChar2(o2 = this.input.charCodeAt(h9)) || o2 > 55295 && o2 < 56320))) return false;
          }
          var c3 = this.input.charCodeAt(s5);
          return isIdentifierStart2(c3, true) || 92 === c3;
        }, L4.isAwaitUsing = function(e5) {
          return this.isUsingKeyword(true, e5);
        }, L4.isUsing = function(e5) {
          return this.isUsingKeyword(false, e5);
        }, L4.parseStatement = function(e5, t4, i3) {
          var s5, r7 = this.type, n2 = this.startNode();
          switch (this.isLet(e5) && (r7 = f3._var, s5 = "let"), r7) {
            case f3._break:
            case f3._continue:
              return this.parseBreakContinueStatement(n2, r7.keyword);
            case f3._debugger:
              return this.parseDebuggerStatement(n2);
            case f3._do:
              return this.parseDoStatement(n2);
            case f3._for:
              return this.parseForStatement(n2);
            case f3._function:
              return e5 && (this.strict || "if" !== e5 && "label" !== e5) && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n2, false, !e5);
            case f3._class:
              return e5 && this.unexpected(), this.parseClass(n2, true);
            case f3._if:
              return this.parseIfStatement(n2);
            case f3._return:
              return this.parseReturnStatement(n2);
            case f3._switch:
              return this.parseSwitchStatement(n2);
            case f3._throw:
              return this.parseThrowStatement(n2);
            case f3._try:
              return this.parseTryStatement(n2);
            case f3._const:
            case f3._var:
              return s5 = s5 || this.value, e5 && "var" !== s5 && this.unexpected(), this.parseVarStatement(n2, s5);
            case f3._while:
              return this.parseWhileStatement(n2);
            case f3._with:
              return this.parseWithStatement(n2);
            case f3.braceL:
              return this.parseBlock(true, n2);
            case f3.semi:
              return this.parseEmptyStatement(n2);
            case f3._export:
            case f3._import:
              if (this.options.ecmaVersion > 10 && r7 === f3._import) {
                v4.lastIndex = this.pos;
                var a4 = v4.exec(this.input), o2 = this.pos + a4[0].length, h9 = this.input.charCodeAt(o2);
                if (40 === h9 || 46 === h9) return this.parseExpressionStatement(n2, this.parseExpression());
              }
              return this.options.allowImportExportEverywhere || (t4 || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r7 === f3._import ? this.parseImport(n2) : this.parseExport(n2, i3);
            default:
              if (this.isAsyncFunction()) return e5 && this.unexpected(), this.next(), this.parseFunctionStatement(n2, true, !e5);
              var c3 = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
              if (c3) return t4 && "script" === this.options.sourceType && this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`"), "await using" === c3 && (this.canAwait || this.raise(this.start, "Await using cannot appear outside of async function"), this.next()), this.next(), this.parseVar(n2, false, c3), this.semicolon(), this.finishNode(n2, "VariableDeclaration");
              var p4 = this.value, l4 = this.parseExpression();
              return r7 === f3.name && "Identifier" === l4.type && this.eat(f3.colon) ? this.parseLabeledStatement(n2, p4, l4, e5) : this.parseExpressionStatement(n2, l4);
          }
        }, L4.parseBreakContinueStatement = function(e5, t4) {
          var i3 = "break" === t4;
          this.next(), this.eat(f3.semi) || this.insertSemicolon() ? e5.label = null : this.type !== f3.name ? this.unexpected() : (e5.label = this.parseIdent(), this.semicolon());
          for (var s5 = 0; s5 < this.labels.length; ++s5) {
            var r7 = this.labels[s5];
            if (null == e5.label || r7.name === e5.label.name) {
              if (null != r7.kind && (i3 || "loop" === r7.kind)) break;
              if (e5.label && i3) break;
            }
          }
          return s5 === this.labels.length && this.raise(e5.start, "Unsyntactic " + t4), this.finishNode(e5, i3 ? "BreakStatement" : "ContinueStatement");
        }, L4.parseDebuggerStatement = function(e5) {
          return this.next(), this.semicolon(), this.finishNode(e5, "DebuggerStatement");
        }, L4.parseDoStatement = function(e5) {
          return this.next(), this.labels.push(O4), e5.body = this.parseStatement("do"), this.labels.pop(), this.expect(f3._while), e5.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(f3.semi) : this.semicolon(), this.finishNode(e5, "DoWhileStatement");
        }, L4.parseForStatement = function(e5) {
          this.next();
          var t4 = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
          if (this.labels.push(O4), this.enterScope(0), this.expect(f3.parenL), this.type === f3.semi) return t4 > -1 && this.unexpected(t4), this.parseFor(e5, null);
          var i3 = this.isLet();
          if (this.type === f3._var || this.type === f3._const || i3) {
            var s5 = this.startNode(), r7 = i3 ? "let" : this.value;
            return this.next(), this.parseVar(s5, true, r7), this.finishNode(s5, "VariableDeclaration"), this.parseForAfterInit(e5, s5, t4);
          }
          var n2 = this.isContextual("let"), a4 = false, o2 = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
          if (o2) {
            var h9 = this.startNode();
            return this.next(), "await using" === o2 && this.next(), this.parseVar(h9, true, o2), this.finishNode(h9, "VariableDeclaration"), this.parseForAfterInit(e5, h9, t4);
          }
          var c3 = this.containsEsc, p4 = new acorn_DestructuringErrors(), l4 = this.start, u5 = t4 > -1 ? this.parseExprSubscripts(p4, "await") : this.parseExpression(true, p4);
          return this.type === f3._in || (a4 = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t4 > -1 ? (this.type === f3._in && this.unexpected(t4), e5.await = true) : a4 && this.options.ecmaVersion >= 8 && (u5.start !== l4 || c3 || "Identifier" !== u5.type || "async" !== u5.name ? this.options.ecmaVersion >= 9 && (e5.await = false) : this.unexpected()), n2 && a4 && this.raise(u5.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(u5, false, p4), this.checkLValPattern(u5), this.parseForIn(e5, u5)) : (this.checkExpressionErrors(p4, true), t4 > -1 && this.unexpected(t4), this.parseFor(e5, u5));
        }, L4.parseForAfterInit = function(e5, t4, i3) {
          return (this.type === f3._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === t4.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === f3._in ? i3 > -1 && this.unexpected(i3) : e5.await = i3 > -1), this.parseForIn(e5, t4)) : (i3 > -1 && this.unexpected(i3), this.parseFor(e5, t4));
        }, L4.parseFunctionStatement = function(e5, t4, i3) {
          return this.next(), this.parseFunction(e5, U6 | (i3 ? 0 : M4), false, t4);
        }, L4.parseIfStatement = function(e5) {
          return this.next(), e5.test = this.parseParenExpression(), e5.consequent = this.parseStatement("if"), e5.alternate = this.eat(f3._else) ? this.parseStatement("if") : null, this.finishNode(e5, "IfStatement");
        }, L4.parseReturnStatement = function(e5) {
          return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(f3.semi) || this.insertSemicolon() ? e5.argument = null : (e5.argument = this.parseExpression(), this.semicolon()), this.finishNode(e5, "ReturnStatement");
        }, L4.parseSwitchStatement = function(e5) {
          var t4;
          this.next(), e5.discriminant = this.parseParenExpression(), e5.cases = [], this.expect(f3.braceL), this.labels.push(D3), this.enterScope(0);
          for (var i3 = false; this.type !== f3.braceR; ) if (this.type === f3._case || this.type === f3._default) {
            var s5 = this.type === f3._case;
            t4 && this.finishNode(t4, "SwitchCase"), e5.cases.push(t4 = this.startNode()), t4.consequent = [], this.next(), s5 ? t4.test = this.parseExpression() : (i3 && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), i3 = true, t4.test = null), this.expect(f3.colon);
          } else t4 || this.unexpected(), t4.consequent.push(this.parseStatement(null));
          return this.exitScope(), t4 && this.finishNode(t4, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e5, "SwitchStatement");
        }, L4.parseThrowStatement = function(e5) {
          return this.next(), m4.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e5.argument = this.parseExpression(), this.semicolon(), this.finishNode(e5, "ThrowStatement");
        };
        var V4 = [];
        L4.parseCatchClauseParam = function() {
          var e5 = this.parseBindingAtom(), t4 = "Identifier" === e5.type;
          return this.enterScope(t4 ? 32 : 0), this.checkLValPattern(e5, t4 ? 4 : 2), this.expect(f3.parenR), e5;
        }, L4.parseTryStatement = function(e5) {
          if (this.next(), e5.block = this.parseBlock(), e5.handler = null, this.type === f3._catch) {
            var t4 = this.startNode();
            this.next(), this.eat(f3.parenL) ? t4.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t4.param = null, this.enterScope(0)), t4.body = this.parseBlock(false), this.exitScope(), e5.handler = this.finishNode(t4, "CatchClause");
          }
          return e5.finalizer = this.eat(f3._finally) ? this.parseBlock() : null, e5.handler || e5.finalizer || this.raise(e5.start, "Missing catch or finally clause"), this.finishNode(e5, "TryStatement");
        }, L4.parseVarStatement = function(e5, t4, i3) {
          return this.next(), this.parseVar(e5, false, t4, i3), this.semicolon(), this.finishNode(e5, "VariableDeclaration");
        }, L4.parseWhileStatement = function(e5) {
          return this.next(), e5.test = this.parseParenExpression(), this.labels.push(O4), e5.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e5, "WhileStatement");
        }, L4.parseWithStatement = function(e5) {
          return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e5.object = this.parseParenExpression(), e5.body = this.parseStatement("with"), this.finishNode(e5, "WithStatement");
        }, L4.parseEmptyStatement = function(e5) {
          return this.next(), this.finishNode(e5, "EmptyStatement");
        }, L4.parseLabeledStatement = function(e5, t4, i3, s5) {
          for (var r7 = 0, n2 = this.labels; r7 < n2.length; r7 += 1) {
            n2[r7].name === t4 && this.raise(i3.start, "Label '" + t4 + "' is already declared");
          }
          for (var a4 = this.type.isLoop ? "loop" : this.type === f3._switch ? "switch" : null, o2 = this.labels.length - 1; o2 >= 0; o2--) {
            var h9 = this.labels[o2];
            if (h9.statementStart !== e5.start) break;
            h9.statementStart = this.start, h9.kind = a4;
          }
          return this.labels.push({ name: t4, kind: a4, statementStart: this.start }), e5.body = this.parseStatement(s5 ? -1 === s5.indexOf("label") ? s5 + "label" : s5 : "label"), this.labels.pop(), e5.label = i3, this.finishNode(e5, "LabeledStatement");
        }, L4.parseExpressionStatement = function(e5, t4) {
          return e5.expression = t4, this.semicolon(), this.finishNode(e5, "ExpressionStatement");
        }, L4.parseBlock = function(e5, t4, i3) {
          for (void 0 === e5 && (e5 = true), void 0 === t4 && (t4 = this.startNode()), t4.body = [], this.expect(f3.braceL), e5 && this.enterScope(0); this.type !== f3.braceR; ) {
            var s5 = this.parseStatement(null);
            t4.body.push(s5);
          }
          return i3 && (this.strict = false), this.next(), e5 && this.exitScope(), this.finishNode(t4, "BlockStatement");
        }, L4.parseFor = function(e5, t4) {
          return e5.init = t4, this.expect(f3.semi), e5.test = this.type === f3.semi ? null : this.parseExpression(), this.expect(f3.semi), e5.update = this.type === f3.parenR ? null : this.parseExpression(), this.expect(f3.parenR), e5.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e5, "ForStatement");
        }, L4.parseForIn = function(e5, t4) {
          var i3 = this.type === f3._in;
          return this.next(), "VariableDeclaration" === t4.type && null != t4.declarations[0].init && (!i3 || this.options.ecmaVersion < 8 || this.strict || "var" !== t4.kind || "Identifier" !== t4.declarations[0].id.type) && this.raise(t4.start, (i3 ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), e5.left = t4, e5.right = i3 ? this.parseExpression() : this.parseMaybeAssign(), this.expect(f3.parenR), e5.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e5, i3 ? "ForInStatement" : "ForOfStatement");
        }, L4.parseVar = function(e5, t4, i3, s5) {
          for (e5.declarations = [], e5.kind = i3; ; ) {
            var r7 = this.startNode();
            if (this.parseVarId(r7, i3), this.eat(f3.eq) ? r7.init = this.parseMaybeAssign(t4) : s5 || "const" !== i3 || this.type === f3._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? s5 || "using" !== i3 && "await using" !== i3 || !(this.options.ecmaVersion >= 17) || this.type === f3._in || this.isContextual("of") ? s5 || "Identifier" === r7.id.type || t4 && (this.type === f3._in || this.isContextual("of")) ? r7.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.raise(this.lastTokEnd, "Missing initializer in " + i3 + " declaration") : this.unexpected(), e5.declarations.push(this.finishNode(r7, "VariableDeclarator")), !this.eat(f3.comma)) break;
          }
          return e5;
        }, L4.parseVarId = function(e5, t4) {
          e5.id = "using" === t4 || "await using" === t4 ? this.parseIdent() : this.parseBindingAtom(), this.checkLValPattern(e5.id, "var" === t4 ? 1 : 2, false);
        };
        var U6 = 1, M4 = 2;
        function isPrivateNameConflicted2(e5, t4) {
          var i3 = t4.key.name, s5 = e5[i3], r7 = "true";
          return "MethodDefinition" !== t4.type || "get" !== t4.kind && "set" !== t4.kind || (r7 = (t4.static ? "s" : "i") + t4.kind), "iget" === s5 && "iset" === r7 || "iset" === s5 && "iget" === r7 || "sget" === s5 && "sset" === r7 || "sset" === s5 && "sget" === r7 ? (e5[i3] = "true", false) : !!s5 || (e5[i3] = r7, false);
        }
        function checkKeyName2(e5, t4) {
          var i3 = e5.computed, s5 = e5.key;
          return !i3 && ("Identifier" === s5.type && s5.name === t4 || "Literal" === s5.type && s5.value === t4);
        }
        L4.parseFunction = function(e5, t4, i3, s5, r7) {
          this.initFunction(e5), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !s5) && (this.type === f3.star && t4 & M4 && this.unexpected(), e5.generator = this.eat(f3.star)), this.options.ecmaVersion >= 8 && (e5.async = !!s5), t4 & U6 && (e5.id = 4 & t4 && this.type !== f3.name ? null : this.parseIdent(), !e5.id || t4 & M4 || this.checkLValSimple(e5.id, this.strict || e5.generator || e5.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
          var n2 = this.yieldPos, a4 = this.awaitPos, o2 = this.awaitIdentPos;
          return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags2(e5.async, e5.generator)), t4 & U6 || (e5.id = this.type === f3.name ? this.parseIdent() : null), this.parseFunctionParams(e5), this.parseFunctionBody(e5, i3, false, r7), this.yieldPos = n2, this.awaitPos = a4, this.awaitIdentPos = o2, this.finishNode(e5, t4 & U6 ? "FunctionDeclaration" : "FunctionExpression");
        }, L4.parseFunctionParams = function(e5) {
          this.expect(f3.parenL), e5.params = this.parseBindingList(f3.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
        }, L4.parseClass = function(e5, t4) {
          this.next();
          var i3 = this.strict;
          this.strict = true, this.parseClassId(e5, t4), this.parseClassSuper(e5);
          var s5 = this.enterClassBody(), r7 = this.startNode(), n2 = false;
          for (r7.body = [], this.expect(f3.braceL); this.type !== f3.braceR; ) {
            var a4 = this.parseClassElement(null !== e5.superClass);
            a4 && (r7.body.push(a4), "MethodDefinition" === a4.type && "constructor" === a4.kind ? (n2 && this.raiseRecoverable(a4.start, "Duplicate constructor in the same class"), n2 = true) : a4.key && "PrivateIdentifier" === a4.key.type && isPrivateNameConflicted2(s5, a4) && this.raiseRecoverable(a4.key.start, "Identifier '#" + a4.key.name + "' has already been declared"));
          }
          return this.strict = i3, this.next(), e5.body = this.finishNode(r7, "ClassBody"), this.exitClassBody(), this.finishNode(e5, t4 ? "ClassDeclaration" : "ClassExpression");
        }, L4.parseClassElement = function(e5) {
          if (this.eat(f3.semi)) return null;
          var t4 = this.options.ecmaVersion, i3 = this.startNode(), s5 = "", r7 = false, n2 = false, a4 = "method", o2 = false;
          if (this.eatContextual("static")) {
            if (t4 >= 13 && this.eat(f3.braceL)) return this.parseClassStaticBlock(i3), i3;
            this.isClassElementNameStart() || this.type === f3.star ? o2 = true : s5 = "static";
          }
          if (i3.static = o2, !s5 && t4 >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== f3.star || this.canInsertSemicolon() ? s5 = "async" : n2 = true), !s5 && (t4 >= 9 || !n2) && this.eat(f3.star) && (r7 = true), !s5 && !n2 && !r7) {
            var h9 = this.value;
            (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? a4 = h9 : s5 = h9);
          }
          if (s5 ? (i3.computed = false, i3.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), i3.key.name = s5, this.finishNode(i3.key, "Identifier")) : this.parseClassElementName(i3), t4 < 13 || this.type === f3.parenL || "method" !== a4 || r7 || n2) {
            var c3 = !i3.static && checkKeyName2(i3, "constructor"), p4 = c3 && e5;
            c3 && "method" !== a4 && this.raise(i3.key.start, "Constructor can't have get/set modifier"), i3.kind = c3 ? "constructor" : a4, this.parseClassMethod(i3, r7, n2, p4);
          } else this.parseClassField(i3);
          return i3;
        }, L4.isClassElementNameStart = function() {
          return this.type === f3.name || this.type === f3.privateId || this.type === f3.num || this.type === f3.string || this.type === f3.bracketL || this.type.keyword;
        }, L4.parseClassElementName = function(e5) {
          this.type === f3.privateId ? ("constructor" === this.value && this.raise(this.start, "Classes can't have an element named '#constructor'"), e5.computed = false, e5.key = this.parsePrivateIdent()) : this.parsePropertyName(e5);
        }, L4.parseClassMethod = function(e5, t4, i3, s5) {
          var r7 = e5.key;
          "constructor" === e5.kind ? (t4 && this.raise(r7.start, "Constructor can't be a generator"), i3 && this.raise(r7.start, "Constructor can't be an async method")) : e5.static && checkKeyName2(e5, "prototype") && this.raise(r7.start, "Classes may not have a static property named prototype");
          var n2 = e5.value = this.parseMethod(t4, i3, s5);
          return "get" === e5.kind && 0 !== n2.params.length && this.raiseRecoverable(n2.start, "getter should have no params"), "set" === e5.kind && 1 !== n2.params.length && this.raiseRecoverable(n2.start, "setter should have exactly one param"), "set" === e5.kind && "RestElement" === n2.params[0].type && this.raiseRecoverable(n2.params[0].start, "Setter cannot use rest params"), this.finishNode(e5, "MethodDefinition");
        }, L4.parseClassField = function(e5) {
          return checkKeyName2(e5, "constructor") ? this.raise(e5.key.start, "Classes can't have a field named 'constructor'") : e5.static && checkKeyName2(e5, "prototype") && this.raise(e5.key.start, "Classes can't have a static field named 'prototype'"), this.eat(f3.eq) ? (this.enterScope(576), e5.value = this.parseMaybeAssign(), this.exitScope()) : e5.value = null, this.semicolon(), this.finishNode(e5, "PropertyDefinition");
        }, L4.parseClassStaticBlock = function(e5) {
          e5.body = [];
          var t4 = this.labels;
          for (this.labels = [], this.enterScope(320); this.type !== f3.braceR; ) {
            var i3 = this.parseStatement(null);
            e5.body.push(i3);
          }
          return this.next(), this.exitScope(), this.labels = t4, this.finishNode(e5, "StaticBlock");
        }, L4.parseClassId = function(e5, t4) {
          this.type === f3.name ? (e5.id = this.parseIdent(), t4 && this.checkLValSimple(e5.id, 2, false)) : (true === t4 && this.unexpected(), e5.id = null);
        }, L4.parseClassSuper = function(e5) {
          e5.superClass = this.eat(f3._extends) ? this.parseExprSubscripts(null, false) : null;
        }, L4.enterClassBody = function() {
          var e5 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
          return this.privateNameStack.push(e5), e5.declared;
        }, L4.exitClassBody = function() {
          var e5 = this.privateNameStack.pop(), t4 = e5.declared, i3 = e5.used;
          if (this.options.checkPrivateFields) for (var s5 = this.privateNameStack.length, r7 = 0 === s5 ? null : this.privateNameStack[s5 - 1], n2 = 0; n2 < i3.length; ++n2) {
            var a4 = i3[n2];
            b6(t4, a4.name) || (r7 ? r7.used.push(a4) : this.raiseRecoverable(a4.start, "Private field '#" + a4.name + "' must be declared in an enclosing class"));
          }
        }, L4.parseExportAllDeclaration = function(e5, t4) {
          return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e5.exported = this.parseModuleExportName(), this.checkExport(t4, e5.exported, this.lastTokStart)) : e5.exported = null), this.expectContextual("from"), this.type !== f3.string && this.unexpected(), e5.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e5.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e5, "ExportAllDeclaration");
        }, L4.parseExport = function(e5, t4) {
          if (this.next(), this.eat(f3.star)) return this.parseExportAllDeclaration(e5, t4);
          if (this.eat(f3._default)) return this.checkExport(t4, "default", this.lastTokStart), e5.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e5, "ExportDefaultDeclaration");
          if (this.shouldParseExportStatement()) e5.declaration = this.parseExportDeclaration(e5), "VariableDeclaration" === e5.declaration.type ? this.checkVariableExport(t4, e5.declaration.declarations) : this.checkExport(t4, e5.declaration.id, e5.declaration.id.start), e5.specifiers = [], e5.source = null, this.options.ecmaVersion >= 16 && (e5.attributes = []);
          else {
            if (e5.declaration = null, e5.specifiers = this.parseExportSpecifiers(t4), this.eatContextual("from")) this.type !== f3.string && this.unexpected(), e5.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e5.attributes = this.parseWithClause());
            else {
              for (var i3 = 0, s5 = e5.specifiers; i3 < s5.length; i3 += 1) {
                var r7 = s5[i3];
                this.checkUnreserved(r7.local), this.checkLocalExport(r7.local), "Literal" === r7.local.type && this.raise(r7.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
              e5.source = null, this.options.ecmaVersion >= 16 && (e5.attributes = []);
            }
            this.semicolon();
          }
          return this.finishNode(e5, "ExportNamedDeclaration");
        }, L4.parseExportDeclaration = function(e5) {
          return this.parseStatement(null);
        }, L4.parseExportDefaultDeclaration = function() {
          var e5;
          if (this.type === f3._function || (e5 = this.isAsyncFunction())) {
            var t4 = this.startNode();
            return this.next(), e5 && this.next(), this.parseFunction(t4, 4 | U6, false, e5);
          }
          if (this.type === f3._class) {
            var i3 = this.startNode();
            return this.parseClass(i3, "nullableID");
          }
          var s5 = this.parseMaybeAssign();
          return this.semicolon(), s5;
        }, L4.checkExport = function(e5, t4, i3) {
          e5 && ("string" != typeof t4 && (t4 = "Identifier" === t4.type ? t4.name : t4.value), b6(e5, t4) && this.raiseRecoverable(i3, "Duplicate export '" + t4 + "'"), e5[t4] = true);
        }, L4.checkPatternExport = function(e5, t4) {
          var i3 = t4.type;
          if ("Identifier" === i3) this.checkExport(e5, t4, t4.start);
          else if ("ObjectPattern" === i3) for (var s5 = 0, r7 = t4.properties; s5 < r7.length; s5 += 1) {
            var n2 = r7[s5];
            this.checkPatternExport(e5, n2);
          }
          else if ("ArrayPattern" === i3) for (var a4 = 0, o2 = t4.elements; a4 < o2.length; a4 += 1) {
            var h9 = o2[a4];
            h9 && this.checkPatternExport(e5, h9);
          }
          else "Property" === i3 ? this.checkPatternExport(e5, t4.value) : "AssignmentPattern" === i3 ? this.checkPatternExport(e5, t4.left) : "RestElement" === i3 && this.checkPatternExport(e5, t4.argument);
        }, L4.checkVariableExport = function(e5, t4) {
          if (e5) for (var i3 = 0, s5 = t4; i3 < s5.length; i3 += 1) {
            var r7 = s5[i3];
            this.checkPatternExport(e5, r7.id);
          }
        }, L4.shouldParseExportStatement = function() {
          return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction();
        }, L4.parseExportSpecifier = function(e5) {
          var t4 = this.startNode();
          return t4.local = this.parseModuleExportName(), t4.exported = this.eatContextual("as") ? this.parseModuleExportName() : t4.local, this.checkExport(e5, t4.exported, t4.exported.start), this.finishNode(t4, "ExportSpecifier");
        }, L4.parseExportSpecifiers = function(e5) {
          var t4 = [], i3 = true;
          for (this.expect(f3.braceL); !this.eat(f3.braceR); ) {
            if (i3) i3 = false;
            else if (this.expect(f3.comma), this.afterTrailingComma(f3.braceR)) break;
            t4.push(this.parseExportSpecifier(e5));
          }
          return t4;
        }, L4.parseImport = function(e5) {
          return this.next(), this.type === f3.string ? (e5.specifiers = V4, e5.source = this.parseExprAtom()) : (e5.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e5.source = this.type === f3.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (e5.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e5, "ImportDeclaration");
        }, L4.parseImportSpecifier = function() {
          var e5 = this.startNode();
          return e5.imported = this.parseModuleExportName(), this.eatContextual("as") ? e5.local = this.parseIdent() : (this.checkUnreserved(e5.imported), e5.local = e5.imported), this.checkLValSimple(e5.local, 2), this.finishNode(e5, "ImportSpecifier");
        }, L4.parseImportDefaultSpecifier = function() {
          var e5 = this.startNode();
          return e5.local = this.parseIdent(), this.checkLValSimple(e5.local, 2), this.finishNode(e5, "ImportDefaultSpecifier");
        }, L4.parseImportNamespaceSpecifier = function() {
          var e5 = this.startNode();
          return this.next(), this.expectContextual("as"), e5.local = this.parseIdent(), this.checkLValSimple(e5.local, 2), this.finishNode(e5, "ImportNamespaceSpecifier");
        }, L4.parseImportSpecifiers = function() {
          var e5 = [], t4 = true;
          if (this.type === f3.name && (e5.push(this.parseImportDefaultSpecifier()), !this.eat(f3.comma))) return e5;
          if (this.type === f3.star) return e5.push(this.parseImportNamespaceSpecifier()), e5;
          for (this.expect(f3.braceL); !this.eat(f3.braceR); ) {
            if (t4) t4 = false;
            else if (this.expect(f3.comma), this.afterTrailingComma(f3.braceR)) break;
            e5.push(this.parseImportSpecifier());
          }
          return e5;
        }, L4.parseWithClause = function() {
          var e5 = [];
          if (!this.eat(f3._with)) return e5;
          this.expect(f3.braceL);
          for (var t4 = {}, i3 = true; !this.eat(f3.braceR); ) {
            if (i3) i3 = false;
            else if (this.expect(f3.comma), this.afterTrailingComma(f3.braceR)) break;
            var s5 = this.parseImportAttribute(), r7 = "Identifier" === s5.key.type ? s5.key.name : s5.key.value;
            b6(t4, r7) && this.raiseRecoverable(s5.key.start, "Duplicate attribute key '" + r7 + "'"), t4[r7] = true, e5.push(s5);
          }
          return e5;
        }, L4.parseImportAttribute = function() {
          var e5 = this.startNode();
          return e5.key = this.type === f3.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved), this.expect(f3.colon), this.type !== f3.string && this.unexpected(), e5.value = this.parseExprAtom(), this.finishNode(e5, "ImportAttribute");
        }, L4.parseModuleExportName = function() {
          if (this.options.ecmaVersion >= 13 && this.type === f3.string) {
            var e5 = this.parseLiteral(this.value);
            return w5.test(e5.value) && this.raise(e5.start, "An export name cannot include a lone surrogate."), e5;
          }
          return this.parseIdent(true);
        }, L4.adaptDirectivePrologue = function(e5) {
          for (var t4 = 0; t4 < e5.length && this.isDirectiveCandidate(e5[t4]); ++t4) e5[t4].directive = e5[t4].expression.raw.slice(1, -1);
        }, L4.isDirectiveCandidate = function(e5) {
          return this.options.ecmaVersion >= 5 && "ExpressionStatement" === e5.type && "Literal" === e5.expression.type && "string" == typeof e5.expression.value && ('"' === this.input[e5.start] || "'" === this.input[e5.start]);
        };
        var j3 = acorn_Parser.prototype;
        j3.toAssignable = function(e5, t4, i3) {
          if (this.options.ecmaVersion >= 6 && e5) switch (e5.type) {
            case "Identifier":
              this.inAsync && "await" === e5.name && this.raise(e5.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              e5.type = "ObjectPattern", i3 && this.checkPatternErrors(i3, true);
              for (var s5 = 0, r7 = e5.properties; s5 < r7.length; s5 += 1) {
                var n2 = r7[s5];
                this.toAssignable(n2, t4), "RestElement" !== n2.type || "ArrayPattern" !== n2.argument.type && "ObjectPattern" !== n2.argument.type || this.raise(n2.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              "init" !== e5.kind && this.raise(e5.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e5.value, t4);
              break;
            case "ArrayExpression":
              e5.type = "ArrayPattern", i3 && this.checkPatternErrors(i3, true), this.toAssignableList(e5.elements, t4);
              break;
            case "SpreadElement":
              e5.type = "RestElement", this.toAssignable(e5.argument, t4), "AssignmentPattern" === e5.argument.type && this.raise(e5.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              "=" !== e5.operator && this.raise(e5.left.end, "Only '=' operator can be used for specifying default value."), e5.type = "AssignmentPattern", delete e5.operator, this.toAssignable(e5.left, t4);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(e5.expression, t4, i3);
              break;
            case "ChainExpression":
              this.raiseRecoverable(e5.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!t4) break;
            default:
              this.raise(e5.start, "Assigning to rvalue");
          }
          else i3 && this.checkPatternErrors(i3, true);
          return e5;
        }, j3.toAssignableList = function(e5, t4) {
          for (var i3 = e5.length, s5 = 0; s5 < i3; s5++) {
            var r7 = e5[s5];
            r7 && this.toAssignable(r7, t4);
          }
          if (i3) {
            var n2 = e5[i3 - 1];
            6 === this.options.ecmaVersion && t4 && n2 && "RestElement" === n2.type && "Identifier" !== n2.argument.type && this.unexpected(n2.argument.start);
          }
          return e5;
        }, j3.parseSpread = function(e5) {
          var t4 = this.startNode();
          return this.next(), t4.argument = this.parseMaybeAssign(false, e5), this.finishNode(t4, "SpreadElement");
        }, j3.parseRestBinding = function() {
          var e5 = this.startNode();
          return this.next(), 6 === this.options.ecmaVersion && this.type !== f3.name && this.unexpected(), e5.argument = this.parseBindingAtom(), this.finishNode(e5, "RestElement");
        }, j3.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6) switch (this.type) {
            case f3.bracketL:
              var e5 = this.startNode();
              return this.next(), e5.elements = this.parseBindingList(f3.bracketR, true, true), this.finishNode(e5, "ArrayPattern");
            case f3.braceL:
              return this.parseObj(true);
          }
          return this.parseIdent();
        }, j3.parseBindingList = function(e5, t4, i3, s5) {
          for (var r7 = [], n2 = true; !this.eat(e5); ) if (n2 ? n2 = false : this.expect(f3.comma), t4 && this.type === f3.comma) r7.push(null);
          else {
            if (i3 && this.afterTrailingComma(e5)) break;
            if (this.type === f3.ellipsis) {
              var a4 = this.parseRestBinding();
              this.parseBindingListItem(a4), r7.push(a4), this.type === f3.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(e5);
              break;
            }
            r7.push(this.parseAssignableListItem(s5));
          }
          return r7;
        }, j3.parseAssignableListItem = function(e5) {
          var t4 = this.parseMaybeDefault(this.start, this.startLoc);
          return this.parseBindingListItem(t4), t4;
        }, j3.parseBindingListItem = function(e5) {
          return e5;
        }, j3.parseMaybeDefault = function(e5, t4, i3) {
          if (i3 = i3 || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(f3.eq)) return i3;
          var s5 = this.startNodeAt(e5, t4);
          return s5.left = i3, s5.right = this.parseMaybeAssign(), this.finishNode(s5, "AssignmentPattern");
        }, j3.checkLValSimple = function(e5, t4, i3) {
          void 0 === t4 && (t4 = 0);
          var s5 = 0 !== t4;
          switch (e5.type) {
            case "Identifier":
              this.strict && this.reservedWordsStrictBind.test(e5.name) && this.raiseRecoverable(e5.start, (s5 ? "Binding " : "Assigning to ") + e5.name + " in strict mode"), s5 && (2 === t4 && "let" === e5.name && this.raiseRecoverable(e5.start, "let is disallowed as a lexically bound name"), i3 && (b6(i3, e5.name) && this.raiseRecoverable(e5.start, "Argument name clash"), i3[e5.name] = true), 5 !== t4 && this.declareName(e5.name, t4, e5.start));
              break;
            case "ChainExpression":
              this.raiseRecoverable(e5.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              s5 && this.raiseRecoverable(e5.start, "Binding member expression");
              break;
            case "ParenthesizedExpression":
              return s5 && this.raiseRecoverable(e5.start, "Binding parenthesized expression"), this.checkLValSimple(e5.expression, t4, i3);
            default:
              this.raise(e5.start, (s5 ? "Binding" : "Assigning to") + " rvalue");
          }
        }, j3.checkLValPattern = function(e5, t4, i3) {
          switch (void 0 === t4 && (t4 = 0), e5.type) {
            case "ObjectPattern":
              for (var s5 = 0, r7 = e5.properties; s5 < r7.length; s5 += 1) {
                var n2 = r7[s5];
                this.checkLValInnerPattern(n2, t4, i3);
              }
              break;
            case "ArrayPattern":
              for (var a4 = 0, o2 = e5.elements; a4 < o2.length; a4 += 1) {
                var h9 = o2[a4];
                h9 && this.checkLValInnerPattern(h9, t4, i3);
              }
              break;
            default:
              this.checkLValSimple(e5, t4, i3);
          }
        }, j3.checkLValInnerPattern = function(e5, t4, i3) {
          switch (void 0 === t4 && (t4 = 0), e5.type) {
            case "Property":
              this.checkLValInnerPattern(e5.value, t4, i3);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(e5.left, t4, i3);
              break;
            case "RestElement":
              this.checkLValPattern(e5.argument, t4, i3);
              break;
            default:
              this.checkLValPattern(e5, t4, i3);
          }
        };
        var acorn_TokContext = function(e5, t4, i3, s5, r7) {
          this.token = e5, this.isExpr = !!t4, this.preserveSpace = !!i3, this.override = s5, this.generator = !!r7;
        }, F2 = { b_stat: new acorn_TokContext("{", false), b_expr: new acorn_TokContext("{", true), b_tmpl: new acorn_TokContext("${", false), p_stat: new acorn_TokContext("(", false), p_expr: new acorn_TokContext("(", true), q_tmpl: new acorn_TokContext("`", true, true, function(e5) {
          return e5.tryReadTemplateToken();
        }), f_stat: new acorn_TokContext("function", false), f_expr: new acorn_TokContext("function", true), f_expr_gen: new acorn_TokContext("function", true, false, null, true), f_gen: new acorn_TokContext("function", false, false, null, true) }, B3 = acorn_Parser.prototype;
        B3.initialContext = function() {
          return [F2.b_stat];
        }, B3.curContext = function() {
          return this.context[this.context.length - 1];
        }, B3.braceIsBlock = function(e5) {
          var t4 = this.curContext();
          return t4 === F2.f_expr || t4 === F2.f_stat || (e5 !== f3.colon || t4 !== F2.b_stat && t4 !== F2.b_expr ? e5 === f3._return || e5 === f3.name && this.exprAllowed ? m4.test(this.input.slice(this.lastTokEnd, this.start)) : e5 === f3._else || e5 === f3.semi || e5 === f3.eof || e5 === f3.parenR || e5 === f3.arrow || (e5 === f3.braceL ? t4 === F2.b_stat : e5 !== f3._var && e5 !== f3._const && e5 !== f3.name && !this.exprAllowed) : !t4.isExpr);
        }, B3.inGeneratorContext = function() {
          for (var e5 = this.context.length - 1; e5 >= 1; e5--) {
            var t4 = this.context[e5];
            if ("function" === t4.token) return t4.generator;
          }
          return false;
        }, B3.updateContext = function(e5) {
          var t4, i3 = this.type;
          i3.keyword && e5 === f3.dot ? this.exprAllowed = false : (t4 = i3.updateContext) ? t4.call(this, e5) : this.exprAllowed = i3.beforeExpr;
        }, B3.overrideContext = function(e5) {
          this.curContext() !== e5 && (this.context[this.context.length - 1] = e5);
        }, f3.parenR.updateContext = f3.braceR.updateContext = function() {
          if (1 !== this.context.length) {
            var e5 = this.context.pop();
            e5 === F2.b_stat && "function" === this.curContext().token && (e5 = this.context.pop()), this.exprAllowed = !e5.isExpr;
          } else this.exprAllowed = true;
        }, f3.braceL.updateContext = function(e5) {
          this.context.push(this.braceIsBlock(e5) ? F2.b_stat : F2.b_expr), this.exprAllowed = true;
        }, f3.dollarBraceL.updateContext = function() {
          this.context.push(F2.b_tmpl), this.exprAllowed = true;
        }, f3.parenL.updateContext = function(e5) {
          var t4 = e5 === f3._if || e5 === f3._for || e5 === f3._with || e5 === f3._while;
          this.context.push(t4 ? F2.p_stat : F2.p_expr), this.exprAllowed = true;
        }, f3.incDec.updateContext = function() {
        }, f3._function.updateContext = f3._class.updateContext = function(e5) {
          !e5.beforeExpr || e5 === f3._else || e5 === f3.semi && this.curContext() !== F2.p_stat || e5 === f3._return && m4.test(this.input.slice(this.lastTokEnd, this.start)) || (e5 === f3.colon || e5 === f3.braceL) && this.curContext() === F2.b_stat ? this.context.push(F2.f_stat) : this.context.push(F2.f_expr), this.exprAllowed = false;
        }, f3.colon.updateContext = function() {
          "function" === this.curContext().token && this.context.pop(), this.exprAllowed = true;
        }, f3.backQuote.updateContext = function() {
          this.curContext() === F2.q_tmpl ? this.context.pop() : this.context.push(F2.q_tmpl), this.exprAllowed = false;
        }, f3.star.updateContext = function(e5) {
          if (e5 === f3._function) {
            var t4 = this.context.length - 1;
            this.context[t4] === F2.f_expr ? this.context[t4] = F2.f_expr_gen : this.context[t4] = F2.f_gen;
          }
          this.exprAllowed = true;
        }, f3.name.updateContext = function(e5) {
          var t4 = false;
          this.options.ecmaVersion >= 6 && e5 !== f3.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (t4 = true), this.exprAllowed = t4;
        };
        var $6 = acorn_Parser.prototype;
        function isLocalVariableAccess2(e5) {
          return "Identifier" === e5.type || "ParenthesizedExpression" === e5.type && isLocalVariableAccess2(e5.expression);
        }
        function isPrivateFieldAccess2(e5) {
          return "MemberExpression" === e5.type && "PrivateIdentifier" === e5.property.type || "ChainExpression" === e5.type && isPrivateFieldAccess2(e5.expression) || "ParenthesizedExpression" === e5.type && isPrivateFieldAccess2(e5.expression);
        }
        $6.checkPropClash = function(e5, t4, i3) {
          if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === e5.type || this.options.ecmaVersion >= 6 && (e5.computed || e5.method || e5.shorthand))) {
            var s5, r7 = e5.key;
            switch (r7.type) {
              case "Identifier":
                s5 = r7.name;
                break;
              case "Literal":
                s5 = String(r7.value);
                break;
              default:
                return;
            }
            var n2 = e5.kind;
            if (this.options.ecmaVersion >= 6) "__proto__" === s5 && "init" === n2 && (t4.proto && (i3 ? i3.doubleProto < 0 && (i3.doubleProto = r7.start) : this.raiseRecoverable(r7.start, "Redefinition of __proto__ property")), t4.proto = true);
            else {
              var a4 = t4[s5 = "$" + s5];
              if (a4) ("init" === n2 ? this.strict && a4.init || a4.get || a4.set : a4.init || a4[n2]) && this.raiseRecoverable(r7.start, "Redefinition of property");
              else a4 = t4[s5] = { init: false, get: false, set: false };
              a4[n2] = true;
            }
          }
        }, $6.parseExpression = function(e5, t4) {
          var i3 = this.start, s5 = this.startLoc, r7 = this.parseMaybeAssign(e5, t4);
          if (this.type === f3.comma) {
            var n2 = this.startNodeAt(i3, s5);
            for (n2.expressions = [r7]; this.eat(f3.comma); ) n2.expressions.push(this.parseMaybeAssign(e5, t4));
            return this.finishNode(n2, "SequenceExpression");
          }
          return r7;
        }, $6.parseMaybeAssign = function(e5, t4, i3) {
          if (this.isContextual("yield")) {
            if (this.inGenerator) return this.parseYield(e5);
            this.exprAllowed = false;
          }
          var s5 = false, r7 = -1, n2 = -1, a4 = -1;
          t4 ? (r7 = t4.parenthesizedAssign, n2 = t4.trailingComma, a4 = t4.doubleProto, t4.parenthesizedAssign = t4.trailingComma = -1) : (t4 = new acorn_DestructuringErrors(), s5 = true);
          var o2 = this.start, h9 = this.startLoc;
          this.type !== f3.parenL && this.type !== f3.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = "await" === e5);
          var c3 = this.parseMaybeConditional(e5, t4);
          if (i3 && (c3 = i3.call(this, c3, o2, h9)), this.type.isAssign) {
            var p4 = this.startNodeAt(o2, h9);
            return p4.operator = this.value, this.type === f3.eq && (c3 = this.toAssignable(c3, false, t4)), s5 || (t4.parenthesizedAssign = t4.trailingComma = t4.doubleProto = -1), t4.shorthandAssign >= c3.start && (t4.shorthandAssign = -1), this.type === f3.eq ? this.checkLValPattern(c3) : this.checkLValSimple(c3), p4.left = c3, this.next(), p4.right = this.parseMaybeAssign(e5), a4 > -1 && (t4.doubleProto = a4), this.finishNode(p4, "AssignmentExpression");
          }
          return s5 && this.checkExpressionErrors(t4, true), r7 > -1 && (t4.parenthesizedAssign = r7), n2 > -1 && (t4.trailingComma = n2), c3;
        }, $6.parseMaybeConditional = function(e5, t4) {
          var i3 = this.start, s5 = this.startLoc, r7 = this.parseExprOps(e5, t4);
          if (this.checkExpressionErrors(t4)) return r7;
          if (this.eat(f3.question)) {
            var n2 = this.startNodeAt(i3, s5);
            return n2.test = r7, n2.consequent = this.parseMaybeAssign(), this.expect(f3.colon), n2.alternate = this.parseMaybeAssign(e5), this.finishNode(n2, "ConditionalExpression");
          }
          return r7;
        }, $6.parseExprOps = function(e5, t4) {
          var i3 = this.start, s5 = this.startLoc, r7 = this.parseMaybeUnary(t4, false, false, e5);
          return this.checkExpressionErrors(t4) || r7.start === i3 && "ArrowFunctionExpression" === r7.type ? r7 : this.parseExprOp(r7, i3, s5, -1, e5);
        }, $6.parseExprOp = function(e5, t4, i3, s5, r7) {
          var n2 = this.type.binop;
          if (null != n2 && (!r7 || this.type !== f3._in) && n2 > s5) {
            var a4 = this.type === f3.logicalOR || this.type === f3.logicalAND, o2 = this.type === f3.coalesce;
            o2 && (n2 = f3.logicalAND.binop);
            var h9 = this.value;
            this.next();
            var c3 = this.start, p4 = this.startLoc, l4 = this.parseExprOp(this.parseMaybeUnary(null, false, false, r7), c3, p4, n2, r7), u5 = this.buildBinary(t4, i3, e5, l4, h9, a4 || o2);
            return (a4 && this.type === f3.coalesce || o2 && (this.type === f3.logicalOR || this.type === f3.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(u5, t4, i3, s5, r7);
          }
          return e5;
        }, $6.buildBinary = function(e5, t4, i3, s5, r7, n2) {
          "PrivateIdentifier" === s5.type && this.raise(s5.start, "Private identifier can only be left side of binary expression");
          var a4 = this.startNodeAt(e5, t4);
          return a4.left = i3, a4.operator = r7, a4.right = s5, this.finishNode(a4, n2 ? "LogicalExpression" : "BinaryExpression");
        }, $6.parseMaybeUnary = function(e5, t4, i3, s5) {
          var r7, n2 = this.start, a4 = this.startLoc;
          if (this.isContextual("await") && this.canAwait) r7 = this.parseAwait(s5), t4 = true;
          else if (this.type.prefix) {
            var o2 = this.startNode(), h9 = this.type === f3.incDec;
            o2.operator = this.value, o2.prefix = true, this.next(), o2.argument = this.parseMaybeUnary(null, true, h9, s5), this.checkExpressionErrors(e5, true), h9 ? this.checkLValSimple(o2.argument) : this.strict && "delete" === o2.operator && isLocalVariableAccess2(o2.argument) ? this.raiseRecoverable(o2.start, "Deleting local variable in strict mode") : "delete" === o2.operator && isPrivateFieldAccess2(o2.argument) ? this.raiseRecoverable(o2.start, "Private fields can not be deleted") : t4 = true, r7 = this.finishNode(o2, h9 ? "UpdateExpression" : "UnaryExpression");
          } else if (t4 || this.type !== f3.privateId) {
            if (r7 = this.parseExprSubscripts(e5, s5), this.checkExpressionErrors(e5)) return r7;
            for (; this.type.postfix && !this.canInsertSemicolon(); ) {
              var c3 = this.startNodeAt(n2, a4);
              c3.operator = this.value, c3.prefix = false, c3.argument = r7, this.checkLValSimple(r7), this.next(), r7 = this.finishNode(c3, "UpdateExpression");
            }
          } else (s5 || 0 === this.privateNameStack.length) && this.options.checkPrivateFields && this.unexpected(), r7 = this.parsePrivateIdent(), this.type !== f3._in && this.unexpected();
          return i3 || !this.eat(f3.starstar) ? r7 : t4 ? void this.unexpected(this.lastTokStart) : this.buildBinary(n2, a4, r7, this.parseMaybeUnary(null, false, false, s5), "**", false);
        }, $6.parseExprSubscripts = function(e5, t4) {
          var i3 = this.start, s5 = this.startLoc, r7 = this.parseExprAtom(e5, t4);
          if ("ArrowFunctionExpression" === r7.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return r7;
          var n2 = this.parseSubscripts(r7, i3, s5, false, t4);
          return e5 && "MemberExpression" === n2.type && (e5.parenthesizedAssign >= n2.start && (e5.parenthesizedAssign = -1), e5.parenthesizedBind >= n2.start && (e5.parenthesizedBind = -1), e5.trailingComma >= n2.start && (e5.trailingComma = -1)), n2;
        }, $6.parseSubscripts = function(e5, t4, i3, s5, r7) {
          for (var n2 = this.options.ecmaVersion >= 8 && "Identifier" === e5.type && "async" === e5.name && this.lastTokEnd === e5.end && !this.canInsertSemicolon() && e5.end - e5.start === 5 && this.potentialArrowAt === e5.start, a4 = false; ; ) {
            var o2 = this.parseSubscript(e5, t4, i3, s5, n2, a4, r7);
            if (o2.optional && (a4 = true), o2 === e5 || "ArrowFunctionExpression" === o2.type) {
              if (a4) {
                var h9 = this.startNodeAt(t4, i3);
                h9.expression = o2, o2 = this.finishNode(h9, "ChainExpression");
              }
              return o2;
            }
            e5 = o2;
          }
        }, $6.shouldParseAsyncArrow = function() {
          return !this.canInsertSemicolon() && this.eat(f3.arrow);
        }, $6.parseSubscriptAsyncArrow = function(e5, t4, i3, s5) {
          return this.parseArrowExpression(this.startNodeAt(e5, t4), i3, true, s5);
        }, $6.parseSubscript = function(e5, t4, i3, s5, r7, n2, a4) {
          var o2 = this.options.ecmaVersion >= 11, h9 = o2 && this.eat(f3.questionDot);
          s5 && h9 && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          var c3 = this.eat(f3.bracketL);
          if (c3 || h9 && this.type !== f3.parenL && this.type !== f3.backQuote || this.eat(f3.dot)) {
            var p4 = this.startNodeAt(t4, i3);
            p4.object = e5, c3 ? (p4.property = this.parseExpression(), this.expect(f3.bracketR)) : this.type === f3.privateId && "Super" !== e5.type ? p4.property = this.parsePrivateIdent() : p4.property = this.parseIdent("never" !== this.options.allowReserved), p4.computed = !!c3, o2 && (p4.optional = h9), e5 = this.finishNode(p4, "MemberExpression");
          } else if (!s5 && this.eat(f3.parenL)) {
            var l4 = new acorn_DestructuringErrors(), u5 = this.yieldPos, d5 = this.awaitPos, m5 = this.awaitIdentPos;
            this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
            var g5 = this.parseExprList(f3.parenR, this.options.ecmaVersion >= 8, false, l4);
            if (r7 && !h9 && this.shouldParseAsyncArrow()) return this.checkPatternErrors(l4, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = u5, this.awaitPos = d5, this.awaitIdentPos = m5, this.parseSubscriptAsyncArrow(t4, i3, g5, a4);
            this.checkExpressionErrors(l4, true), this.yieldPos = u5 || this.yieldPos, this.awaitPos = d5 || this.awaitPos, this.awaitIdentPos = m5 || this.awaitIdentPos;
            var x6 = this.startNodeAt(t4, i3);
            x6.callee = e5, x6.arguments = g5, o2 && (x6.optional = h9), e5 = this.finishNode(x6, "CallExpression");
          } else if (this.type === f3.backQuote) {
            (h9 || n2) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            var v5 = this.startNodeAt(t4, i3);
            v5.tag = e5, v5.quasi = this.parseTemplate({ isTagged: true }), e5 = this.finishNode(v5, "TaggedTemplateExpression");
          }
          return e5;
        }, $6.parseExprAtom = function(e5, t4, i3) {
          this.type === f3.slash && this.readRegexp();
          var s5, r7 = this.potentialArrowAt === this.start;
          switch (this.type) {
            case f3._super:
              return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), s5 = this.startNode(), this.next(), this.type !== f3.parenL || this.allowDirectSuper || this.raise(s5.start, "super() call outside constructor of a subclass"), this.type !== f3.dot && this.type !== f3.bracketL && this.type !== f3.parenL && this.unexpected(), this.finishNode(s5, "Super");
            case f3._this:
              return s5 = this.startNode(), this.next(), this.finishNode(s5, "ThisExpression");
            case f3.name:
              var n2 = this.start, a4 = this.startLoc, o2 = this.containsEsc, h9 = this.parseIdent(false);
              if (this.options.ecmaVersion >= 8 && !o2 && "async" === h9.name && !this.canInsertSemicolon() && this.eat(f3._function)) return this.overrideContext(F2.f_expr), this.parseFunction(this.startNodeAt(n2, a4), 0, false, true, t4);
              if (r7 && !this.canInsertSemicolon()) {
                if (this.eat(f3.arrow)) return this.parseArrowExpression(this.startNodeAt(n2, a4), [h9], false, t4);
                if (this.options.ecmaVersion >= 8 && "async" === h9.name && this.type === f3.name && !o2 && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc)) return h9 = this.parseIdent(false), !this.canInsertSemicolon() && this.eat(f3.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(n2, a4), [h9], true, t4);
              }
              return h9;
            case f3.regexp:
              var c3 = this.value;
              return (s5 = this.parseLiteral(c3.value)).regex = { pattern: c3.pattern, flags: c3.flags }, s5;
            case f3.num:
            case f3.string:
              return this.parseLiteral(this.value);
            case f3._null:
            case f3._true:
            case f3._false:
              return (s5 = this.startNode()).value = this.type === f3._null ? null : this.type === f3._true, s5.raw = this.type.keyword, this.next(), this.finishNode(s5, "Literal");
            case f3.parenL:
              var p4 = this.start, l4 = this.parseParenAndDistinguishExpression(r7, t4);
              return e5 && (e5.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(l4) && (e5.parenthesizedAssign = p4), e5.parenthesizedBind < 0 && (e5.parenthesizedBind = p4)), l4;
            case f3.bracketL:
              return s5 = this.startNode(), this.next(), s5.elements = this.parseExprList(f3.bracketR, true, true, e5), this.finishNode(s5, "ArrayExpression");
            case f3.braceL:
              return this.overrideContext(F2.b_expr), this.parseObj(false, e5);
            case f3._function:
              return s5 = this.startNode(), this.next(), this.parseFunction(s5, 0);
            case f3._class:
              return this.parseClass(this.startNode(), false);
            case f3._new:
              return this.parseNew();
            case f3.backQuote:
              return this.parseTemplate();
            case f3._import:
              return this.options.ecmaVersion >= 11 ? this.parseExprImport(i3) : this.unexpected();
            default:
              return this.parseExprAtomDefault();
          }
        }, $6.parseExprAtomDefault = function() {
          this.unexpected();
        }, $6.parseExprImport = function(e5) {
          var t4 = this.startNode();
          if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === f3.parenL && !e5) return this.parseDynamicImport(t4);
          if (this.type === f3.dot) {
            var i3 = this.startNodeAt(t4.start, t4.loc && t4.loc.start);
            return i3.name = "import", t4.meta = this.finishNode(i3, "Identifier"), this.parseImportMeta(t4);
          }
          this.unexpected();
        }, $6.parseDynamicImport = function(e5) {
          if (this.next(), e5.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16) this.eat(f3.parenR) ? e5.options = null : (this.expect(f3.comma), this.afterTrailingComma(f3.parenR) ? e5.options = null : (e5.options = this.parseMaybeAssign(), this.eat(f3.parenR) || (this.expect(f3.comma), this.afterTrailingComma(f3.parenR) || this.unexpected())));
          else if (!this.eat(f3.parenR)) {
            var t4 = this.start;
            this.eat(f3.comma) && this.eat(f3.parenR) ? this.raiseRecoverable(t4, "Trailing comma is not allowed in import()") : this.unexpected(t4);
          }
          return this.finishNode(e5, "ImportExpression");
        }, $6.parseImportMeta = function(e5) {
          this.next();
          var t4 = this.containsEsc;
          return e5.property = this.parseIdent(true), "meta" !== e5.property.name && this.raiseRecoverable(e5.property.start, "The only valid meta property for import is 'import.meta'"), t4 && this.raiseRecoverable(e5.start, "'import.meta' must not contain escaped characters"), "module" === this.options.sourceType || this.options.allowImportExportEverywhere || this.raiseRecoverable(e5.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e5, "MetaProperty");
        }, $6.parseLiteral = function(e5) {
          var t4 = this.startNode();
          return t4.value = e5, t4.raw = this.input.slice(this.start, this.end), 110 === t4.raw.charCodeAt(t4.raw.length - 1) && (t4.bigint = null != t4.value ? t4.value.toString() : t4.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t4, "Literal");
        }, $6.parseParenExpression = function() {
          this.expect(f3.parenL);
          var e5 = this.parseExpression();
          return this.expect(f3.parenR), e5;
        }, $6.shouldParseArrow = function(e5) {
          return !this.canInsertSemicolon();
        }, $6.parseParenAndDistinguishExpression = function(e5, t4) {
          var i3, s5 = this.start, r7 = this.startLoc, n2 = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var a4, o2 = this.start, h9 = this.startLoc, c3 = [], p4 = true, l4 = false, u5 = new acorn_DestructuringErrors(), d5 = this.yieldPos, m5 = this.awaitPos;
            for (this.yieldPos = 0, this.awaitPos = 0; this.type !== f3.parenR; ) {
              if (p4 ? p4 = false : this.expect(f3.comma), n2 && this.afterTrailingComma(f3.parenR, true)) {
                l4 = true;
                break;
              }
              if (this.type === f3.ellipsis) {
                a4 = this.start, c3.push(this.parseParenItem(this.parseRestBinding())), this.type === f3.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                break;
              }
              c3.push(this.parseMaybeAssign(false, u5, this.parseParenItem));
            }
            var g5 = this.lastTokEnd, x6 = this.lastTokEndLoc;
            if (this.expect(f3.parenR), e5 && this.shouldParseArrow(c3) && this.eat(f3.arrow)) return this.checkPatternErrors(u5, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = d5, this.awaitPos = m5, this.parseParenArrowList(s5, r7, c3, t4);
            c3.length && !l4 || this.unexpected(this.lastTokStart), a4 && this.unexpected(a4), this.checkExpressionErrors(u5, true), this.yieldPos = d5 || this.yieldPos, this.awaitPos = m5 || this.awaitPos, c3.length > 1 ? ((i3 = this.startNodeAt(o2, h9)).expressions = c3, this.finishNodeAt(i3, "SequenceExpression", g5, x6)) : i3 = c3[0];
          } else i3 = this.parseParenExpression();
          if (this.options.preserveParens) {
            var v5 = this.startNodeAt(s5, r7);
            return v5.expression = i3, this.finishNode(v5, "ParenthesizedExpression");
          }
          return i3;
        }, $6.parseParenItem = function(e5) {
          return e5;
        }, $6.parseParenArrowList = function(e5, t4, i3, s5) {
          return this.parseArrowExpression(this.startNodeAt(e5, t4), i3, false, s5);
        };
        var q6 = [];
        $6.parseNew = function() {
          this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          var e5 = this.startNode();
          if (this.next(), this.options.ecmaVersion >= 6 && this.type === f3.dot) {
            var t4 = this.startNodeAt(e5.start, e5.loc && e5.loc.start);
            t4.name = "new", e5.meta = this.finishNode(t4, "Identifier"), this.next();
            var i3 = this.containsEsc;
            return e5.property = this.parseIdent(true), "target" !== e5.property.name && this.raiseRecoverable(e5.property.start, "The only valid meta property for new is 'new.target'"), i3 && this.raiseRecoverable(e5.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e5.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e5, "MetaProperty");
          }
          var s5 = this.start, r7 = this.startLoc;
          return e5.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), s5, r7, true, false), this.eat(f3.parenL) ? e5.arguments = this.parseExprList(f3.parenR, this.options.ecmaVersion >= 8, false) : e5.arguments = q6, this.finishNode(e5, "NewExpression");
        }, $6.parseTemplateElement = function(e5) {
          var t4 = e5.isTagged, i3 = this.startNode();
          return this.type === f3.invalidTemplate ? (t4 || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), i3.value = { raw: this.value.replace(/\r\n?/g, "\n"), cooked: null }) : i3.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"), cooked: this.value }, this.next(), i3.tail = this.type === f3.backQuote, this.finishNode(i3, "TemplateElement");
        }, $6.parseTemplate = function(e5) {
          void 0 === e5 && (e5 = {});
          var t4 = e5.isTagged;
          void 0 === t4 && (t4 = false);
          var i3 = this.startNode();
          this.next(), i3.expressions = [];
          var s5 = this.parseTemplateElement({ isTagged: t4 });
          for (i3.quasis = [s5]; !s5.tail; ) this.type === f3.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(f3.dollarBraceL), i3.expressions.push(this.parseExpression()), this.expect(f3.braceR), i3.quasis.push(s5 = this.parseTemplateElement({ isTagged: t4 }));
          return this.next(), this.finishNode(i3, "TemplateLiteral");
        }, $6.isAsyncProp = function(e5) {
          return !e5.computed && "Identifier" === e5.key.type && "async" === e5.key.name && (this.type === f3.name || this.type === f3.num || this.type === f3.string || this.type === f3.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === f3.star) && !m4.test(this.input.slice(this.lastTokEnd, this.start));
        }, $6.parseObj = function(e5, t4) {
          var i3 = this.startNode(), s5 = true, r7 = {};
          for (i3.properties = [], this.next(); !this.eat(f3.braceR); ) {
            if (s5) s5 = false;
            else if (this.expect(f3.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(f3.braceR)) break;
            var n2 = this.parseProperty(e5, t4);
            e5 || this.checkPropClash(n2, r7, t4), i3.properties.push(n2);
          }
          return this.finishNode(i3, e5 ? "ObjectPattern" : "ObjectExpression");
        }, $6.parseProperty = function(e5, t4) {
          var i3, s5, r7, n2, a4 = this.startNode();
          if (this.options.ecmaVersion >= 9 && this.eat(f3.ellipsis)) return e5 ? (a4.argument = this.parseIdent(false), this.type === f3.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(a4, "RestElement")) : (a4.argument = this.parseMaybeAssign(false, t4), this.type === f3.comma && t4 && t4.trailingComma < 0 && (t4.trailingComma = this.start), this.finishNode(a4, "SpreadElement"));
          this.options.ecmaVersion >= 6 && (a4.method = false, a4.shorthand = false, (e5 || t4) && (r7 = this.start, n2 = this.startLoc), e5 || (i3 = this.eat(f3.star)));
          var o2 = this.containsEsc;
          return this.parsePropertyName(a4), !e5 && !o2 && this.options.ecmaVersion >= 8 && !i3 && this.isAsyncProp(a4) ? (s5 = true, i3 = this.options.ecmaVersion >= 9 && this.eat(f3.star), this.parsePropertyName(a4)) : s5 = false, this.parsePropertyValue(a4, e5, i3, s5, r7, n2, t4, o2), this.finishNode(a4, "Property");
        }, $6.parseGetterSetter = function(e5) {
          var t4 = e5.key.name;
          this.parsePropertyName(e5), e5.value = this.parseMethod(false), e5.kind = t4;
          var i3 = "get" === e5.kind ? 0 : 1;
          if (e5.value.params.length !== i3) {
            var s5 = e5.value.start;
            "get" === e5.kind ? this.raiseRecoverable(s5, "getter should have no params") : this.raiseRecoverable(s5, "setter should have exactly one param");
          } else "set" === e5.kind && "RestElement" === e5.value.params[0].type && this.raiseRecoverable(e5.value.params[0].start, "Setter cannot use rest params");
        }, $6.parsePropertyValue = function(e5, t4, i3, s5, r7, n2, a4, o2) {
          (i3 || s5) && this.type === f3.colon && this.unexpected(), this.eat(f3.colon) ? (e5.value = t4 ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, a4), e5.kind = "init") : this.options.ecmaVersion >= 6 && this.type === f3.parenL ? (t4 && this.unexpected(), e5.method = true, e5.value = this.parseMethod(i3, s5), e5.kind = "init") : t4 || o2 || !(this.options.ecmaVersion >= 5) || e5.computed || "Identifier" !== e5.key.type || "get" !== e5.key.name && "set" !== e5.key.name || this.type === f3.comma || this.type === f3.braceR || this.type === f3.eq ? this.options.ecmaVersion >= 6 && !e5.computed && "Identifier" === e5.key.type ? ((i3 || s5) && this.unexpected(), this.checkUnreserved(e5.key), "await" !== e5.key.name || this.awaitIdentPos || (this.awaitIdentPos = r7), t4 ? e5.value = this.parseMaybeDefault(r7, n2, this.copyNode(e5.key)) : this.type === f3.eq && a4 ? (a4.shorthandAssign < 0 && (a4.shorthandAssign = this.start), e5.value = this.parseMaybeDefault(r7, n2, this.copyNode(e5.key))) : e5.value = this.copyNode(e5.key), e5.kind = "init", e5.shorthand = true) : this.unexpected() : ((i3 || s5) && this.unexpected(), this.parseGetterSetter(e5));
        }, $6.parsePropertyName = function(e5) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(f3.bracketL)) return e5.computed = true, e5.key = this.parseMaybeAssign(), this.expect(f3.bracketR), e5.key;
            e5.computed = false;
          }
          return e5.key = this.type === f3.num || this.type === f3.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
        }, $6.initFunction = function(e5) {
          e5.id = null, this.options.ecmaVersion >= 6 && (e5.generator = e5.expression = false), this.options.ecmaVersion >= 8 && (e5.async = false);
        }, $6.parseMethod = function(e5, t4, i3) {
          var s5 = this.startNode(), r7 = this.yieldPos, n2 = this.awaitPos, a4 = this.awaitIdentPos;
          return this.initFunction(s5), this.options.ecmaVersion >= 6 && (s5.generator = e5), this.options.ecmaVersion >= 8 && (s5.async = !!t4), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | functionFlags2(t4, s5.generator) | (i3 ? 128 : 0)), this.expect(f3.parenL), s5.params = this.parseBindingList(f3.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(s5, false, true, false), this.yieldPos = r7, this.awaitPos = n2, this.awaitIdentPos = a4, this.finishNode(s5, "FunctionExpression");
        }, $6.parseArrowExpression = function(e5, t4, i3, s5) {
          var r7 = this.yieldPos, n2 = this.awaitPos, a4 = this.awaitIdentPos;
          return this.enterScope(16 | functionFlags2(i3, false)), this.initFunction(e5), this.options.ecmaVersion >= 8 && (e5.async = !!i3), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e5.params = this.toAssignableList(t4, true), this.parseFunctionBody(e5, true, false, s5), this.yieldPos = r7, this.awaitPos = n2, this.awaitIdentPos = a4, this.finishNode(e5, "ArrowFunctionExpression");
        }, $6.parseFunctionBody = function(e5, t4, i3, s5) {
          var r7 = t4 && this.type !== f3.braceL, n2 = this.strict, a4 = false;
          if (r7) e5.body = this.parseMaybeAssign(s5), e5.expression = true, this.checkParams(e5, false);
          else {
            var o2 = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e5.params);
            n2 && !o2 || (a4 = this.strictDirective(this.end)) && o2 && this.raiseRecoverable(e5.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            var h9 = this.labels;
            this.labels = [], a4 && (this.strict = true), this.checkParams(e5, !n2 && !a4 && !t4 && !i3 && this.isSimpleParamList(e5.params)), this.strict && e5.id && this.checkLValSimple(e5.id, 5), e5.body = this.parseBlock(false, void 0, a4 && !n2), e5.expression = false, this.adaptDirectivePrologue(e5.body.body), this.labels = h9;
          }
          this.exitScope();
        }, $6.isSimpleParamList = function(e5) {
          for (var t4 = 0, i3 = e5; t4 < i3.length; t4 += 1) {
            if ("Identifier" !== i3[t4].type) return false;
          }
          return true;
        }, $6.checkParams = function(e5, t4) {
          for (var i3 = /* @__PURE__ */ Object.create(null), s5 = 0, r7 = e5.params; s5 < r7.length; s5 += 1) {
            var n2 = r7[s5];
            this.checkLValInnerPattern(n2, 1, t4 ? null : i3);
          }
        }, $6.parseExprList = function(e5, t4, i3, s5) {
          for (var r7 = [], n2 = true; !this.eat(e5); ) {
            if (n2) n2 = false;
            else if (this.expect(f3.comma), t4 && this.afterTrailingComma(e5)) break;
            var a4 = void 0;
            i3 && this.type === f3.comma ? a4 = null : this.type === f3.ellipsis ? (a4 = this.parseSpread(s5), s5 && this.type === f3.comma && s5.trailingComma < 0 && (s5.trailingComma = this.start)) : a4 = this.parseMaybeAssign(false, s5), r7.push(a4);
          }
          return r7;
        }, $6.checkUnreserved = function(e5) {
          var t4 = e5.start, i3 = e5.end, s5 = e5.name;
          (this.inGenerator && "yield" === s5 && this.raiseRecoverable(t4, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && "await" === s5 && this.raiseRecoverable(t4, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().flags & P5 || "arguments" !== s5 || this.raiseRecoverable(t4, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || "arguments" !== s5 && "await" !== s5 || this.raise(t4, "Cannot use " + s5 + " in class static initialization block"), this.keywords.test(s5) && this.raise(t4, "Unexpected keyword '" + s5 + "'"), this.options.ecmaVersion < 6 && -1 !== this.input.slice(t4, i3).indexOf("\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(s5) && (this.inAsync || "await" !== s5 || this.raiseRecoverable(t4, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t4, "The keyword '" + s5 + "' is reserved"));
        }, $6.parseIdent = function(e5) {
          var t4 = this.parseIdentNode();
          return this.next(!!e5), this.finishNode(t4, "Identifier"), e5 || (this.checkUnreserved(t4), "await" !== t4.name || this.awaitIdentPos || (this.awaitIdentPos = t4.start)), t4;
        }, $6.parseIdentNode = function() {
          var e5 = this.startNode();
          return this.type === f3.name ? e5.name = this.value : this.type.keyword ? (e5.name = this.type.keyword, "class" !== e5.name && "function" !== e5.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop(), this.type = f3.name) : this.unexpected(), e5;
        }, $6.parsePrivateIdent = function() {
          var e5 = this.startNode();
          return this.type === f3.privateId ? e5.name = this.value : this.unexpected(), this.next(), this.finishNode(e5, "PrivateIdentifier"), this.options.checkPrivateFields && (0 === this.privateNameStack.length ? this.raise(e5.start, "Private field '#" + e5.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e5)), e5;
        }, $6.parseYield = function(e5) {
          this.yieldPos || (this.yieldPos = this.start);
          var t4 = this.startNode();
          return this.next(), this.type === f3.semi || this.canInsertSemicolon() || this.type !== f3.star && !this.type.startsExpr ? (t4.delegate = false, t4.argument = null) : (t4.delegate = this.eat(f3.star), t4.argument = this.parseMaybeAssign(e5)), this.finishNode(t4, "YieldExpression");
        }, $6.parseAwait = function(e5) {
          this.awaitPos || (this.awaitPos = this.start);
          var t4 = this.startNode();
          return this.next(), t4.argument = this.parseMaybeUnary(null, true, false, e5), this.finishNode(t4, "AwaitExpression");
        };
        var W6 = acorn_Parser.prototype;
        W6.raise = function(e5, t4) {
          var i3 = getLineInfo2(this.input, e5);
          t4 += " (" + i3.line + ":" + i3.column + ")", this.sourceFile && (t4 += " in " + this.sourceFile);
          var s5 = new SyntaxError(t4);
          throw s5.pos = e5, s5.loc = i3, s5.raisedAt = this.pos, s5;
        }, W6.raiseRecoverable = W6.raise, W6.curPosition = function() {
          if (this.options.locations) return new acorn_Position(this.curLine, this.pos - this.lineStart);
        };
        var G3 = acorn_Parser.prototype, acorn_Scope = function(e5) {
          this.flags = e5, this.var = [], this.lexical = [], this.functions = [];
        };
        G3.enterScope = function(e5) {
          this.scopeStack.push(new acorn_Scope(e5));
        }, G3.exitScope = function() {
          this.scopeStack.pop();
        }, G3.treatFunctionsAsVarInScope = function(e5) {
          return 2 & e5.flags || !this.inModule && 1 & e5.flags;
        }, G3.declareName = function(e5, t4, i3) {
          var s5 = false;
          if (2 === t4) {
            var r7 = this.currentScope();
            s5 = r7.lexical.indexOf(e5) > -1 || r7.functions.indexOf(e5) > -1 || r7.var.indexOf(e5) > -1, r7.lexical.push(e5), this.inModule && 1 & r7.flags && delete this.undefinedExports[e5];
          } else if (4 === t4) {
            this.currentScope().lexical.push(e5);
          } else if (3 === t4) {
            var n2 = this.currentScope();
            s5 = this.treatFunctionsAsVar ? n2.lexical.indexOf(e5) > -1 : n2.lexical.indexOf(e5) > -1 || n2.var.indexOf(e5) > -1, n2.functions.push(e5);
          } else for (var a4 = this.scopeStack.length - 1; a4 >= 0; --a4) {
            var o2 = this.scopeStack[a4];
            if (o2.lexical.indexOf(e5) > -1 && !(32 & o2.flags && o2.lexical[0] === e5) || !this.treatFunctionsAsVarInScope(o2) && o2.functions.indexOf(e5) > -1) {
              s5 = true;
              break;
            }
            if (o2.var.push(e5), this.inModule && 1 & o2.flags && delete this.undefinedExports[e5], o2.flags & P5) break;
          }
          s5 && this.raiseRecoverable(i3, "Identifier '" + e5 + "' has already been declared");
        }, G3.checkLocalExport = function(e5) {
          -1 === this.scopeStack[0].lexical.indexOf(e5.name) && -1 === this.scopeStack[0].var.indexOf(e5.name) && (this.undefinedExports[e5.name] = e5);
        }, G3.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1];
        }, G3.currentVarScope = function() {
          for (var e5 = this.scopeStack.length - 1; ; e5--) {
            var t4 = this.scopeStack[e5];
            if (771 & t4.flags) return t4;
          }
        }, G3.currentThisScope = function() {
          for (var e5 = this.scopeStack.length - 1; ; e5--) {
            var t4 = this.scopeStack[e5];
            if (771 & t4.flags && !(16 & t4.flags)) return t4;
          }
        };
        var acorn_Node = function(e5, t4, i3) {
          this.type = "", this.start = t4, this.end = 0, e5.options.locations && (this.loc = new acorn_SourceLocation(e5, i3)), e5.options.directSourceFile && (this.sourceFile = e5.options.directSourceFile), e5.options.ranges && (this.range = [t4, 0]);
        }, H5 = acorn_Parser.prototype;
        function finishNodeAt2(e5, t4, i3, s5) {
          return e5.type = t4, e5.end = i3, this.options.locations && (e5.loc.end = s5), this.options.ranges && (e5.range[1] = i3), e5;
        }
        H5.startNode = function() {
          return new acorn_Node(this, this.start, this.startLoc);
        }, H5.startNodeAt = function(e5, t4) {
          return new acorn_Node(this, e5, t4);
        }, H5.finishNode = function(e5, t4) {
          return finishNodeAt2.call(this, e5, t4, this.lastTokEnd, this.lastTokEndLoc);
        }, H5.finishNodeAt = function(e5, t4, i3, s5) {
          return finishNodeAt2.call(this, e5, t4, i3, s5);
        }, H5.copyNode = function(e5) {
          var t4 = new acorn_Node(this, e5.start, this.startLoc);
          for (var i3 in e5) t4[i3] = e5[i3];
          return t4;
        };
        var K4 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", z4 = K4 + " Extended_Pictographic", J5 = z4 + " EBase EComp EMod EPres ExtPict", Y4 = { 9: K4, 10: z4, 11: z4, 12: J5, 13: J5, 14: J5 }, Q5 = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji" }, Z4 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", X5 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ee3 = X5 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", te3 = ee3 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", ie3 = te3 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", se2 = ie3 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", re3 = { 9: X5, 10: ee3, 11: te3, 12: ie3, 13: se2, 14: se2 + " Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz" }, ne3 = {};
        function buildUnicodeData2(e5) {
          var t4 = ne3[e5] = { binary: wordsRegexp2(Y4[e5] + " " + Z4), binaryOfStrings: wordsRegexp2(Q5[e5]), nonBinary: { General_Category: wordsRegexp2(Z4), Script: wordsRegexp2(re3[e5]) } };
          t4.nonBinary.Script_Extensions = t4.nonBinary.Script, t4.nonBinary.gc = t4.nonBinary.General_Category, t4.nonBinary.sc = t4.nonBinary.Script, t4.nonBinary.scx = t4.nonBinary.Script_Extensions;
        }
        for (var ae3 = 0, oe3 = [9, 10, 11, 12, 13, 14]; ae3 < oe3.length; ae3 += 1) {
          buildUnicodeData2(oe3[ae3]);
        }
        var he3 = acorn_Parser.prototype, acorn_BranchID = function(e5, t4) {
          this.parent = e5, this.base = t4 || this;
        };
        acorn_BranchID.prototype.separatedFrom = function(e5) {
          for (var t4 = this; t4; t4 = t4.parent) for (var i3 = e5; i3; i3 = i3.parent) if (t4.base === i3.base && t4 !== i3) return true;
          return false;
        }, acorn_BranchID.prototype.sibling = function() {
          return new acorn_BranchID(this.parent, this.base);
        };
        var acorn_RegExpValidationState = function(e5) {
          this.parser = e5, this.validFlags = "gim" + (e5.options.ecmaVersion >= 6 ? "uy" : "") + (e5.options.ecmaVersion >= 9 ? "s" : "") + (e5.options.ecmaVersion >= 13 ? "d" : "") + (e5.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = ne3[e5.options.ecmaVersion >= 14 ? 14 : e5.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchV = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
        };
        function isRegularExpressionModifier2(e5) {
          return 105 === e5 || 109 === e5 || 115 === e5;
        }
        function isSyntaxCharacter2(e5) {
          return 36 === e5 || e5 >= 40 && e5 <= 43 || 46 === e5 || 63 === e5 || e5 >= 91 && e5 <= 94 || e5 >= 123 && e5 <= 125;
        }
        function isControlLetter2(e5) {
          return e5 >= 65 && e5 <= 90 || e5 >= 97 && e5 <= 122;
        }
        acorn_RegExpValidationState.prototype.reset = function(e5, t4, i3) {
          var s5 = -1 !== i3.indexOf("v"), r7 = -1 !== i3.indexOf("u");
          this.start = 0 | e5, this.source = t4 + "", this.flags = i3, s5 && this.parser.options.ecmaVersion >= 15 ? (this.switchU = true, this.switchV = true, this.switchN = true) : (this.switchU = r7 && this.parser.options.ecmaVersion >= 6, this.switchV = false, this.switchN = r7 && this.parser.options.ecmaVersion >= 9);
        }, acorn_RegExpValidationState.prototype.raise = function(e5) {
          this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e5);
        }, acorn_RegExpValidationState.prototype.at = function(e5, t4) {
          void 0 === t4 && (t4 = false);
          var i3 = this.source, s5 = i3.length;
          if (e5 >= s5) return -1;
          var r7 = i3.charCodeAt(e5);
          if (!t4 && !this.switchU || r7 <= 55295 || r7 >= 57344 || e5 + 1 >= s5) return r7;
          var n2 = i3.charCodeAt(e5 + 1);
          return n2 >= 56320 && n2 <= 57343 ? (r7 << 10) + n2 - 56613888 : r7;
        }, acorn_RegExpValidationState.prototype.nextIndex = function(e5, t4) {
          void 0 === t4 && (t4 = false);
          var i3 = this.source, s5 = i3.length;
          if (e5 >= s5) return s5;
          var r7, n2 = i3.charCodeAt(e5);
          return !t4 && !this.switchU || n2 <= 55295 || n2 >= 57344 || e5 + 1 >= s5 || (r7 = i3.charCodeAt(e5 + 1)) < 56320 || r7 > 57343 ? e5 + 1 : e5 + 2;
        }, acorn_RegExpValidationState.prototype.current = function(e5) {
          return void 0 === e5 && (e5 = false), this.at(this.pos, e5);
        }, acorn_RegExpValidationState.prototype.lookahead = function(e5) {
          return void 0 === e5 && (e5 = false), this.at(this.nextIndex(this.pos, e5), e5);
        }, acorn_RegExpValidationState.prototype.advance = function(e5) {
          void 0 === e5 && (e5 = false), this.pos = this.nextIndex(this.pos, e5);
        }, acorn_RegExpValidationState.prototype.eat = function(e5, t4) {
          return void 0 === t4 && (t4 = false), this.current(t4) === e5 && (this.advance(t4), true);
        }, acorn_RegExpValidationState.prototype.eatChars = function(e5, t4) {
          void 0 === t4 && (t4 = false);
          for (var i3 = this.pos, s5 = 0, r7 = e5; s5 < r7.length; s5 += 1) {
            var n2 = r7[s5], a4 = this.at(i3, t4);
            if (-1 === a4 || a4 !== n2) return false;
            i3 = this.nextIndex(i3, t4);
          }
          return this.pos = i3, true;
        }, he3.validateRegExpFlags = function(e5) {
          for (var t4 = e5.validFlags, i3 = e5.flags, s5 = false, r7 = false, n2 = 0; n2 < i3.length; n2++) {
            var a4 = i3.charAt(n2);
            -1 === t4.indexOf(a4) && this.raise(e5.start, "Invalid regular expression flag"), i3.indexOf(a4, n2 + 1) > -1 && this.raise(e5.start, "Duplicate regular expression flag"), "u" === a4 && (s5 = true), "v" === a4 && (r7 = true);
          }
          this.options.ecmaVersion >= 15 && s5 && r7 && this.raise(e5.start, "Invalid regular expression flag");
        }, he3.validateRegExpPattern = function(e5) {
          this.regexp_pattern(e5), !e5.switchN && this.options.ecmaVersion >= 9 && (function(e6) {
            for (var t4 in e6) return true;
            return false;
          })(e5.groupNames) && (e5.switchN = true, this.regexp_pattern(e5));
        }, he3.regexp_pattern = function(e5) {
          e5.pos = 0, e5.lastIntValue = 0, e5.lastStringValue = "", e5.lastAssertionIsQuantifiable = false, e5.numCapturingParens = 0, e5.maxBackReference = 0, e5.groupNames = /* @__PURE__ */ Object.create(null), e5.backReferenceNames.length = 0, e5.branchID = null, this.regexp_disjunction(e5), e5.pos !== e5.source.length && (e5.eat(41) && e5.raise("Unmatched ')'"), (e5.eat(93) || e5.eat(125)) && e5.raise("Lone quantifier brackets")), e5.maxBackReference > e5.numCapturingParens && e5.raise("Invalid escape");
          for (var t4 = 0, i3 = e5.backReferenceNames; t4 < i3.length; t4 += 1) {
            var s5 = i3[t4];
            e5.groupNames[s5] || e5.raise("Invalid named capture referenced");
          }
        }, he3.regexp_disjunction = function(e5) {
          var t4 = this.options.ecmaVersion >= 16;
          for (t4 && (e5.branchID = new acorn_BranchID(e5.branchID, null)), this.regexp_alternative(e5); e5.eat(124); ) t4 && (e5.branchID = e5.branchID.sibling()), this.regexp_alternative(e5);
          t4 && (e5.branchID = e5.branchID.parent), this.regexp_eatQuantifier(e5, true) && e5.raise("Nothing to repeat"), e5.eat(123) && e5.raise("Lone quantifier brackets");
        }, he3.regexp_alternative = function(e5) {
          for (; e5.pos < e5.source.length && this.regexp_eatTerm(e5); ) ;
        }, he3.regexp_eatTerm = function(e5) {
          return this.regexp_eatAssertion(e5) ? (e5.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e5) && e5.switchU && e5.raise("Invalid quantifier"), true) : !!(e5.switchU ? this.regexp_eatAtom(e5) : this.regexp_eatExtendedAtom(e5)) && (this.regexp_eatQuantifier(e5), true);
        }, he3.regexp_eatAssertion = function(e5) {
          var t4 = e5.pos;
          if (e5.lastAssertionIsQuantifiable = false, e5.eat(94) || e5.eat(36)) return true;
          if (e5.eat(92)) {
            if (e5.eat(66) || e5.eat(98)) return true;
            e5.pos = t4;
          }
          if (e5.eat(40) && e5.eat(63)) {
            var i3 = false;
            if (this.options.ecmaVersion >= 9 && (i3 = e5.eat(60)), e5.eat(61) || e5.eat(33)) return this.regexp_disjunction(e5), e5.eat(41) || e5.raise("Unterminated group"), e5.lastAssertionIsQuantifiable = !i3, true;
          }
          return e5.pos = t4, false;
        }, he3.regexp_eatQuantifier = function(e5, t4) {
          return void 0 === t4 && (t4 = false), !!this.regexp_eatQuantifierPrefix(e5, t4) && (e5.eat(63), true);
        }, he3.regexp_eatQuantifierPrefix = function(e5, t4) {
          return e5.eat(42) || e5.eat(43) || e5.eat(63) || this.regexp_eatBracedQuantifier(e5, t4);
        }, he3.regexp_eatBracedQuantifier = function(e5, t4) {
          var i3 = e5.pos;
          if (e5.eat(123)) {
            var s5 = 0, r7 = -1;
            if (this.regexp_eatDecimalDigits(e5) && (s5 = e5.lastIntValue, e5.eat(44) && this.regexp_eatDecimalDigits(e5) && (r7 = e5.lastIntValue), e5.eat(125))) return -1 !== r7 && r7 < s5 && !t4 && e5.raise("numbers out of order in {} quantifier"), true;
            e5.switchU && !t4 && e5.raise("Incomplete quantifier"), e5.pos = i3;
          }
          return false;
        }, he3.regexp_eatAtom = function(e5) {
          return this.regexp_eatPatternCharacters(e5) || e5.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e5) || this.regexp_eatCharacterClass(e5) || this.regexp_eatUncapturingGroup(e5) || this.regexp_eatCapturingGroup(e5);
        }, he3.regexp_eatReverseSolidusAtomEscape = function(e5) {
          var t4 = e5.pos;
          if (e5.eat(92)) {
            if (this.regexp_eatAtomEscape(e5)) return true;
            e5.pos = t4;
          }
          return false;
        }, he3.regexp_eatUncapturingGroup = function(e5) {
          var t4 = e5.pos;
          if (e5.eat(40)) {
            if (e5.eat(63)) {
              if (this.options.ecmaVersion >= 16) {
                var i3 = this.regexp_eatModifiers(e5), s5 = e5.eat(45);
                if (i3 || s5) {
                  for (var r7 = 0; r7 < i3.length; r7++) {
                    var n2 = i3.charAt(r7);
                    i3.indexOf(n2, r7 + 1) > -1 && e5.raise("Duplicate regular expression modifiers");
                  }
                  if (s5) {
                    var a4 = this.regexp_eatModifiers(e5);
                    i3 || a4 || 58 !== e5.current() || e5.raise("Invalid regular expression modifiers");
                    for (var o2 = 0; o2 < a4.length; o2++) {
                      var h9 = a4.charAt(o2);
                      (a4.indexOf(h9, o2 + 1) > -1 || i3.indexOf(h9) > -1) && e5.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
              if (e5.eat(58)) {
                if (this.regexp_disjunction(e5), e5.eat(41)) return true;
                e5.raise("Unterminated group");
              }
            }
            e5.pos = t4;
          }
          return false;
        }, he3.regexp_eatCapturingGroup = function(e5) {
          if (e5.eat(40)) {
            if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e5) : 63 === e5.current() && e5.raise("Invalid group"), this.regexp_disjunction(e5), e5.eat(41)) return e5.numCapturingParens += 1, true;
            e5.raise("Unterminated group");
          }
          return false;
        }, he3.regexp_eatModifiers = function(e5) {
          for (var t4 = "", i3 = 0; -1 !== (i3 = e5.current()) && isRegularExpressionModifier2(i3); ) t4 += codePointToString2(i3), e5.advance();
          return t4;
        }, he3.regexp_eatExtendedAtom = function(e5) {
          return e5.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e5) || this.regexp_eatCharacterClass(e5) || this.regexp_eatUncapturingGroup(e5) || this.regexp_eatCapturingGroup(e5) || this.regexp_eatInvalidBracedQuantifier(e5) || this.regexp_eatExtendedPatternCharacter(e5);
        }, he3.regexp_eatInvalidBracedQuantifier = function(e5) {
          return this.regexp_eatBracedQuantifier(e5, true) && e5.raise("Nothing to repeat"), false;
        }, he3.regexp_eatSyntaxCharacter = function(e5) {
          var t4 = e5.current();
          return !!isSyntaxCharacter2(t4) && (e5.lastIntValue = t4, e5.advance(), true);
        }, he3.regexp_eatPatternCharacters = function(e5) {
          for (var t4 = e5.pos, i3 = 0; -1 !== (i3 = e5.current()) && !isSyntaxCharacter2(i3); ) e5.advance();
          return e5.pos !== t4;
        }, he3.regexp_eatExtendedPatternCharacter = function(e5) {
          var t4 = e5.current();
          return !(-1 === t4 || 36 === t4 || t4 >= 40 && t4 <= 43 || 46 === t4 || 63 === t4 || 91 === t4 || 94 === t4 || 124 === t4) && (e5.advance(), true);
        }, he3.regexp_groupSpecifier = function(e5) {
          if (e5.eat(63)) {
            this.regexp_eatGroupName(e5) || e5.raise("Invalid group");
            var t4 = this.options.ecmaVersion >= 16, i3 = e5.groupNames[e5.lastStringValue];
            if (i3) if (t4) for (var s5 = 0, r7 = i3; s5 < r7.length; s5 += 1) {
              r7[s5].separatedFrom(e5.branchID) || e5.raise("Duplicate capture group name");
            }
            else e5.raise("Duplicate capture group name");
            t4 ? (i3 || (e5.groupNames[e5.lastStringValue] = [])).push(e5.branchID) : e5.groupNames[e5.lastStringValue] = true;
          }
        }, he3.regexp_eatGroupName = function(e5) {
          if (e5.lastStringValue = "", e5.eat(60)) {
            if (this.regexp_eatRegExpIdentifierName(e5) && e5.eat(62)) return true;
            e5.raise("Invalid capture group name");
          }
          return false;
        }, he3.regexp_eatRegExpIdentifierName = function(e5) {
          if (e5.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e5)) {
            for (e5.lastStringValue += codePointToString2(e5.lastIntValue); this.regexp_eatRegExpIdentifierPart(e5); ) e5.lastStringValue += codePointToString2(e5.lastIntValue);
            return true;
          }
          return false;
        }, he3.regexp_eatRegExpIdentifierStart = function(e5) {
          var t4 = e5.pos, i3 = this.options.ecmaVersion >= 11, s5 = e5.current(i3);
          return e5.advance(i3), 92 === s5 && this.regexp_eatRegExpUnicodeEscapeSequence(e5, i3) && (s5 = e5.lastIntValue), (function(e6) {
            return isIdentifierStart2(e6, true) || 36 === e6 || 95 === e6;
          })(s5) ? (e5.lastIntValue = s5, true) : (e5.pos = t4, false);
        }, he3.regexp_eatRegExpIdentifierPart = function(e5) {
          var t4 = e5.pos, i3 = this.options.ecmaVersion >= 11, s5 = e5.current(i3);
          return e5.advance(i3), 92 === s5 && this.regexp_eatRegExpUnicodeEscapeSequence(e5, i3) && (s5 = e5.lastIntValue), (function(e6) {
            return isIdentifierChar2(e6, true) || 36 === e6 || 95 === e6 || 8204 === e6 || 8205 === e6;
          })(s5) ? (e5.lastIntValue = s5, true) : (e5.pos = t4, false);
        }, he3.regexp_eatAtomEscape = function(e5) {
          return !!(this.regexp_eatBackReference(e5) || this.regexp_eatCharacterClassEscape(e5) || this.regexp_eatCharacterEscape(e5) || e5.switchN && this.regexp_eatKGroupName(e5)) || (e5.switchU && (99 === e5.current() && e5.raise("Invalid unicode escape"), e5.raise("Invalid escape")), false);
        }, he3.regexp_eatBackReference = function(e5) {
          var t4 = e5.pos;
          if (this.regexp_eatDecimalEscape(e5)) {
            var i3 = e5.lastIntValue;
            if (e5.switchU) return i3 > e5.maxBackReference && (e5.maxBackReference = i3), true;
            if (i3 <= e5.numCapturingParens) return true;
            e5.pos = t4;
          }
          return false;
        }, he3.regexp_eatKGroupName = function(e5) {
          if (e5.eat(107)) {
            if (this.regexp_eatGroupName(e5)) return e5.backReferenceNames.push(e5.lastStringValue), true;
            e5.raise("Invalid named reference");
          }
          return false;
        }, he3.regexp_eatCharacterEscape = function(e5) {
          return this.regexp_eatControlEscape(e5) || this.regexp_eatCControlLetter(e5) || this.regexp_eatZero(e5) || this.regexp_eatHexEscapeSequence(e5) || this.regexp_eatRegExpUnicodeEscapeSequence(e5, false) || !e5.switchU && this.regexp_eatLegacyOctalEscapeSequence(e5) || this.regexp_eatIdentityEscape(e5);
        }, he3.regexp_eatCControlLetter = function(e5) {
          var t4 = e5.pos;
          if (e5.eat(99)) {
            if (this.regexp_eatControlLetter(e5)) return true;
            e5.pos = t4;
          }
          return false;
        }, he3.regexp_eatZero = function(e5) {
          return 48 === e5.current() && !isDecimalDigit2(e5.lookahead()) && (e5.lastIntValue = 0, e5.advance(), true);
        }, he3.regexp_eatControlEscape = function(e5) {
          var t4 = e5.current();
          return 116 === t4 ? (e5.lastIntValue = 9, e5.advance(), true) : 110 === t4 ? (e5.lastIntValue = 10, e5.advance(), true) : 118 === t4 ? (e5.lastIntValue = 11, e5.advance(), true) : 102 === t4 ? (e5.lastIntValue = 12, e5.advance(), true) : 114 === t4 && (e5.lastIntValue = 13, e5.advance(), true);
        }, he3.regexp_eatControlLetter = function(e5) {
          var t4 = e5.current();
          return !!isControlLetter2(t4) && (e5.lastIntValue = t4 % 32, e5.advance(), true);
        }, he3.regexp_eatRegExpUnicodeEscapeSequence = function(e5, t4) {
          void 0 === t4 && (t4 = false);
          var i3, s5 = e5.pos, r7 = t4 || e5.switchU;
          if (e5.eat(117)) {
            if (this.regexp_eatFixedHexDigits(e5, 4)) {
              var n2 = e5.lastIntValue;
              if (r7 && n2 >= 55296 && n2 <= 56319) {
                var a4 = e5.pos;
                if (e5.eat(92) && e5.eat(117) && this.regexp_eatFixedHexDigits(e5, 4)) {
                  var o2 = e5.lastIntValue;
                  if (o2 >= 56320 && o2 <= 57343) return e5.lastIntValue = 1024 * (n2 - 55296) + (o2 - 56320) + 65536, true;
                }
                e5.pos = a4, e5.lastIntValue = n2;
              }
              return true;
            }
            if (r7 && e5.eat(123) && this.regexp_eatHexDigits(e5) && e5.eat(125) && ((i3 = e5.lastIntValue) >= 0 && i3 <= 1114111)) return true;
            r7 && e5.raise("Invalid unicode escape"), e5.pos = s5;
          }
          return false;
        }, he3.regexp_eatIdentityEscape = function(e5) {
          if (e5.switchU) return !!this.regexp_eatSyntaxCharacter(e5) || !!e5.eat(47) && (e5.lastIntValue = 47, true);
          var t4 = e5.current();
          return !(99 === t4 || e5.switchN && 107 === t4) && (e5.lastIntValue = t4, e5.advance(), true);
        }, he3.regexp_eatDecimalEscape = function(e5) {
          e5.lastIntValue = 0;
          var t4 = e5.current();
          if (t4 >= 49 && t4 <= 57) {
            do {
              e5.lastIntValue = 10 * e5.lastIntValue + (t4 - 48), e5.advance();
            } while ((t4 = e5.current()) >= 48 && t4 <= 57);
            return true;
          }
          return false;
        };
        function isUnicodePropertyNameCharacter2(e5) {
          return isControlLetter2(e5) || 95 === e5;
        }
        function isUnicodePropertyValueCharacter2(e5) {
          return isUnicodePropertyNameCharacter2(e5) || isDecimalDigit2(e5);
        }
        function isDecimalDigit2(e5) {
          return e5 >= 48 && e5 <= 57;
        }
        function isHexDigit2(e5) {
          return e5 >= 48 && e5 <= 57 || e5 >= 65 && e5 <= 70 || e5 >= 97 && e5 <= 102;
        }
        function hexToInt2(e5) {
          return e5 >= 65 && e5 <= 70 ? e5 - 65 + 10 : e5 >= 97 && e5 <= 102 ? e5 - 97 + 10 : e5 - 48;
        }
        function isOctalDigit2(e5) {
          return e5 >= 48 && e5 <= 55;
        }
        he3.regexp_eatCharacterClassEscape = function(e5) {
          var t4 = e5.current();
          if (/* @__PURE__ */ (function(e6) {
            return 100 === e6 || 68 === e6 || 115 === e6 || 83 === e6 || 119 === e6 || 87 === e6;
          })(t4)) return e5.lastIntValue = -1, e5.advance(), 1;
          var i3 = false;
          if (e5.switchU && this.options.ecmaVersion >= 9 && ((i3 = 80 === t4) || 112 === t4)) {
            var s5;
            if (e5.lastIntValue = -1, e5.advance(), e5.eat(123) && (s5 = this.regexp_eatUnicodePropertyValueExpression(e5)) && e5.eat(125)) return i3 && 2 === s5 && e5.raise("Invalid property name"), s5;
            e5.raise("Invalid property name");
          }
          return 0;
        }, he3.regexp_eatUnicodePropertyValueExpression = function(e5) {
          var t4 = e5.pos;
          if (this.regexp_eatUnicodePropertyName(e5) && e5.eat(61)) {
            var i3 = e5.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(e5)) {
              var s5 = e5.lastStringValue;
              return this.regexp_validateUnicodePropertyNameAndValue(e5, i3, s5), 1;
            }
          }
          if (e5.pos = t4, this.regexp_eatLoneUnicodePropertyNameOrValue(e5)) {
            var r7 = e5.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(e5, r7);
          }
          return 0;
        }, he3.regexp_validateUnicodePropertyNameAndValue = function(e5, t4, i3) {
          b6(e5.unicodeProperties.nonBinary, t4) || e5.raise("Invalid property name"), e5.unicodeProperties.nonBinary[t4].test(i3) || e5.raise("Invalid property value");
        }, he3.regexp_validateUnicodePropertyNameOrValue = function(e5, t4) {
          return e5.unicodeProperties.binary.test(t4) ? 1 : e5.switchV && e5.unicodeProperties.binaryOfStrings.test(t4) ? 2 : void e5.raise("Invalid property name");
        }, he3.regexp_eatUnicodePropertyName = function(e5) {
          var t4 = 0;
          for (e5.lastStringValue = ""; isUnicodePropertyNameCharacter2(t4 = e5.current()); ) e5.lastStringValue += codePointToString2(t4), e5.advance();
          return "" !== e5.lastStringValue;
        }, he3.regexp_eatUnicodePropertyValue = function(e5) {
          var t4 = 0;
          for (e5.lastStringValue = ""; isUnicodePropertyValueCharacter2(t4 = e5.current()); ) e5.lastStringValue += codePointToString2(t4), e5.advance();
          return "" !== e5.lastStringValue;
        }, he3.regexp_eatLoneUnicodePropertyNameOrValue = function(e5) {
          return this.regexp_eatUnicodePropertyValue(e5);
        }, he3.regexp_eatCharacterClass = function(e5) {
          if (e5.eat(91)) {
            var t4 = e5.eat(94), i3 = this.regexp_classContents(e5);
            return e5.eat(93) || e5.raise("Unterminated character class"), t4 && 2 === i3 && e5.raise("Negated character class may contain strings"), true;
          }
          return false;
        }, he3.regexp_classContents = function(e5) {
          return 93 === e5.current() ? 1 : e5.switchV ? this.regexp_classSetExpression(e5) : (this.regexp_nonEmptyClassRanges(e5), 1);
        }, he3.regexp_nonEmptyClassRanges = function(e5) {
          for (; this.regexp_eatClassAtom(e5); ) {
            var t4 = e5.lastIntValue;
            if (e5.eat(45) && this.regexp_eatClassAtom(e5)) {
              var i3 = e5.lastIntValue;
              !e5.switchU || -1 !== t4 && -1 !== i3 || e5.raise("Invalid character class"), -1 !== t4 && -1 !== i3 && t4 > i3 && e5.raise("Range out of order in character class");
            }
          }
        }, he3.regexp_eatClassAtom = function(e5) {
          var t4 = e5.pos;
          if (e5.eat(92)) {
            if (this.regexp_eatClassEscape(e5)) return true;
            if (e5.switchU) {
              var i3 = e5.current();
              (99 === i3 || isOctalDigit2(i3)) && e5.raise("Invalid class escape"), e5.raise("Invalid escape");
            }
            e5.pos = t4;
          }
          var s5 = e5.current();
          return 93 !== s5 && (e5.lastIntValue = s5, e5.advance(), true);
        }, he3.regexp_eatClassEscape = function(e5) {
          var t4 = e5.pos;
          if (e5.eat(98)) return e5.lastIntValue = 8, true;
          if (e5.switchU && e5.eat(45)) return e5.lastIntValue = 45, true;
          if (!e5.switchU && e5.eat(99)) {
            if (this.regexp_eatClassControlLetter(e5)) return true;
            e5.pos = t4;
          }
          return this.regexp_eatCharacterClassEscape(e5) || this.regexp_eatCharacterEscape(e5);
        }, he3.regexp_classSetExpression = function(e5) {
          var t4, i3 = 1;
          if (this.regexp_eatClassSetRange(e5)) ;
          else if (t4 = this.regexp_eatClassSetOperand(e5)) {
            2 === t4 && (i3 = 2);
            for (var s5 = e5.pos; e5.eatChars([38, 38]); ) 38 !== e5.current() && (t4 = this.regexp_eatClassSetOperand(e5)) ? 2 !== t4 && (i3 = 1) : e5.raise("Invalid character in character class");
            if (s5 !== e5.pos) return i3;
            for (; e5.eatChars([45, 45]); ) this.regexp_eatClassSetOperand(e5) || e5.raise("Invalid character in character class");
            if (s5 !== e5.pos) return i3;
          } else e5.raise("Invalid character in character class");
          for (; ; ) if (!this.regexp_eatClassSetRange(e5)) {
            if (!(t4 = this.regexp_eatClassSetOperand(e5))) return i3;
            2 === t4 && (i3 = 2);
          }
        }, he3.regexp_eatClassSetRange = function(e5) {
          var t4 = e5.pos;
          if (this.regexp_eatClassSetCharacter(e5)) {
            var i3 = e5.lastIntValue;
            if (e5.eat(45) && this.regexp_eatClassSetCharacter(e5)) {
              var s5 = e5.lastIntValue;
              return -1 !== i3 && -1 !== s5 && i3 > s5 && e5.raise("Range out of order in character class"), true;
            }
            e5.pos = t4;
          }
          return false;
        }, he3.regexp_eatClassSetOperand = function(e5) {
          return this.regexp_eatClassSetCharacter(e5) ? 1 : this.regexp_eatClassStringDisjunction(e5) || this.regexp_eatNestedClass(e5);
        }, he3.regexp_eatNestedClass = function(e5) {
          var t4 = e5.pos;
          if (e5.eat(91)) {
            var i3 = e5.eat(94), s5 = this.regexp_classContents(e5);
            if (e5.eat(93)) return i3 && 2 === s5 && e5.raise("Negated character class may contain strings"), s5;
            e5.pos = t4;
          }
          if (e5.eat(92)) {
            var r7 = this.regexp_eatCharacterClassEscape(e5);
            if (r7) return r7;
            e5.pos = t4;
          }
          return null;
        }, he3.regexp_eatClassStringDisjunction = function(e5) {
          var t4 = e5.pos;
          if (e5.eatChars([92, 113])) {
            if (e5.eat(123)) {
              var i3 = this.regexp_classStringDisjunctionContents(e5);
              if (e5.eat(125)) return i3;
            } else e5.raise("Invalid escape");
            e5.pos = t4;
          }
          return null;
        }, he3.regexp_classStringDisjunctionContents = function(e5) {
          for (var t4 = this.regexp_classString(e5); e5.eat(124); ) 2 === this.regexp_classString(e5) && (t4 = 2);
          return t4;
        }, he3.regexp_classString = function(e5) {
          for (var t4 = 0; this.regexp_eatClassSetCharacter(e5); ) t4++;
          return 1 === t4 ? 1 : 2;
        }, he3.regexp_eatClassSetCharacter = function(e5) {
          var t4 = e5.pos;
          if (e5.eat(92)) return !(!this.regexp_eatCharacterEscape(e5) && !this.regexp_eatClassSetReservedPunctuator(e5)) || (e5.eat(98) ? (e5.lastIntValue = 8, true) : (e5.pos = t4, false));
          var i3 = e5.current();
          return !(i3 < 0 || i3 === e5.lookahead() && (function(e6) {
            return 33 === e6 || e6 >= 35 && e6 <= 38 || e6 >= 42 && e6 <= 44 || 46 === e6 || e6 >= 58 && e6 <= 64 || 94 === e6 || 96 === e6 || 126 === e6;
          })(i3)) && (!(function(e6) {
            return 40 === e6 || 41 === e6 || 45 === e6 || 47 === e6 || e6 >= 91 && e6 <= 93 || e6 >= 123 && e6 <= 125;
          })(i3) && (e5.advance(), e5.lastIntValue = i3, true));
        }, he3.regexp_eatClassSetReservedPunctuator = function(e5) {
          var t4 = e5.current();
          return !!(function(e6) {
            return 33 === e6 || 35 === e6 || 37 === e6 || 38 === e6 || 44 === e6 || 45 === e6 || e6 >= 58 && e6 <= 62 || 64 === e6 || 96 === e6 || 126 === e6;
          })(t4) && (e5.lastIntValue = t4, e5.advance(), true);
        }, he3.regexp_eatClassControlLetter = function(e5) {
          var t4 = e5.current();
          return !(!isDecimalDigit2(t4) && 95 !== t4) && (e5.lastIntValue = t4 % 32, e5.advance(), true);
        }, he3.regexp_eatHexEscapeSequence = function(e5) {
          var t4 = e5.pos;
          if (e5.eat(120)) {
            if (this.regexp_eatFixedHexDigits(e5, 2)) return true;
            e5.switchU && e5.raise("Invalid escape"), e5.pos = t4;
          }
          return false;
        }, he3.regexp_eatDecimalDigits = function(e5) {
          var t4 = e5.pos, i3 = 0;
          for (e5.lastIntValue = 0; isDecimalDigit2(i3 = e5.current()); ) e5.lastIntValue = 10 * e5.lastIntValue + (i3 - 48), e5.advance();
          return e5.pos !== t4;
        }, he3.regexp_eatHexDigits = function(e5) {
          var t4 = e5.pos, i3 = 0;
          for (e5.lastIntValue = 0; isHexDigit2(i3 = e5.current()); ) e5.lastIntValue = 16 * e5.lastIntValue + hexToInt2(i3), e5.advance();
          return e5.pos !== t4;
        }, he3.regexp_eatLegacyOctalEscapeSequence = function(e5) {
          if (this.regexp_eatOctalDigit(e5)) {
            var t4 = e5.lastIntValue;
            if (this.regexp_eatOctalDigit(e5)) {
              var i3 = e5.lastIntValue;
              t4 <= 3 && this.regexp_eatOctalDigit(e5) ? e5.lastIntValue = 64 * t4 + 8 * i3 + e5.lastIntValue : e5.lastIntValue = 8 * t4 + i3;
            } else e5.lastIntValue = t4;
            return true;
          }
          return false;
        }, he3.regexp_eatOctalDigit = function(e5) {
          var t4 = e5.current();
          return isOctalDigit2(t4) ? (e5.lastIntValue = t4 - 48, e5.advance(), true) : (e5.lastIntValue = 0, false);
        }, he3.regexp_eatFixedHexDigits = function(e5, t4) {
          var i3 = e5.pos;
          e5.lastIntValue = 0;
          for (var s5 = 0; s5 < t4; ++s5) {
            var r7 = e5.current();
            if (!isHexDigit2(r7)) return e5.pos = i3, false;
            e5.lastIntValue = 16 * e5.lastIntValue + hexToInt2(r7), e5.advance();
          }
          return true;
        };
        var acorn_Token = function(e5) {
          this.type = e5.type, this.value = e5.value, this.start = e5.start, this.end = e5.end, e5.options.locations && (this.loc = new acorn_SourceLocation(e5, e5.startLoc, e5.endLoc)), e5.options.ranges && (this.range = [e5.start, e5.end]);
        }, ce2 = acorn_Parser.prototype;
        function stringToBigInt2(e5) {
          return "function" != typeof BigInt ? null : BigInt(e5.replace(/_/g, ""));
        }
        ce2.next = function(e5) {
          !e5 && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new acorn_Token(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
        }, ce2.getToken = function() {
          return this.next(), new acorn_Token(this);
        }, "undefined" != typeof Symbol && (ce2[Symbol.iterator] = function() {
          var e5 = this;
          return { next: function() {
            var t4 = e5.getToken();
            return { done: t4.type === f3.eof, value: t4 };
          } };
        }), ce2.nextToken = function() {
          var e5 = this.curContext();
          return e5 && e5.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(f3.eof) : e5.override ? e5.override(this) : void this.readToken(this.fullCharCodeAtPos());
        }, ce2.readToken = function(e5) {
          return isIdentifierStart2(e5, this.options.ecmaVersion >= 6) || 92 === e5 ? this.readWord() : this.getTokenFromCode(e5);
        }, ce2.fullCharCodeAtPos = function() {
          var e5 = this.input.charCodeAt(this.pos);
          if (e5 <= 55295 || e5 >= 56320) return e5;
          var t4 = this.input.charCodeAt(this.pos + 1);
          return t4 <= 56319 || t4 >= 57344 ? e5 : (e5 << 10) + t4 - 56613888;
        }, ce2.skipBlockComment = function() {
          var e5 = this.options.onComment && this.curPosition(), t4 = this.pos, i3 = this.input.indexOf("*/", this.pos += 2);
          if (-1 === i3 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = i3 + 2, this.options.locations) for (var s5 = void 0, r7 = t4; (s5 = nextLineBreak2(this.input, r7, this.pos)) > -1; ) ++this.curLine, r7 = this.lineStart = s5;
          this.options.onComment && this.options.onComment(true, this.input.slice(t4 + 2, i3), t4, this.pos, e5, this.curPosition());
        }, ce2.skipLineComment = function(e5) {
          for (var t4 = this.pos, i3 = this.options.onComment && this.curPosition(), s5 = this.input.charCodeAt(this.pos += e5); this.pos < this.input.length && !isNewLine2(s5); ) s5 = this.input.charCodeAt(++this.pos);
          this.options.onComment && this.options.onComment(false, this.input.slice(t4 + e5, this.pos), t4, this.pos, i3, this.curPosition());
        }, ce2.skipSpace = function() {
          e: for (; this.pos < this.input.length; ) {
            var e5 = this.input.charCodeAt(this.pos);
            switch (e5) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break e;
                }
                break;
              default:
                if (!(e5 > 8 && e5 < 14 || e5 >= 5760 && x5.test(String.fromCharCode(e5)))) break e;
                ++this.pos;
            }
          }
        }, ce2.finishToken = function(e5, t4) {
          this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
          var i3 = this.type;
          this.type = e5, this.value = t4, this.updateContext(i3);
        }, ce2.readToken_dot = function() {
          var e5 = this.input.charCodeAt(this.pos + 1);
          if (e5 >= 48 && e5 <= 57) return this.readNumber(true);
          var t4 = this.input.charCodeAt(this.pos + 2);
          return this.options.ecmaVersion >= 6 && 46 === e5 && 46 === t4 ? (this.pos += 3, this.finishToken(f3.ellipsis)) : (++this.pos, this.finishToken(f3.dot));
        }, ce2.readToken_slash = function() {
          var e5 = this.input.charCodeAt(this.pos + 1);
          return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === e5 ? this.finishOp(f3.assign, 2) : this.finishOp(f3.slash, 1);
        }, ce2.readToken_mult_modulo_exp = function(e5) {
          var t4 = this.input.charCodeAt(this.pos + 1), i3 = 1, s5 = 42 === e5 ? f3.star : f3.modulo;
          return this.options.ecmaVersion >= 7 && 42 === e5 && 42 === t4 && (++i3, s5 = f3.starstar, t4 = this.input.charCodeAt(this.pos + 2)), 61 === t4 ? this.finishOp(f3.assign, i3 + 1) : this.finishOp(s5, i3);
        }, ce2.readToken_pipe_amp = function(e5) {
          var t4 = this.input.charCodeAt(this.pos + 1);
          if (t4 === e5) {
            if (this.options.ecmaVersion >= 12) {
              if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(f3.assign, 3);
            }
            return this.finishOp(124 === e5 ? f3.logicalOR : f3.logicalAND, 2);
          }
          return 61 === t4 ? this.finishOp(f3.assign, 2) : this.finishOp(124 === e5 ? f3.bitwiseOR : f3.bitwiseAND, 1);
        }, ce2.readToken_caret = function() {
          return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(f3.assign, 2) : this.finishOp(f3.bitwiseXOR, 1);
        }, ce2.readToken_plus_min = function(e5) {
          var t4 = this.input.charCodeAt(this.pos + 1);
          return t4 === e5 ? 45 !== t4 || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !m4.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(f3.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === t4 ? this.finishOp(f3.assign, 2) : this.finishOp(f3.plusMin, 1);
        }, ce2.readToken_lt_gt = function(e5) {
          var t4 = this.input.charCodeAt(this.pos + 1), i3 = 1;
          return t4 === e5 ? (i3 = 62 === e5 && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + i3) ? this.finishOp(f3.assign, i3 + 1) : this.finishOp(f3.bitShift, i3)) : 33 !== t4 || 60 !== e5 || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === t4 && (i3 = 2), this.finishOp(f3.relational, i3)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
        }, ce2.readToken_eq_excl = function(e5) {
          var t4 = this.input.charCodeAt(this.pos + 1);
          return 61 === t4 ? this.finishOp(f3.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === e5 && 62 === t4 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(f3.arrow)) : this.finishOp(61 === e5 ? f3.eq : f3.prefix, 1);
        }, ce2.readToken_question = function() {
          var e5 = this.options.ecmaVersion;
          if (e5 >= 11) {
            var t4 = this.input.charCodeAt(this.pos + 1);
            if (46 === t4) {
              var i3 = this.input.charCodeAt(this.pos + 2);
              if (i3 < 48 || i3 > 57) return this.finishOp(f3.questionDot, 2);
            }
            if (63 === t4) {
              if (e5 >= 12) {
                if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(f3.assign, 3);
              }
              return this.finishOp(f3.coalesce, 2);
            }
          }
          return this.finishOp(f3.question, 1);
        }, ce2.readToken_numberSign = function() {
          var e5 = 35;
          if (this.options.ecmaVersion >= 13 && (++this.pos, isIdentifierStart2(e5 = this.fullCharCodeAtPos(), true) || 92 === e5)) return this.finishToken(f3.privateId, this.readWord1());
          this.raise(this.pos, "Unexpected character '" + codePointToString2(e5) + "'");
        }, ce2.getTokenFromCode = function(e5) {
          switch (e5) {
            case 46:
              return this.readToken_dot();
            case 40:
              return ++this.pos, this.finishToken(f3.parenL);
            case 41:
              return ++this.pos, this.finishToken(f3.parenR);
            case 59:
              return ++this.pos, this.finishToken(f3.semi);
            case 44:
              return ++this.pos, this.finishToken(f3.comma);
            case 91:
              return ++this.pos, this.finishToken(f3.bracketL);
            case 93:
              return ++this.pos, this.finishToken(f3.bracketR);
            case 123:
              return ++this.pos, this.finishToken(f3.braceL);
            case 125:
              return ++this.pos, this.finishToken(f3.braceR);
            case 58:
              return ++this.pos, this.finishToken(f3.colon);
            case 96:
              if (this.options.ecmaVersion < 6) break;
              return ++this.pos, this.finishToken(f3.backQuote);
            case 48:
              var t4 = this.input.charCodeAt(this.pos + 1);
              if (120 === t4 || 88 === t4) return this.readRadixNumber(16);
              if (this.options.ecmaVersion >= 6) {
                if (111 === t4 || 79 === t4) return this.readRadixNumber(8);
                if (98 === t4 || 66 === t4) return this.readRadixNumber(2);
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(false);
            case 34:
            case 39:
              return this.readString(e5);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(e5);
            case 124:
            case 38:
              return this.readToken_pipe_amp(e5);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(e5);
            case 60:
            case 62:
              return this.readToken_lt_gt(e5);
            case 61:
            case 33:
              return this.readToken_eq_excl(e5);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(f3.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + codePointToString2(e5) + "'");
        }, ce2.finishOp = function(e5, t4) {
          var i3 = this.input.slice(this.pos, this.pos + t4);
          return this.pos += t4, this.finishToken(e5, i3);
        }, ce2.readRegexp = function() {
          for (var e5, t4, i3 = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(i3, "Unterminated regular expression");
            var s5 = this.input.charAt(this.pos);
            if (m4.test(s5) && this.raise(i3, "Unterminated regular expression"), e5) e5 = false;
            else {
              if ("[" === s5) t4 = true;
              else if ("]" === s5 && t4) t4 = false;
              else if ("/" === s5 && !t4) break;
              e5 = "\\" === s5;
            }
            ++this.pos;
          }
          var r7 = this.input.slice(i3, this.pos);
          ++this.pos;
          var n2 = this.pos, a4 = this.readWord1();
          this.containsEsc && this.unexpected(n2);
          var o2 = this.regexpState || (this.regexpState = new acorn_RegExpValidationState(this));
          o2.reset(i3, r7, a4), this.validateRegExpFlags(o2), this.validateRegExpPattern(o2);
          var h9 = null;
          try {
            h9 = new RegExp(r7, a4);
          } catch (e6) {
          }
          return this.finishToken(f3.regexp, { pattern: r7, flags: a4, value: h9 });
        }, ce2.readInt = function(e5, t4, i3) {
          for (var s5 = this.options.ecmaVersion >= 12 && void 0 === t4, r7 = i3 && 48 === this.input.charCodeAt(this.pos), n2 = this.pos, a4 = 0, o2 = 0, h9 = 0, c3 = null == t4 ? 1 / 0 : t4; h9 < c3; ++h9, ++this.pos) {
            var p4 = this.input.charCodeAt(this.pos), l4 = void 0;
            if (s5 && 95 === p4) r7 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), 95 === o2 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), 0 === h9 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o2 = p4;
            else {
              if ((l4 = p4 >= 97 ? p4 - 97 + 10 : p4 >= 65 ? p4 - 65 + 10 : p4 >= 48 && p4 <= 57 ? p4 - 48 : 1 / 0) >= e5) break;
              o2 = p4, a4 = a4 * e5 + l4;
            }
          }
          return s5 && 95 === o2 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === n2 || null != t4 && this.pos - n2 !== t4 ? null : a4;
        }, ce2.readRadixNumber = function(e5) {
          var t4 = this.pos;
          this.pos += 2;
          var i3 = this.readInt(e5);
          return null == i3 && this.raise(this.start + 2, "Expected number in radix " + e5), this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (i3 = stringToBigInt2(this.input.slice(t4, this.pos)), ++this.pos) : isIdentifierStart2(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(f3.num, i3);
        }, ce2.readNumber = function(e5) {
          var t4 = this.pos;
          e5 || null !== this.readInt(10, void 0, true) || this.raise(t4, "Invalid number");
          var i3 = this.pos - t4 >= 2 && 48 === this.input.charCodeAt(t4);
          i3 && this.strict && this.raise(t4, "Invalid number");
          var s5 = this.input.charCodeAt(this.pos);
          if (!i3 && !e5 && this.options.ecmaVersion >= 11 && 110 === s5) {
            var r7 = stringToBigInt2(this.input.slice(t4, this.pos));
            return ++this.pos, isIdentifierStart2(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(f3.num, r7);
          }
          i3 && /[89]/.test(this.input.slice(t4, this.pos)) && (i3 = false), 46 !== s5 || i3 || (++this.pos, this.readInt(10), s5 = this.input.charCodeAt(this.pos)), 69 !== s5 && 101 !== s5 || i3 || (43 !== (s5 = this.input.charCodeAt(++this.pos)) && 45 !== s5 || ++this.pos, null === this.readInt(10) && this.raise(t4, "Invalid number")), isIdentifierStart2(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
          var n2, a4 = (n2 = this.input.slice(t4, this.pos), i3 ? parseInt(n2, 8) : parseFloat(n2.replace(/_/g, "")));
          return this.finishToken(f3.num, a4);
        }, ce2.readCodePoint = function() {
          var e5;
          if (123 === this.input.charCodeAt(this.pos)) {
            this.options.ecmaVersion < 6 && this.unexpected();
            var t4 = ++this.pos;
            e5 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e5 > 1114111 && this.invalidStringToken(t4, "Code point out of bounds");
          } else e5 = this.readHexChar(4);
          return e5;
        }, ce2.readString = function(e5) {
          for (var t4 = "", i3 = ++this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            var s5 = this.input.charCodeAt(this.pos);
            if (s5 === e5) break;
            92 === s5 ? (t4 += this.input.slice(i3, this.pos), t4 += this.readEscapedChar(false), i3 = this.pos) : 8232 === s5 || 8233 === s5 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (isNewLine2(s5) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
          }
          return t4 += this.input.slice(i3, this.pos++), this.finishToken(f3.string, t4);
        };
        var pe2 = {};
        ce2.tryReadTemplateToken = function() {
          this.inTemplateElement = true;
          try {
            this.readTmplToken();
          } catch (e5) {
            if (e5 !== pe2) throw e5;
            this.readInvalidTemplateToken();
          }
          this.inTemplateElement = false;
        }, ce2.invalidStringToken = function(e5, t4) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw pe2;
          this.raise(e5, t4);
        }, ce2.readTmplToken = function() {
          for (var e5 = "", t4 = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
            var i3 = this.input.charCodeAt(this.pos);
            if (96 === i3 || 36 === i3 && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== f3.template && this.type !== f3.invalidTemplate ? (e5 += this.input.slice(t4, this.pos), this.finishToken(f3.template, e5)) : 36 === i3 ? (this.pos += 2, this.finishToken(f3.dollarBraceL)) : (++this.pos, this.finishToken(f3.backQuote));
            if (92 === i3) e5 += this.input.slice(t4, this.pos), e5 += this.readEscapedChar(true), t4 = this.pos;
            else if (isNewLine2(i3)) {
              switch (e5 += this.input.slice(t4, this.pos), ++this.pos, i3) {
                case 13:
                  10 === this.input.charCodeAt(this.pos) && ++this.pos;
                case 10:
                  e5 += "\n";
                  break;
                default:
                  e5 += String.fromCharCode(i3);
              }
              this.options.locations && (++this.curLine, this.lineStart = this.pos), t4 = this.pos;
            } else ++this.pos;
          }
        }, ce2.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if ("{" !== this.input[this.pos + 1]) break;
            case "`":
              return this.finishToken(f3.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              "\n" === this.input[this.pos + 1] && ++this.pos;
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine, this.lineStart = this.pos + 1;
          }
          this.raise(this.start, "Unterminated template");
        }, ce2.readEscapedChar = function(e5) {
          var t4 = this.input.charCodeAt(++this.pos);
          switch (++this.pos, t4) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return codePointToString2(this.readCodePoint());
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              10 === this.input.charCodeAt(this.pos) && ++this.pos;
            case 10:
              return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
            case 56:
            case 57:
              if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), e5) {
                var i3 = this.pos - 1;
                this.invalidStringToken(i3, "Invalid escape sequence in template string");
              }
            default:
              if (t4 >= 48 && t4 <= 55) {
                var s5 = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], r7 = parseInt(s5, 8);
                return r7 > 255 && (s5 = s5.slice(0, -1), r7 = parseInt(s5, 8)), this.pos += s5.length - 1, t4 = this.input.charCodeAt(this.pos), "0" === s5 && 56 !== t4 && 57 !== t4 || !this.strict && !e5 || this.invalidStringToken(this.pos - 1 - s5.length, e5 ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(r7);
              }
              return isNewLine2(t4) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t4);
          }
        }, ce2.readHexChar = function(e5) {
          var t4 = this.pos, i3 = this.readInt(16, e5);
          return null === i3 && this.invalidStringToken(t4, "Bad character escape sequence"), i3;
        }, ce2.readWord1 = function() {
          this.containsEsc = false;
          for (var e5 = "", t4 = true, i3 = this.pos, s5 = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
            var r7 = this.fullCharCodeAtPos();
            if (isIdentifierChar2(r7, s5)) this.pos += r7 <= 65535 ? 1 : 2;
            else {
              if (92 !== r7) break;
              this.containsEsc = true, e5 += this.input.slice(i3, this.pos);
              var n2 = this.pos;
              117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
              var a4 = this.readCodePoint();
              (t4 ? isIdentifierStart2 : isIdentifierChar2)(a4, s5) || this.invalidStringToken(n2, "Invalid Unicode escape"), e5 += codePointToString2(a4), i3 = this.pos;
            }
            t4 = false;
          }
          return e5 + this.input.slice(i3, this.pos);
        }, ce2.readWord = function() {
          var e5 = this.readWord1(), t4 = f3.name;
          return this.keywords.test(e5) && (t4 = d4[e5]), this.finishToken(t4, e5);
        };
        acorn_Parser.acorn = { Parser: acorn_Parser, version: "8.15.0", defaultOptions: I5, Position: acorn_Position, SourceLocation: acorn_SourceLocation, getLineInfo: getLineInfo2, Node: acorn_Node, TokenType: acorn_TokenType, tokTypes: f3, keywordTypes: d4, TokContext: acorn_TokContext, tokContexts: F2, isIdentifierChar: isIdentifierChar2, isIdentifierStart: isIdentifierStart2, Token: acorn_Token, isNewLine: isNewLine2, lineBreak: m4, lineBreakG: g4, nonASCIIwhitespace: x5 };
        const le3 = require("module"), ue3 = require("fs");
        String.fromCharCode;
        const de3 = /\/$|\/\?|\/#/, fe4 = /^\.?\//;
        function hasTrailingSlash2(e5 = "", t4) {
          return t4 ? de3.test(e5) : e5.endsWith("/");
        }
        function withTrailingSlash2(e5 = "", t4) {
          if (!t4) return e5.endsWith("/") ? e5 : e5 + "/";
          if (hasTrailingSlash2(e5, true)) return e5 || "/";
          let i3 = e5, s5 = "";
          const r7 = e5.indexOf("#");
          if (-1 !== r7 && (i3 = e5.slice(0, r7), s5 = e5.slice(r7), !i3)) return s5;
          const [n2, ...a4] = i3.split("?");
          return n2 + "/" + (a4.length > 0 ? `?${a4.join("?")}` : "") + s5;
        }
        function isNonEmptyURL2(e5) {
          return e5 && "/" !== e5;
        }
        function dist_joinURL(e5, ...t4) {
          let i3 = e5 || "";
          for (const e6 of t4.filter((e7) => isNonEmptyURL2(e7))) if (i3) {
            const t5 = e6.replace(fe4, "");
            i3 = withTrailingSlash2(i3) + t5;
          } else i3 = e6;
          return i3;
        }
        Symbol.for("ufo:protocolRelative");
        const me3 = /^[A-Za-z]:\//;
        function pathe_M_eThtNZ_normalizeWindowsPath(e5 = "") {
          return e5 ? e5.replace(/\\/g, "/").replace(me3, (e6) => e6.toUpperCase()) : e5;
        }
        const ge3 = /^[/\\]{2}/, xe3 = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/, ve2 = /^[A-Za-z]:$/, ye2 = /.(\.[^./]+|\.)$/, pathe_M_eThtNZ_normalize = function(e5) {
          if (0 === e5.length) return ".";
          const t4 = (e5 = pathe_M_eThtNZ_normalizeWindowsPath(e5)).match(ge3), i3 = isAbsolute2(e5), s5 = "/" === e5[e5.length - 1];
          return 0 === (e5 = normalizeString2(e5, !i3)).length ? i3 ? "/" : s5 ? "./" : "." : (s5 && (e5 += "/"), ve2.test(e5) && (e5 += "/"), t4 ? i3 ? `//${e5}` : `//./${e5}` : i3 && !isAbsolute2(e5) ? `/${e5}` : e5);
        }, pathe_M_eThtNZ_join = function(...e5) {
          let t4 = "";
          for (const i3 of e5) if (i3) if (t4.length > 0) {
            const e6 = "/" === t4[t4.length - 1], s5 = "/" === i3[0];
            t4 += e6 && s5 ? i3.slice(1) : e6 || s5 ? i3 : `/${i3}`;
          } else t4 += i3;
          return pathe_M_eThtNZ_normalize(t4);
        };
        function pathe_M_eThtNZ_cwd() {
          return "undefined" != typeof process && "function" == typeof process.cwd ? process.cwd().replace(/\\/g, "/") : "/";
        }
        const pathe_M_eThtNZ_resolve = function(...e5) {
          let t4 = "", i3 = false;
          for (let s5 = (e5 = e5.map((e6) => pathe_M_eThtNZ_normalizeWindowsPath(e6))).length - 1; s5 >= -1 && !i3; s5--) {
            const r7 = s5 >= 0 ? e5[s5] : pathe_M_eThtNZ_cwd();
            r7 && 0 !== r7.length && (t4 = `${r7}/${t4}`, i3 = isAbsolute2(r7));
          }
          return t4 = normalizeString2(t4, !i3), i3 && !isAbsolute2(t4) ? `/${t4}` : t4.length > 0 ? t4 : ".";
        };
        function normalizeString2(e5, t4) {
          let i3 = "", s5 = 0, r7 = -1, n2 = 0, a4 = null;
          for (let o2 = 0; o2 <= e5.length; ++o2) {
            if (o2 < e5.length) a4 = e5[o2];
            else {
              if ("/" === a4) break;
              a4 = "/";
            }
            if ("/" === a4) {
              if (r7 === o2 - 1 || 1 === n2) ;
              else if (2 === n2) {
                if (i3.length < 2 || 2 !== s5 || "." !== i3[i3.length - 1] || "." !== i3[i3.length - 2]) {
                  if (i3.length > 2) {
                    const e6 = i3.lastIndexOf("/");
                    -1 === e6 ? (i3 = "", s5 = 0) : (i3 = i3.slice(0, e6), s5 = i3.length - 1 - i3.lastIndexOf("/")), r7 = o2, n2 = 0;
                    continue;
                  }
                  if (i3.length > 0) {
                    i3 = "", s5 = 0, r7 = o2, n2 = 0;
                    continue;
                  }
                }
                t4 && (i3 += i3.length > 0 ? "/.." : "..", s5 = 2);
              } else i3.length > 0 ? i3 += `/${e5.slice(r7 + 1, o2)}` : i3 = e5.slice(r7 + 1, o2), s5 = o2 - r7 - 1;
              r7 = o2, n2 = 0;
            } else "." === a4 && -1 !== n2 ? ++n2 : n2 = -1;
          }
          return i3;
        }
        const isAbsolute2 = function(e5) {
          return xe3.test(e5);
        }, extname3 = function(e5) {
          if (".." === e5) return "";
          const t4 = ye2.exec(pathe_M_eThtNZ_normalizeWindowsPath(e5));
          return t4 && t4[1] || "";
        }, pathe_M_eThtNZ_dirname = function(e5) {
          const t4 = pathe_M_eThtNZ_normalizeWindowsPath(e5).replace(/\/$/, "").split("/").slice(0, -1);
          return 1 === t4.length && ve2.test(t4[0]) && (t4[0] += "/"), t4.join("/") || (isAbsolute2(e5) ? "/" : ".");
        }, basename3 = function(e5, t4) {
          const i3 = pathe_M_eThtNZ_normalizeWindowsPath(e5).split("/");
          let s5 = "";
          for (let e6 = i3.length - 1; e6 >= 0; e6--) {
            const t5 = i3[e6];
            if (t5) {
              s5 = t5;
              break;
            }
          }
          return t4 && s5.endsWith(t4) ? s5.slice(0, -t4.length) : s5;
        }, _e2 = require("url"), Ee3 = require("assert"), be3 = require("process"), Se2 = require("path"), ke2 = require("v8"), we3 = require("util"), Ie2 = new Set(le3.builtinModules);
        function normalizeSlash2(e5) {
          return e5.replace(/\\/g, "/");
        }
        const Ce2 = {}.hasOwnProperty, Re2 = /^([A-Z][a-z\d]*)+$/, Pe2 = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), Te2 = {};
        function formatList2(e5, t4 = "and") {
          return e5.length < 3 ? e5.join(` ${t4} `) : `${e5.slice(0, -1).join(", ")}, ${t4} ${e5[e5.length - 1]}`;
        }
        const Ae = /* @__PURE__ */ new Map();
        let Ne2;
        function createError2(e5, t4, i3) {
          return Ae.set(e5, t4), /* @__PURE__ */ (function(e6, t5) {
            return NodeError;
            function NodeError(...i4) {
              const s5 = Error.stackTraceLimit;
              isErrorStackTraceLimitWritable2() && (Error.stackTraceLimit = 0);
              const r7 = new e6();
              isErrorStackTraceLimitWritable2() && (Error.stackTraceLimit = s5);
              const n2 = (function(e7, t6, i5) {
                const s6 = Ae.get(e7);
                if (Ee3(void 0 !== s6, "expected `message` to be found"), "function" == typeof s6) return Ee3(s6.length <= t6.length, `Code: ${e7}; The provided arguments length (${t6.length}) does not match the required ones (${s6.length}).`), Reflect.apply(s6, i5, t6);
                const r8 = /%[dfijoOs]/g;
                let n3 = 0;
                for (; null !== r8.exec(s6); ) n3++;
                return Ee3(n3 === t6.length, `Code: ${e7}; The provided arguments length (${t6.length}) does not match the required ones (${n3}).`), 0 === t6.length ? s6 : (t6.unshift(s6), Reflect.apply(we3.format, null, t6));
              })(t5, i4, r7);
              return Object.defineProperties(r7, { message: { value: n2, enumerable: false, writable: true, configurable: true }, toString: { value() {
                return `${this.name} [${t5}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true } }), Le2(r7), r7.code = t5, r7;
            }
          })(i3, e5);
        }
        function isErrorStackTraceLimitWritable2() {
          try {
            if (ke2.startupSnapshot.isBuildingSnapshot()) return false;
          } catch {
          }
          const e5 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return void 0 === e5 ? Object.isExtensible(Error) : Ce2.call(e5, "writable") && void 0 !== e5.writable ? e5.writable : void 0 !== e5.set;
        }
        Te2.ERR_INVALID_ARG_TYPE = createError2("ERR_INVALID_ARG_TYPE", (e5, t4, i3) => {
          Ee3("string" == typeof e5, "'name' must be a string"), Array.isArray(t4) || (t4 = [t4]);
          let s5 = "The ";
          if (e5.endsWith(" argument")) s5 += `${e5} `;
          else {
            const t5 = e5.includes(".") ? "property" : "argument";
            s5 += `"${e5}" ${t5} `;
          }
          s5 += "must be ";
          const r7 = [], n2 = [], a4 = [];
          for (const e6 of t4) Ee3("string" == typeof e6, "All expected entries have to be of type string"), Pe2.has(e6) ? r7.push(e6.toLowerCase()) : null === Re2.exec(e6) ? (Ee3("object" !== e6, 'The value "object" should be written as "Object"'), a4.push(e6)) : n2.push(e6);
          if (n2.length > 0) {
            const e6 = r7.indexOf("object");
            -1 !== e6 && (r7.slice(e6, 1), n2.push("Object"));
          }
          return r7.length > 0 && (s5 += `${r7.length > 1 ? "one of type" : "of type"} ${formatList2(r7, "or")}`, (n2.length > 0 || a4.length > 0) && (s5 += " or ")), n2.length > 0 && (s5 += `an instance of ${formatList2(n2, "or")}`, a4.length > 0 && (s5 += " or ")), a4.length > 0 && (a4.length > 1 ? s5 += `one of ${formatList2(a4, "or")}` : (a4[0].toLowerCase() !== a4[0] && (s5 += "an "), s5 += `${a4[0]}`)), s5 += `. Received ${(function(e6) {
            if (null == e6) return String(e6);
            if ("function" == typeof e6 && e6.name) return `function ${e6.name}`;
            if ("object" == typeof e6) return e6.constructor && e6.constructor.name ? `an instance of ${e6.constructor.name}` : `${(0, we3.inspect)(e6, { depth: -1 })}`;
            let t5 = (0, we3.inspect)(e6, { colors: false });
            t5.length > 28 && (t5 = `${t5.slice(0, 25)}...`);
            return `type ${typeof e6} (${t5})`;
          })(i3)}`, s5;
        }, TypeError), Te2.ERR_INVALID_MODULE_SPECIFIER = createError2("ERR_INVALID_MODULE_SPECIFIER", (e5, t4, i3 = void 0) => `Invalid module "${e5}" ${t4}${i3 ? ` imported from ${i3}` : ""}`, TypeError), Te2.ERR_INVALID_PACKAGE_CONFIG = createError2("ERR_INVALID_PACKAGE_CONFIG", (e5, t4, i3) => `Invalid package config ${e5}${t4 ? ` while importing ${t4}` : ""}${i3 ? `. ${i3}` : ""}`, Error), Te2.ERR_INVALID_PACKAGE_TARGET = createError2("ERR_INVALID_PACKAGE_TARGET", (e5, t4, i3, s5 = false, r7 = void 0) => {
          const n2 = "string" == typeof i3 && !s5 && i3.length > 0 && !i3.startsWith("./");
          return "." === t4 ? (Ee3(false === s5), `Invalid "exports" main target ${JSON.stringify(i3)} defined in the package config ${e5}package.json${r7 ? ` imported from ${r7}` : ""}${n2 ? '; targets must start with "./"' : ""}`) : `Invalid "${s5 ? "imports" : "exports"}" target ${JSON.stringify(i3)} defined for '${t4}' in the package config ${e5}package.json${r7 ? ` imported from ${r7}` : ""}${n2 ? '; targets must start with "./"' : ""}`;
        }, Error), Te2.ERR_MODULE_NOT_FOUND = createError2("ERR_MODULE_NOT_FOUND", (e5, t4, i3 = false) => `Cannot find ${i3 ? "module" : "package"} '${e5}' imported from ${t4}`, Error), Te2.ERR_NETWORK_IMPORT_DISALLOWED = createError2("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), Te2.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError2("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e5, t4, i3) => `Package import specifier "${e5}" is not defined${t4 ? ` in package ${t4}package.json` : ""} imported from ${i3}`, TypeError), Te2.ERR_PACKAGE_PATH_NOT_EXPORTED = createError2("ERR_PACKAGE_PATH_NOT_EXPORTED", (e5, t4, i3 = void 0) => "." === t4 ? `No "exports" main defined in ${e5}package.json${i3 ? ` imported from ${i3}` : ""}` : `Package subpath '${t4}' is not defined by "exports" in ${e5}package.json${i3 ? ` imported from ${i3}` : ""}`, Error), Te2.ERR_UNSUPPORTED_DIR_IMPORT = createError2("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), Te2.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError2("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError), Te2.ERR_UNKNOWN_FILE_EXTENSION = createError2("ERR_UNKNOWN_FILE_EXTENSION", (e5, t4) => `Unknown file extension "${e5}" for ${t4}`, TypeError), Te2.ERR_INVALID_ARG_VALUE = createError2("ERR_INVALID_ARG_VALUE", (e5, t4, i3 = "is invalid") => {
          let s5 = (0, we3.inspect)(t4);
          s5.length > 128 && (s5 = `${s5.slice(0, 128)}...`);
          return `The ${e5.includes(".") ? "property" : "argument"} '${e5}' ${i3}. Received ${s5}`;
        }, TypeError);
        const Le2 = (function(e5) {
          const t4 = "__node_internal_" + e5.name;
          return Object.defineProperty(e5, "name", { value: t4 }), e5;
        })(function(e5) {
          const t4 = isErrorStackTraceLimitWritable2();
          return t4 && (Ne2 = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(e5), t4 && (Error.stackTraceLimit = Ne2), e5;
        });
        const Oe2 = {}.hasOwnProperty, { ERR_INVALID_PACKAGE_CONFIG: De2 } = Te2, Ve2 = /* @__PURE__ */ new Map();
        function read3(e5, { base: t4, specifier: i3 }) {
          const s5 = Ve2.get(e5);
          if (s5) return s5;
          let r7;
          try {
            r7 = ue3.readFileSync(Se2.toNamespacedPath(e5), "utf8");
          } catch (e6) {
            const t5 = e6;
            if ("ENOENT" !== t5.code) throw t5;
          }
          const n2 = { exists: false, pjsonPath: e5, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          if (void 0 !== r7) {
            let s6;
            try {
              s6 = JSON.parse(r7);
            } catch (s7) {
              const r8 = s7, n3 = new De2(e5, (t4 ? `"${i3}" from ` : "") + (0, _e2.fileURLToPath)(t4 || i3), r8.message);
              throw n3.cause = r8, n3;
            }
            n2.exists = true, Oe2.call(s6, "name") && "string" == typeof s6.name && (n2.name = s6.name), Oe2.call(s6, "main") && "string" == typeof s6.main && (n2.main = s6.main), Oe2.call(s6, "exports") && (n2.exports = s6.exports), Oe2.call(s6, "imports") && (n2.imports = s6.imports), !Oe2.call(s6, "type") || "commonjs" !== s6.type && "module" !== s6.type || (n2.type = s6.type);
          }
          return Ve2.set(e5, n2), n2;
        }
        function getPackageScopeConfig2(e5) {
          let t4 = new URL("package.json", e5);
          for (; ; ) {
            if (t4.pathname.endsWith("node_modules/package.json")) break;
            const i3 = read3((0, _e2.fileURLToPath)(t4), { specifier: e5 });
            if (i3.exists) return i3;
            const s5 = t4;
            if (t4 = new URL("../package.json", t4), t4.pathname === s5.pathname) break;
          }
          return { pjsonPath: (0, _e2.fileURLToPath)(t4), exists: false, type: "none" };
        }
        function getPackageType2(e5) {
          return getPackageScopeConfig2(e5).type;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: Ue2 } = Te2, Me2 = {}.hasOwnProperty, je2 = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" };
        const Fe2 = { __proto__: null, "data:": function(e5) {
          const { 1: t4 } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e5.pathname) || [null, null, null];
          return (function(e6) {
            return e6 && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e6) ? "module" : "application/json" === e6 ? "json" : null;
          })(t4);
        }, "file:": function(e5, t4, i3) {
          const s5 = (function(e6) {
            const t5 = e6.pathname;
            let i4 = t5.length;
            for (; i4--; ) {
              const e7 = t5.codePointAt(i4);
              if (47 === e7) return "";
              if (46 === e7) return 47 === t5.codePointAt(i4 - 1) ? "" : t5.slice(i4);
            }
            return "";
          })(e5);
          if (".js" === s5) {
            const t5 = getPackageType2(e5);
            return "none" !== t5 ? t5 : "commonjs";
          }
          if ("" === s5) {
            const t5 = getPackageType2(e5);
            return "none" === t5 || "commonjs" === t5 ? "commonjs" : "module";
          }
          const r7 = je2[s5];
          if (r7) return r7;
          if (i3) return;
          const n2 = (0, _e2.fileURLToPath)(e5);
          throw new Ue2(s5, n2);
        }, "http:": getHttpProtocolModuleFormat2, "https:": getHttpProtocolModuleFormat2, "node:": () => "builtin" };
        function getHttpProtocolModuleFormat2() {
        }
        const Be2 = RegExp.prototype[Symbol.replace], { ERR_INVALID_MODULE_SPECIFIER: $e2, ERR_INVALID_PACKAGE_CONFIG: qe, ERR_INVALID_PACKAGE_TARGET: We2, ERR_MODULE_NOT_FOUND: Ge, ERR_PACKAGE_IMPORT_NOT_DEFINED: He2, ERR_PACKAGE_PATH_NOT_EXPORTED: Ke2, ERR_UNSUPPORTED_DIR_IMPORT: ze2, ERR_UNSUPPORTED_RESOLVE_REQUEST: Je2 } = Te2, Ye2 = {}.hasOwnProperty, Qe2 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, Ze2 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, Xe2 = /^\.|%|\\/, et2 = /\*/g, tt = /%2f|%5c/i, it = /* @__PURE__ */ new Set(), st = /[/\\]{2}/;
        function emitInvalidSegmentDeprecation2(e5, t4, i3, s5, r7, n2, a4) {
          if (be3.noDeprecation) return;
          const o2 = (0, _e2.fileURLToPath)(s5), h9 = null !== st.exec(a4 ? e5 : t4);
          be3.emitWarning(`Use of deprecated ${h9 ? "double slash" : "leading or trailing slash matching"} resolving "${e5}" for module request "${t4}" ${t4 === i3 ? "" : `matched to "${i3}" `}in the "${r7 ? "imports" : "exports"}" field module resolution of the package at ${o2}${n2 ? ` imported from ${(0, _e2.fileURLToPath)(n2)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function emitLegacyIndexDeprecation2(e5, t4, i3, s5) {
          if (be3.noDeprecation) return;
          const r7 = (function(e6, t5) {
            const i4 = e6.protocol;
            return Me2.call(Fe2, i4) && Fe2[i4](e6, t5, true) || null;
          })(e5, { parentURL: i3.href });
          if ("module" !== r7) return;
          const n2 = (0, _e2.fileURLToPath)(e5.href), a4 = (0, _e2.fileURLToPath)(new _e2.URL(".", t4)), o2 = (0, _e2.fileURLToPath)(i3);
          s5 ? Se2.resolve(a4, s5) !== n2 && be3.emitWarning(`Package ${a4} has a "main" field set to "${s5}", excluding the full filename and extension to the resolved file at "${n2.slice(a4.length)}", imported from ${o2}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : be3.emitWarning(`No "main" or "exports" field defined in the package.json for ${a4} resolving the main entry point "${n2.slice(a4.length)}", imported from ${o2}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function tryStatSync2(e5) {
          try {
            return (0, ue3.statSync)(e5);
          } catch {
          }
        }
        function fileExists2(e5) {
          const t4 = (0, ue3.statSync)(e5, { throwIfNoEntry: false }), i3 = t4 ? t4.isFile() : void 0;
          return null != i3 && i3;
        }
        function legacyMainResolve2(e5, t4, i3) {
          let s5;
          if (void 0 !== t4.main) {
            if (s5 = new _e2.URL(t4.main, e5), fileExists2(s5)) return s5;
            const r8 = [`./${t4.main}.js`, `./${t4.main}.json`, `./${t4.main}.node`, `./${t4.main}/index.js`, `./${t4.main}/index.json`, `./${t4.main}/index.node`];
            let n3 = -1;
            for (; ++n3 < r8.length && (s5 = new _e2.URL(r8[n3], e5), !fileExists2(s5)); ) s5 = void 0;
            if (s5) return emitLegacyIndexDeprecation2(s5, e5, i3, t4.main), s5;
          }
          const r7 = ["./index.js", "./index.json", "./index.node"];
          let n2 = -1;
          for (; ++n2 < r7.length && (s5 = new _e2.URL(r7[n2], e5), !fileExists2(s5)); ) s5 = void 0;
          if (s5) return emitLegacyIndexDeprecation2(s5, e5, i3, t4.main), s5;
          throw new Ge((0, _e2.fileURLToPath)(new _e2.URL(".", e5)), (0, _e2.fileURLToPath)(i3));
        }
        function exportsNotFound2(e5, t4, i3) {
          return new Ke2((0, _e2.fileURLToPath)(new _e2.URL(".", t4)), e5, i3 && (0, _e2.fileURLToPath)(i3));
        }
        function invalidPackageTarget2(e5, t4, i3, s5, r7) {
          return t4 = "object" == typeof t4 && null !== t4 ? JSON.stringify(t4, null, "") : `${t4}`, new We2((0, _e2.fileURLToPath)(new _e2.URL(".", i3)), e5, t4, s5, r7 && (0, _e2.fileURLToPath)(r7));
        }
        function resolvePackageTargetString2(e5, t4, i3, s5, r7, n2, a4, o2, h9) {
          if ("" !== t4 && !n2 && "/" !== e5[e5.length - 1]) throw invalidPackageTarget2(i3, e5, s5, a4, r7);
          if (!e5.startsWith("./")) {
            if (a4 && !e5.startsWith("../") && !e5.startsWith("/")) {
              let i4 = false;
              try {
                new _e2.URL(e5), i4 = true;
              } catch {
              }
              if (!i4) {
                return packageResolve2(n2 ? Be2.call(et2, e5, () => t4) : e5 + t4, s5, h9);
              }
            }
            throw invalidPackageTarget2(i3, e5, s5, a4, r7);
          }
          if (null !== Qe2.exec(e5.slice(2))) {
            if (null !== Ze2.exec(e5.slice(2))) throw invalidPackageTarget2(i3, e5, s5, a4, r7);
            if (!o2) {
              const o3 = n2 ? i3.replace("*", () => t4) : i3 + t4;
              emitInvalidSegmentDeprecation2(n2 ? Be2.call(et2, e5, () => t4) : e5, o3, i3, s5, a4, r7, true);
            }
          }
          const c3 = new _e2.URL(e5, s5), p4 = c3.pathname, l4 = new _e2.URL(".", s5).pathname;
          if (!p4.startsWith(l4)) throw invalidPackageTarget2(i3, e5, s5, a4, r7);
          if ("" === t4) return c3;
          if (null !== Qe2.exec(t4)) {
            const h10 = n2 ? i3.replace("*", () => t4) : i3 + t4;
            if (null === Ze2.exec(t4)) {
              if (!o2) {
                emitInvalidSegmentDeprecation2(n2 ? Be2.call(et2, e5, () => t4) : e5, h10, i3, s5, a4, r7, false);
              }
            } else !(function(e6, t5, i4, s6, r8) {
              const n3 = `request is not a valid match in pattern "${t5}" for the "${s6 ? "imports" : "exports"}" resolution of ${(0, _e2.fileURLToPath)(i4)}`;
              throw new $e2(e6, n3, r8 && (0, _e2.fileURLToPath)(r8));
            })(h10, i3, s5, a4, r7);
          }
          return n2 ? new _e2.URL(Be2.call(et2, c3.href, () => t4)) : new _e2.URL(t4, c3);
        }
        function isArrayIndex2(e5) {
          const t4 = Number(e5);
          return `${t4}` === e5 && (t4 >= 0 && t4 < 4294967295);
        }
        function resolvePackageTarget2(e5, t4, i3, s5, r7, n2, a4, o2, h9) {
          if ("string" == typeof t4) return resolvePackageTargetString2(t4, i3, s5, e5, r7, n2, a4, o2, h9);
          if (Array.isArray(t4)) {
            const c3 = t4;
            if (0 === c3.length) return null;
            let p4, l4 = -1;
            for (; ++l4 < c3.length; ) {
              const t5 = c3[l4];
              let u5;
              try {
                u5 = resolvePackageTarget2(e5, t5, i3, s5, r7, n2, a4, o2, h9);
              } catch (e6) {
                if (p4 = e6, "ERR_INVALID_PACKAGE_TARGET" === e6.code) continue;
                throw e6;
              }
              if (void 0 !== u5) {
                if (null !== u5) return u5;
                p4 = null;
              }
            }
            if (null == p4) return null;
            throw p4;
          }
          if ("object" == typeof t4 && null !== t4) {
            const c3 = Object.getOwnPropertyNames(t4);
            let p4 = -1;
            for (; ++p4 < c3.length; ) {
              if (isArrayIndex2(c3[p4])) throw new qe((0, _e2.fileURLToPath)(e5), r7, '"exports" cannot contain numeric property keys.');
            }
            for (p4 = -1; ++p4 < c3.length; ) {
              const l4 = c3[p4];
              if ("default" === l4 || h9 && h9.has(l4)) {
                const c4 = resolvePackageTarget2(e5, t4[l4], i3, s5, r7, n2, a4, o2, h9);
                if (void 0 === c4) continue;
                return c4;
              }
            }
            return null;
          }
          if (null === t4) return null;
          throw invalidPackageTarget2(s5, t4, e5, a4, r7);
        }
        function emitTrailingSlashPatternDeprecation2(e5, t4, i3) {
          if (be3.noDeprecation) return;
          const s5 = (0, _e2.fileURLToPath)(t4);
          it.has(s5 + "|" + e5) || (it.add(s5 + "|" + e5), be3.emitWarning(`Use of deprecated trailing slash pattern mapping "${e5}" in the "exports" field module resolution of the package at ${s5}${i3 ? ` imported from ${(0, _e2.fileURLToPath)(i3)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function packageExportsResolve2(e5, t4, i3, s5, r7) {
          let n2 = i3.exports;
          if ((function(e6, t5, i4) {
            if ("string" == typeof e6 || Array.isArray(e6)) return true;
            if ("object" != typeof e6 || null === e6) return false;
            const s6 = Object.getOwnPropertyNames(e6);
            let r8 = false, n3 = 0, a5 = -1;
            for (; ++a5 < s6.length; ) {
              const e7 = s6[a5], o3 = "" === e7 || "." !== e7[0];
              if (0 === n3++) r8 = o3;
              else if (r8 !== o3) throw new qe((0, _e2.fileURLToPath)(t5), i4, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return r8;
          })(n2, e5, s5) && (n2 = { ".": n2 }), Ye2.call(n2, t4) && !t4.includes("*") && !t4.endsWith("/")) {
            const i4 = resolvePackageTarget2(e5, n2[t4], "", t4, s5, false, false, false, r7);
            if (null == i4) throw exportsNotFound2(t4, e5, s5);
            return i4;
          }
          let a4 = "", o2 = "";
          const h9 = Object.getOwnPropertyNames(n2);
          let c3 = -1;
          for (; ++c3 < h9.length; ) {
            const i4 = h9[c3], r8 = i4.indexOf("*");
            if (-1 !== r8 && t4.startsWith(i4.slice(0, r8))) {
              t4.endsWith("/") && emitTrailingSlashPatternDeprecation2(t4, e5, s5);
              const n3 = i4.slice(r8 + 1);
              t4.length >= i4.length && t4.endsWith(n3) && 1 === patternKeyCompare2(a4, i4) && i4.lastIndexOf("*") === r8 && (a4 = i4, o2 = t4.slice(r8, t4.length - n3.length));
            }
          }
          if (a4) {
            const i4 = resolvePackageTarget2(e5, n2[a4], o2, a4, s5, true, false, t4.endsWith("/"), r7);
            if (null == i4) throw exportsNotFound2(t4, e5, s5);
            return i4;
          }
          throw exportsNotFound2(t4, e5, s5);
        }
        function patternKeyCompare2(e5, t4) {
          const i3 = e5.indexOf("*"), s5 = t4.indexOf("*"), r7 = -1 === i3 ? e5.length : i3 + 1, n2 = -1 === s5 ? t4.length : s5 + 1;
          return r7 > n2 ? -1 : n2 > r7 || -1 === i3 ? 1 : -1 === s5 || e5.length > t4.length ? -1 : t4.length > e5.length ? 1 : 0;
        }
        function packageImportsResolve2(e5, t4, i3) {
          if ("#" === e5 || e5.startsWith("#/") || e5.endsWith("/")) {
            throw new $e2(e5, "is not a valid internal imports specifier name", (0, _e2.fileURLToPath)(t4));
          }
          let s5;
          const r7 = getPackageScopeConfig2(t4);
          if (r7.exists) {
            s5 = (0, _e2.pathToFileURL)(r7.pjsonPath);
            const n2 = r7.imports;
            if (n2) if (Ye2.call(n2, e5) && !e5.includes("*")) {
              const r8 = resolvePackageTarget2(s5, n2[e5], "", e5, t4, false, true, false, i3);
              if (null != r8) return r8;
            } else {
              let r8 = "", a4 = "";
              const o2 = Object.getOwnPropertyNames(n2);
              let h9 = -1;
              for (; ++h9 < o2.length; ) {
                const t5 = o2[h9], i4 = t5.indexOf("*");
                if (-1 !== i4 && e5.startsWith(t5.slice(0, -1))) {
                  const s6 = t5.slice(i4 + 1);
                  e5.length >= t5.length && e5.endsWith(s6) && 1 === patternKeyCompare2(r8, t5) && t5.lastIndexOf("*") === i4 && (r8 = t5, a4 = e5.slice(i4, e5.length - s6.length));
                }
              }
              if (r8) {
                const e6 = resolvePackageTarget2(s5, n2[r8], a4, r8, t4, true, true, false, i3);
                if (null != e6) return e6;
              }
            }
          }
          throw (function(e6, t5, i4) {
            return new He2(e6, t5 && (0, _e2.fileURLToPath)(new _e2.URL(".", t5)), (0, _e2.fileURLToPath)(i4));
          })(e5, s5, t4);
        }
        function packageResolve2(e5, t4, i3) {
          if (le3.builtinModules.includes(e5)) return new _e2.URL("node:" + e5);
          const { packageName: s5, packageSubpath: r7, isScoped: n2 } = (function(e6, t5) {
            let i4 = e6.indexOf("/"), s6 = true, r8 = false;
            "@" === e6[0] && (r8 = true, -1 === i4 || 0 === e6.length ? s6 = false : i4 = e6.indexOf("/", i4 + 1));
            const n3 = -1 === i4 ? e6 : e6.slice(0, i4);
            if (null !== Xe2.exec(n3) && (s6 = false), !s6) throw new $e2(e6, "is not a valid package name", (0, _e2.fileURLToPath)(t5));
            return { packageName: n3, packageSubpath: "." + (-1 === i4 ? "" : e6.slice(i4)), isScoped: r8 };
          })(e5, t4), a4 = getPackageScopeConfig2(t4);
          if (a4.exists) {
            const e6 = (0, _e2.pathToFileURL)(a4.pjsonPath);
            if (a4.name === s5 && void 0 !== a4.exports && null !== a4.exports) return packageExportsResolve2(e6, r7, a4, t4, i3);
          }
          let o2, h9 = new _e2.URL("./node_modules/" + s5 + "/package.json", t4), c3 = (0, _e2.fileURLToPath)(h9);
          do {
            const a5 = tryStatSync2(c3.slice(0, -13));
            if (!a5 || !a5.isDirectory()) {
              o2 = c3, h9 = new _e2.URL((n2 ? "../../../../node_modules/" : "../../../node_modules/") + s5 + "/package.json", h9), c3 = (0, _e2.fileURLToPath)(h9);
              continue;
            }
            const p4 = read3(c3, { base: t4, specifier: e5 });
            return void 0 !== p4.exports && null !== p4.exports ? packageExportsResolve2(h9, r7, p4, t4, i3) : "." === r7 ? legacyMainResolve2(h9, p4, t4) : new _e2.URL(r7, h9);
          } while (c3.length !== o2.length);
          throw new Ge(s5, (0, _e2.fileURLToPath)(t4), false);
        }
        function moduleResolve2(e5, t4, i3, s5) {
          const r7 = t4.protocol, n2 = "data:" === r7 || "http:" === r7 || "https:" === r7;
          let a4;
          if ((function(e6) {
            return "" !== e6 && ("/" === e6[0] || (function(e7) {
              if ("." === e7[0]) {
                if (1 === e7.length || "/" === e7[1]) return true;
                if ("." === e7[1] && (2 === e7.length || "/" === e7[2])) return true;
              }
              return false;
            })(e6));
          })(e5)) try {
            a4 = new _e2.URL(e5, t4);
          } catch (i4) {
            const s6 = new Je2(e5, t4);
            throw s6.cause = i4, s6;
          }
          else if ("file:" === r7 && "#" === e5[0]) a4 = packageImportsResolve2(e5, t4, i3);
          else try {
            a4 = new _e2.URL(e5);
          } catch (s6) {
            if (n2 && !le3.builtinModules.includes(e5)) {
              const i4 = new Je2(e5, t4);
              throw i4.cause = s6, i4;
            }
            a4 = packageResolve2(e5, t4, i3);
          }
          return Ee3(void 0 !== a4, "expected to be defined"), "file:" !== a4.protocol ? a4 : (function(e6, t5) {
            if (null !== tt.exec(e6.pathname)) throw new $e2(e6.pathname, 'must not include encoded "/" or "\\" characters', (0, _e2.fileURLToPath)(t5));
            let i4;
            try {
              i4 = (0, _e2.fileURLToPath)(e6);
            } catch (i5) {
              const s7 = i5;
              throw Object.defineProperty(s7, "input", { value: String(e6) }), Object.defineProperty(s7, "module", { value: String(t5) }), s7;
            }
            const s6 = tryStatSync2(i4.endsWith("/") ? i4.slice(-1) : i4);
            if (s6 && s6.isDirectory()) {
              const s7 = new ze2(i4, (0, _e2.fileURLToPath)(t5));
              throw s7.url = String(e6), s7;
            }
            if (!s6 || !s6.isFile()) {
              const s7 = new Ge(i4 || e6.pathname, t5 && (0, _e2.fileURLToPath)(t5), true);
              throw s7.url = String(e6), s7;
            }
            {
              const t6 = (0, ue3.realpathSync)(i4), { search: s7, hash: r8 } = e6;
              (e6 = (0, _e2.pathToFileURL)(t6 + (i4.endsWith(Se2.sep) ? "/" : ""))).search = s7, e6.hash = r8;
            }
            return e6;
          })(a4, t4);
        }
        function fileURLToPath2(e5) {
          return "string" != typeof e5 || e5.startsWith("file://") ? normalizeSlash2((0, _e2.fileURLToPath)(e5)) : normalizeSlash2(e5);
        }
        function pathToFileURL2(e5) {
          return (0, _e2.pathToFileURL)(fileURLToPath2(e5)).toString();
        }
        const rt2 = /* @__PURE__ */ new Set(["node", "import"]), nt = [".mjs", ".cjs", ".js", ".json"], at2 = /* @__PURE__ */ new Set(["ERR_MODULE_NOT_FOUND", "ERR_UNSUPPORTED_DIR_IMPORT", "MODULE_NOT_FOUND", "ERR_PACKAGE_PATH_NOT_EXPORTED"]);
        function _tryModuleResolve2(e5, t4, i3) {
          try {
            return moduleResolve2(e5, t4, i3);
          } catch (e6) {
            if (!at2.has(e6?.code)) throw e6;
          }
        }
        function _resolve2(e5, t4 = {}) {
          if ("string" != typeof e5) {
            if (!(e5 instanceof URL)) throw new TypeError("input must be a `string` or `URL`");
            e5 = fileURLToPath2(e5);
          }
          if (/(?:node|data|http|https):/.test(e5)) return e5;
          if (Ie2.has(e5)) return "node:" + e5;
          if (e5.startsWith("file://") && (e5 = fileURLToPath2(e5)), isAbsolute2(e5)) try {
            if ((0, ue3.statSync)(e5).isFile()) return pathToFileURL2(e5);
          } catch (e6) {
            if ("ENOENT" !== e6?.code) throw e6;
          }
          const i3 = t4.conditions ? new Set(t4.conditions) : rt2, s5 = (Array.isArray(t4.url) ? t4.url : [t4.url]).filter(Boolean).map((e6) => new URL((function(e7) {
            return "string" != typeof e7 && (e7 = e7.toString()), /(?:node|data|http|https|file):/.test(e7) ? e7 : Ie2.has(e7) ? "node:" + e7 : "file://" + encodeURI(normalizeSlash2(e7));
          })(e6.toString())));
          0 === s5.length && s5.push(new URL(pathToFileURL2(process.cwd())));
          const r7 = [...s5];
          for (const e6 of s5) "file:" === e6.protocol && r7.push(new URL("./", e6), new URL(dist_joinURL(e6.pathname, "_index.js"), e6), new URL("node_modules", e6));
          let n2;
          for (const s6 of r7) {
            if (n2 = _tryModuleResolve2(e5, s6, i3), n2) break;
            for (const r8 of ["", "/index"]) {
              for (const a4 of t4.extensions || nt) if (n2 = _tryModuleResolve2(dist_joinURL(e5, r8) + a4, s6, i3), n2) break;
              if (n2) break;
            }
            if (n2) break;
          }
          if (!n2) {
            const t5 = new Error(`Cannot find module ${e5} imported from ${r7.join(", ")}`);
            throw t5.code = "ERR_MODULE_NOT_FOUND", t5;
          }
          return pathToFileURL2(n2);
        }
        function resolveSync2(e5, t4) {
          return _resolve2(e5, t4);
        }
        function resolvePathSync2(e5, t4) {
          return fileURLToPath2(resolveSync2(e5, t4));
        }
        const ot = /(?:[\s;]|^)(?:import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m, ht2 = /\/\*.+?\*\/|\/\/.*(?=[nr])/g;
        function hasESMSyntax(e5, t4 = {}) {
          return t4.stripComments && (e5 = e5.replace(ht2, "")), ot.test(e5);
        }
        function escapeStringRegexp(e5) {
          if ("string" != typeof e5) throw new TypeError("Expected a string");
          return e5.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        const ct2 = /* @__PURE__ */ new Set(["/", "\\", void 0]), pt = Symbol.for("pathe:normalizedAlias"), lt2 = /[/\\]/;
        function normalizeAliases(e5) {
          if (e5[pt]) return e5;
          const t4 = Object.fromEntries(Object.entries(e5).sort(([e6], [t5]) => (function(e7, t6) {
            return t6.split("/").length - e7.split("/").length;
          })(e6, t5)));
          for (const e6 in t4) for (const i3 in t4) i3 === e6 || e6.startsWith(i3) || t4[e6]?.startsWith(i3) && ct2.has(t4[e6][i3.length]) && (t4[e6] = t4[i3] + t4[e6].slice(i3.length));
          return Object.defineProperty(t4, pt, { value: true, enumerable: false }), t4;
        }
        function utils_hasTrailingSlash(e5 = "/") {
          const t4 = e5[e5.length - 1];
          return "/" === t4 || "\\" === t4;
        }
        var ut2 = { rE: "2.6.1" };
        const dt2 = require("crypto");
        var ft = __webpack_require__.n(dt2);
        const mt = /* @__PURE__ */ Object.create(null), dist_i = (e5) => globalThis.process?.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (e5 ? mt : globalThis), gt = new Proxy(mt, { get: (e5, t4) => dist_i()[t4] ?? mt[t4], has: (e5, t4) => t4 in dist_i() || t4 in mt, set: (e5, t4, i3) => (dist_i(true)[t4] = i3, true), deleteProperty(e5, t4) {
          if (!t4) return false;
          return delete dist_i(true)[t4], true;
        }, ownKeys() {
          const e5 = dist_i(true);
          return Object.keys(e5);
        } }), xt = typeof process < "u" && process.env && process.env.NODE_ENV || "", vt = [["APPVEYOR"], ["AWS_AMPLIFY", "AWS_APP_ID", { ci: true }], ["AZURE_PIPELINES", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"], ["AZURE_STATIC", "INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"], ["APPCIRCLE", "AC_APPCIRCLE"], ["BAMBOO", "bamboo_planKey"], ["BITBUCKET", "BITBUCKET_COMMIT"], ["BITRISE", "BITRISE_IO"], ["BUDDY", "BUDDY_WORKSPACE_ID"], ["BUILDKITE"], ["CIRCLE", "CIRCLECI"], ["CIRRUS", "CIRRUS_CI"], ["CLOUDFLARE_PAGES", "CF_PAGES", { ci: true }], ["CLOUDFLARE_WORKERS", "WORKERS_CI", { ci: true }], ["CODEBUILD", "CODEBUILD_BUILD_ARN"], ["CODEFRESH", "CF_BUILD_ID"], ["DRONE"], ["DRONE", "DRONE_BUILD_EVENT"], ["DSARI"], ["GITHUB_ACTIONS"], ["GITLAB", "GITLAB_CI"], ["GITLAB", "CI_MERGE_REQUEST_ID"], ["GOCD", "GO_PIPELINE_LABEL"], ["LAYERCI"], ["HUDSON", "HUDSON_URL"], ["JENKINS", "JENKINS_URL"], ["MAGNUM"], ["NETLIFY"], ["NETLIFY", "NETLIFY_LOCAL", { ci: false }], ["NEVERCODE"], ["RENDER"], ["SAIL", "SAILCI"], ["SEMAPHORE"], ["SCREWDRIVER"], ["SHIPPABLE"], ["SOLANO", "TDDIUM"], ["STRIDER"], ["TEAMCITY", "TEAMCITY_VERSION"], ["TRAVIS"], ["VERCEL", "NOW_BUILDER"], ["VERCEL", "VERCEL", { ci: false }], ["VERCEL", "VERCEL_ENV", { ci: false }], ["APPCENTER", "APPCENTER_BUILD_ID"], ["CODESANDBOX", "CODESANDBOX_SSE", { ci: false }], ["CODESANDBOX", "CODESANDBOX_HOST", { ci: false }], ["STACKBLITZ"], ["STORMKIT"], ["CLEAVR"], ["ZEABUR"], ["CODESPHERE", "CODESPHERE_APP_ID", { ci: true }], ["RAILWAY", "RAILWAY_PROJECT_ID"], ["RAILWAY", "RAILWAY_SERVICE_ID"], ["DENO-DEPLOY", "DENO_DEPLOYMENT_ID"], ["FIREBASE_APP_HOSTING", "FIREBASE_APP_HOSTING", { ci: true }]];
        const yt = (function() {
          if (globalThis.process?.env) for (const e5 of vt) {
            const t4 = e5[1] || e5[0];
            if (globalThis.process?.env[t4]) return { name: e5[0].toLowerCase(), ...e5[2] };
          }
          return "/bin/jsh" === globalThis.process?.env?.SHELL && globalThis.process?.versions?.webcontainer ? { name: "stackblitz", ci: false } : { name: "", ci: false };
        })();
        yt.name;
        function std_env_dist_n(e5) {
          return !!e5 && "false" !== e5;
        }
        const _t = globalThis.process?.platform || "", Et = std_env_dist_n(gt.CI) || false !== yt.ci, bt2 = std_env_dist_n(globalThis.process?.stdout && globalThis.process?.stdout.isTTY), St2 = (std_env_dist_n(gt.DEBUG), "test" === xt || std_env_dist_n(gt.TEST)), kt2 = (std_env_dist_n(gt.MINIMAL), /^win/i.test(_t)), wt2 = (/^linux/i.test(_t), /^darwin/i.test(_t), !std_env_dist_n(gt.NO_COLOR) && (std_env_dist_n(gt.FORCE_COLOR) || (bt2 || kt2) && gt.TERM), (globalThis.process?.versions?.node || "").replace(/^v/, "") || null), It2 = (Number(wt2?.split(".")[0]), globalThis.process || /* @__PURE__ */ Object.create(null)), Ct2 = { versions: {} }, Rt2 = (new Proxy(It2, { get: (e5, t4) => "env" === t4 ? gt : t4 in e5 ? e5[t4] : t4 in Ct2 ? Ct2[t4] : void 0 }), "node" === globalThis.process?.release?.name), Pt2 = !!globalThis.Bun || !!globalThis.process?.versions?.bun, Tt2 = !!globalThis.Deno, At2 = !!globalThis.fastly, Nt2 = [[!!globalThis.Netlify, "netlify"], [!!globalThis.EdgeRuntime, "edge-light"], ["Cloudflare-Workers" === globalThis.navigator?.userAgent, "workerd"], [At2, "fastly"], [Tt2, "deno"], [Pt2, "bun"], [Rt2, "node"]];
        !(function() {
          const e5 = Nt2.find((e6) => e6[0]);
          if (e5) e5[1];
        })();
        const Lt2 = require("tty"), Ot = Lt2?.WriteStream?.prototype?.hasColors?.() ?? false, base_format = (e5, t4) => {
          if (!Ot) return (e6) => e6;
          const i3 = `\x1B[${e5}m`, s5 = `\x1B[${t4}m`;
          return (e6) => {
            const r7 = e6 + "";
            let n2 = r7.indexOf(s5);
            if (-1 === n2) return i3 + r7 + s5;
            let a4 = i3, o2 = 0;
            const h9 = (22 === t4 ? s5 : "") + i3;
            for (; -1 !== n2; ) a4 += r7.slice(o2, n2) + h9, o2 = n2 + s5.length, n2 = r7.indexOf(s5, o2);
            return a4 += r7.slice(o2) + s5, a4;
          };
        }, Dt = (base_format(0, 0), base_format(1, 22), base_format(2, 22), base_format(3, 23), base_format(4, 24), base_format(53, 55), base_format(7, 27), base_format(8, 28), base_format(9, 29), base_format(30, 39), base_format(31, 39)), Vt = base_format(32, 39), Ut = base_format(33, 39), Mt = base_format(34, 39), jt2 = (base_format(35, 39), base_format(36, 39)), Ft2 = (base_format(37, 39), base_format(90, 39));
        base_format(40, 49), base_format(41, 49), base_format(42, 49), base_format(43, 49), base_format(44, 49), base_format(45, 49), base_format(46, 49), base_format(47, 49), base_format(100, 49), base_format(91, 39), base_format(92, 39), base_format(93, 39), base_format(94, 39), base_format(95, 39), base_format(96, 39), base_format(97, 39), base_format(101, 49), base_format(102, 49), base_format(103, 49), base_format(104, 49), base_format(105, 49), base_format(106, 49), base_format(107, 49);
        function isDir(e5) {
          if ("string" != typeof e5 || e5.startsWith("file://")) return false;
          try {
            return (0, ue3.lstatSync)(e5).isDirectory();
          } catch {
            return false;
          }
        }
        function utils_hash(e5, t4 = 8) {
          return ((function() {
            if (void 0 !== $t2) return $t2;
            try {
              return $t2 = !!ft().getFips?.(), $t2;
            } catch {
              return $t2 = false, $t2;
            }
          })() ? ft().createHash("sha256") : ft().createHash("md5")).update(e5).digest("hex").slice(0, t4);
        }
        const Bt = { true: Vt("true"), false: Ut("false"), "[rebuild]": Ut("[rebuild]"), "[esm]": Mt("[esm]"), "[cjs]": Vt("[cjs]"), "[import]": Mt("[import]"), "[require]": Vt("[require]"), "[native]": jt2("[native]"), "[transpile]": Ut("[transpile]"), "[fallback]": Dt("[fallback]"), "[unknown]": Dt("[unknown]"), "[hit]": Vt("[hit]"), "[miss]": Ut("[miss]"), "[json]": Vt("[json]"), "[data]": Vt("[data]") };
        function debug2(e5, ...t4) {
          if (!e5.opts.debug) return;
          const i3 = process.cwd();
          console.log(Ft2(["[jiti]", ...t4.map((e6) => e6 in Bt ? Bt[e6] : "string" != typeof e6 ? JSON.stringify(e6) : e6.replace(i3, "."))].join(" ")));
        }
        function jitiInteropDefault(e5, t4) {
          return e5.opts.interopDefault ? (function(e6) {
            const t5 = typeof e6;
            if (null === e6 || "object" !== t5 && "function" !== t5) return e6;
            const i3 = e6.default, s5 = typeof i3, r7 = null == i3, n2 = "object" === s5 || "function" === s5;
            if (r7 && e6 instanceof Promise) return e6;
            return new Proxy(e6, { get(t6, s6, a4) {
              if ("__esModule" === s6) return true;
              if ("default" === s6) return r7 ? e6 : "function" == typeof i3?.default && e6.__esModule ? i3.default : i3;
              if (Reflect.has(t6, s6)) return Reflect.get(t6, s6, a4);
              if (n2 && !(i3 instanceof Promise)) {
                let e7 = Reflect.get(i3, s6, a4);
                return "function" == typeof e7 && (e7 = e7.bind(i3)), e7;
              }
            }, apply: (e7, t6, r8) => "function" == typeof e7 ? Reflect.apply(e7, t6, r8) : "function" === s5 ? Reflect.apply(i3, t6, r8) : void 0 });
          })(t4) : t4;
        }
        let $t2;
        function _booleanEnv(e5, t4) {
          const i3 = _jsonEnv(e5, t4);
          return Boolean(i3);
        }
        function _jsonEnv(e5, t4) {
          const i3 = process.env[e5];
          if (!(e5 in process.env)) return t4;
          try {
            return JSON.parse(i3);
          } catch {
            return t4;
          }
        }
        const qt2 = /\.(c|m)?j(sx?)$/, Wt = /\.(c|m)?t(sx?)$/;
        function jitiResolve(e5, t4, i3) {
          let s5, r7;
          if (e5.isNativeRe.test(t4)) return t4;
          e5.alias && (t4 = (function(e6, t5) {
            const i4 = pathe_M_eThtNZ_normalizeWindowsPath(e6);
            t5 = normalizeAliases(t5);
            for (const [e7, s6] of Object.entries(t5)) {
              if (!i4.startsWith(e7)) continue;
              const t6 = utils_hasTrailingSlash(e7) ? e7.slice(0, -1) : e7;
              if (utils_hasTrailingSlash(i4[t6.length])) return pathe_M_eThtNZ_join(s6, i4.slice(e7.length));
            }
            return i4;
          })(t4, e5.alias));
          let n2 = i3?.parentURL || e5.url;
          isDir(n2) && (n2 = pathe_M_eThtNZ_join(n2, "_index.js"));
          const a4 = (i3?.async ? [i3?.conditions, ["node", "import"], ["node", "require"]] : [i3?.conditions, ["node", "require"], ["node", "import"]]).filter(Boolean);
          for (const i4 of a4) {
            try {
              s5 = resolvePathSync2(t4, { url: n2, conditions: i4, extensions: e5.opts.extensions });
            } catch (e6) {
              r7 = e6;
            }
            if (s5) return s5;
          }
          try {
            return e5.nativeRequire.resolve(t4, { paths: i3.paths });
          } catch (e6) {
            r7 = e6;
          }
          for (const r8 of e5.additionalExts) {
            if (s5 = tryNativeRequireResolve(e5, t4 + r8, n2, i3) || tryNativeRequireResolve(e5, t4 + "/index" + r8, n2, i3), s5) return s5;
            if ((Wt.test(e5.filename) || Wt.test(e5.parentModule?.filename || "") || qt2.test(t4)) && (s5 = tryNativeRequireResolve(e5, t4.replace(qt2, ".$1t$2"), n2, i3), s5)) return s5;
          }
          if (!i3?.try) throw r7;
        }
        function tryNativeRequireResolve(e5, t4, i3, s5) {
          try {
            return e5.nativeRequire.resolve(t4, { ...s5, paths: [pathe_M_eThtNZ_dirname(fileURLToPath2(i3)), ...s5?.paths || []] });
          } catch {
          }
        }
        const Gt = require("perf_hooks"), Ht = require("vm");
        var Kt = __webpack_require__.n(Ht);
        function jitiRequire(e5, t4, i3) {
          const s5 = e5.parentCache || {};
          if (t4.startsWith("node:")) return nativeImportOrRequire(e5, t4, i3.async);
          if (t4.startsWith("file:")) t4 = (0, _e2.fileURLToPath)(t4);
          else if (t4.startsWith("data:")) {
            if (!i3.async) throw new Error("`data:` URLs are only supported in ESM context. Use `import` or `jiti.import` instead.");
            return debug2(e5, "[native]", "[data]", "[import]", t4), nativeImportOrRequire(e5, t4, true);
          }
          if (le3.builtinModules.includes(t4) || ".pnp.js" === t4) return nativeImportOrRequire(e5, t4, i3.async);
          if (e5.opts.tryNative && !e5.opts.transformOptions) try {
            if (!(t4 = jitiResolve(e5, t4, i3)) && i3.try) return;
            if (debug2(e5, "[try-native]", i3.async && e5.nativeImport ? "[import]" : "[require]", t4), i3.async && e5.nativeImport) return e5.nativeImport(t4).then((i4) => (false === e5.opts.moduleCache && delete e5.nativeRequire.cache[t4], jitiInteropDefault(e5, i4)));
            {
              const i4 = e5.nativeRequire(t4);
              return false === e5.opts.moduleCache && delete e5.nativeRequire.cache[t4], jitiInteropDefault(e5, i4);
            }
          } catch (i4) {
            debug2(e5, `[try-native] Using fallback for ${t4} because of an error:`, i4);
          }
          const r7 = jitiResolve(e5, t4, i3);
          if (!r7 && i3.try) return;
          const n2 = extname3(r7);
          if (".json" === n2) {
            debug2(e5, "[json]", r7);
            const t5 = e5.nativeRequire(r7);
            return t5 && !("default" in t5) && Object.defineProperty(t5, "default", { value: t5, enumerable: false }), t5;
          }
          if (n2 && !e5.opts.extensions.includes(n2)) return debug2(e5, "[native]", "[unknown]", i3.async ? "[import]" : "[require]", r7), nativeImportOrRequire(e5, r7, i3.async);
          if (e5.isNativeRe.test(r7)) return debug2(e5, "[native]", i3.async ? "[import]" : "[require]", r7), nativeImportOrRequire(e5, r7, i3.async);
          if (s5[r7]) return jitiInteropDefault(e5, s5[r7]?.exports);
          if (e5.opts.moduleCache) {
            const t5 = e5.nativeRequire.cache[r7];
            if (t5?.loaded) return jitiInteropDefault(e5, t5.exports);
          }
          const a4 = (0, ue3.readFileSync)(r7, "utf8");
          return eval_evalModule(e5, a4, { id: t4, filename: r7, ext: n2, cache: s5, async: i3.async });
        }
        function nativeImportOrRequire(e5, t4, i3) {
          return i3 && e5.nativeImport ? e5.nativeImport((function(e6) {
            return kt2 && isAbsolute2(e6) ? pathToFileURL2(e6) : e6;
          })(t4)).then((t5) => jitiInteropDefault(e5, t5)) : jitiInteropDefault(e5, e5.nativeRequire(t4));
        }
        const zt2 = "9";
        function getCache(e5, t4, i3) {
          if (!e5.opts.fsCache || !t4.filename) return i3();
          const s5 = ` /* v${zt2}-${utils_hash(t4.source, 16)} */
`;
          let r7 = `${basename3(pathe_M_eThtNZ_dirname(t4.filename))}-${(function(e6) {
            const t5 = e6.split(lt2).pop();
            if (!t5) return;
            const i4 = t5.lastIndexOf(".");
            return i4 <= 0 ? t5 : t5.slice(0, i4);
          })(t4.filename)}` + (e5.opts.sourceMaps ? "+map" : "") + (t4.interopDefault ? ".i" : "") + `.${utils_hash(t4.filename)}` + (t4.async ? ".mjs" : ".cjs");
          t4.jsx && t4.filename.endsWith("x") && (r7 += "x");
          const n2 = e5.opts.fsCache, a4 = pathe_M_eThtNZ_join(n2, r7);
          if (!e5.opts.rebuildFsCache && (0, ue3.existsSync)(a4)) {
            const i4 = (0, ue3.readFileSync)(a4, "utf8");
            if (i4.endsWith(s5)) return debug2(e5, "[cache]", "[hit]", t4.filename, "~>", a4), i4;
          }
          debug2(e5, "[cache]", "[miss]", t4.filename);
          const o2 = i3();
          return o2.includes("__JITI_ERROR__") || ((0, ue3.writeFileSync)(a4, o2 + s5, "utf8"), debug2(e5, "[cache]", "[store]", t4.filename, "~>", a4)), o2;
        }
        function prepareCacheDir(t4) {
          if (true === t4.opts.fsCache && (t4.opts.fsCache = (function(t5) {
            const i3 = t5.filename && pathe_M_eThtNZ_resolve(t5.filename, "../node_modules");
            if (i3 && (0, ue3.existsSync)(i3)) return pathe_M_eThtNZ_join(i3, ".cache/jiti");
            let s5 = (0, e4.tmpdir)();
            if (process.env.TMPDIR && s5 === process.cwd() && !process.env.JITI_RESPECT_TMPDIR_ENV) {
              const t6 = process.env.TMPDIR;
              delete process.env.TMPDIR, s5 = (0, e4.tmpdir)(), process.env.TMPDIR = t6;
            }
            return pathe_M_eThtNZ_join(s5, "jiti");
          })(t4)), t4.opts.fsCache) try {
            if ((0, ue3.mkdirSync)(t4.opts.fsCache, { recursive: true }), !(function(e5) {
              try {
                return (0, ue3.accessSync)(e5, ue3.constants.W_OK), true;
              } catch {
                return false;
              }
            })(t4.opts.fsCache)) throw new Error("directory is not writable!");
          } catch (e5) {
            debug2(t4, "Error creating cache directory at ", t4.opts.fsCache, e5), t4.opts.fsCache = false;
          }
        }
        function transform(e5, t4) {
          let i3 = getCache(e5, t4, () => {
            const i4 = e5.opts.transform({ ...e5.opts.transformOptions, babel: { ...e5.opts.sourceMaps ? { sourceFileName: t4.filename, sourceMaps: "inline" } : {}, ...e5.opts.transformOptions?.babel }, interopDefault: e5.opts.interopDefault, ...t4 });
            return i4.error && e5.opts.debug && debug2(e5, i4.error), i4.code;
          });
          return i3.startsWith("#!") && (i3 = "// " + i3), i3;
        }
        function eval_evalModule(e5, t4, i3 = {}) {
          const s5 = i3.id || (i3.filename ? basename3(i3.filename) : `_jitiEval.${i3.ext || (i3.async ? "mjs" : "js")}`), r7 = i3.filename || jitiResolve(e5, s5, { async: i3.async }), n2 = i3.ext || extname3(r7), a4 = i3.cache || e5.parentCache || {}, o2 = /\.[cm]?tsx?$/.test(n2), h9 = ".mjs" === n2 || ".js" === n2 && "module" === (function(e6) {
            for (; e6 && "." !== e6 && "/" !== e6; ) {
              e6 = pathe_M_eThtNZ_join(e6, "..");
              try {
                const t5 = (0, ue3.readFileSync)(pathe_M_eThtNZ_join(e6, "package.json"), "utf8");
                try {
                  return JSON.parse(t5);
                } catch {
                }
                break;
              } catch {
              }
            }
          })(r7)?.type, c3 = ".cjs" === n2, p4 = i3.forceTranspile ?? (!c3 && !(h9 && i3.async) && (o2 || h9 || e5.isTransformRe.test(r7) || hasESMSyntax(t4))), l4 = Gt.performance.now();
          if (p4) {
            t4 = transform(e5, { filename: r7, source: t4, ts: o2, async: i3.async ?? false, jsx: e5.opts.jsx });
            const s6 = Math.round(1e3 * (Gt.performance.now() - l4)) / 1e3;
            debug2(e5, "[transpile]", i3.async ? "[esm]" : "[cjs]", r7, `(${s6}ms)`);
          } else {
            if (debug2(e5, "[native]", i3.async ? "[import]" : "[require]", r7), i3.async) return Promise.resolve(nativeImportOrRequire(e5, r7, i3.async)).catch((s6) => (debug2(e5, "Native import error:", s6), debug2(e5, "[fallback]", r7), eval_evalModule(e5, t4, { ...i3, forceTranspile: true })));
            try {
              return nativeImportOrRequire(e5, r7, i3.async);
            } catch (s6) {
              debug2(e5, "Native require error:", s6), debug2(e5, "[fallback]", r7), t4 = transform(e5, { filename: r7, source: t4, ts: o2, async: i3.async ?? false, jsx: e5.opts.jsx });
            }
          }
          const u5 = new le3.Module(r7);
          u5.filename = r7, e5.parentModule && (u5.parent = e5.parentModule, Array.isArray(e5.parentModule.children) && !e5.parentModule.children.includes(u5) && e5.parentModule.children.push(u5));
          const d5 = createJiti2(r7, e5.opts, { parentModule: u5, parentCache: a4, nativeImport: e5.nativeImport, onError: e5.onError, createRequire: e5.createRequire }, true);
          let f4;
          u5.require = d5, u5.path = pathe_M_eThtNZ_dirname(r7), u5.paths = le3.Module._nodeModulePaths(u5.path), a4[r7] = u5, e5.opts.moduleCache && (e5.nativeRequire.cache[r7] = u5);
          const m5 = (function(e6, t5) {
            return `(${t5?.async ? "async " : ""}function (exports, require, module, __filename, __dirname, jitiImport, jitiESMResolve) { ${e6}
});`;
          })(t4, { async: i3.async });
          try {
            f4 = Kt().runInThisContext(m5, { filename: r7, lineOffset: 0, displayErrors: false });
          } catch (t5) {
            "SyntaxError" === t5.name && i3.async && e5.nativeImport ? (debug2(e5, "[esm]", "[import]", "[fallback]", r7), f4 = (function(e6, t6) {
              const i4 = `data:text/javascript;base64,${Buffer.from(`export default ${e6}`).toString("base64")}`;
              return (...e7) => t6(i4).then((t7) => t7.default(...e7));
            })(m5, e5.nativeImport)) : (e5.opts.moduleCache && delete e5.nativeRequire.cache[r7], e5.onError(t5));
          }
          let g5;
          try {
            g5 = f4(u5.exports, u5.require, u5, u5.filename, pathe_M_eThtNZ_dirname(u5.filename), d5.import, d5.esmResolve);
          } catch (t5) {
            e5.opts.moduleCache && delete e5.nativeRequire.cache[r7], e5.onError(t5);
          }
          function next() {
            if (u5.exports && u5.exports.__JITI_ERROR__) {
              const { filename: t5, line: i4, column: s6, code: r8, message: n3 } = u5.exports.__JITI_ERROR__, a5 = new Error(`${r8}: ${n3} 
 ${`${t5}:${i4}:${s6}`}`);
              Error.captureStackTrace(a5, jitiRequire), e5.onError(a5);
            }
            u5.loaded = true;
            return jitiInteropDefault(e5, u5.exports);
          }
          return i3.async ? Promise.resolve(g5).then(next) : next();
        }
        const Jt = "win32" === (0, e4.platform)();
        function createJiti2(e5, t4 = {}, i3, s5 = false) {
          const r7 = s5 ? t4 : (function(e6) {
            const t5 = { fsCache: _booleanEnv("JITI_FS_CACHE", _booleanEnv("JITI_CACHE", true)), rebuildFsCache: _booleanEnv("JITI_REBUILD_FS_CACHE", false), moduleCache: _booleanEnv("JITI_MODULE_CACHE", _booleanEnv("JITI_REQUIRE_CACHE", true)), debug: _booleanEnv("JITI_DEBUG", false), sourceMaps: _booleanEnv("JITI_SOURCE_MAPS", false), interopDefault: _booleanEnv("JITI_INTEROP_DEFAULT", true), extensions: _jsonEnv("JITI_EXTENSIONS", [".js", ".mjs", ".cjs", ".ts", ".tsx", ".mts", ".cts", ".mtsx", ".ctsx"]), alias: _jsonEnv("JITI_ALIAS", {}), nativeModules: _jsonEnv("JITI_NATIVE_MODULES", []), transformModules: _jsonEnv("JITI_TRANSFORM_MODULES", []), tryNative: _jsonEnv("JITI_TRY_NATIVE", "Bun" in globalThis), jsx: _booleanEnv("JITI_JSX", false) };
            t5.jsx && t5.extensions.push(".jsx", ".tsx");
            const i4 = {};
            return void 0 !== e6.cache && (i4.fsCache = e6.cache), void 0 !== e6.requireCache && (i4.moduleCache = e6.requireCache), { ...t5, ...i4, ...e6 };
          })(t4), n2 = r7.alias && Object.keys(r7.alias).length > 0 ? normalizeAliases(r7.alias || {}) : void 0, a4 = ["typescript", "jiti", ...r7.nativeModules || []], o2 = new RegExp(`node_modules/(${a4.map((e6) => escapeStringRegexp(e6)).join("|")})/`), h9 = [...r7.transformModules || []], c3 = new RegExp(`node_modules/(${h9.map((e6) => escapeStringRegexp(e6)).join("|")})/`);
          e5 || (e5 = process.cwd()), !s5 && isDir(e5) && (e5 = pathe_M_eThtNZ_join(e5, "_index.js"));
          const p4 = pathToFileURL2(e5), l4 = [...r7.extensions].filter((e6) => ".js" !== e6), u5 = i3.createRequire(Jt ? e5.replace(/\//g, "\\") : e5), d5 = { filename: e5, url: p4, opts: r7, alias: n2, nativeModules: a4, transformModules: h9, isNativeRe: o2, isTransformRe: c3, additionalExts: l4, nativeRequire: u5, onError: i3.onError, parentModule: i3.parentModule, parentCache: i3.parentCache, nativeImport: i3.nativeImport, createRequire: i3.createRequire };
          s5 || debug2(d5, "[init]", ...[["version:", ut2.rE], ["module-cache:", r7.moduleCache], ["fs-cache:", r7.fsCache], ["rebuild-fs-cache:", r7.rebuildFsCache], ["interop-defaults:", r7.interopDefault]].flat()), s5 || prepareCacheDir(d5);
          const f4 = Object.assign(function(e6) {
            return jitiRequire(d5, e6, { async: false });
          }, { cache: r7.moduleCache ? u5.cache : /* @__PURE__ */ Object.create(null), extensions: u5.extensions, main: u5.main, options: r7, resolve: Object.assign(function(e6) {
            return jitiResolve(d5, e6, { async: false });
          }, { paths: u5.resolve.paths }), transform: (e6) => transform(d5, e6), evalModule: (e6, t5) => eval_evalModule(d5, e6, t5), async import(e6, t5) {
            const i4 = await jitiRequire(d5, e6, { ...t5, async: true });
            return t5?.default ? i4?.default ?? i4 : i4;
          }, esmResolve(e6, t5) {
            "string" == typeof t5 && (t5 = { parentURL: t5 });
            const i4 = jitiResolve(d5, e6, { parentURL: p4, ...t5, async: true });
            return !i4 || "string" != typeof i4 || i4.startsWith("file://") ? i4 : pathToFileURL2(i4);
          } });
          return f4;
        }
      })(), module2.exports = i2.default;
    })();
  }
});

// ../../node_modules/.pnpm/acorn@8.15.0/node_modules/acorn/dist/acorn.mjs
function isInAstralSet(code, set) {
  var pos = 65536;
  for (var i2 = 0; i2 < set.length; i2 += 2) {
    pos += set[i2];
    if (pos > code) {
      return false;
    }
    pos += set[i2 + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
function kw(name, options) {
  if (options === void 0) options = {};
  options.keyword = name;
  return keywords[name] = new TokenType(name, options);
}
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0) end = code.length;
  for (var i2 = from; i2 < end; i2++) {
    var next = code.charCodeAt(i2);
    if (isNewLine(next)) {
      return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
    }
  }
  return -1;
}
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start, end];
    }
    array.push(comment);
  };
}
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
function isLocalVariableAccess(node) {
  return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
function buildUnicodeData(ecmaVersion) {
  var d4 = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d4.nonBinary.Script_Extensions = d4.nonBinary.Script;
  d4.nonBinary.gc = d4.nonBinary.General_Category;
  d4.nonBinary.sc = d4.nonBinary.Script;
  d4.nonBinary.scx = d4.nonBinary.Script_Extensions;
}
function hasProp(obj) {
  for (var _5 in obj) {
    return true;
  }
  return false;
}
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
var astralIdentifierCodes, astralIdentifierStartCodes, nonASCIIidentifierChars, nonASCIIidentifierStartChars, reservedWords, ecma5AndLessKeywords, keywords$1, keywordRelationalOperator, nonASCIIidentifierStart, nonASCIIidentifier, TokenType, beforeExpr, startsExpr, keywords, types$1, lineBreak, lineBreakG, nonASCIIwhitespace, skipWhiteSpace, ref, hasOwnProperty, toString, hasOwn, isArray, regexpCache, loneSurrogate, Position, SourceLocation, defaultOptions, warnedAboutEcmaVersion, SCOPE_TOP, SCOPE_FUNCTION, SCOPE_ASYNC, SCOPE_GENERATOR, SCOPE_ARROW, SCOPE_SIMPLE_CATCH, SCOPE_SUPER, SCOPE_DIRECT_SUPER, SCOPE_CLASS_STATIC_BLOCK, SCOPE_CLASS_FIELD_INIT, SCOPE_VAR, BIND_NONE, BIND_VAR, BIND_LEXICAL, BIND_FUNCTION, BIND_SIMPLE_CATCH, BIND_OUTSIDE, Parser, prototypeAccessors, pp$9, literal, DestructuringErrors, pp$8, loopLabel, switchLabel, empty$1, FUNC_STATEMENT, FUNC_HANGING_STATEMENT, FUNC_NULLABLE_ID, pp$7, TokContext, types, pp$6, pp$5, empty, pp$4, pp$3, Scope, Node, pp$2, scriptValuesAddedInUnicode, ecma9BinaryProperties, ecma10BinaryProperties, ecma11BinaryProperties, ecma12BinaryProperties, ecma13BinaryProperties, ecma14BinaryProperties, unicodeBinaryProperties, ecma14BinaryPropertiesOfStrings, unicodeBinaryPropertiesOfStrings, unicodeGeneralCategoryValues, ecma9ScriptValues, ecma10ScriptValues, ecma11ScriptValues, ecma12ScriptValues, ecma13ScriptValues, ecma14ScriptValues, unicodeScriptValues, data, ecmaVersion, i2, list, pp$1, BranchID, RegExpValidationState, CharSetNone, CharSetOk, CharSetString, Token, pp, INVALID_TEMPLATE_ESCAPE_ERROR, version;
var init_acorn = __esm({
  "../../node_modules/.pnpm/acorn@8.15.0/node_modules/acorn/dist/acorn.mjs"() {
    "use strict";
    astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    reservedWords = {
      3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
      5: "class enum extends super const export import",
      6: "enum",
      strict: "implements interface let package private protected public static yield",
      strictBind: "eval arguments"
    };
    ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
    keywords$1 = {
      5: ecma5AndLessKeywords,
      "5module": ecma5AndLessKeywords + " export import",
      6: ecma5AndLessKeywords + " const class extends export import super"
    };
    keywordRelationalOperator = /^in(stanceof)?$/;
    nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    TokenType = function TokenType2(label, conf) {
      if (conf === void 0) conf = {};
      this.label = label;
      this.keyword = conf.keyword;
      this.beforeExpr = !!conf.beforeExpr;
      this.startsExpr = !!conf.startsExpr;
      this.isLoop = !!conf.isLoop;
      this.isAssign = !!conf.isAssign;
      this.prefix = !!conf.prefix;
      this.postfix = !!conf.postfix;
      this.binop = conf.binop || null;
      this.updateContext = null;
    };
    beforeExpr = { beforeExpr: true };
    startsExpr = { startsExpr: true };
    keywords = {};
    types$1 = {
      num: new TokenType("num", startsExpr),
      regexp: new TokenType("regexp", startsExpr),
      string: new TokenType("string", startsExpr),
      name: new TokenType("name", startsExpr),
      privateId: new TokenType("privateId", startsExpr),
      eof: new TokenType("eof"),
      // Punctuation token types.
      bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
      bracketR: new TokenType("]"),
      braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
      braceR: new TokenType("}"),
      parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
      parenR: new TokenType(")"),
      comma: new TokenType(",", beforeExpr),
      semi: new TokenType(";", beforeExpr),
      colon: new TokenType(":", beforeExpr),
      dot: new TokenType("."),
      question: new TokenType("?", beforeExpr),
      questionDot: new TokenType("?."),
      arrow: new TokenType("=>", beforeExpr),
      template: new TokenType("template"),
      invalidTemplate: new TokenType("invalidTemplate"),
      ellipsis: new TokenType("...", beforeExpr),
      backQuote: new TokenType("`", startsExpr),
      dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
      // Operators. These carry several kinds of properties to help the
      // parser use them properly (the presence of these properties is
      // what categorizes them as operators).
      //
      // `binop`, when present, specifies that this operator is a binary
      // operator, and will refer to its precedence.
      //
      // `prefix` and `postfix` mark the operator as a prefix or postfix
      // unary operator.
      //
      // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
      // binary operators with a very low precedence, that should result
      // in AssignmentExpression nodes.
      eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
      assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
      incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
      prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
      logicalOR: binop("||", 1),
      logicalAND: binop("&&", 2),
      bitwiseOR: binop("|", 3),
      bitwiseXOR: binop("^", 4),
      bitwiseAND: binop("&", 5),
      equality: binop("==/!=/===/!==", 6),
      relational: binop("</>/<=/>=", 7),
      bitShift: binop("<</>>/>>>", 8),
      plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
      modulo: binop("%", 10),
      star: binop("*", 10),
      slash: binop("/", 10),
      starstar: new TokenType("**", { beforeExpr: true }),
      coalesce: binop("??", 1),
      // Keyword token types.
      _break: kw("break"),
      _case: kw("case", beforeExpr),
      _catch: kw("catch"),
      _continue: kw("continue"),
      _debugger: kw("debugger"),
      _default: kw("default", beforeExpr),
      _do: kw("do", { isLoop: true, beforeExpr: true }),
      _else: kw("else", beforeExpr),
      _finally: kw("finally"),
      _for: kw("for", { isLoop: true }),
      _function: kw("function", startsExpr),
      _if: kw("if"),
      _return: kw("return", beforeExpr),
      _switch: kw("switch"),
      _throw: kw("throw", beforeExpr),
      _try: kw("try"),
      _var: kw("var"),
      _const: kw("const"),
      _while: kw("while", { isLoop: true }),
      _with: kw("with"),
      _new: kw("new", { beforeExpr: true, startsExpr: true }),
      _this: kw("this", startsExpr),
      _super: kw("super", startsExpr),
      _class: kw("class", startsExpr),
      _extends: kw("extends", beforeExpr),
      _export: kw("export"),
      _import: kw("import", startsExpr),
      _null: kw("null", startsExpr),
      _true: kw("true", startsExpr),
      _false: kw("false", startsExpr),
      _in: kw("in", { beforeExpr: true, binop: 7 }),
      _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
      _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
      _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
      _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
    };
    lineBreak = /\r\n?|\n|\u2028|\u2029/;
    lineBreakG = new RegExp(lineBreak.source, "g");
    nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    ref = Object.prototype;
    hasOwnProperty = ref.hasOwnProperty;
    toString = ref.toString;
    hasOwn = Object.hasOwn || (function(obj, propName) {
      return hasOwnProperty.call(obj, propName);
    });
    isArray = Array.isArray || (function(obj) {
      return toString.call(obj) === "[object Array]";
    });
    regexpCache = /* @__PURE__ */ Object.create(null);
    loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
    Position = function Position2(line, col) {
      this.line = line;
      this.column = col;
    };
    Position.prototype.offset = function offset(n) {
      return new Position(this.line, this.column + n);
    };
    SourceLocation = function SourceLocation2(p3, start, end) {
      this.start = start;
      this.end = end;
      if (p3.sourceFile !== null) {
        this.source = p3.sourceFile;
      }
    };
    defaultOptions = {
      // `ecmaVersion` indicates the ECMAScript version to parse. Must be
      // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
      // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
      // (the latest version the library supports). This influences
      // support for strict mode, the set of reserved words, and support
      // for new syntax features.
      ecmaVersion: null,
      // `sourceType` indicates the mode the code should be parsed in.
      // Can be either `"script"` or `"module"`. This influences global
      // strict mode and parsing of `import` and `export` declarations.
      sourceType: "script",
      // `onInsertedSemicolon` can be a callback that will be called when
      // a semicolon is automatically inserted. It will be passed the
      // position of the inserted semicolon as an offset, and if
      // `locations` is enabled, it is given the location as a `{line,
      // column}` object as second argument.
      onInsertedSemicolon: null,
      // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
      // trailing commas.
      onTrailingComma: null,
      // By default, reserved words are only enforced if ecmaVersion >= 5.
      // Set `allowReserved` to a boolean value to explicitly turn this on
      // an off. When this option has the value "never", reserved words
      // and keywords can also not be used as property names.
      allowReserved: null,
      // When enabled, a return at the top level is not considered an
      // error.
      allowReturnOutsideFunction: false,
      // When enabled, import/export statements are not constrained to
      // appearing at the top of the program, and an import.meta expression
      // in a script isn't considered an error.
      allowImportExportEverywhere: false,
      // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
      // When enabled, await identifiers are allowed to appear at the top-level scope,
      // but they are still not allowed in non-async functions.
      allowAwaitOutsideFunction: null,
      // When enabled, super identifiers are not constrained to
      // appearing in methods and do not raise an error when they appear elsewhere.
      allowSuperOutsideMethod: null,
      // When enabled, hashbang directive in the beginning of file is
      // allowed and treated as a line comment. Enabled by default when
      // `ecmaVersion` >= 2023.
      allowHashBang: false,
      // By default, the parser will verify that private properties are
      // only used in places where they are valid and have been declared.
      // Set this to false to turn such checks off.
      checkPrivateFields: true,
      // When `locations` is on, `loc` properties holding objects with
      // `start` and `end` properties in `{line, column}` form (with
      // line being 1-based and column 0-based) will be attached to the
      // nodes.
      locations: false,
      // A function can be passed as `onToken` option, which will
      // cause Acorn to call that function with object in the same
      // format as tokens returned from `tokenizer().getToken()`. Note
      // that you are not allowed to call the parser from the
      // callbackthat will corrupt its internal state.
      onToken: null,
      // A function can be passed as `onComment` option, which will
      // cause Acorn to call that function with `(block, text, start,
      // end)` parameters whenever a comment is skipped. `block` is a
      // boolean indicating whether this is a block (`/* */`) comment,
      // `text` is the content of the comment, and `start` and `end` are
      // character offsets that denote the start and end of the comment.
      // When the `locations` option is on, two more parameters are
      // passed, the full `{line, column}` locations of the start and
      // end of the comments. Note that you are not allowed to call the
      // parser from the callbackthat will corrupt its internal state.
      // When this option has an array as value, objects representing the
      // comments are pushed to it.
      onComment: null,
      // Nodes have their start and end characters offsets recorded in
      // `start` and `end` properties (directly on the node, rather than
      // the `loc` object, which holds line/column data. To also add a
      // [semi-standardized][range] `range` property holding a `[start,
      // end]` array with the same numbers, set the `ranges` option to
      // `true`.
      //
      // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
      ranges: false,
      // It is possible to parse multiple files into a single AST by
      // passing the tree produced by parsing the first file as
      // `program` option in subsequent parses. This will add the
      // toplevel forms of the parsed file to the `Program` (top) node
      // of an existing parse tree.
      program: null,
      // When `locations` is on, you can pass this to record the source
      // file in every node's `loc` object.
      sourceFile: null,
      // This value, if given, is stored in every node, whether
      // `locations` is on or off.
      directSourceFile: null,
      // When enabled, parenthesized expressions are represented by
      // (non-standard) ParenthesizedExpression nodes
      preserveParens: false
    };
    warnedAboutEcmaVersion = false;
    SCOPE_TOP = 1;
    SCOPE_FUNCTION = 2;
    SCOPE_ASYNC = 4;
    SCOPE_GENERATOR = 8;
    SCOPE_ARROW = 16;
    SCOPE_SIMPLE_CATCH = 32;
    SCOPE_SUPER = 64;
    SCOPE_DIRECT_SUPER = 128;
    SCOPE_CLASS_STATIC_BLOCK = 256;
    SCOPE_CLASS_FIELD_INIT = 512;
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
    BIND_NONE = 0;
    BIND_VAR = 1;
    BIND_LEXICAL = 2;
    BIND_FUNCTION = 3;
    BIND_SIMPLE_CATCH = 4;
    BIND_OUTSIDE = 5;
    Parser = function Parser2(options, input, startPos) {
      this.options = options = getOptions(options);
      this.sourceFile = options.sourceFile;
      this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
      var reserved = "";
      if (options.allowReserved !== true) {
        reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
        if (options.sourceType === "module") {
          reserved += " await";
        }
      }
      this.reservedWords = wordsRegexp(reserved);
      var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
      this.reservedWordsStrict = wordsRegexp(reservedStrict);
      this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
      this.input = String(input);
      this.containsEsc = false;
      if (startPos) {
        this.pos = startPos;
        this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
        this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
      } else {
        this.pos = this.lineStart = 0;
        this.curLine = 1;
      }
      this.type = types$1.eof;
      this.value = null;
      this.start = this.end = this.pos;
      this.startLoc = this.endLoc = this.curPosition();
      this.lastTokEndLoc = this.lastTokStartLoc = null;
      this.lastTokStart = this.lastTokEnd = this.pos;
      this.context = this.initialContext();
      this.exprAllowed = true;
      this.inModule = options.sourceType === "module";
      this.strict = this.inModule || this.strictDirective(this.pos);
      this.potentialArrowAt = -1;
      this.potentialArrowInForAwait = false;
      this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
      this.labels = [];
      this.undefinedExports = /* @__PURE__ */ Object.create(null);
      if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
        this.skipLineComment(2);
      }
      this.scopeStack = [];
      this.enterScope(SCOPE_TOP);
      this.regexpState = null;
      this.privateNameStack = [];
    };
    prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    Parser.prototype.parse = function parse2() {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node);
    };
    prototypeAccessors.inFunction.get = function() {
      return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
    };
    prototypeAccessors.inGenerator.get = function() {
      return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
    };
    prototypeAccessors.inAsync.get = function() {
      return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
    };
    prototypeAccessors.canAwait.get = function() {
      for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
        var ref2 = this.scopeStack[i2];
        var flags = ref2.flags;
        if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
          return false;
        }
        if (flags & SCOPE_FUNCTION) {
          return (flags & SCOPE_ASYNC) > 0;
        }
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    };
    prototypeAccessors.allowSuper.get = function() {
      var ref2 = this.currentThisScope();
      var flags = ref2.flags;
      return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
    };
    prototypeAccessors.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
    };
    prototypeAccessors.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    };
    prototypeAccessors.allowNewDotTarget.get = function() {
      for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
        var ref2 = this.scopeStack[i2];
        var flags = ref2.flags;
        if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
          return true;
        }
      }
      return false;
    };
    prototypeAccessors.inClassStaticBlock.get = function() {
      return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
    };
    Parser.extend = function extend() {
      var plugins = [], len = arguments.length;
      while (len--) plugins[len] = arguments[len];
      var cls = this;
      for (var i2 = 0; i2 < plugins.length; i2++) {
        cls = plugins[i2](cls);
      }
      return cls;
    };
    Parser.parse = function parse3(input, options) {
      return new this(options, input).parse();
    };
    Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
      var parser = new this(options, input, pos);
      parser.nextToken();
      return parser.parseExpression();
    };
    Parser.tokenizer = function tokenizer(input, options) {
      return new this(options, input);
    };
    Object.defineProperties(Parser.prototype, prototypeAccessors);
    pp$9 = Parser.prototype;
    literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
    pp$9.strictDirective = function(start) {
      if (this.options.ecmaVersion < 5) {
        return false;
      }
      for (; ; ) {
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        var match = literal.exec(this.input.slice(start));
        if (!match) {
          return false;
        }
        if ((match[1] || match[2]) === "use strict") {
          skipWhiteSpace.lastIndex = start + match[0].length;
          var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
          var next = this.input.charAt(end);
          return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
        }
        start += match[0].length;
        skipWhiteSpace.lastIndex = start;
        start += skipWhiteSpace.exec(this.input)[0].length;
        if (this.input[start] === ";") {
          start++;
        }
      }
    };
    pp$9.eat = function(type) {
      if (this.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    };
    pp$9.isContextual = function(name) {
      return this.type === types$1.name && this.value === name && !this.containsEsc;
    };
    pp$9.eatContextual = function(name) {
      if (!this.isContextual(name)) {
        return false;
      }
      this.next();
      return true;
    };
    pp$9.expectContextual = function(name) {
      if (!this.eatContextual(name)) {
        this.unexpected();
      }
    };
    pp$9.canInsertSemicolon = function() {
      return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$9.insertSemicolon = function() {
      if (this.canInsertSemicolon()) {
        if (this.options.onInsertedSemicolon) {
          this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
        }
        return true;
      }
    };
    pp$9.semicolon = function() {
      if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
        this.unexpected();
      }
    };
    pp$9.afterTrailingComma = function(tokType, notNext) {
      if (this.type === tokType) {
        if (this.options.onTrailingComma) {
          this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
        }
        if (!notNext) {
          this.next();
        }
        return true;
      }
    };
    pp$9.expect = function(type) {
      this.eat(type) || this.unexpected();
    };
    pp$9.unexpected = function(pos) {
      this.raise(pos != null ? pos : this.start, "Unexpected token");
    };
    DestructuringErrors = function DestructuringErrors2() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    };
    pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
      if (!refDestructuringErrors) {
        return;
      }
      if (refDestructuringErrors.trailingComma > -1) {
        this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
      }
      var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
      if (parens > -1) {
        this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
      }
    };
    pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
      if (!refDestructuringErrors) {
        return false;
      }
      var shorthandAssign = refDestructuringErrors.shorthandAssign;
      var doubleProto = refDestructuringErrors.doubleProto;
      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0;
      }
      if (shorthandAssign >= 0) {
        this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
      }
      if (doubleProto >= 0) {
        this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
      }
    };
    pp$9.checkYieldAwaitInDefaultParams = function() {
      if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
        this.raise(this.yieldPos, "Yield expression cannot be a default value");
      }
      if (this.awaitPos) {
        this.raise(this.awaitPos, "Await expression cannot be a default value");
      }
    };
    pp$9.isSimpleAssignTarget = function(expr) {
      if (expr.type === "ParenthesizedExpression") {
        return this.isSimpleAssignTarget(expr.expression);
      }
      return expr.type === "Identifier" || expr.type === "MemberExpression";
    };
    pp$8 = Parser.prototype;
    pp$8.parseTopLevel = function(node) {
      var exports2 = /* @__PURE__ */ Object.create(null);
      if (!node.body) {
        node.body = [];
      }
      while (this.type !== types$1.eof) {
        var stmt = this.parseStatement(null, true, exports2);
        node.body.push(stmt);
      }
      if (this.inModule) {
        for (var i2 = 0, list = Object.keys(this.undefinedExports); i2 < list.length; i2 += 1) {
          var name = list[i2];
          this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
        }
      }
      this.adaptDirectivePrologue(node.body);
      this.next();
      node.sourceType = this.options.sourceType;
      return this.finishNode(node, "Program");
    };
    loopLabel = { kind: "loop" };
    switchLabel = { kind: "switch" };
    pp$8.isLet = function(context4) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 91 || nextCh === 92) {
        return true;
      }
      if (context4) {
        return false;
      }
      if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
        return true;
      }
      if (isIdentifierStart(nextCh, true)) {
        var pos = next + 1;
        while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
          ++pos;
        }
        if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        var ident = this.input.slice(next, pos);
        if (!keywordRelationalOperator.test(ident)) {
          return true;
        }
      }
      return false;
    };
    pp$8.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, after;
      return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
    };
    pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
      if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
        return false;
      }
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length;
      if (lineBreak.test(this.input.slice(this.pos, next))) {
        return false;
      }
      if (isAwaitUsing) {
        var awaitEndPos = next + 5, after;
        if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
          return false;
        }
        skipWhiteSpace.lastIndex = awaitEndPos;
        var skipAfterUsing = skipWhiteSpace.exec(this.input);
        if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
          return false;
        }
      }
      if (isFor) {
        var ofEndPos = next + 2, after$1;
        if (this.input.slice(next, ofEndPos) === "of") {
          if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
            return false;
          }
        }
      }
      var ch = this.input.charCodeAt(next);
      return isIdentifierStart(ch, true) || ch === 92;
    };
    pp$8.isAwaitUsing = function(isFor) {
      return this.isUsingKeyword(true, isFor);
    };
    pp$8.isUsing = function(isFor) {
      return this.isUsingKeyword(false, isFor);
    };
    pp$8.parseStatement = function(context4, topLevel, exports2) {
      var starttype = this.type, node = this.startNode(), kind;
      if (this.isLet(context4)) {
        starttype = types$1._var;
        kind = "let";
      }
      switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);
        case types$1._debugger:
          return this.parseDebuggerStatement(node);
        case types$1._do:
          return this.parseDoStatement(node);
        case types$1._for:
          return this.parseForStatement(node);
        case types$1._function:
          if (context4 && (this.strict || context4 !== "if" && context4 !== "label") && this.options.ecmaVersion >= 6) {
            this.unexpected();
          }
          return this.parseFunctionStatement(node, false, !context4);
        case types$1._class:
          if (context4) {
            this.unexpected();
          }
          return this.parseClass(node, true);
        case types$1._if:
          return this.parseIfStatement(node);
        case types$1._return:
          return this.parseReturnStatement(node);
        case types$1._switch:
          return this.parseSwitchStatement(node);
        case types$1._throw:
          return this.parseThrowStatement(node);
        case types$1._try:
          return this.parseTryStatement(node);
        case types$1._const:
        case types$1._var:
          kind = kind || this.value;
          if (context4 && kind !== "var") {
            this.unexpected();
          }
          return this.parseVarStatement(node, kind);
        case types$1._while:
          return this.parseWhileStatement(node);
        case types$1._with:
          return this.parseWithStatement(node);
        case types$1.braceL:
          return this.parseBlock(true, node);
        case types$1.semi:
          return this.parseEmptyStatement(node);
        case types$1._export:
        case types$1._import:
          if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40 || nextCh === 46) {
              return this.parseExpressionStatement(node, this.parseExpression());
            }
          }
          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel) {
              this.raise(this.start, "'import' and 'export' may only appear at the top level");
            }
            if (!this.inModule) {
              this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
            }
          }
          return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports2);
        // If the statement does not start with a statement keyword or a
        // brace, it's an ExpressionStatement or LabeledStatement. We
        // simply start parsing an expression, and afterwards, if the
        // next token is a colon and the expression was a simple
        // Identifier node, we switch to interpreting it as a label.
        default:
          if (this.isAsyncFunction()) {
            if (context4) {
              this.unexpected();
            }
            this.next();
            return this.parseFunctionStatement(node, true, !context4);
          }
          var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
          if (usingKind) {
            if (topLevel && this.options.sourceType === "script") {
              this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
            }
            if (usingKind === "await using") {
              if (!this.canAwait) {
                this.raise(this.start, "Await using cannot appear outside of async function");
              }
              this.next();
            }
            this.next();
            this.parseVar(node, false, usingKind);
            this.semicolon();
            return this.finishNode(node, "VariableDeclaration");
          }
          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
            return this.parseLabeledStatement(node, maybeName, expr, context4);
          } else {
            return this.parseExpressionStatement(node, expr);
          }
      }
    };
    pp$8.parseBreakContinueStatement = function(node, keyword) {
      var isBreak = keyword === "break";
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node.label = null;
      } else if (this.type !== types$1.name) {
        this.unexpected();
      } else {
        node.label = this.parseIdent();
        this.semicolon();
      }
      var i2 = 0;
      for (; i2 < this.labels.length; ++i2) {
        var lab = this.labels[i2];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) {
            break;
          }
          if (node.label && isBreak) {
            break;
          }
        }
      }
      if (i2 === this.labels.length) {
        this.raise(node.start, "Unsyntactic " + keyword);
      }
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };
    pp$8.parseDebuggerStatement = function(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };
    pp$8.parseDoStatement = function(node) {
      this.next();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("do");
      this.labels.pop();
      this.expect(types$1._while);
      node.test = this.parseParenExpression();
      if (this.options.ecmaVersion >= 6) {
        this.eat(types$1.semi);
      } else {
        this.semicolon();
      }
      return this.finishNode(node, "DoWhileStatement");
    };
    pp$8.parseForStatement = function(node) {
      this.next();
      var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      this.labels.push(loopLabel);
      this.enterScope(0);
      this.expect(types$1.parenL);
      if (this.type === types$1.semi) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, null);
      }
      var isLet = this.isLet();
      if (this.type === types$1._var || this.type === types$1._const || isLet) {
        var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
        this.next();
        this.parseVar(init$1, true, kind);
        this.finishNode(init$1, "VariableDeclaration");
        return this.parseForAfterInit(node, init$1, awaitAt);
      }
      var startsWithLet = this.isContextual("let"), isForOf = false;
      var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
      if (usingKind) {
        var init$2 = this.startNode();
        this.next();
        if (usingKind === "await using") {
          this.next();
        }
        this.parseVar(init$2, true, usingKind);
        this.finishNode(init$2, "VariableDeclaration");
        return this.parseForAfterInit(node, init$2, awaitAt);
      }
      var containsEsc = this.containsEsc;
      var refDestructuringErrors = new DestructuringErrors();
      var initPos = this.start;
      var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
      if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
        if (awaitAt > -1) {
          if (this.type === types$1._in) {
            this.unexpected(awaitAt);
          }
          node.await = true;
        } else if (isForOf && this.options.ecmaVersion >= 8) {
          if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
            this.unexpected();
          } else if (this.options.ecmaVersion >= 9) {
            node.await = false;
          }
        }
        if (startsWithLet && isForOf) {
          this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
        }
        this.toAssignable(init, false, refDestructuringErrors);
        this.checkLValPattern(init);
        return this.parseForIn(node, init);
      } else {
        this.checkExpressionErrors(refDestructuringErrors, true);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, init);
    };
    pp$8.parseForAfterInit = function(node, init, awaitAt) {
      if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$1._in) {
            if (awaitAt > -1) {
              this.unexpected(awaitAt);
            }
          } else {
            node.await = awaitAt > -1;
          }
        }
        return this.parseForIn(node, init);
      }
      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }
      return this.parseFor(node, init);
    };
    pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
    };
    pp$8.parseIfStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    };
    pp$8.parseReturnStatement = function(node) {
      if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
        this.raise(this.start, "'return' outside of function");
      }
      this.next();
      if (this.eat(types$1.semi) || this.insertSemicolon()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");
    };
    pp$8.parseSwitchStatement = function(node) {
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.expect(types$1.braceL);
      this.labels.push(switchLabel);
      this.enterScope(0);
      var cur;
      for (var sawDefault = false; this.type !== types$1.braceR; ) {
        if (this.type === types$1._case || this.type === types$1._default) {
          var isCase = this.type === types$1._case;
          if (cur) {
            this.finishNode(cur, "SwitchCase");
          }
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
            }
            sawDefault = true;
            cur.test = null;
          }
          this.expect(types$1.colon);
        } else {
          if (!cur) {
            this.unexpected();
          }
          cur.consequent.push(this.parseStatement(null));
        }
      }
      this.exitScope();
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      this.next();
      this.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };
    pp$8.parseThrowStatement = function(node) {
      this.next();
      if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
        this.raise(this.lastTokEnd, "Illegal newline after throw");
      }
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };
    empty$1 = [];
    pp$8.parseCatchClauseParam = function() {
      var param = this.parseBindingAtom();
      var simple = param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);
      return param;
    };
    pp$8.parseTryStatement = function(node) {
      this.next();
      node.block = this.parseBlock();
      node.handler = null;
      if (this.type === types$1._catch) {
        var clause = this.startNode();
        this.next();
        if (this.eat(types$1.parenL)) {
          clause.param = this.parseCatchClauseParam();
        } else {
          if (this.options.ecmaVersion < 10) {
            this.unexpected();
          }
          clause.param = null;
          this.enterScope(0);
        }
        clause.body = this.parseBlock(false);
        this.exitScope();
        node.handler = this.finishNode(clause, "CatchClause");
      }
      node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) {
        this.raise(node.start, "Missing catch or finally clause");
      }
      return this.finishNode(node, "TryStatement");
    };
    pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
      this.next();
      this.parseVar(node, false, kind, allowMissingInitializer);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };
    pp$8.parseWhileStatement = function(node) {
      this.next();
      node.test = this.parseParenExpression();
      this.labels.push(loopLabel);
      node.body = this.parseStatement("while");
      this.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };
    pp$8.parseWithStatement = function(node) {
      if (this.strict) {
        this.raise(this.start, "'with' in strict mode");
      }
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement("with");
      return this.finishNode(node, "WithStatement");
    };
    pp$8.parseEmptyStatement = function(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };
    pp$8.parseLabeledStatement = function(node, maybeName, expr, context4) {
      for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
        var label = list[i$1];
        if (label.name === maybeName) {
          this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        }
      }
      var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
      for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
        var label$1 = this.labels[i2];
        if (label$1.statementStart === node.start) {
          label$1.statementStart = this.start;
          label$1.kind = kind;
        } else {
          break;
        }
      }
      this.labels.push({ name: maybeName, kind, statementStart: this.start });
      node.body = this.parseStatement(context4 ? context4.indexOf("label") === -1 ? context4 + "label" : context4 : "label");
      this.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };
    pp$8.parseExpressionStatement = function(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };
    pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
      if (createNewLexicalScope === void 0) createNewLexicalScope = true;
      if (node === void 0) node = this.startNode();
      node.body = [];
      this.expect(types$1.braceL);
      if (createNewLexicalScope) {
        this.enterScope(0);
      }
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      if (exitStrict) {
        this.strict = false;
      }
      this.next();
      if (createNewLexicalScope) {
        this.exitScope();
      }
      return this.finishNode(node, "BlockStatement");
    };
    pp$8.parseFor = function(node, init) {
      node.init = init;
      this.expect(types$1.semi);
      node.test = this.type === types$1.semi ? null : this.parseExpression();
      this.expect(types$1.semi);
      node.update = this.type === types$1.parenR ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, "ForStatement");
    };
    pp$8.parseForIn = function(node, init) {
      var isForIn = this.type === types$1._in;
      this.next();
      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(
          init.start,
          (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        );
      }
      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
      this.expect(types$1.parenR);
      node.body = this.parseStatement("for");
      this.exitScope();
      this.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };
    pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
      node.declarations = [];
      node.kind = kind;
      for (; ; ) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);
        if (this.eat(types$1.eq)) {
          decl.init = this.parseMaybeAssign(isFor);
        } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          this.unexpected();
        } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
          this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
        } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
          this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
        } else {
          decl.init = null;
        }
        node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) {
          break;
        }
      }
      return node;
    };
    pp$8.parseVarId = function(decl, kind) {
      decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
      this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
    };
    FUNC_STATEMENT = 1;
    FUNC_HANGING_STATEMENT = 2;
    FUNC_NULLABLE_ID = 4;
    pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
      this.initFunction(node);
      if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
        if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
          this.unexpected();
        }
        node.generator = this.eat(types$1.star);
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      if (statement & FUNC_STATEMENT) {
        node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
        if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
          this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
        }
      }
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(node.async, node.generator));
      if (!(statement & FUNC_STATEMENT)) {
        node.id = this.type === types$1.name ? this.parseIdent() : null;
      }
      this.parseFunctionParams(node);
      this.parseFunctionBody(node, allowExpressionBody, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
    };
    pp$8.parseFunctionParams = function(node) {
      this.expect(types$1.parenL);
      node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
    };
    pp$8.parseClass = function(node, isStatement) {
      this.next();
      var oldStrict = this.strict;
      this.strict = true;
      this.parseClassId(node, isStatement);
      this.parseClassSuper(node);
      var privateNameMap = this.enterClassBody();
      var classBody = this.startNode();
      var hadConstructor = false;
      classBody.body = [];
      this.expect(types$1.braceL);
      while (this.type !== types$1.braceR) {
        var element = this.parseClassElement(node.superClass !== null);
        if (element) {
          classBody.body.push(element);
          if (element.type === "MethodDefinition" && element.kind === "constructor") {
            if (hadConstructor) {
              this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
            }
            hadConstructor = true;
          } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
            this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
          }
        }
      }
      this.strict = oldStrict;
      this.next();
      node.body = this.finishNode(classBody, "ClassBody");
      this.exitClassBody();
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };
    pp$8.parseClassElement = function(constructorAllowsSuper) {
      if (this.eat(types$1.semi)) {
        return null;
      }
      var ecmaVersion = this.options.ecmaVersion;
      var node = this.startNode();
      var keyName = "";
      var isGenerator = false;
      var isAsync = false;
      var kind = "method";
      var isStatic = false;
      if (this.eatContextual("static")) {
        if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(node);
          return node;
        }
        if (this.isClassElementNameStart() || this.type === types$1.star) {
          isStatic = true;
        } else {
          keyName = "static";
        }
      }
      node.static = isStatic;
      if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
        if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
          isAsync = true;
        } else {
          keyName = "async";
        }
      }
      if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
        isGenerator = true;
      }
      if (!keyName && !isAsync && !isGenerator) {
        var lastValue = this.value;
        if (this.eatContextual("get") || this.eatContextual("set")) {
          if (this.isClassElementNameStart()) {
            kind = lastValue;
          } else {
            keyName = lastValue;
          }
        }
      }
      if (keyName) {
        node.computed = false;
        node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
        node.key.name = keyName;
        this.finishNode(node.key, "Identifier");
      } else {
        this.parseClassElementName(node);
      }
      if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
        var isConstructor = !node.static && checkKeyName(node, "constructor");
        var allowsDirectSuper = isConstructor && constructorAllowsSuper;
        if (isConstructor && kind !== "method") {
          this.raise(node.key.start, "Constructor can't have get/set modifier");
        }
        node.kind = isConstructor ? "constructor" : kind;
        this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
      } else {
        this.parseClassField(node);
      }
      return node;
    };
    pp$8.isClassElementNameStart = function() {
      return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
    };
    pp$8.parseClassElementName = function(element) {
      if (this.type === types$1.privateId) {
        if (this.value === "constructor") {
          this.raise(this.start, "Classes can't have an element named '#constructor'");
        }
        element.computed = false;
        element.key = this.parsePrivateIdent();
      } else {
        this.parsePropertyName(element);
      }
    };
    pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
      var key = method.key;
      if (method.kind === "constructor") {
        if (isGenerator) {
          this.raise(key.start, "Constructor can't be a generator");
        }
        if (isAsync) {
          this.raise(key.start, "Constructor can't be an async method");
        }
      } else if (method.static && checkKeyName(method, "prototype")) {
        this.raise(key.start, "Classes may not have a static property named prototype");
      }
      var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
      if (method.kind === "get" && value.params.length !== 0) {
        this.raiseRecoverable(value.start, "getter should have no params");
      }
      if (method.kind === "set" && value.params.length !== 1) {
        this.raiseRecoverable(value.start, "setter should have exactly one param");
      }
      if (method.kind === "set" && value.params[0].type === "RestElement") {
        this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
      }
      return this.finishNode(method, "MethodDefinition");
    };
    pp$8.parseClassField = function(field) {
      if (checkKeyName(field, "constructor")) {
        this.raise(field.key.start, "Classes can't have a field named 'constructor'");
      } else if (field.static && checkKeyName(field, "prototype")) {
        this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
      }
      if (this.eat(types$1.eq)) {
        this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
        field.value = this.parseMaybeAssign();
        this.exitScope();
      } else {
        field.value = null;
      }
      this.semicolon();
      return this.finishNode(field, "PropertyDefinition");
    };
    pp$8.parseClassStaticBlock = function(node) {
      node.body = [];
      var oldLabels = this.labels;
      this.labels = [];
      this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
      while (this.type !== types$1.braceR) {
        var stmt = this.parseStatement(null);
        node.body.push(stmt);
      }
      this.next();
      this.exitScope();
      this.labels = oldLabels;
      return this.finishNode(node, "StaticBlock");
    };
    pp$8.parseClassId = function(node, isStatement) {
      if (this.type === types$1.name) {
        node.id = this.parseIdent();
        if (isStatement) {
          this.checkLValSimple(node.id, BIND_LEXICAL, false);
        }
      } else {
        if (isStatement === true) {
          this.unexpected();
        }
        node.id = null;
      }
    };
    pp$8.parseClassSuper = function(node) {
      node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
    };
    pp$8.enterClassBody = function() {
      var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
      this.privateNameStack.push(element);
      return element.declared;
    };
    pp$8.exitClassBody = function() {
      var ref2 = this.privateNameStack.pop();
      var declared = ref2.declared;
      var used = ref2.used;
      if (!this.options.checkPrivateFields) {
        return;
      }
      var len = this.privateNameStack.length;
      var parent = len === 0 ? null : this.privateNameStack[len - 1];
      for (var i2 = 0; i2 < used.length; ++i2) {
        var id = used[i2];
        if (!hasOwn(declared, id.name)) {
          if (parent) {
            parent.used.push(id);
          } else {
            this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
          }
        }
      }
    };
    pp$8.parseExportAllDeclaration = function(node, exports2) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node.exported = this.parseModuleExportName();
          this.checkExport(exports2, node.exported, this.lastTokStart);
        } else {
          node.exported = null;
        }
      }
      this.expectContextual("from");
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
      this.semicolon();
      return this.finishNode(node, "ExportAllDeclaration");
    };
    pp$8.parseExport = function(node, exports2) {
      this.next();
      if (this.eat(types$1.star)) {
        return this.parseExportAllDeclaration(node, exports2);
      }
      if (this.eat(types$1._default)) {
        this.checkExport(exports2, "default", this.lastTokStart);
        node.declaration = this.parseExportDefaultDeclaration();
        return this.finishNode(node, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) {
        node.declaration = this.parseExportDeclaration(node);
        if (node.declaration.type === "VariableDeclaration") {
          this.checkVariableExport(exports2, node.declaration.declarations);
        } else {
          this.checkExport(exports2, node.declaration.id, node.declaration.id.start);
        }
        node.specifiers = [];
        node.source = null;
        if (this.options.ecmaVersion >= 16) {
          node.attributes = [];
        }
      } else {
        node.declaration = null;
        node.specifiers = this.parseExportSpecifiers(exports2);
        if (this.eatContextual("from")) {
          if (this.type !== types$1.string) {
            this.unexpected();
          }
          node.source = this.parseExprAtom();
          if (this.options.ecmaVersion >= 16) {
            node.attributes = this.parseWithClause();
          }
        } else {
          for (var i2 = 0, list = node.specifiers; i2 < list.length; i2 += 1) {
            var spec = list[i2];
            this.checkUnreserved(spec.local);
            this.checkLocalExport(spec.local);
            if (spec.local.type === "Literal") {
              this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
          }
          node.source = null;
          if (this.options.ecmaVersion >= 16) {
            node.attributes = [];
          }
        }
        this.semicolon();
      }
      return this.finishNode(node, "ExportNamedDeclaration");
    };
    pp$8.parseExportDeclaration = function(node) {
      return this.parseStatement(null);
    };
    pp$8.parseExportDefaultDeclaration = function() {
      var isAsync;
      if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync) {
          this.next();
        }
        return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types$1._class) {
        var cNode = this.startNode();
        return this.parseClass(cNode, "nullableID");
      } else {
        var declaration = this.parseMaybeAssign();
        this.semicolon();
        return declaration;
      }
    };
    pp$8.checkExport = function(exports2, name, pos) {
      if (!exports2) {
        return;
      }
      if (typeof name !== "string") {
        name = name.type === "Identifier" ? name.name : name.value;
      }
      if (hasOwn(exports2, name)) {
        this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
      }
      exports2[name] = true;
    };
    pp$8.checkPatternExport = function(exports2, pat) {
      var type = pat.type;
      if (type === "Identifier") {
        this.checkExport(exports2, pat, pat.start);
      } else if (type === "ObjectPattern") {
        for (var i2 = 0, list = pat.properties; i2 < list.length; i2 += 1) {
          var prop = list[i2];
          this.checkPatternExport(exports2, prop);
        }
      } else if (type === "ArrayPattern") {
        for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
          var elt = list$1[i$1];
          if (elt) {
            this.checkPatternExport(exports2, elt);
          }
        }
      } else if (type === "Property") {
        this.checkPatternExport(exports2, pat.value);
      } else if (type === "AssignmentPattern") {
        this.checkPatternExport(exports2, pat.left);
      } else if (type === "RestElement") {
        this.checkPatternExport(exports2, pat.argument);
      }
    };
    pp$8.checkVariableExport = function(exports2, decls) {
      if (!exports2) {
        return;
      }
      for (var i2 = 0, list = decls; i2 < list.length; i2 += 1) {
        var decl = list[i2];
        this.checkPatternExport(exports2, decl.id);
      }
    };
    pp$8.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    };
    pp$8.parseExportSpecifier = function(exports2) {
      var node = this.startNode();
      node.local = this.parseModuleExportName();
      node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
      this.checkExport(
        exports2,
        node.exported,
        node.exported.start
      );
      return this.finishNode(node, "ExportSpecifier");
    };
    pp$8.parseExportSpecifiers = function(exports2) {
      var nodes = [], first = true;
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        nodes.push(this.parseExportSpecifier(exports2));
      }
      return nodes;
    };
    pp$8.parseImport = function(node) {
      this.next();
      if (this.type === types$1.string) {
        node.specifiers = empty$1;
        node.source = this.parseExprAtom();
      } else {
        node.specifiers = this.parseImportSpecifiers();
        this.expectContextual("from");
        node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
      }
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };
    pp$8.parseImportSpecifier = function() {
      var node = this.startNode();
      node.imported = this.parseModuleExportName();
      if (this.eatContextual("as")) {
        node.local = this.parseIdent();
      } else {
        this.checkUnreserved(node.imported);
        node.local = node.imported;
      }
      this.checkLValSimple(node.local, BIND_LEXICAL);
      return this.finishNode(node, "ImportSpecifier");
    };
    pp$8.parseImportDefaultSpecifier = function() {
      var node = this.startNode();
      node.local = this.parseIdent();
      this.checkLValSimple(node.local, BIND_LEXICAL);
      return this.finishNode(node, "ImportDefaultSpecifier");
    };
    pp$8.parseImportNamespaceSpecifier = function() {
      var node = this.startNode();
      this.next();
      this.expectContextual("as");
      node.local = this.parseIdent();
      this.checkLValSimple(node.local, BIND_LEXICAL);
      return this.finishNode(node, "ImportNamespaceSpecifier");
    };
    pp$8.parseImportSpecifiers = function() {
      var nodes = [], first = true;
      if (this.type === types$1.name) {
        nodes.push(this.parseImportDefaultSpecifier());
        if (!this.eat(types$1.comma)) {
          return nodes;
        }
      }
      if (this.type === types$1.star) {
        nodes.push(this.parseImportNamespaceSpecifier());
        return nodes;
      }
      this.expect(types$1.braceL);
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        nodes.push(this.parseImportSpecifier());
      }
      return nodes;
    };
    pp$8.parseWithClause = function() {
      var nodes = [];
      if (!this.eat(types$1._with)) {
        return nodes;
      }
      this.expect(types$1.braceL);
      var attributeKeys = {};
      var first = true;
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var attr = this.parseImportAttribute();
        var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
        if (hasOwn(attributeKeys, keyName)) {
          this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
        }
        attributeKeys[keyName] = true;
        nodes.push(attr);
      }
      return nodes;
    };
    pp$8.parseImportAttribute = function() {
      var node = this.startNode();
      node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      this.expect(types$1.colon);
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.value = this.parseExprAtom();
      return this.finishNode(node, "ImportAttribute");
    };
    pp$8.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
        var stringLiteral = this.parseLiteral(this.value);
        if (loneSurrogate.test(stringLiteral.value)) {
          this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
        }
        return stringLiteral;
      }
      return this.parseIdent(true);
    };
    pp$8.adaptDirectivePrologue = function(statements) {
      for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
        statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
      }
    };
    pp$8.isDirectiveCandidate = function(statement) {
      return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
      (this.input[statement.start] === '"' || this.input[statement.start] === "'");
    };
    pp$7 = Parser.prototype;
    pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 6 && node) {
        switch (node.type) {
          case "Identifier":
            if (this.inAsync && node.name === "await") {
              this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
            }
            break;
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            for (var i2 = 0, list = node.properties; i2 < list.length; i2 += 1) {
              var prop = list[i2];
              this.toAssignable(prop, isBinding);
              if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break;
          case "Property":
            if (node.kind !== "init") {
              this.raise(node.key.start, "Object pattern can't contain getter or setter");
            }
            this.toAssignable(node.value, isBinding);
            break;
          case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) {
              this.checkPatternErrors(refDestructuringErrors, true);
            }
            this.toAssignableList(node.elements, isBinding);
            break;
          case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern") {
              this.raise(node.argument.start, "Rest elements cannot have a default value");
            }
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break;
          case "ChainExpression":
            this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (!isBinding) {
              break;
            }
          default:
            this.raise(node.start, "Assigning to rvalue");
        }
      } else if (refDestructuringErrors) {
        this.checkPatternErrors(refDestructuringErrors, true);
      }
      return node;
    };
    pp$7.toAssignableList = function(exprList, isBinding) {
      var end = exprList.length;
      for (var i2 = 0; i2 < end; i2++) {
        var elt = exprList[i2];
        if (elt) {
          this.toAssignable(elt, isBinding);
        }
      }
      if (end) {
        var last = exprList[end - 1];
        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
          this.unexpected(last.argument.start);
        }
      }
      return exprList;
    };
    pp$7.parseSpread = function(refDestructuringErrors) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      return this.finishNode(node, "SpreadElement");
    };
    pp$7.parseRestBinding = function() {
      var node = this.startNode();
      this.next();
      if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
        this.unexpected();
      }
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    };
    pp$7.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) {
        switch (this.type) {
          case types$1.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types$1.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern");
          case types$1.braceL:
            return this.parseObj(true);
        }
      }
      return this.parseIdent();
    };
    pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
        }
        if (allowEmpty && this.type === types$1.comma) {
          elts.push(null);
        } else if (allowTrailingComma && this.afterTrailingComma(close)) {
          break;
        } else if (this.type === types$1.ellipsis) {
          var rest = this.parseRestBinding();
          this.parseBindingListItem(rest);
          elts.push(rest);
          if (this.type === types$1.comma) {
            this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          }
          this.expect(close);
          break;
        } else {
          elts.push(this.parseAssignableListItem(allowModifiers));
        }
      }
      return elts;
    };
    pp$7.parseAssignableListItem = function(allowModifiers) {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      return elem;
    };
    pp$7.parseBindingListItem = function(param) {
      return param;
    };
    pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
      left = left || this.parseBindingAtom();
      if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
        return left;
      }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssign();
      return this.finishNode(node, "AssignmentPattern");
    };
    pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0) bindingType = BIND_NONE;
      var isBind = bindingType !== BIND_NONE;
      switch (expr.type) {
        case "Identifier":
          if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
            this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
          }
          if (isBind) {
            if (bindingType === BIND_LEXICAL && expr.name === "let") {
              this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
            }
            if (checkClashes) {
              if (hasOwn(checkClashes, expr.name)) {
                this.raiseRecoverable(expr.start, "Argument name clash");
              }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_OUTSIDE) {
              this.declareName(expr.name, bindingType, expr.start);
            }
          }
          break;
        case "ChainExpression":
          this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding member expression");
          }
          break;
        case "ParenthesizedExpression":
          if (isBind) {
            this.raiseRecoverable(expr.start, "Binding parenthesized expression");
          }
          return this.checkLValSimple(expr.expression, bindingType, checkClashes);
        default:
          this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
      }
    };
    pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0) bindingType = BIND_NONE;
      switch (expr.type) {
        case "ObjectPattern":
          for (var i2 = 0, list = expr.properties; i2 < list.length; i2 += 1) {
            var prop = list[i2];
            this.checkLValInnerPattern(prop, bindingType, checkClashes);
          }
          break;
        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];
            if (elem) {
              this.checkLValInnerPattern(elem, bindingType, checkClashes);
            }
          }
          break;
        default:
          this.checkLValSimple(expr, bindingType, checkClashes);
      }
    };
    pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
      if (bindingType === void 0) bindingType = BIND_NONE;
      switch (expr.type) {
        case "Property":
          this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(expr.left, bindingType, checkClashes);
          break;
        case "RestElement":
          this.checkLValPattern(expr.argument, bindingType, checkClashes);
          break;
        default:
          this.checkLValPattern(expr, bindingType, checkClashes);
      }
    };
    TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
      this.token = token;
      this.isExpr = !!isExpr;
      this.preserveSpace = !!preserveSpace;
      this.override = override;
      this.generator = !!generator;
    };
    types = {
      b_stat: new TokContext("{", false),
      b_expr: new TokContext("{", true),
      b_tmpl: new TokContext("${", false),
      p_stat: new TokContext("(", false),
      p_expr: new TokContext("(", true),
      q_tmpl: new TokContext("`", true, true, function(p3) {
        return p3.tryReadTemplateToken();
      }),
      f_stat: new TokContext("function", false),
      f_expr: new TokContext("function", true),
      f_expr_gen: new TokContext("function", true, false, null, true),
      f_gen: new TokContext("function", false, false, null, true)
    };
    pp$6 = Parser.prototype;
    pp$6.initialContext = function() {
      return [types.b_stat];
    };
    pp$6.curContext = function() {
      return this.context[this.context.length - 1];
    };
    pp$6.braceIsBlock = function(prevType) {
      var parent = this.curContext();
      if (parent === types.f_expr || parent === types.f_stat) {
        return true;
      }
      if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
        return !parent.isExpr;
      }
      if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
        return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      }
      if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
        return true;
      }
      if (prevType === types$1.braceL) {
        return parent === types.b_stat;
      }
      if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
        return false;
      }
      return !this.exprAllowed;
    };
    pp$6.inGeneratorContext = function() {
      for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
        var context4 = this.context[i2];
        if (context4.token === "function") {
          return context4.generator;
        }
      }
      return false;
    };
    pp$6.updateContext = function(prevType) {
      var update, type = this.type;
      if (type.keyword && prevType === types$1.dot) {
        this.exprAllowed = false;
      } else if (update = type.updateContext) {
        update.call(this, prevType);
      } else {
        this.exprAllowed = type.beforeExpr;
      }
    };
    pp$6.overrideContext = function(tokenCtx) {
      if (this.curContext() !== tokenCtx) {
        this.context[this.context.length - 1] = tokenCtx;
      }
    };
    types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (out === types.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      this.exprAllowed = !out.isExpr;
    };
    types$1.braceL.updateContext = function(prevType) {
      this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
      this.exprAllowed = true;
    };
    types$1.dollarBraceL.updateContext = function() {
      this.context.push(types.b_tmpl);
      this.exprAllowed = true;
    };
    types$1.parenL.updateContext = function(prevType) {
      var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
      this.context.push(statementParens ? types.p_stat : types.p_expr);
      this.exprAllowed = true;
    };
    types$1.incDec.updateContext = function() {
    };
    types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
      if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
        this.context.push(types.f_expr);
      } else {
        this.context.push(types.f_stat);
      }
      this.exprAllowed = false;
    };
    types$1.colon.updateContext = function() {
      if (this.curContext().token === "function") {
        this.context.pop();
      }
      this.exprAllowed = true;
    };
    types$1.backQuote.updateContext = function() {
      if (this.curContext() === types.q_tmpl) {
        this.context.pop();
      } else {
        this.context.push(types.q_tmpl);
      }
      this.exprAllowed = false;
    };
    types$1.star.updateContext = function(prevType) {
      if (prevType === types$1._function) {
        var index = this.context.length - 1;
        if (this.context[index] === types.f_expr) {
          this.context[index] = types.f_expr_gen;
        } else {
          this.context[index] = types.f_gen;
        }
      }
      this.exprAllowed = true;
    };
    types$1.name.updateContext = function(prevType) {
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    pp$5 = Parser.prototype;
    pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
      if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
        return;
      }
      if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
        return;
      }
      var key = prop.key;
      var name;
      switch (key.type) {
        case "Identifier":
          name = key.name;
          break;
        case "Literal":
          name = String(key.value);
          break;
        default:
          return;
      }
      var kind = prop.kind;
      if (this.options.ecmaVersion >= 6) {
        if (name === "__proto__" && kind === "init") {
          if (propHash.proto) {
            if (refDestructuringErrors) {
              if (refDestructuringErrors.doubleProto < 0) {
                refDestructuringErrors.doubleProto = key.start;
              }
            } else {
              this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
            }
          }
          propHash.proto = true;
        }
        return;
      }
      name = "$" + name;
      var other = propHash[name];
      if (other) {
        var redefinition;
        if (kind === "init") {
          redefinition = this.strict && other.init || other.get || other.set;
        } else {
          redefinition = other.init || other[kind];
        }
        if (redefinition) {
          this.raiseRecoverable(key.start, "Redefinition of property");
        }
      } else {
        other = propHash[name] = {
          init: false,
          get: false,
          set: false
        };
      }
      other[kind] = true;
    };
    pp$5.parseExpression = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
      if (this.type === types$1.comma) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];
        while (this.eat(types$1.comma)) {
          node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
        }
        return this.finishNode(node, "SequenceExpression");
      }
      return expr;
    };
    pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) {
          return this.parseYield(forInit);
        } else {
          this.exprAllowed = false;
        }
      }
      var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
      if (refDestructuringErrors) {
        oldParenAssign = refDestructuringErrors.parenthesizedAssign;
        oldTrailingComma = refDestructuringErrors.trailingComma;
        oldDoubleProto = refDestructuringErrors.doubleProto;
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
      } else {
        refDestructuringErrors = new DestructuringErrors();
        ownDestructuringErrors = true;
      }
      var startPos = this.start, startLoc = this.startLoc;
      if (this.type === types$1.parenL || this.type === types$1.name) {
        this.potentialArrowAt = this.start;
        this.potentialArrowInForAwait = forInit === "await";
      }
      var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }
      if (this.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        node.operator = this.value;
        if (this.type === types$1.eq) {
          left = this.toAssignable(left, false, refDestructuringErrors);
        }
        if (!ownDestructuringErrors) {
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
        }
        if (refDestructuringErrors.shorthandAssign >= left.start) {
          refDestructuringErrors.shorthandAssign = -1;
        }
        if (this.type === types$1.eq) {
          this.checkLValPattern(left);
        } else {
          this.checkLValSimple(left);
        }
        node.left = left;
        this.next();
        node.right = this.parseMaybeAssign(forInit);
        if (oldDoubleProto > -1) {
          refDestructuringErrors.doubleProto = oldDoubleProto;
        }
        return this.finishNode(node, "AssignmentExpression");
      } else {
        if (ownDestructuringErrors) {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
      }
      if (oldParenAssign > -1) {
        refDestructuringErrors.parenthesizedAssign = oldParenAssign;
      }
      if (oldTrailingComma > -1) {
        refDestructuringErrors.trailingComma = oldTrailingComma;
      }
      return left;
    };
    pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprOps(forInit, refDestructuringErrors);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      if (this.eat(types$1.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssign();
        this.expect(types$1.colon);
        node.alternate = this.parseMaybeAssign(forInit);
        return this.finishNode(node, "ConditionalExpression");
      }
      return expr;
    };
    pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors)) {
        return expr;
      }
      return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
    };
    pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
      var prec = this.type.binop;
      if (prec != null && (!forInit || this.type !== types$1._in)) {
        if (prec > minPrec) {
          var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
          var coalesce = this.type === types$1.coalesce;
          if (coalesce) {
            prec = types$1.logicalAND.binop;
          }
          var op = this.value;
          this.next();
          var startPos = this.start, startLoc = this.startLoc;
          var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
          var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
          if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
            this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
          }
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
        }
      }
      return left;
    };
    pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
      if (right.type === "PrivateIdentifier") {
        this.raise(right.start, "Private identifier can only be left side of binary expression");
      }
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.operator = op;
      node.right = right;
      return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
    };
    pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
      var startPos = this.start, startLoc = this.startLoc, expr;
      if (this.isContextual("await") && this.canAwait) {
        expr = this.parseAwait(forInit);
        sawUnary = true;
      } else if (this.type.prefix) {
        var node = this.startNode(), update = this.type === types$1.incDec;
        node.operator = this.value;
        node.prefix = true;
        this.next();
        node.argument = this.parseMaybeUnary(null, true, update, forInit);
        this.checkExpressionErrors(refDestructuringErrors, true);
        if (update) {
          this.checkLValSimple(node.argument);
        } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
          this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
        } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
          this.raiseRecoverable(node.start, "Private fields can not be deleted");
        } else {
          sawUnary = true;
        }
        expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
      } else if (!sawUnary && this.type === types$1.privateId) {
        if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
          this.unexpected();
        }
        expr = this.parsePrivateIdent();
        if (this.type !== types$1._in) {
          this.unexpected();
        }
      } else {
        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        while (this.type.postfix && !this.canInsertSemicolon()) {
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.operator = this.value;
          node$1.prefix = false;
          node$1.argument = expr;
          this.checkLValSimple(expr);
          this.next();
          expr = this.finishNode(node$1, "UpdateExpression");
        }
      }
      if (!incDec && this.eat(types$1.starstar)) {
        if (sawUnary) {
          this.unexpected(this.lastTokStart);
        } else {
          return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
        }
      } else {
        return expr;
      }
    };
    pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
      var startPos = this.start, startLoc = this.startLoc;
      var expr = this.parseExprAtom(refDestructuringErrors, forInit);
      if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
        return expr;
      }
      var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
      if (refDestructuringErrors && result.type === "MemberExpression") {
        if (refDestructuringErrors.parenthesizedAssign >= result.start) {
          refDestructuringErrors.parenthesizedAssign = -1;
        }
        if (refDestructuringErrors.parenthesizedBind >= result.start) {
          refDestructuringErrors.parenthesizedBind = -1;
        }
        if (refDestructuringErrors.trailingComma >= result.start) {
          refDestructuringErrors.trailingComma = -1;
        }
      }
      return result;
    };
    pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
      var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
      var optionalChained = false;
      while (true) {
        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
        if (element.optional) {
          optionalChained = true;
        }
        if (element === base || element.type === "ArrowFunctionExpression") {
          if (optionalChained) {
            var chainNode = this.startNodeAt(startPos, startLoc);
            chainNode.expression = element;
            element = this.finishNode(chainNode, "ChainExpression");
          }
          return element;
        }
        base = element;
      }
    };
    pp$5.shouldParseAsyncArrow = function() {
      return !this.canInsertSemicolon() && this.eat(types$1.arrow);
    };
    pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    };
    pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
      var optionalSupported = this.options.ecmaVersion >= 11;
      var optional = optionalSupported && this.eat(types$1.questionDot);
      if (noCalls && optional) {
        this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      }
      var computed = this.eat(types$1.bracketL);
      if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.object = base;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(types$1.bracketR);
        } else if (this.type === types$1.privateId && base.type !== "Super") {
          node.property = this.parsePrivateIdent();
        } else {
          node.property = this.parseIdent(this.options.allowReserved !== "never");
        }
        node.computed = !!computed;
        if (optionalSupported) {
          node.optional = optional;
        }
        base = this.finishNode(node, "MemberExpression");
      } else if (!noCalls && this.eat(types$1.parenL)) {
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
        if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          if (this.awaitIdentPos > 0) {
            this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
          }
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
        var node$1 = this.startNodeAt(startPos, startLoc);
        node$1.callee = base;
        node$1.arguments = exprList;
        if (optionalSupported) {
          node$1.optional = optional;
        }
        base = this.finishNode(node$1, "CallExpression");
      } else if (this.type === types$1.backQuote) {
        if (optional || optionalChained) {
          this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        }
        var node$2 = this.startNodeAt(startPos, startLoc);
        node$2.tag = base;
        node$2.quasi = this.parseTemplate({ isTagged: true });
        base = this.finishNode(node$2, "TaggedTemplateExpression");
      }
      return base;
    };
    pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
      if (this.type === types$1.slash) {
        this.readRegexp();
      }
      var node, canBeArrow = this.potentialArrowAt === this.start;
      switch (this.type) {
        case types$1._super:
          if (!this.allowSuper) {
            this.raise(this.start, "'super' keyword outside a method");
          }
          node = this.startNode();
          this.next();
          if (this.type === types$1.parenL && !this.allowDirectSuper) {
            this.raise(node.start, "super() call outside constructor of a subclass");
          }
          if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
            this.unexpected();
          }
          return this.finishNode(node, "Super");
        case types$1._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");
        case types$1.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
            this.overrideContext(types.f_expr);
            return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
          }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types$1.arrow)) {
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
            }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                this.unexpected();
              }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
            }
          }
          return id;
        case types$1.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = { pattern: value.pattern, flags: value.flags };
          return node;
        case types$1.num:
        case types$1.string:
          return this.parseLiteral(this.value);
        case types$1._null:
        case types$1._true:
        case types$1._false:
          node = this.startNode();
          node.value = this.type === types$1._null ? null : this.type === types$1._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal");
        case types$1.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
              refDestructuringErrors.parenthesizedAssign = start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = start;
            }
          }
          return expr;
        case types$1.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node, "ArrayExpression");
        case types$1.braceL:
          this.overrideContext(types.b_expr);
          return this.parseObj(false, refDestructuringErrors);
        case types$1._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, 0);
        case types$1._class:
          return this.parseClass(this.startNode(), false);
        case types$1._new:
          return this.parseNew();
        case types$1.backQuote:
          return this.parseTemplate();
        case types$1._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport(forNew);
          } else {
            return this.unexpected();
          }
        default:
          return this.parseExprAtomDefault();
      }
    };
    pp$5.parseExprAtomDefault = function() {
      this.unexpected();
    };
    pp$5.parseExprImport = function(forNew) {
      var node = this.startNode();
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      }
      this.next();
      if (this.type === types$1.parenL && !forNew) {
        return this.parseDynamicImport(node);
      } else if (this.type === types$1.dot) {
        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
        meta.name = "import";
        node.meta = this.finishNode(meta, "Identifier");
        return this.parseImportMeta(node);
      } else {
        this.unexpected();
      }
    };
    pp$5.parseDynamicImport = function(node) {
      this.next();
      node.source = this.parseMaybeAssign();
      if (this.options.ecmaVersion >= 16) {
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            node.options = this.parseMaybeAssign();
            if (!this.eat(types$1.parenR)) {
              this.expect(types$1.comma);
              if (!this.afterTrailingComma(types$1.parenR)) {
                this.unexpected();
              }
            }
          } else {
            node.options = null;
          }
        } else {
          node.options = null;
        }
      } else {
        if (!this.eat(types$1.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
      }
      return this.finishNode(node, "ImportExpression");
    };
    pp$5.parseImportMeta = function(node) {
      this.next();
      var containsEsc = this.containsEsc;
      node.property = this.parseIdent(true);
      if (node.property.name !== "meta") {
        this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
      }
      if (containsEsc) {
        this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
      }
      if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
        this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
      }
      return this.finishNode(node, "MetaProperty");
    };
    pp$5.parseLiteral = function(value) {
      var node = this.startNode();
      node.value = value;
      node.raw = this.input.slice(this.start, this.end);
      if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
        node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
      }
      this.next();
      return this.finishNode(node, "Literal");
    };
    pp$5.parseParenExpression = function() {
      this.expect(types$1.parenL);
      var val = this.parseExpression();
      this.expect(types$1.parenR);
      return val;
    };
    pp$5.shouldParseArrow = function(exprList) {
      return !this.canInsertSemicolon();
    };
    pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
      var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var innerStartPos = this.start, innerStartLoc = this.startLoc;
        var exprList = [], first = true, lastIsComma = false;
        var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
        this.yieldPos = 0;
        this.awaitPos = 0;
        while (this.type !== types$1.parenR) {
          first ? first = false : this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
            lastIsComma = true;
            break;
          } else if (this.type === types$1.ellipsis) {
            spreadStart = this.start;
            exprList.push(this.parseParenItem(this.parseRestBinding()));
            if (this.type === types$1.comma) {
              this.raiseRecoverable(
                this.start,
                "Comma is not permitted after the rest element"
              );
            }
            break;
          } else {
            exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
          }
        }
        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
        this.expect(types$1.parenR);
        if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
          this.checkPatternErrors(refDestructuringErrors, false);
          this.checkYieldAwaitInDefaultParams();
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
        }
        if (!exprList.length || lastIsComma) {
          this.unexpected(this.lastTokStart);
        }
        if (spreadStart) {
          this.unexpected(spreadStart);
        }
        this.checkExpressionErrors(refDestructuringErrors, true);
        this.yieldPos = oldYieldPos || this.yieldPos;
        this.awaitPos = oldAwaitPos || this.awaitPos;
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartPos, innerStartLoc);
          val.expressions = exprList;
          this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
        } else {
          val = exprList[0];
        }
      } else {
        val = this.parseParenExpression();
      }
      if (this.options.preserveParens) {
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        return this.finishNode(par, "ParenthesizedExpression");
      } else {
        return val;
      }
    };
    pp$5.parseParenItem = function(item) {
      return item;
    };
    pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
    };
    empty = [];
    pp$5.parseNew = function() {
      if (this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      }
      var node = this.startNode();
      this.next();
      if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
        meta.name = "new";
        node.meta = this.finishNode(meta, "Identifier");
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "target") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
        }
        if (!this.allowNewDotTarget) {
          this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
        }
        return this.finishNode(node, "MetaProperty");
      }
      var startPos = this.start, startLoc = this.startLoc;
      node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
      if (this.eat(types$1.parenL)) {
        node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
      } else {
        node.arguments = empty;
      }
      return this.finishNode(node, "NewExpression");
    };
    pp$5.parseTemplateElement = function(ref2) {
      var isTagged = ref2.isTagged;
      var elem = this.startNode();
      if (this.type === types$1.invalidTemplate) {
        if (!isTagged) {
          this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
        }
        elem.value = {
          raw: this.value.replace(/\r\n?/g, "\n"),
          cooked: null
        };
      } else {
        elem.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
          cooked: this.value
        };
      }
      this.next();
      elem.tail = this.type === types$1.backQuote;
      return this.finishNode(elem, "TemplateElement");
    };
    pp$5.parseTemplate = function(ref2) {
      if (ref2 === void 0) ref2 = {};
      var isTagged = ref2.isTagged;
      if (isTagged === void 0) isTagged = false;
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement({ isTagged });
      node.quasis = [curElt];
      while (!curElt.tail) {
        if (this.type === types$1.eof) {
          this.raise(this.pos, "Unterminated template literal");
        }
        this.expect(types$1.dollarBraceL);
        node.expressions.push(this.parseExpression());
        this.expect(types$1.braceR);
        node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
      }
      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };
    pp$5.isAsyncProp = function(prop) {
      return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    };
    pp$5.parseObj = function(isPattern, refDestructuringErrors) {
      var node = this.startNode(), first = true, propHash = {};
      node.properties = [];
      this.next();
      while (!this.eat(types$1.braceR)) {
        if (!first) {
          this.expect(types$1.comma);
          if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
            break;
          }
        } else {
          first = false;
        }
        var prop = this.parseProperty(isPattern, refDestructuringErrors);
        if (!isPattern) {
          this.checkPropClash(prop, propHash, refDestructuringErrors);
        }
        node.properties.push(prop);
      }
      return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
    };
    pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
      var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
      if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
        if (isPattern) {
          prop.argument = this.parseIdent(false);
          if (this.type === types$1.comma) {
            this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
          }
          return this.finishNode(prop, "RestElement");
        }
        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
          refDestructuringErrors.trailingComma = this.start;
        }
        return this.finishNode(prop, "SpreadElement");
      }
      if (this.options.ecmaVersion >= 6) {
        prop.method = false;
        prop.shorthand = false;
        if (isPattern || refDestructuringErrors) {
          startPos = this.start;
          startLoc = this.startLoc;
        }
        if (!isPattern) {
          isGenerator = this.eat(types$1.star);
        }
      }
      var containsEsc = this.containsEsc;
      this.parsePropertyName(prop);
      if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
        isAsync = true;
        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
        this.parsePropertyName(prop);
      } else {
        isAsync = false;
      }
      this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
      return this.finishNode(prop, "Property");
    };
    pp$5.parseGetterSetter = function(prop) {
      var kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      prop.kind = kind;
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get") {
          this.raiseRecoverable(start, "getter should have no params");
        } else {
          this.raiseRecoverable(start, "setter should have exactly one param");
        }
      } else {
        if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
          this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
        }
      }
    };
    pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
      if ((isGenerator || isAsync) && this.type === types$1.colon) {
        this.unexpected();
      }
      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
        prop.kind = "init";
      } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
        if (isPattern) {
          this.unexpected();
        }
        prop.method = true;
        prop.value = this.parseMethod(isGenerator, isAsync);
        prop.kind = "init";
      } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        this.parseGetterSetter(prop);
      } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
        if (isGenerator || isAsync) {
          this.unexpected();
        }
        this.checkUnreserved(prop.key);
        if (prop.key.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = startPos;
        }
        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else if (this.type === types$1.eq && refDestructuringErrors) {
          if (refDestructuringErrors.shorthandAssign < 0) {
            refDestructuringErrors.shorthandAssign = this.start;
          }
          prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
        } else {
          prop.value = this.copyNode(prop.key);
        }
        prop.kind = "init";
        prop.shorthand = true;
      } else {
        this.unexpected();
      }
    };
    pp$5.parsePropertyName = function(prop) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(types$1.bracketL)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssign();
          this.expect(types$1.bracketR);
          return prop.key;
        } else {
          prop.computed = false;
        }
      }
      return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    };
    pp$5.initFunction = function(node) {
      node.id = null;
      if (this.options.ecmaVersion >= 6) {
        node.generator = node.expression = false;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = false;
      }
    };
    pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
      var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.initFunction(node);
      if (this.options.ecmaVersion >= 6) {
        node.generator = isGenerator;
      }
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.expect(types$1.parenL);
      node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
      this.checkYieldAwaitInDefaultParams();
      this.parseFunctionBody(node, false, true, false);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "FunctionExpression");
    };
    pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
      var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
      this.initFunction(node);
      if (this.options.ecmaVersion >= 8) {
        node.async = !!isAsync;
      }
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      node.params = this.toAssignableList(params, true);
      this.parseFunctionBody(node, true, false, forInit);
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.finishNode(node, "ArrowFunctionExpression");
    };
    pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
      var isExpression = isArrowFunction && this.type !== types$1.braceL;
      var oldStrict = this.strict, useStrict = false;
      if (isExpression) {
        node.body = this.parseMaybeAssign(forInit);
        node.expression = true;
        this.checkParams(node, false);
      } else {
        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
        if (!oldStrict || nonSimple) {
          useStrict = this.strictDirective(this.end);
          if (useStrict && nonSimple) {
            this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
          }
        }
        var oldLabels = this.labels;
        this.labels = [];
        if (useStrict) {
          this.strict = true;
        }
        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
        if (this.strict && node.id) {
          this.checkLValSimple(node.id, BIND_OUTSIDE);
        }
        node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
        node.expression = false;
        this.adaptDirectivePrologue(node.body.body);
        this.labels = oldLabels;
      }
      this.exitScope();
    };
    pp$5.isSimpleParamList = function(params) {
      for (var i2 = 0, list = params; i2 < list.length; i2 += 1) {
        var param = list[i2];
        if (param.type !== "Identifier") {
          return false;
        }
      }
      return true;
    };
    pp$5.checkParams = function(node, allowDuplicates) {
      var nameHash = /* @__PURE__ */ Object.create(null);
      for (var i2 = 0, list = node.params; i2 < list.length; i2 += 1) {
        var param = list[i2];
        this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
      }
    };
    pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
      var elts = [], first = true;
      while (!this.eat(close)) {
        if (!first) {
          this.expect(types$1.comma);
          if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          }
        } else {
          first = false;
        }
        var elt = void 0;
        if (allowEmpty && this.type === types$1.comma) {
          elt = null;
        } else if (this.type === types$1.ellipsis) {
          elt = this.parseSpread(refDestructuringErrors);
          if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
        } else {
          elt = this.parseMaybeAssign(false, refDestructuringErrors);
        }
        elts.push(elt);
      }
      return elts;
    };
    pp$5.checkUnreserved = function(ref2) {
      var start = ref2.start;
      var end = ref2.end;
      var name = ref2.name;
      if (this.inGenerator && name === "yield") {
        this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
      }
      if (this.inAsync && name === "await") {
        this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
      }
      if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
        this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
      }
      if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
        this.raise(start, "Cannot use " + name + " in class static initialization block");
      }
      if (this.keywords.test(name)) {
        this.raise(start, "Unexpected keyword '" + name + "'");
      }
      if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
        return;
      }
      var re3 = this.strict ? this.reservedWordsStrict : this.reservedWords;
      if (re3.test(name)) {
        if (!this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
        }
        this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
      }
    };
    pp$5.parseIdent = function(liberal) {
      var node = this.parseIdentNode();
      this.next(!!liberal);
      this.finishNode(node, "Identifier");
      if (!liberal) {
        this.checkUnreserved(node);
        if (node.name === "await" && !this.awaitIdentPos) {
          this.awaitIdentPos = node.start;
        }
      }
      return node;
    };
    pp$5.parseIdentNode = function() {
      var node = this.startNode();
      if (this.type === types$1.name) {
        node.name = this.value;
      } else if (this.type.keyword) {
        node.name = this.type.keyword;
        if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
          this.context.pop();
        }
        this.type = types$1.name;
      } else {
        this.unexpected();
      }
      return node;
    };
    pp$5.parsePrivateIdent = function() {
      var node = this.startNode();
      if (this.type === types$1.privateId) {
        node.name = this.value;
      } else {
        this.unexpected();
      }
      this.next();
      this.finishNode(node, "PrivateIdentifier");
      if (this.options.checkPrivateFields) {
        if (this.privateNameStack.length === 0) {
          this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
        } else {
          this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
        }
      }
      return node;
    };
    pp$5.parseYield = function(forInit) {
      if (!this.yieldPos) {
        this.yieldPos = this.start;
      }
      var node = this.startNode();
      this.next();
      if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
        node.delegate = false;
        node.argument = null;
      } else {
        node.delegate = this.eat(types$1.star);
        node.argument = this.parseMaybeAssign(forInit);
      }
      return this.finishNode(node, "YieldExpression");
    };
    pp$5.parseAwait = function(forInit) {
      if (!this.awaitPos) {
        this.awaitPos = this.start;
      }
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeUnary(null, true, false, forInit);
      return this.finishNode(node, "AwaitExpression");
    };
    pp$4 = Parser.prototype;
    pp$4.raise = function(pos, message) {
      var loc = getLineInfo(this.input, pos);
      message += " (" + loc.line + ":" + loc.column + ")";
      if (this.sourceFile) {
        message += " in " + this.sourceFile;
      }
      var err = new SyntaxError(message);
      err.pos = pos;
      err.loc = loc;
      err.raisedAt = this.pos;
      throw err;
    };
    pp$4.raiseRecoverable = pp$4.raise;
    pp$4.curPosition = function() {
      if (this.options.locations) {
        return new Position(this.curLine, this.pos - this.lineStart);
      }
    };
    pp$3 = Parser.prototype;
    Scope = function Scope2(flags) {
      this.flags = flags;
      this.var = [];
      this.lexical = [];
      this.functions = [];
    };
    pp$3.enterScope = function(flags) {
      this.scopeStack.push(new Scope(flags));
    };
    pp$3.exitScope = function() {
      this.scopeStack.pop();
    };
    pp$3.treatFunctionsAsVarInScope = function(scope) {
      return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
    };
    pp$3.declareName = function(name, bindingType, pos) {
      var redeclared = false;
      if (bindingType === BIND_LEXICAL) {
        var scope = this.currentScope();
        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
        scope.lexical.push(name);
        if (this.inModule && scope.flags & SCOPE_TOP) {
          delete this.undefinedExports[name];
        }
      } else if (bindingType === BIND_SIMPLE_CATCH) {
        var scope$1 = this.currentScope();
        scope$1.lexical.push(name);
      } else if (bindingType === BIND_FUNCTION) {
        var scope$2 = this.currentScope();
        if (this.treatFunctionsAsVar) {
          redeclared = scope$2.lexical.indexOf(name) > -1;
        } else {
          redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
        }
        scope$2.functions.push(name);
      } else {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
          var scope$3 = this.scopeStack[i2];
          if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
            redeclared = true;
            break;
          }
          scope$3.var.push(name);
          if (this.inModule && scope$3.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
          if (scope$3.flags & SCOPE_VAR) {
            break;
          }
        }
      }
      if (redeclared) {
        this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
      }
    };
    pp$3.checkLocalExport = function(id) {
      if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
        this.undefinedExports[id.name] = id;
      }
    };
    pp$3.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    };
    pp$3.currentVarScope = function() {
      for (var i2 = this.scopeStack.length - 1; ; i2--) {
        var scope = this.scopeStack[i2];
        if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
          return scope;
        }
      }
    };
    pp$3.currentThisScope = function() {
      for (var i2 = this.scopeStack.length - 1; ; i2--) {
        var scope = this.scopeStack[i2];
        if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
          return scope;
        }
      }
    };
    Node = function Node2(parser, pos, loc) {
      this.type = "";
      this.start = pos;
      this.end = 0;
      if (parser.options.locations) {
        this.loc = new SourceLocation(parser, loc);
      }
      if (parser.options.directSourceFile) {
        this.sourceFile = parser.options.directSourceFile;
      }
      if (parser.options.ranges) {
        this.range = [pos, 0];
      }
    };
    pp$2 = Parser.prototype;
    pp$2.startNode = function() {
      return new Node(this, this.start, this.startLoc);
    };
    pp$2.startNodeAt = function(pos, loc) {
      return new Node(this, pos, loc);
    };
    pp$2.finishNode = function(node, type) {
      return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
    };
    pp$2.finishNodeAt = function(node, type, pos, loc) {
      return finishNodeAt.call(this, node, type, pos, loc);
    };
    pp$2.copyNode = function(node) {
      var newNode = new Node(this, node.start, this.startLoc);
      for (var prop in node) {
        newNode[prop] = node[prop];
      }
      return newNode;
    };
    scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
    ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
    ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
    ecma11BinaryProperties = ecma10BinaryProperties;
    ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
    ecma13BinaryProperties = ecma12BinaryProperties;
    ecma14BinaryProperties = ecma13BinaryProperties;
    unicodeBinaryProperties = {
      9: ecma9BinaryProperties,
      10: ecma10BinaryProperties,
      11: ecma11BinaryProperties,
      12: ecma12BinaryProperties,
      13: ecma13BinaryProperties,
      14: ecma14BinaryProperties
    };
    ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
    unicodeBinaryPropertiesOfStrings = {
      9: "",
      10: "",
      11: "",
      12: "",
      13: "",
      14: ecma14BinaryPropertiesOfStrings
    };
    unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
    ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
    ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
    ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
    ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
    ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
    ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
    unicodeScriptValues = {
      9: ecma9ScriptValues,
      10: ecma10ScriptValues,
      11: ecma11ScriptValues,
      12: ecma12ScriptValues,
      13: ecma13ScriptValues,
      14: ecma14ScriptValues
    };
    data = {};
    for (i2 = 0, list = [9, 10, 11, 12, 13, 14]; i2 < list.length; i2 += 1) {
      ecmaVersion = list[i2];
      buildUnicodeData(ecmaVersion);
    }
    pp$1 = Parser.prototype;
    BranchID = function BranchID2(parent, base) {
      this.parent = parent;
      this.base = base || this;
    };
    BranchID.prototype.separatedFrom = function separatedFrom(alt) {
      for (var self2 = this; self2; self2 = self2.parent) {
        for (var other = alt; other; other = other.parent) {
          if (self2.base === other.base && self2 !== other) {
            return true;
          }
        }
      }
      return false;
    };
    BranchID.prototype.sibling = function sibling() {
      return new BranchID(this.parent, this.base);
    };
    RegExpValidationState = function RegExpValidationState2(parser) {
      this.parser = parser;
      this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
      this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
      this.source = "";
      this.flags = "";
      this.start = 0;
      this.switchU = false;
      this.switchV = false;
      this.switchN = false;
      this.pos = 0;
      this.lastIntValue = 0;
      this.lastStringValue = "";
      this.lastAssertionIsQuantifiable = false;
      this.numCapturingParens = 0;
      this.maxBackReference = 0;
      this.groupNames = /* @__PURE__ */ Object.create(null);
      this.backReferenceNames = [];
      this.branchID = null;
    };
    RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
      var unicodeSets = flags.indexOf("v") !== -1;
      var unicode = flags.indexOf("u") !== -1;
      this.start = start | 0;
      this.source = pattern + "";
      this.flags = flags;
      if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
        this.switchU = true;
        this.switchV = true;
        this.switchN = true;
      } else {
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchV = false;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      }
    };
    RegExpValidationState.prototype.raise = function raise(message) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
    };
    RegExpValidationState.prototype.at = function at(i2, forceU) {
      if (forceU === void 0) forceU = false;
      var s4 = this.source;
      var l3 = s4.length;
      if (i2 >= l3) {
        return -1;
      }
      var c2 = s4.charCodeAt(i2);
      if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l3) {
        return c2;
      }
      var next = s4.charCodeAt(i2 + 1);
      return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
    };
    RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
      if (forceU === void 0) forceU = false;
      var s4 = this.source;
      var l3 = s4.length;
      if (i2 >= l3) {
        return l3;
      }
      var c2 = s4.charCodeAt(i2), next;
      if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l3 || (next = s4.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
        return i2 + 1;
      }
      return i2 + 2;
    };
    RegExpValidationState.prototype.current = function current(forceU) {
      if (forceU === void 0) forceU = false;
      return this.at(this.pos, forceU);
    };
    RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
      if (forceU === void 0) forceU = false;
      return this.at(this.nextIndex(this.pos, forceU), forceU);
    };
    RegExpValidationState.prototype.advance = function advance(forceU) {
      if (forceU === void 0) forceU = false;
      this.pos = this.nextIndex(this.pos, forceU);
    };
    RegExpValidationState.prototype.eat = function eat(ch, forceU) {
      if (forceU === void 0) forceU = false;
      if (this.current(forceU) === ch) {
        this.advance(forceU);
        return true;
      }
      return false;
    };
    RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
      if (forceU === void 0) forceU = false;
      var pos = this.pos;
      for (var i2 = 0, list = chs; i2 < list.length; i2 += 1) {
        var ch = list[i2];
        var current2 = this.at(pos, forceU);
        if (current2 === -1 || current2 !== ch) {
          return false;
        }
        pos = this.nextIndex(pos, forceU);
      }
      this.pos = pos;
      return true;
    };
    pp$1.validateRegExpFlags = function(state) {
      var validFlags = state.validFlags;
      var flags = state.flags;
      var u4 = false;
      var v4 = false;
      for (var i2 = 0; i2 < flags.length; i2++) {
        var flag = flags.charAt(i2);
        if (validFlags.indexOf(flag) === -1) {
          this.raise(state.start, "Invalid regular expression flag");
        }
        if (flags.indexOf(flag, i2 + 1) > -1) {
          this.raise(state.start, "Duplicate regular expression flag");
        }
        if (flag === "u") {
          u4 = true;
        }
        if (flag === "v") {
          v4 = true;
        }
      }
      if (this.options.ecmaVersion >= 15 && u4 && v4) {
        this.raise(state.start, "Invalid regular expression flag");
      }
    };
    pp$1.validateRegExpPattern = function(state) {
      this.regexp_pattern(state);
      if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
        state.switchN = true;
        this.regexp_pattern(state);
      }
    };
    pp$1.regexp_pattern = function(state) {
      state.pos = 0;
      state.lastIntValue = 0;
      state.lastStringValue = "";
      state.lastAssertionIsQuantifiable = false;
      state.numCapturingParens = 0;
      state.maxBackReference = 0;
      state.groupNames = /* @__PURE__ */ Object.create(null);
      state.backReferenceNames.length = 0;
      state.branchID = null;
      this.regexp_disjunction(state);
      if (state.pos !== state.source.length) {
        if (state.eat(
          41
          /* ) */
        )) {
          state.raise("Unmatched ')'");
        }
        if (state.eat(
          93
          /* ] */
        ) || state.eat(
          125
          /* } */
        )) {
          state.raise("Lone quantifier brackets");
        }
      }
      if (state.maxBackReference > state.numCapturingParens) {
        state.raise("Invalid escape");
      }
      for (var i2 = 0, list = state.backReferenceNames; i2 < list.length; i2 += 1) {
        var name = list[i2];
        if (!state.groupNames[name]) {
          state.raise("Invalid named capture referenced");
        }
      }
    };
    pp$1.regexp_disjunction = function(state) {
      var trackDisjunction = this.options.ecmaVersion >= 16;
      if (trackDisjunction) {
        state.branchID = new BranchID(state.branchID, null);
      }
      this.regexp_alternative(state);
      while (state.eat(
        124
        /* | */
      )) {
        if (trackDisjunction) {
          state.branchID = state.branchID.sibling();
        }
        this.regexp_alternative(state);
      }
      if (trackDisjunction) {
        state.branchID = state.branchID.parent;
      }
      if (this.regexp_eatQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      if (state.eat(
        123
        /* { */
      )) {
        state.raise("Lone quantifier brackets");
      }
    };
    pp$1.regexp_alternative = function(state) {
      while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
      }
    };
    pp$1.regexp_eatTerm = function(state) {
      if (this.regexp_eatAssertion(state)) {
        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
          if (state.switchU) {
            state.raise("Invalid quantifier");
          }
        }
        return true;
      }
      if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
        this.regexp_eatQuantifier(state);
        return true;
      }
      return false;
    };
    pp$1.regexp_eatAssertion = function(state) {
      var start = state.pos;
      state.lastAssertionIsQuantifiable = false;
      if (state.eat(
        94
        /* ^ */
      ) || state.eat(
        36
        /* $ */
      )) {
        return true;
      }
      if (state.eat(
        92
        /* \ */
      )) {
        if (state.eat(
          66
          /* B */
        ) || state.eat(
          98
          /* b */
        )) {
          return true;
        }
        state.pos = start;
      }
      if (state.eat(
        40
        /* ( */
      ) && state.eat(
        63
        /* ? */
      )) {
        var lookbehind = false;
        if (this.options.ecmaVersion >= 9) {
          lookbehind = state.eat(
            60
            /* < */
          );
        }
        if (state.eat(
          61
          /* = */
        ) || state.eat(
          33
          /* ! */
        )) {
          this.regexp_disjunction(state);
          if (!state.eat(
            41
            /* ) */
          )) {
            state.raise("Unterminated group");
          }
          state.lastAssertionIsQuantifiable = !lookbehind;
          return true;
        }
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatQuantifier = function(state, noError) {
      if (noError === void 0) noError = false;
      if (this.regexp_eatQuantifierPrefix(state, noError)) {
        state.eat(
          63
          /* ? */
        );
        return true;
      }
      return false;
    };
    pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
      return state.eat(
        42
        /* * */
      ) || state.eat(
        43
        /* + */
      ) || state.eat(
        63
        /* ? */
      ) || this.regexp_eatBracedQuantifier(state, noError);
    };
    pp$1.regexp_eatBracedQuantifier = function(state, noError) {
      var start = state.pos;
      if (state.eat(
        123
        /* { */
      )) {
        var min = 0, max = -1;
        if (this.regexp_eatDecimalDigits(state)) {
          min = state.lastIntValue;
          if (state.eat(
            44
            /* , */
          ) && this.regexp_eatDecimalDigits(state)) {
            max = state.lastIntValue;
          }
          if (state.eat(
            125
            /* } */
          )) {
            if (max !== -1 && max < min && !noError) {
              state.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (state.switchU && !noError) {
          state.raise("Incomplete quantifier");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatAtom = function(state) {
      return this.regexp_eatPatternCharacters(state) || state.eat(
        46
        /* . */
      ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
    };
    pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
      var start = state.pos;
      if (state.eat(
        92
        /* \ */
      )) {
        if (this.regexp_eatAtomEscape(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatUncapturingGroup = function(state) {
      var start = state.pos;
      if (state.eat(
        40
        /* ( */
      )) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (this.options.ecmaVersion >= 16) {
            var addModifiers = this.regexp_eatModifiers(state);
            var hasHyphen = state.eat(
              45
              /* - */
            );
            if (addModifiers || hasHyphen) {
              for (var i2 = 0; i2 < addModifiers.length; i2++) {
                var modifier = addModifiers.charAt(i2);
                if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
                  state.raise("Duplicate regular expression modifiers");
                }
              }
              if (hasHyphen) {
                var removeModifiers = this.regexp_eatModifiers(state);
                if (!addModifiers && !removeModifiers && state.current() === 58) {
                  state.raise("Invalid regular expression modifiers");
                }
                for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
                  var modifier$1 = removeModifiers.charAt(i$1);
                  if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                    state.raise("Duplicate regular expression modifiers");
                  }
                }
              }
            }
          }
          if (state.eat(
            58
            /* : */
          )) {
            this.regexp_disjunction(state);
            if (state.eat(
              41
              /* ) */
            )) {
              return true;
            }
            state.raise("Unterminated group");
          }
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatCapturingGroup = function(state) {
      if (state.eat(
        40
        /* ( */
      )) {
        if (this.options.ecmaVersion >= 9) {
          this.regexp_groupSpecifier(state);
        } else if (state.current() === 63) {
          state.raise("Invalid group");
        }
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          state.numCapturingParens += 1;
          return true;
        }
        state.raise("Unterminated group");
      }
      return false;
    };
    pp$1.regexp_eatModifiers = function(state) {
      var modifiers = "";
      var ch = 0;
      while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
        modifiers += codePointToString(ch);
        state.advance();
      }
      return modifiers;
    };
    pp$1.regexp_eatExtendedAtom = function(state) {
      return state.eat(
        46
        /* . */
      ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
    };
    pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
      if (this.regexp_eatBracedQuantifier(state, true)) {
        state.raise("Nothing to repeat");
      }
      return false;
    };
    pp$1.regexp_eatSyntaxCharacter = function(state) {
      var ch = state.current();
      if (isSyntaxCharacter(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatPatternCharacters = function(state) {
      var start = state.pos;
      var ch = 0;
      while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatExtendedPatternCharacter = function(state) {
      var ch = state.current();
      if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_groupSpecifier = function(state) {
      if (state.eat(
        63
        /* ? */
      )) {
        if (!this.regexp_eatGroupName(state)) {
          state.raise("Invalid group");
        }
        var trackDisjunction = this.options.ecmaVersion >= 16;
        var known = state.groupNames[state.lastStringValue];
        if (known) {
          if (trackDisjunction) {
            for (var i2 = 0, list = known; i2 < list.length; i2 += 1) {
              var altID = list[i2];
              if (!altID.separatedFrom(state.branchID)) {
                state.raise("Duplicate capture group name");
              }
            }
          } else {
            state.raise("Duplicate capture group name");
          }
        }
        if (trackDisjunction) {
          (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
        } else {
          state.groupNames[state.lastStringValue] = true;
        }
      }
    };
    pp$1.regexp_eatGroupName = function(state) {
      state.lastStringValue = "";
      if (state.eat(
        60
        /* < */
      )) {
        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
          62
          /* > */
        )) {
          return true;
        }
        state.raise("Invalid capture group name");
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierName = function(state) {
      state.lastStringValue = "";
      if (this.regexp_eatRegExpIdentifierStart(state)) {
        state.lastStringValue += codePointToString(state.lastIntValue);
        while (this.regexp_eatRegExpIdentifierPart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierStart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierStart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatRegExpIdentifierPart = function(state) {
      var start = state.pos;
      var forceU = this.options.ecmaVersion >= 11;
      var ch = state.current(forceU);
      state.advance(forceU);
      if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
        ch = state.lastIntValue;
      }
      if (isRegExpIdentifierPart(ch)) {
        state.lastIntValue = ch;
        return true;
      }
      state.pos = start;
      return false;
    };
    pp$1.regexp_eatAtomEscape = function(state) {
      if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
        return true;
      }
      if (state.switchU) {
        if (state.current() === 99) {
          state.raise("Invalid unicode escape");
        }
        state.raise("Invalid escape");
      }
      return false;
    };
    pp$1.regexp_eatBackReference = function(state) {
      var start = state.pos;
      if (this.regexp_eatDecimalEscape(state)) {
        var n = state.lastIntValue;
        if (state.switchU) {
          if (n > state.maxBackReference) {
            state.maxBackReference = n;
          }
          return true;
        }
        if (n <= state.numCapturingParens) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatKGroupName = function(state) {
      if (state.eat(
        107
        /* k */
      )) {
        if (this.regexp_eatGroupName(state)) {
          state.backReferenceNames.push(state.lastStringValue);
          return true;
        }
        state.raise("Invalid named reference");
      }
      return false;
    };
    pp$1.regexp_eatCharacterEscape = function(state) {
      return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
    };
    pp$1.regexp_eatCControlLetter = function(state) {
      var start = state.pos;
      if (state.eat(
        99
        /* c */
      )) {
        if (this.regexp_eatControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatZero = function(state) {
      if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
        state.lastIntValue = 0;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlEscape = function(state) {
      var ch = state.current();
      if (ch === 116) {
        state.lastIntValue = 9;
        state.advance();
        return true;
      }
      if (ch === 110) {
        state.lastIntValue = 10;
        state.advance();
        return true;
      }
      if (ch === 118) {
        state.lastIntValue = 11;
        state.advance();
        return true;
      }
      if (ch === 102) {
        state.lastIntValue = 12;
        state.advance();
        return true;
      }
      if (ch === 114) {
        state.lastIntValue = 13;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatControlLetter = function(state) {
      var ch = state.current();
      if (isControlLetter(ch)) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
      if (forceU === void 0) forceU = false;
      var start = state.pos;
      var switchU = forceU || state.switchU;
      if (state.eat(
        117
        /* u */
      )) {
        if (this.regexp_eatFixedHexDigits(state, 4)) {
          var lead = state.lastIntValue;
          if (switchU && lead >= 55296 && lead <= 56319) {
            var leadSurrogateEnd = state.pos;
            if (state.eat(
              92
              /* \ */
            ) && state.eat(
              117
              /* u */
            ) && this.regexp_eatFixedHexDigits(state, 4)) {
              var trail = state.lastIntValue;
              if (trail >= 56320 && trail <= 57343) {
                state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                return true;
              }
            }
            state.pos = leadSurrogateEnd;
            state.lastIntValue = lead;
          }
          return true;
        }
        if (switchU && state.eat(
          123
          /* { */
        ) && this.regexp_eatHexDigits(state) && state.eat(
          125
          /* } */
        ) && isValidUnicode(state.lastIntValue)) {
          return true;
        }
        if (switchU) {
          state.raise("Invalid unicode escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatIdentityEscape = function(state) {
      if (state.switchU) {
        if (this.regexp_eatSyntaxCharacter(state)) {
          return true;
        }
        if (state.eat(
          47
          /* / */
        )) {
          state.lastIntValue = 47;
          return true;
        }
        return false;
      }
      var ch = state.current();
      if (ch !== 99 && (!state.switchN || ch !== 107)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatDecimalEscape = function(state) {
      state.lastIntValue = 0;
      var ch = state.current();
      if (ch >= 49 && ch <= 57) {
        do {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        } while ((ch = state.current()) >= 48 && ch <= 57);
        return true;
      }
      return false;
    };
    CharSetNone = 0;
    CharSetOk = 1;
    CharSetString = 2;
    pp$1.regexp_eatCharacterClassEscape = function(state) {
      var ch = state.current();
      if (isCharacterClassEscape(ch)) {
        state.lastIntValue = -1;
        state.advance();
        return CharSetOk;
      }
      var negate = false;
      if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
        state.lastIntValue = -1;
        state.advance();
        var result;
        if (state.eat(
          123
          /* { */
        ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
          125
          /* } */
        )) {
          if (negate && result === CharSetString) {
            state.raise("Invalid property name");
          }
          return result;
        }
        state.raise("Invalid property name");
      }
      return CharSetNone;
    };
    pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
      var start = state.pos;
      if (this.regexp_eatUnicodePropertyName(state) && state.eat(
        61
        /* = */
      )) {
        var name = state.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(state)) {
          var value = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
          return CharSetOk;
        }
      }
      state.pos = start;
      if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
        var nameOrValue = state.lastStringValue;
        return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      }
      return CharSetNone;
    };
    pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
      if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
        state.raise("Invalid property name");
      }
      if (!state.unicodeProperties.nonBinary[name].test(value)) {
        state.raise("Invalid property value");
      }
    };
    pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
      if (state.unicodeProperties.binary.test(nameOrValue)) {
        return CharSetOk;
      }
      if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
        return CharSetString;
      }
      state.raise("Invalid property name");
    };
    pp$1.regexp_eatUnicodePropertyName = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyNameCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$1.regexp_eatUnicodePropertyValue = function(state) {
      var ch = 0;
      state.lastStringValue = "";
      while (isUnicodePropertyValueCharacter(ch = state.current())) {
        state.lastStringValue += codePointToString(ch);
        state.advance();
      }
      return state.lastStringValue !== "";
    };
    pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
      return this.regexp_eatUnicodePropertyValue(state);
    };
    pp$1.regexp_eatCharacterClass = function(state) {
      if (state.eat(
        91
        /* [ */
      )) {
        var negate = state.eat(
          94
          /* ^ */
        );
        var result = this.regexp_classContents(state);
        if (!state.eat(
          93
          /* ] */
        )) {
          state.raise("Unterminated character class");
        }
        if (negate && result === CharSetString) {
          state.raise("Negated character class may contain strings");
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_classContents = function(state) {
      if (state.current() === 93) {
        return CharSetOk;
      }
      if (state.switchV) {
        return this.regexp_classSetExpression(state);
      }
      this.regexp_nonEmptyClassRanges(state);
      return CharSetOk;
    };
    pp$1.regexp_nonEmptyClassRanges = function(state) {
      while (this.regexp_eatClassAtom(state)) {
        var left = state.lastIntValue;
        if (state.eat(
          45
          /* - */
        ) && this.regexp_eatClassAtom(state)) {
          var right = state.lastIntValue;
          if (state.switchU && (left === -1 || right === -1)) {
            state.raise("Invalid character class");
          }
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
        }
      }
    };
    pp$1.regexp_eatClassAtom = function(state) {
      var start = state.pos;
      if (state.eat(
        92
        /* \ */
      )) {
        if (this.regexp_eatClassEscape(state)) {
          return true;
        }
        if (state.switchU) {
          var ch$1 = state.current();
          if (ch$1 === 99 || isOctalDigit(ch$1)) {
            state.raise("Invalid class escape");
          }
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      var ch = state.current();
      if (ch !== 93) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatClassEscape = function(state) {
      var start = state.pos;
      if (state.eat(
        98
        /* b */
      )) {
        state.lastIntValue = 8;
        return true;
      }
      if (state.switchU && state.eat(
        45
        /* - */
      )) {
        state.lastIntValue = 45;
        return true;
      }
      if (!state.switchU && state.eat(
        99
        /* c */
      )) {
        if (this.regexp_eatClassControlLetter(state)) {
          return true;
        }
        state.pos = start;
      }
      return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
    };
    pp$1.regexp_classSetExpression = function(state) {
      var result = CharSetOk, subResult;
      if (this.regexp_eatClassSetRange(state)) ;
      else if (subResult = this.regexp_eatClassSetOperand(state)) {
        if (subResult === CharSetString) {
          result = CharSetString;
        }
        var start = state.pos;
        while (state.eatChars(
          [38, 38]
          /* && */
        )) {
          if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
            if (subResult !== CharSetString) {
              result = CharSetOk;
            }
            continue;
          }
          state.raise("Invalid character in character class");
        }
        if (start !== state.pos) {
          return result;
        }
        while (state.eatChars(
          [45, 45]
          /* -- */
        )) {
          if (this.regexp_eatClassSetOperand(state)) {
            continue;
          }
          state.raise("Invalid character in character class");
        }
        if (start !== state.pos) {
          return result;
        }
      } else {
        state.raise("Invalid character in character class");
      }
      for (; ; ) {
        if (this.regexp_eatClassSetRange(state)) {
          continue;
        }
        subResult = this.regexp_eatClassSetOperand(state);
        if (!subResult) {
          return result;
        }
        if (subResult === CharSetString) {
          result = CharSetString;
        }
      }
    };
    pp$1.regexp_eatClassSetRange = function(state) {
      var start = state.pos;
      if (this.regexp_eatClassSetCharacter(state)) {
        var left = state.lastIntValue;
        if (state.eat(
          45
          /* - */
        ) && this.regexp_eatClassSetCharacter(state)) {
          var right = state.lastIntValue;
          if (left !== -1 && right !== -1 && left > right) {
            state.raise("Range out of order in character class");
          }
          return true;
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatClassSetOperand = function(state) {
      if (this.regexp_eatClassSetCharacter(state)) {
        return CharSetOk;
      }
      return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
    };
    pp$1.regexp_eatNestedClass = function(state) {
      var start = state.pos;
      if (state.eat(
        91
        /* [ */
      )) {
        var negate = state.eat(
          94
          /* ^ */
        );
        var result = this.regexp_classContents(state);
        if (state.eat(
          93
          /* ] */
        )) {
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return result;
        }
        state.pos = start;
      }
      if (state.eat(
        92
        /* \ */
      )) {
        var result$1 = this.regexp_eatCharacterClassEscape(state);
        if (result$1) {
          return result$1;
        }
        state.pos = start;
      }
      return null;
    };
    pp$1.regexp_eatClassStringDisjunction = function(state) {
      var start = state.pos;
      if (state.eatChars(
        [92, 113]
        /* \q */
      )) {
        if (state.eat(
          123
          /* { */
        )) {
          var result = this.regexp_classStringDisjunctionContents(state);
          if (state.eat(
            125
            /* } */
          )) {
            return result;
          }
        } else {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return null;
    };
    pp$1.regexp_classStringDisjunctionContents = function(state) {
      var result = this.regexp_classString(state);
      while (state.eat(
        124
        /* | */
      )) {
        if (this.regexp_classString(state) === CharSetString) {
          result = CharSetString;
        }
      }
      return result;
    };
    pp$1.regexp_classString = function(state) {
      var count = 0;
      while (this.regexp_eatClassSetCharacter(state)) {
        count++;
      }
      return count === 1 ? CharSetOk : CharSetString;
    };
    pp$1.regexp_eatClassSetCharacter = function(state) {
      var start = state.pos;
      if (state.eat(
        92
        /* \ */
      )) {
        if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
          return true;
        }
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        state.pos = start;
        return false;
      }
      var ch = state.current();
      if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
        return false;
      }
      if (isClassSetSyntaxCharacter(ch)) {
        return false;
      }
      state.advance();
      state.lastIntValue = ch;
      return true;
    };
    pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
      var ch = state.current();
      if (isClassSetReservedPunctuator(ch)) {
        state.lastIntValue = ch;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatClassControlLetter = function(state) {
      var ch = state.current();
      if (isDecimalDigit(ch) || ch === 95) {
        state.lastIntValue = ch % 32;
        state.advance();
        return true;
      }
      return false;
    };
    pp$1.regexp_eatHexEscapeSequence = function(state) {
      var start = state.pos;
      if (state.eat(
        120
        /* x */
      )) {
        if (this.regexp_eatFixedHexDigits(state, 2)) {
          return true;
        }
        if (state.switchU) {
          state.raise("Invalid escape");
        }
        state.pos = start;
      }
      return false;
    };
    pp$1.regexp_eatDecimalDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isDecimalDigit(ch = state.current())) {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatHexDigits = function(state) {
      var start = state.pos;
      var ch = 0;
      state.lastIntValue = 0;
      while (isHexDigit(ch = state.current())) {
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return state.pos !== start;
    };
    pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
      if (this.regexp_eatOctalDigit(state)) {
        var n1 = state.lastIntValue;
        if (this.regexp_eatOctalDigit(state)) {
          var n2 = state.lastIntValue;
          if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
            state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
          } else {
            state.lastIntValue = n1 * 8 + n2;
          }
        } else {
          state.lastIntValue = n1;
        }
        return true;
      }
      return false;
    };
    pp$1.regexp_eatOctalDigit = function(state) {
      var ch = state.current();
      if (isOctalDigit(ch)) {
        state.lastIntValue = ch - 48;
        state.advance();
        return true;
      }
      state.lastIntValue = 0;
      return false;
    };
    pp$1.regexp_eatFixedHexDigits = function(state, length) {
      var start = state.pos;
      state.lastIntValue = 0;
      for (var i2 = 0; i2 < length; ++i2) {
        var ch = state.current();
        if (!isHexDigit(ch)) {
          state.pos = start;
          return false;
        }
        state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
        state.advance();
      }
      return true;
    };
    Token = function Token2(p3) {
      this.type = p3.type;
      this.value = p3.value;
      this.start = p3.start;
      this.end = p3.end;
      if (p3.options.locations) {
        this.loc = new SourceLocation(p3, p3.startLoc, p3.endLoc);
      }
      if (p3.options.ranges) {
        this.range = [p3.start, p3.end];
      }
    };
    pp = Parser.prototype;
    pp.next = function(ignoreEscapeSequenceInKeyword) {
      if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
        this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
      }
      if (this.options.onToken) {
        this.options.onToken(new Token(this));
      }
      this.lastTokEnd = this.end;
      this.lastTokStart = this.start;
      this.lastTokEndLoc = this.endLoc;
      this.lastTokStartLoc = this.startLoc;
      this.nextToken();
    };
    pp.getToken = function() {
      this.next();
      return new Token(this);
    };
    if (typeof Symbol !== "undefined") {
      pp[Symbol.iterator] = function() {
        var this$1$1 = this;
        return {
          next: function() {
            var token = this$1$1.getToken();
            return {
              done: token.type === types$1.eof,
              value: token
            };
          }
        };
      };
    }
    pp.nextToken = function() {
      var curContext = this.curContext();
      if (!curContext || !curContext.preserveSpace) {
        this.skipSpace();
      }
      this.start = this.pos;
      if (this.options.locations) {
        this.startLoc = this.curPosition();
      }
      if (this.pos >= this.input.length) {
        return this.finishToken(types$1.eof);
      }
      if (curContext.override) {
        return curContext.override(this);
      } else {
        this.readToken(this.fullCharCodeAtPos());
      }
    };
    pp.readToken = function(code) {
      if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
        return this.readWord();
      }
      return this.getTokenFromCode(code);
    };
    pp.fullCharCodeAtPos = function() {
      var code = this.input.charCodeAt(this.pos);
      if (code <= 55295 || code >= 56320) {
        return code;
      }
      var next = this.input.charCodeAt(this.pos + 1);
      return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
    };
    pp.skipBlockComment = function() {
      var startLoc = this.options.onComment && this.curPosition();
      var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
      if (end === -1) {
        this.raise(this.pos - 2, "Unterminated comment");
      }
      this.pos = end + 2;
      if (this.options.locations) {
        for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
          ++this.curLine;
          pos = this.lineStart = nextBreak;
        }
      }
      if (this.options.onComment) {
        this.options.onComment(
          true,
          this.input.slice(start + 2, end),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp.skipLineComment = function(startSkip) {
      var start = this.pos;
      var startLoc = this.options.onComment && this.curPosition();
      var ch = this.input.charCodeAt(this.pos += startSkip);
      while (this.pos < this.input.length && !isNewLine(ch)) {
        ch = this.input.charCodeAt(++this.pos);
      }
      if (this.options.onComment) {
        this.options.onComment(
          false,
          this.input.slice(start + startSkip, this.pos),
          start,
          this.pos,
          startLoc,
          this.curPosition()
        );
      }
    };
    pp.skipSpace = function() {
      loop: while (this.pos < this.input.length) {
        var ch = this.input.charCodeAt(this.pos);
        switch (ch) {
          case 32:
          case 160:
            ++this.pos;
            break;
          case 13:
            if (this.input.charCodeAt(this.pos + 1) === 10) {
              ++this.pos;
            }
          case 10:
          case 8232:
          case 8233:
            ++this.pos;
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            break;
          case 47:
            switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break loop;
            }
            break;
          default:
            if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
              ++this.pos;
            } else {
              break loop;
            }
        }
      }
    };
    pp.finishToken = function(type, val) {
      this.end = this.pos;
      if (this.options.locations) {
        this.endLoc = this.curPosition();
      }
      var prevType = this.type;
      this.type = type;
      this.value = val;
      this.updateContext(prevType);
    };
    pp.readToken_dot = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next >= 48 && next <= 57) {
        return this.readNumber(true);
      }
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
        this.pos += 3;
        return this.finishToken(types$1.ellipsis);
      } else {
        ++this.pos;
        return this.finishToken(types$1.dot);
      }
    };
    pp.readToken_slash = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (this.exprAllowed) {
        ++this.pos;
        return this.readRegexp();
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.slash, 1);
    };
    pp.readToken_mult_modulo_exp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      var tokentype = code === 42 ? types$1.star : types$1.modulo;
      if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
        ++size;
        tokentype = types$1.starstar;
        next = this.input.charCodeAt(this.pos + 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, size + 1);
      }
      return this.finishOp(tokentype, size);
    };
    pp.readToken_pipe_amp = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (this.options.ecmaVersion >= 12) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 === 61) {
            return this.finishOp(types$1.assign, 3);
          }
        }
        return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    };
    pp.readToken_caret = function() {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.bitwiseXOR, 1);
    };
    pp.readToken_plus_min = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
          this.skipLineComment(3);
          this.skipSpace();
          return this.nextToken();
        }
        return this.finishOp(types$1.incDec, 2);
      }
      if (next === 61) {
        return this.finishOp(types$1.assign, 2);
      }
      return this.finishOp(types$1.plusMin, 1);
    };
    pp.readToken_lt_gt = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      var size = 1;
      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(this.pos + size) === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(types$1.bitShift, size);
      }
      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        return this.nextToken();
      }
      if (next === 61) {
        size = 2;
      }
      return this.finishOp(types$1.relational, size);
    };
    pp.readToken_eq_excl = function(code) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 61) {
        return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
      }
      if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
        this.pos += 2;
        return this.finishToken(types$1.arrow);
      }
      return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
    };
    pp.readToken_question = function() {
      var ecmaVersion = this.options.ecmaVersion;
      if (ecmaVersion >= 11) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 46) {
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (next2 < 48 || next2 > 57) {
            return this.finishOp(types$1.questionDot, 2);
          }
        }
        if (next === 63) {
          if (ecmaVersion >= 12) {
            var next2$1 = this.input.charCodeAt(this.pos + 2);
            if (next2$1 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(types$1.coalesce, 2);
        }
      }
      return this.finishOp(types$1.question, 1);
    };
    pp.readToken_numberSign = function() {
      var ecmaVersion = this.options.ecmaVersion;
      var code = 35;
      if (ecmaVersion >= 13) {
        ++this.pos;
        code = this.fullCharCodeAtPos();
        if (isIdentifierStart(code, true) || code === 92) {
          return this.finishToken(types$1.privateId, this.readWord1());
        }
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.getTokenFromCode = function(code) {
      switch (code) {
        // The interpretation of a dot depends on whether it is followed
        // by a digit or another two dots.
        case 46:
          return this.readToken_dot();
        // Punctuation tokens.
        case 40:
          ++this.pos;
          return this.finishToken(types$1.parenL);
        case 41:
          ++this.pos;
          return this.finishToken(types$1.parenR);
        case 59:
          ++this.pos;
          return this.finishToken(types$1.semi);
        case 44:
          ++this.pos;
          return this.finishToken(types$1.comma);
        case 91:
          ++this.pos;
          return this.finishToken(types$1.bracketL);
        case 93:
          ++this.pos;
          return this.finishToken(types$1.bracketR);
        case 123:
          ++this.pos;
          return this.finishToken(types$1.braceL);
        case 125:
          ++this.pos;
          return this.finishToken(types$1.braceR);
        case 58:
          ++this.pos;
          return this.finishToken(types$1.colon);
        case 96:
          if (this.options.ecmaVersion < 6) {
            break;
          }
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        case 48:
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) {
            return this.readRadixNumber(16);
          }
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) {
              return this.readRadixNumber(8);
            }
            if (next === 98 || next === 66) {
              return this.readRadixNumber(2);
            }
          }
        // Anything else beginning with a digit is an integer, octal
        // number, or float.
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        // Quotes produce strings.
        case 34:
        case 39:
          return this.readString(code);
        // Operators are parsed inline in tiny state machines. '=' (61) is
        // often referred to. `finishOp` simply skips the amount of
        // characters it is given as second argument, and returns a token
        // of the type given by its first argument.
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(code);
        case 124:
        case 38:
          return this.readToken_pipe_amp(code);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(code);
        case 60:
        case 62:
          return this.readToken_lt_gt(code);
        case 61:
        case 33:
          return this.readToken_eq_excl(code);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(types$1.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
    };
    pp.finishOp = function(type, size) {
      var str = this.input.slice(this.pos, this.pos + size);
      this.pos += size;
      return this.finishToken(type, str);
    };
    pp.readRegexp = function() {
      var escaped, inClass, start = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(start, "Unterminated regular expression");
        }
        var ch = this.input.charAt(this.pos);
        if (lineBreak.test(ch)) {
          this.raise(start, "Unterminated regular expression");
        }
        if (!escaped) {
          if (ch === "[") {
            inClass = true;
          } else if (ch === "]" && inClass) {
            inClass = false;
          } else if (ch === "/" && !inClass) {
            break;
          }
          escaped = ch === "\\";
        } else {
          escaped = false;
        }
        ++this.pos;
      }
      var pattern = this.input.slice(start, this.pos);
      ++this.pos;
      var flagsStart = this.pos;
      var flags = this.readWord1();
      if (this.containsEsc) {
        this.unexpected(flagsStart);
      }
      var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
      state.reset(start, pattern, flags);
      this.validateRegExpFlags(state);
      this.validateRegExpPattern(state);
      var value = null;
      try {
        value = new RegExp(pattern, flags);
      } catch (e3) {
      }
      return this.finishToken(types$1.regexp, { pattern, flags, value });
    };
    pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
      var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
      var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
      var start = this.pos, total = 0, lastCode = 0;
      for (var i2 = 0, e3 = len == null ? Infinity : len; i2 < e3; ++i2, ++this.pos) {
        var code = this.input.charCodeAt(this.pos), val = void 0;
        if (allowSeparators && code === 95) {
          if (isLegacyOctalNumericLiteral) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
          }
          if (lastCode === 95) {
            this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
          }
          if (i2 === 0) {
            this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
          }
          lastCode = code;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (code >= 48 && code <= 57) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          break;
        }
        lastCode = code;
        total = total * radix + val;
      }
      if (allowSeparators && lastCode === 95) {
        this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
      }
      if (this.pos === start || len != null && this.pos - start !== len) {
        return null;
      }
      return total;
    };
    pp.readRadixNumber = function(radix) {
      var start = this.pos;
      this.pos += 2;
      var val = this.readInt(radix);
      if (val == null) {
        this.raise(this.start + 2, "Expected number in radix " + radix);
      }
      if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
        val = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
      } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      return this.finishToken(types$1.num, val);
    };
    pp.readNumber = function(startsWithDot) {
      var start = this.pos;
      if (!startsWithDot && this.readInt(10, void 0, true) === null) {
        this.raise(start, "Invalid number");
      }
      var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
      if (octal && this.strict) {
        this.raise(start, "Invalid number");
      }
      var next = this.input.charCodeAt(this.pos);
      if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
        var val$1 = stringToBigInt(this.input.slice(start, this.pos));
        ++this.pos;
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val$1);
      }
      if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
        octal = false;
      }
      if (next === 46 && !octal) {
        ++this.pos;
        this.readInt(10);
        next = this.input.charCodeAt(this.pos);
      }
      if ((next === 69 || next === 101) && !octal) {
        next = this.input.charCodeAt(++this.pos);
        if (next === 43 || next === 45) {
          ++this.pos;
        }
        if (this.readInt(10) === null) {
          this.raise(start, "Invalid number");
        }
      }
      if (isIdentifierStart(this.fullCharCodeAtPos())) {
        this.raise(this.pos, "Identifier directly after number");
      }
      var val = stringToNumber(this.input.slice(start, this.pos), octal);
      return this.finishToken(types$1.num, val);
    };
    pp.readCodePoint = function() {
      var ch = this.input.charCodeAt(this.pos), code;
      if (ch === 123) {
        if (this.options.ecmaVersion < 6) {
          this.unexpected();
        }
        var codePos = ++this.pos;
        code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
        ++this.pos;
        if (code > 1114111) {
          this.invalidStringToken(codePos, "Code point out of bounds");
        }
      } else {
        code = this.readHexChar(4);
      }
      return code;
    };
    pp.readString = function(quote) {
      var out = "", chunkStart = ++this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated string constant");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === quote) {
          break;
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.pos;
        } else if (ch === 8232 || ch === 8233) {
          if (this.options.ecmaVersion < 10) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
          if (this.options.locations) {
            this.curLine++;
            this.lineStart = this.pos;
          }
        } else {
          if (isNewLine(ch)) {
            this.raise(this.start, "Unterminated string constant");
          }
          ++this.pos;
        }
      }
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(types$1.string, out);
    };
    INVALID_TEMPLATE_ESCAPE_ERROR = {};
    pp.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (err) {
        if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
          this.readInvalidTemplateToken();
        } else {
          throw err;
        }
      }
      this.inTemplateElement = false;
    };
    pp.invalidStringToken = function(position, message) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
        throw INVALID_TEMPLATE_ESCAPE_ERROR;
      } else {
        this.raise(position, message);
      }
    };
    pp.readTmplToken = function() {
      var out = "", chunkStart = this.pos;
      for (; ; ) {
        if (this.pos >= this.input.length) {
          this.raise(this.start, "Unterminated template");
        }
        var ch = this.input.charCodeAt(this.pos);
        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
          if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
            if (ch === 36) {
              this.pos += 2;
              return this.finishToken(types$1.dollarBraceL);
            } else {
              ++this.pos;
              return this.finishToken(types$1.backQuote);
            }
          }
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(types$1.template, out);
        }
        if (ch === 92) {
          out += this.input.slice(chunkStart, this.pos);
          out += this.readEscapedChar(true);
          chunkStart = this.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.pos);
          ++this.pos;
          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) {
                ++this.pos;
              }
            case 10:
              out += "\n";
              break;
            default:
              out += String.fromCharCode(ch);
              break;
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          chunkStart = this.pos;
        } else {
          ++this.pos;
        }
      }
    };
    pp.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) {
        switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break;
          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break;
            }
          // fall through
          case "`":
            return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
          case "\r":
            if (this.input[this.pos + 1] === "\n") {
              ++this.pos;
            }
          // fall through
          case "\n":
          case "\u2028":
          case "\u2029":
            ++this.curLine;
            this.lineStart = this.pos + 1;
            break;
        }
      }
      this.raise(this.start, "Unterminated template");
    };
    pp.readEscapedChar = function(inTemplate) {
      var ch = this.input.charCodeAt(++this.pos);
      ++this.pos;
      switch (ch) {
        case 110:
          return "\n";
        // 'n' -> '\n'
        case 114:
          return "\r";
        // 'r' -> '\r'
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        // 'x'
        case 117:
          return codePointToString(this.readCodePoint());
        // 'u'
        case 116:
          return "	";
        // 't' -> '\t'
        case 98:
          return "\b";
        // 'b' -> '\b'
        case 118:
          return "\v";
        // 'v' -> '\u000b'
        case 102:
          return "\f";
        // 'f' -> '\f'
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        // '\r\n'
        case 10:
          if (this.options.locations) {
            this.lineStart = this.pos;
            ++this.curLine;
          }
          return "";
        case 56:
        case 57:
          if (this.strict) {
            this.invalidStringToken(
              this.pos - 1,
              "Invalid escape sequence"
            );
          }
          if (inTemplate) {
            var codePos = this.pos - 1;
            this.invalidStringToken(
              codePos,
              "Invalid escape sequence in template string"
            );
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(
                this.pos - 1 - octalStr.length,
                inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
              );
            }
            return String.fromCharCode(octal);
          }
          if (isNewLine(ch)) {
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          }
          return String.fromCharCode(ch);
      }
    };
    pp.readHexChar = function(len) {
      var codePos = this.pos;
      var n = this.readInt(16, len);
      if (n === null) {
        this.invalidStringToken(codePos, "Bad character escape sequence");
      }
      return n;
    };
    pp.readWord1 = function() {
      this.containsEsc = false;
      var word = "", first = true, chunkStart = this.pos;
      var astral = this.options.ecmaVersion >= 6;
      while (this.pos < this.input.length) {
        var ch = this.fullCharCodeAtPos();
        if (isIdentifierChar(ch, astral)) {
          this.pos += ch <= 65535 ? 1 : 2;
        } else if (ch === 92) {
          this.containsEsc = true;
          word += this.input.slice(chunkStart, this.pos);
          var escStart = this.pos;
          if (this.input.charCodeAt(++this.pos) !== 117) {
            this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
          }
          ++this.pos;
          var esc = this.readCodePoint();
          if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
            this.invalidStringToken(escStart, "Invalid Unicode escape");
          }
          word += codePointToString(esc);
          chunkStart = this.pos;
        } else {
          break;
        }
        first = false;
      }
      return word + this.input.slice(chunkStart, this.pos);
    };
    pp.readWord = function() {
      var word = this.readWord1();
      var type = types$1.name;
      if (this.keywords.test(word)) {
        type = keywords[word];
      }
      return this.finishToken(type, word);
    };
    version = "8.15.0";
    Parser.acorn = {
      Parser,
      version,
      defaultOptions,
      Position,
      SourceLocation,
      getLineInfo,
      Node,
      TokenType,
      tokTypes: types$1,
      keywordTypes: keywords,
      TokContext,
      tokContexts: types,
      isIdentifierChar,
      isIdentifierStart,
      Token,
      isNewLine,
      lineBreak,
      lineBreakG,
      nonASCIIwhitespace
    };
  }
});

// ../../node_modules/.pnpm/ufo@1.6.1/node_modules/ufo/dist/index.mjs
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path4 = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path4 = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path4) {
      return fragment;
    }
  }
  const [s0, ...s4] = path4.split("?");
  return s0 + "/" + (s4.length > 0 ? `?${s4.join("?")}` : "") + fragment;
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
var r2, TRAILING_SLASH_RE, JOIN_LEADING_SLASH_RE, protocolRelative;
var init_dist2 = __esm({
  "../../node_modules/.pnpm/ufo@1.6.1/node_modules/ufo/dist/index.mjs"() {
    "use strict";
    r2 = String.fromCharCode;
    TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
    JOIN_LEADING_SLASH_RE = /^\.?\//;
    protocolRelative = Symbol.for("ufo:protocolRelative");
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/shared/confbox.9388d834.mjs
function g(e3, t2) {
  const n = /* @__PURE__ */ new Map();
  let i2 = 0, s4, o;
  for (const c2 of e3.split(/\n/g)) {
    if (!c2) continue;
    let f3, a3, l3, p3, r6;
    const y3 = c2.match(b);
    if (y3 === null) i2 = 0, s4 = "";
    else {
      if (f3 = y3[0].length, a3 = y3[1] ? d : h2, t2 && a3 === d && f3 === 1) continue;
      a3 !== s4 && (i2 = 0), s4 = a3, l3 = 1, p3 = 0;
      const u4 = f3 - i2;
      if (i2 = f3, u4 === 0) l3 = 0, p3 = 1;
      else {
        const I5 = u4 > 0 ? u4 : -u4;
        o = T(a3, I5);
      }
      r6 = n.get(o), r6 = r6 === void 0 ? [1, 0] : [r6[0] + l3, r6[1] + p3], n.set(o, r6);
    }
  }
  return n;
}
function T(e3, t2) {
  return (e3 === d ? "s" : "t") + String(t2);
}
function w(e3) {
  const n = e3[0] === "s" ? d : h2, i2 = Number(e3.slice(1));
  return { type: n, amount: i2 };
}
function E(e3) {
  let t2, n = 0, i2 = 0;
  for (const [s4, [o, c2]] of e3) (o > n || o === n && c2 > i2) && (n = o, i2 = c2, t2 = s4);
  return t2;
}
function S(e3, t2) {
  return (e3 === d ? " " : "	").repeat(t2);
}
function _(e3) {
  if (typeof e3 != "string") throw new TypeError("Expected a string");
  let t2 = g(e3, true);
  t2.size === 0 && (t2 = g(e3, false));
  const n = E(t2);
  let i2, s4 = 0, o = "";
  return n !== void 0 && ({ type: i2, amount: s4 } = w(n), o = S(i2, s4)), { amount: s4, type: i2, indent: o };
}
function x(e3, t2 = {}) {
  const n = t2.indent === void 0 && t2.preserveIndentation !== false && e3.slice(0, t2?.sampleSize || 1024), i2 = t2.preserveWhitespace === false ? void 0 : { start: k.exec(e3)?.[0] || "", end: v.exec(e3)?.[0] || "" };
  return { sample: n, whiteSpace: i2 };
}
function N(e3, t2, n) {
  !t2 || typeof t2 != "object" || Object.defineProperty(t2, m2, { enumerable: false, configurable: true, writable: true, value: x(e3, n) });
}
function C2(e3, t2) {
  if (!e3 || typeof e3 != "object" || !(m2 in e3)) return { indent: t2?.indent, whitespace: { start: "", end: "" } };
  const n = e3[m2];
  return { indent: t2?.indent || _(n.sample || "").indent, whitespace: n.whiteSpace || { start: "", end: "" } };
}
var b, d, h2, m2, k, v;
var init_confbox_9388d834 = __esm({
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/shared/confbox.9388d834.mjs"() {
    "use strict";
    b = /^(?:( )+|\t+)/;
    d = "space";
    h2 = "tab";
    m2 = Symbol.for("__confbox_fmt__");
    k = /^(\s+)/;
    v = /(\s+)$/;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/json5.mjs
var json5_exports = {};
__export(json5_exports, {
  parseJSON5: () => ou,
  stringifyJSON5: () => cu
});
function X(D3) {
  return D3 && D3.__esModule && Object.prototype.hasOwnProperty.call(D3, "default") ? D3.default : D3;
}
function T2(D3, C5, E3) {
  const n = D3[C5];
  if (n != null && typeof n == "object") if (Array.isArray(n)) for (let m4 = 0; m4 < n.length; m4++) {
    const o = String(m4), x5 = T2(n, o, E3);
    x5 === void 0 ? delete n[o] : Object.defineProperty(n, o, { value: x5, writable: true, enumerable: true, configurable: true });
  }
  else for (const m4 in n) {
    const o = T2(n, m4, E3);
    o === void 0 ? delete n[m4] : Object.defineProperty(n, m4, { value: o, writable: true, enumerable: true, configurable: true });
  }
  return E3.call(D3, C5, n);
}
function ru() {
  for (t = "default", e = "", $ = false, w2 = 1; ; ) {
    r3 = b2();
    const D3 = U[t]();
    if (D3) return D3;
  }
}
function b2() {
  if (q[V]) return String.fromCodePoint(q.codePointAt(V));
}
function u2() {
  const D3 = b2();
  return D3 === `
` ? (S2++, g2 = 0) : D3 ? g2 += D3.length : g2++, D3 && (V += D3.length), D3;
}
function i(D3, C5) {
  return { type: D3, value: C5, line: S2, column: g2 };
}
function P(D3) {
  for (const C5 of D3) {
    if (b2() !== C5) throw a2(u2());
    u2();
  }
}
function Au() {
  switch (b2()) {
    case "b":
      return u2(), "\b";
    case "f":
      return u2(), "\f";
    case "n":
      return u2(), `
`;
    case "r":
      return u2(), "\r";
    case "t":
      return u2(), "	";
    case "v":
      return u2(), "\v";
    case "0":
      if (u2(), f2.isDigit(b2())) throw a2(u2());
      return "\0";
    case "x":
      return u2(), Eu();
    case "u":
      return u2(), Z();
    case `
`:
    case "\u2028":
    case "\u2029":
      return u2(), "";
    case "\r":
      return u2(), b2() === `
` && u2(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw a2(u2());
    case void 0:
      throw a2(u2());
  }
  return u2();
}
function Eu() {
  let D3 = "", C5 = b2();
  if (!f2.isHexDigit(C5) || (D3 += u2(), C5 = b2(), !f2.isHexDigit(C5))) throw a2(u2());
  return D3 += u2(), String.fromCodePoint(parseInt(D3, 16));
}
function Z() {
  let D3 = "", C5 = 4;
  for (; C5-- > 0; ) {
    const E3 = b2();
    if (!f2.isHexDigit(E3)) throw a2(u2());
    D3 += u2();
  }
  return String.fromCodePoint(parseInt(D3, 16));
}
function K() {
  let D3;
  switch (l.type) {
    case "punctuator":
      switch (l.value) {
        case "{":
          D3 = {};
          break;
        case "[":
          D3 = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      D3 = l.value;
      break;
  }
  if (O === void 0) O = D3;
  else {
    const C5 = y[y.length - 1];
    Array.isArray(C5) ? C5.push(D3) : Object.defineProperty(C5, M, { value: D3, writable: true, enumerable: true, configurable: true });
  }
  if (D3 !== null && typeof D3 == "object") y.push(D3), Array.isArray(D3) ? h3 = "beforeArrayValue" : h3 = "beforePropertyName";
  else {
    const C5 = y[y.length - 1];
    C5 == null ? h3 = "end" : Array.isArray(C5) ? h3 = "afterArrayValue" : h3 = "afterPropertyValue";
  }
}
function _2() {
  y.pop();
  const D3 = y[y.length - 1];
  D3 == null ? h3 = "end" : Array.isArray(D3) ? h3 = "afterArrayValue" : h3 = "afterPropertyValue";
}
function a2(D3) {
  return J(D3 === void 0 ? `JSON5: invalid end of input at ${S2}:${g2}` : `JSON5: invalid character '${Y(D3)}' at ${S2}:${g2}`);
}
function I() {
  return J(`JSON5: invalid end of input at ${S2}:${g2}`);
}
function W() {
  return g2 -= 5, J(`JSON5: invalid identifier character at ${S2}:${g2}`);
}
function iu(D3) {
  console.warn(`JSON5: '${Y(D3)}' in strings is not valid ECMAScript; consider escaping`);
}
function Y(D3) {
  const C5 = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
  if (C5[D3]) return C5[D3];
  if (D3 < " ") {
    const E3 = D3.charCodeAt(0).toString(16);
    return "\\x" + ("00" + E3).substring(E3.length);
  }
  return D3;
}
function J(D3) {
  const C5 = new SyntaxError(D3);
  return C5.lineNumber = S2, C5.columnNumber = g2, C5;
}
function ou(D3, C5) {
  const E3 = au(D3, C5?.reviver);
  return N(D3, E3, C5), E3;
}
function cu(D3, C5) {
  const E3 = C2(D3, C5), n = su(D3, C5?.replacer, E3.indent);
  return E3.whitespace.start + n + E3.whitespace.end;
}
var k2, H, G, f2, q, h3, y, V, S2, g2, l, M, O, Cu, t, e, $, w2, r3, U, nu, au, Q, Bu, su;
var init_json5 = __esm({
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/json5.mjs"() {
    "use strict";
    init_confbox_9388d834();
    k2 = {};
    k2.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, k2.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, k2.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
    H = k2;
    G = { isSpaceSeparator(D3) {
      return typeof D3 == "string" && H.Space_Separator.test(D3);
    }, isIdStartChar(D3) {
      return typeof D3 == "string" && (D3 >= "a" && D3 <= "z" || D3 >= "A" && D3 <= "Z" || D3 === "$" || D3 === "_" || H.ID_Start.test(D3));
    }, isIdContinueChar(D3) {
      return typeof D3 == "string" && (D3 >= "a" && D3 <= "z" || D3 >= "A" && D3 <= "Z" || D3 >= "0" && D3 <= "9" || D3 === "$" || D3 === "_" || D3 === "\u200C" || D3 === "\u200D" || H.ID_Continue.test(D3));
    }, isDigit(D3) {
      return typeof D3 == "string" && /[0-9]/.test(D3);
    }, isHexDigit(D3) {
      return typeof D3 == "string" && /[0-9A-Fa-f]/.test(D3);
    } };
    f2 = G;
    Cu = function(C5, E3) {
      q = String(C5), h3 = "start", y = [], V = 0, S2 = 1, g2 = 0, l = void 0, M = void 0, O = void 0;
      do
        l = ru(), nu[h3]();
      while (l.type !== "eof");
      return typeof E3 == "function" ? T2({ "": O }, "", E3) : O;
    };
    U = { default() {
      switch (r3) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          u2();
          return;
        case "/":
          u2(), t = "comment";
          return;
        case void 0:
          return u2(), i("eof");
      }
      if (f2.isSpaceSeparator(r3)) {
        u2();
        return;
      }
      return U[h3]();
    }, comment() {
      switch (r3) {
        case "*":
          u2(), t = "multiLineComment";
          return;
        case "/":
          u2(), t = "singleLineComment";
          return;
      }
      throw a2(u2());
    }, multiLineComment() {
      switch (r3) {
        case "*":
          u2(), t = "multiLineCommentAsterisk";
          return;
        case void 0:
          throw a2(u2());
      }
      u2();
    }, multiLineCommentAsterisk() {
      switch (r3) {
        case "*":
          u2();
          return;
        case "/":
          u2(), t = "default";
          return;
        case void 0:
          throw a2(u2());
      }
      u2(), t = "multiLineComment";
    }, singleLineComment() {
      switch (r3) {
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          u2(), t = "default";
          return;
        case void 0:
          return u2(), i("eof");
      }
      u2();
    }, value() {
      switch (r3) {
        case "{":
        case "[":
          return i("punctuator", u2());
        case "n":
          return u2(), P("ull"), i("null", null);
        case "t":
          return u2(), P("rue"), i("boolean", true);
        case "f":
          return u2(), P("alse"), i("boolean", false);
        case "-":
        case "+":
          u2() === "-" && (w2 = -1), t = "sign";
          return;
        case ".":
          e = u2(), t = "decimalPointLeading";
          return;
        case "0":
          e = u2(), t = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          e = u2(), t = "decimalInteger";
          return;
        case "I":
          return u2(), P("nfinity"), i("numeric", 1 / 0);
        case "N":
          return u2(), P("aN"), i("numeric", NaN);
        case '"':
        case "'":
          $ = u2() === '"', e = "", t = "string";
          return;
      }
      throw a2(u2());
    }, identifierNameStartEscape() {
      if (r3 !== "u") throw a2(u2());
      u2();
      const D3 = Z();
      switch (D3) {
        case "$":
        case "_":
          break;
        default:
          if (!f2.isIdStartChar(D3)) throw W();
          break;
      }
      e += D3, t = "identifierName";
    }, identifierName() {
      switch (r3) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          e += u2();
          return;
        case "\\":
          u2(), t = "identifierNameEscape";
          return;
      }
      if (f2.isIdContinueChar(r3)) {
        e += u2();
        return;
      }
      return i("identifier", e);
    }, identifierNameEscape() {
      if (r3 !== "u") throw a2(u2());
      u2();
      const D3 = Z();
      switch (D3) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!f2.isIdContinueChar(D3)) throw W();
          break;
      }
      e += D3, t = "identifierName";
    }, sign() {
      switch (r3) {
        case ".":
          e = u2(), t = "decimalPointLeading";
          return;
        case "0":
          e = u2(), t = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          e = u2(), t = "decimalInteger";
          return;
        case "I":
          return u2(), P("nfinity"), i("numeric", w2 * (1 / 0));
        case "N":
          return u2(), P("aN"), i("numeric", NaN);
      }
      throw a2(u2());
    }, zero() {
      switch (r3) {
        case ".":
          e += u2(), t = "decimalPoint";
          return;
        case "e":
        case "E":
          e += u2(), t = "decimalExponent";
          return;
        case "x":
        case "X":
          e += u2(), t = "hexadecimal";
          return;
      }
      return i("numeric", w2 * 0);
    }, decimalInteger() {
      switch (r3) {
        case ".":
          e += u2(), t = "decimalPoint";
          return;
        case "e":
        case "E":
          e += u2(), t = "decimalExponent";
          return;
      }
      if (f2.isDigit(r3)) {
        e += u2();
        return;
      }
      return i("numeric", w2 * Number(e));
    }, decimalPointLeading() {
      if (f2.isDigit(r3)) {
        e += u2(), t = "decimalFraction";
        return;
      }
      throw a2(u2());
    }, decimalPoint() {
      switch (r3) {
        case "e":
        case "E":
          e += u2(), t = "decimalExponent";
          return;
      }
      if (f2.isDigit(r3)) {
        e += u2(), t = "decimalFraction";
        return;
      }
      return i("numeric", w2 * Number(e));
    }, decimalFraction() {
      switch (r3) {
        case "e":
        case "E":
          e += u2(), t = "decimalExponent";
          return;
      }
      if (f2.isDigit(r3)) {
        e += u2();
        return;
      }
      return i("numeric", w2 * Number(e));
    }, decimalExponent() {
      switch (r3) {
        case "+":
        case "-":
          e += u2(), t = "decimalExponentSign";
          return;
      }
      if (f2.isDigit(r3)) {
        e += u2(), t = "decimalExponentInteger";
        return;
      }
      throw a2(u2());
    }, decimalExponentSign() {
      if (f2.isDigit(r3)) {
        e += u2(), t = "decimalExponentInteger";
        return;
      }
      throw a2(u2());
    }, decimalExponentInteger() {
      if (f2.isDigit(r3)) {
        e += u2();
        return;
      }
      return i("numeric", w2 * Number(e));
    }, hexadecimal() {
      if (f2.isHexDigit(r3)) {
        e += u2(), t = "hexadecimalInteger";
        return;
      }
      throw a2(u2());
    }, hexadecimalInteger() {
      if (f2.isHexDigit(r3)) {
        e += u2();
        return;
      }
      return i("numeric", w2 * Number(e));
    }, string() {
      switch (r3) {
        case "\\":
          u2(), e += Au();
          return;
        case '"':
          if ($) return u2(), i("string", e);
          e += u2();
          return;
        case "'":
          if (!$) return u2(), i("string", e);
          e += u2();
          return;
        case `
`:
        case "\r":
          throw a2(u2());
        case "\u2028":
        case "\u2029":
          iu(r3);
          break;
        case void 0:
          throw a2(u2());
      }
      e += u2();
    }, start() {
      switch (r3) {
        case "{":
        case "[":
          return i("punctuator", u2());
      }
      t = "value";
    }, beforePropertyName() {
      switch (r3) {
        case "$":
        case "_":
          e = u2(), t = "identifierName";
          return;
        case "\\":
          u2(), t = "identifierNameStartEscape";
          return;
        case "}":
          return i("punctuator", u2());
        case '"':
        case "'":
          $ = u2() === '"', t = "string";
          return;
      }
      if (f2.isIdStartChar(r3)) {
        e += u2(), t = "identifierName";
        return;
      }
      throw a2(u2());
    }, afterPropertyName() {
      if (r3 === ":") return i("punctuator", u2());
      throw a2(u2());
    }, beforePropertyValue() {
      t = "value";
    }, afterPropertyValue() {
      switch (r3) {
        case ",":
        case "}":
          return i("punctuator", u2());
      }
      throw a2(u2());
    }, beforeArrayValue() {
      if (r3 === "]") return i("punctuator", u2());
      t = "value";
    }, afterArrayValue() {
      switch (r3) {
        case ",":
        case "]":
          return i("punctuator", u2());
      }
      throw a2(u2());
    }, end() {
      throw a2(u2());
    } };
    nu = { start() {
      if (l.type === "eof") throw I();
      K();
    }, beforePropertyName() {
      switch (l.type) {
        case "identifier":
        case "string":
          M = l.value, h3 = "afterPropertyName";
          return;
        case "punctuator":
          _2();
          return;
        case "eof":
          throw I();
      }
    }, afterPropertyName() {
      if (l.type === "eof") throw I();
      h3 = "beforePropertyValue";
    }, beforePropertyValue() {
      if (l.type === "eof") throw I();
      K();
    }, beforeArrayValue() {
      if (l.type === "eof") throw I();
      if (l.type === "punctuator" && l.value === "]") {
        _2();
        return;
      }
      K();
    }, afterPropertyValue() {
      if (l.type === "eof") throw I();
      switch (l.value) {
        case ",":
          h3 = "beforePropertyName";
          return;
        case "}":
          _2();
      }
    }, afterArrayValue() {
      if (l.type === "eof") throw I();
      switch (l.value) {
        case ",":
          h3 = "beforeArrayValue";
          return;
        case "]":
          _2();
      }
    }, end() {
    } };
    au = X(Cu);
    Q = G;
    Bu = function(C5, E3, n) {
      const m4 = [];
      let o = "", x5, L4, N6 = "", R4;
      if (E3 != null && typeof E3 == "object" && !Array.isArray(E3) && (n = E3.space, R4 = E3.quote, E3 = E3.replacer), typeof E3 == "function") L4 = E3;
      else if (Array.isArray(E3)) {
        x5 = [];
        for (const A2 of E3) {
          let B3;
          typeof A2 == "string" ? B3 = A2 : (typeof A2 == "number" || A2 instanceof String || A2 instanceof Number) && (B3 = String(A2)), B3 !== void 0 && x5.indexOf(B3) < 0 && x5.push(B3);
        }
      }
      return n instanceof Number ? n = Number(n) : n instanceof String && (n = String(n)), typeof n == "number" ? n > 0 && (n = Math.min(10, Math.floor(n)), N6 = "          ".substr(0, n)) : typeof n == "string" && (N6 = n.substr(0, 10)), z4("", { "": C5 });
      function z4(A2, B3) {
        let F2 = B3[A2];
        switch (F2 != null && (typeof F2.toJSON5 == "function" ? F2 = F2.toJSON5(A2) : typeof F2.toJSON == "function" && (F2 = F2.toJSON(A2))), L4 && (F2 = L4.call(B3, A2, F2)), F2 instanceof Number ? F2 = Number(F2) : F2 instanceof String ? F2 = String(F2) : F2 instanceof Boolean && (F2 = F2.valueOf()), F2) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof F2 == "string") return j3(F2);
        if (typeof F2 == "number") return String(F2);
        if (typeof F2 == "object") return Array.isArray(F2) ? eu(F2) : uu(F2);
      }
      function j3(A2) {
        const B3 = { "'": 0.1, '"': 0.2 }, F2 = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
        let c2 = "";
        for (let s4 = 0; s4 < A2.length; s4++) {
          const p3 = A2[s4];
          switch (p3) {
            case "'":
            case '"':
              B3[p3]++, c2 += p3;
              continue;
            case "\0":
              if (Q.isDigit(A2[s4 + 1])) {
                c2 += "\\x00";
                continue;
              }
          }
          if (F2[p3]) {
            c2 += F2[p3];
            continue;
          }
          if (p3 < " ") {
            let v4 = p3.charCodeAt(0).toString(16);
            c2 += "\\x" + ("00" + v4).substring(v4.length);
            continue;
          }
          c2 += p3;
        }
        const d4 = R4 || Object.keys(B3).reduce((s4, p3) => B3[s4] < B3[p3] ? s4 : p3);
        return c2 = c2.replace(new RegExp(d4, "g"), F2[d4]), d4 + c2 + d4;
      }
      function uu(A2) {
        if (m4.indexOf(A2) >= 0) throw TypeError("Converting circular structure to JSON5");
        m4.push(A2);
        let B3 = o;
        o = o + N6;
        let F2 = x5 || Object.keys(A2), c2 = [];
        for (const s4 of F2) {
          const p3 = z4(s4, A2);
          if (p3 !== void 0) {
            let v4 = Du(s4) + ":";
            N6 !== "" && (v4 += " "), v4 += p3, c2.push(v4);
          }
        }
        let d4;
        if (c2.length === 0) d4 = "{}";
        else {
          let s4;
          if (N6 === "") s4 = c2.join(","), d4 = "{" + s4 + "}";
          else {
            let p3 = `,
` + o;
            s4 = c2.join(p3), d4 = `{
` + o + s4 + `,
` + B3 + "}";
          }
        }
        return m4.pop(), o = B3, d4;
      }
      function Du(A2) {
        if (A2.length === 0) return j3(A2);
        const B3 = String.fromCodePoint(A2.codePointAt(0));
        if (!Q.isIdStartChar(B3)) return j3(A2);
        for (let F2 = B3.length; F2 < A2.length; F2++) if (!Q.isIdContinueChar(String.fromCodePoint(A2.codePointAt(F2)))) return j3(A2);
        return A2;
      }
      function eu(A2) {
        if (m4.indexOf(A2) >= 0) throw TypeError("Converting circular structure to JSON5");
        m4.push(A2);
        let B3 = o;
        o = o + N6;
        let F2 = [];
        for (let d4 = 0; d4 < A2.length; d4++) {
          const s4 = z4(String(d4), A2);
          F2.push(s4 !== void 0 ? s4 : "null");
        }
        let c2;
        if (F2.length === 0) c2 = "[]";
        else if (N6 === "") c2 = "[" + F2.join(",") + "]";
        else {
          let d4 = `,
` + o, s4 = F2.join(d4);
          c2 = `[
` + o + s4 + `,
` + B3 + "]";
        }
        return m4.pop(), o = B3, c2;
      }
    };
    su = X(Bu);
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/shared/confbox.f9f03f05.mjs
function $2(n, l3 = false) {
  const g4 = n.length;
  let e3 = 0, u4 = "", p3 = 0, k4 = 16, A2 = 0, o = 0, O4 = 0, B3 = 0, b6 = 0;
  function I5(i2, T5) {
    let s4 = 0, c2 = 0;
    for (; s4 < i2 || !T5; ) {
      let t2 = n.charCodeAt(e3);
      if (t2 >= 48 && t2 <= 57) c2 = c2 * 16 + t2 - 48;
      else if (t2 >= 65 && t2 <= 70) c2 = c2 * 16 + t2 - 65 + 10;
      else if (t2 >= 97 && t2 <= 102) c2 = c2 * 16 + t2 - 97 + 10;
      else break;
      e3++, s4++;
    }
    return s4 < i2 && (c2 = -1), c2;
  }
  function V4(i2) {
    e3 = i2, u4 = "", p3 = 0, k4 = 16, b6 = 0;
  }
  function F2() {
    let i2 = e3;
    if (n.charCodeAt(e3) === 48) e3++;
    else for (e3++; e3 < n.length && L(n.charCodeAt(e3)); ) e3++;
    if (e3 < n.length && n.charCodeAt(e3) === 46) if (e3++, e3 < n.length && L(n.charCodeAt(e3))) for (e3++; e3 < n.length && L(n.charCodeAt(e3)); ) e3++;
    else return b6 = 3, n.substring(i2, e3);
    let T5 = e3;
    if (e3 < n.length && (n.charCodeAt(e3) === 69 || n.charCodeAt(e3) === 101)) if (e3++, (e3 < n.length && n.charCodeAt(e3) === 43 || n.charCodeAt(e3) === 45) && e3++, e3 < n.length && L(n.charCodeAt(e3))) {
      for (e3++; e3 < n.length && L(n.charCodeAt(e3)); ) e3++;
      T5 = e3;
    } else b6 = 3;
    return n.substring(i2, T5);
  }
  function j3() {
    let i2 = "", T5 = e3;
    for (; ; ) {
      if (e3 >= g4) {
        i2 += n.substring(T5, e3), b6 = 2;
        break;
      }
      const s4 = n.charCodeAt(e3);
      if (s4 === 34) {
        i2 += n.substring(T5, e3), e3++;
        break;
      }
      if (s4 === 92) {
        if (i2 += n.substring(T5, e3), e3++, e3 >= g4) {
          b6 = 2;
          break;
        }
        switch (n.charCodeAt(e3++)) {
          case 34:
            i2 += '"';
            break;
          case 92:
            i2 += "\\";
            break;
          case 47:
            i2 += "/";
            break;
          case 98:
            i2 += "\b";
            break;
          case 102:
            i2 += "\f";
            break;
          case 110:
            i2 += `
`;
            break;
          case 114:
            i2 += "\r";
            break;
          case 116:
            i2 += "	";
            break;
          case 117:
            const t2 = I5(4, true);
            t2 >= 0 ? i2 += String.fromCharCode(t2) : b6 = 4;
            break;
          default:
            b6 = 5;
        }
        T5 = e3;
        continue;
      }
      if (s4 >= 0 && s4 <= 31) if (r4(s4)) {
        i2 += n.substring(T5, e3), b6 = 2;
        break;
      } else b6 = 6;
      e3++;
    }
    return i2;
  }
  function w5() {
    if (u4 = "", b6 = 0, p3 = e3, o = A2, B3 = O4, e3 >= g4) return p3 = g4, k4 = 17;
    let i2 = n.charCodeAt(e3);
    if (J2(i2)) {
      do
        e3++, u4 += String.fromCharCode(i2), i2 = n.charCodeAt(e3);
      while (J2(i2));
      return k4 = 15;
    }
    if (r4(i2)) return e3++, u4 += String.fromCharCode(i2), i2 === 13 && n.charCodeAt(e3) === 10 && (e3++, u4 += `
`), A2++, O4 = e3, k4 = 14;
    switch (i2) {
      case 123:
        return e3++, k4 = 1;
      case 125:
        return e3++, k4 = 2;
      case 91:
        return e3++, k4 = 3;
      case 93:
        return e3++, k4 = 4;
      case 58:
        return e3++, k4 = 6;
      case 44:
        return e3++, k4 = 5;
      case 34:
        return e3++, u4 = j3(), k4 = 10;
      case 47:
        const T5 = e3 - 1;
        if (n.charCodeAt(e3 + 1) === 47) {
          for (e3 += 2; e3 < g4 && !r4(n.charCodeAt(e3)); ) e3++;
          return u4 = n.substring(T5, e3), k4 = 12;
        }
        if (n.charCodeAt(e3 + 1) === 42) {
          e3 += 2;
          const s4 = g4 - 1;
          let c2 = false;
          for (; e3 < s4; ) {
            const t2 = n.charCodeAt(e3);
            if (t2 === 42 && n.charCodeAt(e3 + 1) === 47) {
              e3 += 2, c2 = true;
              break;
            }
            e3++, r4(t2) && (t2 === 13 && n.charCodeAt(e3) === 10 && e3++, A2++, O4 = e3);
          }
          return c2 || (e3++, b6 = 1), u4 = n.substring(T5, e3), k4 = 13;
        }
        return u4 += String.fromCharCode(i2), e3++, k4 = 16;
      case 45:
        if (u4 += String.fromCharCode(i2), e3++, e3 === g4 || !L(n.charCodeAt(e3))) return k4 = 16;
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return u4 += F2(), k4 = 11;
      default:
        for (; e3 < g4 && v4(i2); ) e3++, i2 = n.charCodeAt(e3);
        if (p3 !== e3) {
          switch (u4 = n.substring(p3, e3), u4) {
            case "true":
              return k4 = 8;
            case "false":
              return k4 = 9;
            case "null":
              return k4 = 7;
          }
          return k4 = 16;
        }
        return u4 += String.fromCharCode(i2), e3++, k4 = 16;
    }
  }
  function v4(i2) {
    if (J2(i2) || r4(i2)) return false;
    switch (i2) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function E3() {
    let i2;
    do
      i2 = w5();
    while (i2 >= 12 && i2 <= 15);
    return i2;
  }
  return { setPosition: V4, getPosition: () => e3, scan: l3 ? E3 : w5, getToken: () => k4, getTokenValue: () => u4, getTokenOffset: () => p3, getTokenLength: () => e3 - p3, getTokenStartLine: () => o, getTokenStartCharacter: () => p3 - B3, getTokenError: () => b6 };
}
function J2(n) {
  return n === 32 || n === 9;
}
function r4(n) {
  return n === 10 || n === 13;
}
function L(n) {
  return n >= 48 && n <= 57;
}
function S3(n, l3 = [], g4 = U2.DEFAULT) {
  let e3 = null, u4 = [];
  const p3 = [];
  function k4(o) {
    Array.isArray(u4) ? u4.push(o) : e3 !== null && (u4[e3] = o);
  }
  return P2(n, { onObjectBegin: () => {
    const o = {};
    k4(o), p3.push(u4), u4 = o, e3 = null;
  }, onObjectProperty: (o) => {
    e3 = o;
  }, onObjectEnd: () => {
    u4 = p3.pop();
  }, onArrayBegin: () => {
    const o = [];
    k4(o), p3.push(u4), u4 = o, e3 = null;
  }, onArrayEnd: () => {
    u4 = p3.pop();
  }, onLiteralValue: k4, onError: (o, O4, B3) => {
    l3.push({ error: o, offset: O4, length: B3 });
  } }, g4), u4[0];
}
function P2(n, l3, g4 = U2.DEFAULT) {
  const e3 = $2(n, false), u4 = [];
  let p3 = 0;
  function k4(f3) {
    return f3 ? () => p3 === 0 && f3(e3.getTokenOffset(), e3.getTokenLength(), e3.getTokenStartLine(), e3.getTokenStartCharacter()) : () => true;
  }
  function A2(f3) {
    return f3 ? (m4) => p3 === 0 && f3(m4, e3.getTokenOffset(), e3.getTokenLength(), e3.getTokenStartLine(), e3.getTokenStartCharacter()) : () => true;
  }
  function o(f3) {
    return f3 ? (m4) => p3 === 0 && f3(m4, e3.getTokenOffset(), e3.getTokenLength(), e3.getTokenStartLine(), e3.getTokenStartCharacter(), () => u4.slice()) : () => true;
  }
  function O4(f3) {
    return f3 ? () => {
      p3 > 0 ? p3++ : f3(e3.getTokenOffset(), e3.getTokenLength(), e3.getTokenStartLine(), e3.getTokenStartCharacter(), () => u4.slice()) === false && (p3 = 1);
    } : () => true;
  }
  function B3(f3) {
    return f3 ? () => {
      p3 > 0 && p3--, p3 === 0 && f3(e3.getTokenOffset(), e3.getTokenLength(), e3.getTokenStartLine(), e3.getTokenStartCharacter());
    } : () => true;
  }
  const b6 = O4(l3.onObjectBegin), I5 = o(l3.onObjectProperty), V4 = B3(l3.onObjectEnd), F2 = O4(l3.onArrayBegin), j3 = B3(l3.onArrayEnd), w5 = o(l3.onLiteralValue), v4 = A2(l3.onSeparator), E3 = k4(l3.onComment), i2 = A2(l3.onError), T5 = g4 && g4.disallowComments, s4 = g4 && g4.allowTrailingComma;
  function c2() {
    for (; ; ) {
      const f3 = e3.scan();
      switch (e3.getTokenError()) {
        case 4:
          t2(14);
          break;
        case 5:
          t2(15);
          break;
        case 3:
          t2(13);
          break;
        case 1:
          T5 || t2(11);
          break;
        case 2:
          t2(12);
          break;
        case 6:
          t2(16);
          break;
      }
      switch (f3) {
        case 12:
        case 13:
          T5 ? t2(10) : E3();
          break;
        case 16:
          t2(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return f3;
      }
    }
  }
  function t2(f3, m4 = [], y3 = []) {
    if (i2(f3), m4.length + y3.length > 0) {
      let _5 = e3.getToken();
      for (; _5 !== 17; ) {
        if (m4.indexOf(_5) !== -1) {
          c2();
          break;
        } else if (y3.indexOf(_5) !== -1) break;
        _5 = c2();
      }
    }
  }
  function D3(f3) {
    const m4 = e3.getTokenValue();
    return f3 ? w5(m4) : (I5(m4), u4.push(m4)), c2(), true;
  }
  function G3() {
    switch (e3.getToken()) {
      case 11:
        const f3 = e3.getTokenValue();
        let m4 = Number(f3);
        isNaN(m4) && (t2(2), m4 = 0), w5(m4);
        break;
      case 7:
        w5(null);
        break;
      case 8:
        w5(true);
        break;
      case 9:
        w5(false);
        break;
      default:
        return false;
    }
    return c2(), true;
  }
  function M4() {
    return e3.getToken() !== 10 ? (t2(3, [], [2, 5]), false) : (D3(false), e3.getToken() === 6 ? (v4(":"), c2(), a3() || t2(4, [], [2, 5])) : t2(5, [], [2, 5]), u4.pop(), true);
  }
  function X5() {
    b6(), c2();
    let f3 = false;
    for (; e3.getToken() !== 2 && e3.getToken() !== 17; ) {
      if (e3.getToken() === 5) {
        if (f3 || t2(4, [], []), v4(","), c2(), e3.getToken() === 2 && s4) break;
      } else f3 && t2(6, [], []);
      M4() || t2(4, [], [2, 5]), f3 = true;
    }
    return V4(), e3.getToken() !== 2 ? t2(7, [2], []) : c2(), true;
  }
  function Y4() {
    F2(), c2();
    let f3 = true, m4 = false;
    for (; e3.getToken() !== 4 && e3.getToken() !== 17; ) {
      if (e3.getToken() === 5) {
        if (m4 || t2(4, [], []), v4(","), c2(), e3.getToken() === 4 && s4) break;
      } else m4 && t2(6, [], []);
      f3 ? (u4.push(0), f3 = false) : u4[u4.length - 1]++, a3() || t2(4, [], [4, 5]), m4 = true;
    }
    return j3(), f3 || u4.pop(), e3.getToken() !== 4 ? t2(8, [4], []) : c2(), true;
  }
  function a3() {
    switch (e3.getToken()) {
      case 3:
        return Y4();
      case 1:
        return X5();
      case 10:
        return D3(true);
      default:
        return G3();
    }
  }
  return c2(), e3.getToken() === 17 ? g4.allowEmptyContent ? true : (t2(4, [], []), false) : a3() ? (e3.getToken() !== 17 && t2(9, [], []), true) : (t2(4, [], []), false);
}
function x2(n, l3) {
  const g4 = JSON.parse(n, l3?.reviver);
  return N(n, g4, l3), g4;
}
function z2(n, l3) {
  const g4 = C2(n, l3), e3 = JSON.stringify(n, l3?.replacer, g4.indent);
  return g4.whitespace.start + e3 + g4.whitespace.end;
}
function h4(n, l3) {
  const g4 = K2(n, l3?.errors, l3);
  return N(n, g4, l3), g4;
}
function d2(n, l3) {
  return z2(n, l3);
}
var Q2, N2, U2, W2, H2, K2, q2;
var init_confbox_f9f03f05 = __esm({
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/shared/confbox.f9f03f05.mjs"() {
    "use strict";
    init_confbox_9388d834();
    (function(n) {
      n[n.lineFeed = 10] = "lineFeed", n[n.carriageReturn = 13] = "carriageReturn", n[n.space = 32] = "space", n[n._0 = 48] = "_0", n[n._1 = 49] = "_1", n[n._2 = 50] = "_2", n[n._3 = 51] = "_3", n[n._4 = 52] = "_4", n[n._5 = 53] = "_5", n[n._6 = 54] = "_6", n[n._7 = 55] = "_7", n[n._8 = 56] = "_8", n[n._9 = 57] = "_9", n[n.a = 97] = "a", n[n.b = 98] = "b", n[n.c = 99] = "c", n[n.d = 100] = "d", n[n.e = 101] = "e", n[n.f = 102] = "f", n[n.g = 103] = "g", n[n.h = 104] = "h", n[n.i = 105] = "i", n[n.j = 106] = "j", n[n.k = 107] = "k", n[n.l = 108] = "l", n[n.m = 109] = "m", n[n.n = 110] = "n", n[n.o = 111] = "o", n[n.p = 112] = "p", n[n.q = 113] = "q", n[n.r = 114] = "r", n[n.s = 115] = "s", n[n.t = 116] = "t", n[n.u = 117] = "u", n[n.v = 118] = "v", n[n.w = 119] = "w", n[n.x = 120] = "x", n[n.y = 121] = "y", n[n.z = 122] = "z", n[n.A = 65] = "A", n[n.B = 66] = "B", n[n.C = 67] = "C", n[n.D = 68] = "D", n[n.E = 69] = "E", n[n.F = 70] = "F", n[n.G = 71] = "G", n[n.H = 72] = "H", n[n.I = 73] = "I", n[n.J = 74] = "J", n[n.K = 75] = "K", n[n.L = 76] = "L", n[n.M = 77] = "M", n[n.N = 78] = "N", n[n.O = 79] = "O", n[n.P = 80] = "P", n[n.Q = 81] = "Q", n[n.R = 82] = "R", n[n.S = 83] = "S", n[n.T = 84] = "T", n[n.U = 85] = "U", n[n.V = 86] = "V", n[n.W = 87] = "W", n[n.X = 88] = "X", n[n.Y = 89] = "Y", n[n.Z = 90] = "Z", n[n.asterisk = 42] = "asterisk", n[n.backslash = 92] = "backslash", n[n.closeBrace = 125] = "closeBrace", n[n.closeBracket = 93] = "closeBracket", n[n.colon = 58] = "colon", n[n.comma = 44] = "comma", n[n.dot = 46] = "dot", n[n.doubleQuote = 34] = "doubleQuote", n[n.minus = 45] = "minus", n[n.openBrace = 123] = "openBrace", n[n.openBracket = 91] = "openBracket", n[n.plus = 43] = "plus", n[n.slash = 47] = "slash", n[n.formFeed = 12] = "formFeed", n[n.tab = 9] = "tab";
    })(Q2 || (Q2 = {})), new Array(20).fill(0).map((n, l3) => " ".repeat(l3));
    N2 = 200;
    new Array(N2).fill(0).map((n, l3) => `
` + " ".repeat(l3)), new Array(N2).fill(0).map((n, l3) => "\r" + " ".repeat(l3)), new Array(N2).fill(0).map((n, l3) => `\r
` + " ".repeat(l3)), new Array(N2).fill(0).map((n, l3) => `
` + "	".repeat(l3)), new Array(N2).fill(0).map((n, l3) => "\r" + "	".repeat(l3)), new Array(N2).fill(0).map((n, l3) => `\r
` + "	".repeat(l3));
    (function(n) {
      n.DEFAULT = { allowTrailingComma: false };
    })(U2 || (U2 = {}));
    (function(n) {
      n[n.None = 0] = "None", n[n.UnexpectedEndOfComment = 1] = "UnexpectedEndOfComment", n[n.UnexpectedEndOfString = 2] = "UnexpectedEndOfString", n[n.UnexpectedEndOfNumber = 3] = "UnexpectedEndOfNumber", n[n.InvalidUnicode = 4] = "InvalidUnicode", n[n.InvalidEscapeCharacter = 5] = "InvalidEscapeCharacter", n[n.InvalidCharacter = 6] = "InvalidCharacter";
    })(W2 || (W2 = {}));
    (function(n) {
      n[n.OpenBraceToken = 1] = "OpenBraceToken", n[n.CloseBraceToken = 2] = "CloseBraceToken", n[n.OpenBracketToken = 3] = "OpenBracketToken", n[n.CloseBracketToken = 4] = "CloseBracketToken", n[n.CommaToken = 5] = "CommaToken", n[n.ColonToken = 6] = "ColonToken", n[n.NullKeyword = 7] = "NullKeyword", n[n.TrueKeyword = 8] = "TrueKeyword", n[n.FalseKeyword = 9] = "FalseKeyword", n[n.StringLiteral = 10] = "StringLiteral", n[n.NumericLiteral = 11] = "NumericLiteral", n[n.LineCommentTrivia = 12] = "LineCommentTrivia", n[n.BlockCommentTrivia = 13] = "BlockCommentTrivia", n[n.LineBreakTrivia = 14] = "LineBreakTrivia", n[n.Trivia = 15] = "Trivia", n[n.Unknown = 16] = "Unknown", n[n.EOF = 17] = "EOF";
    })(H2 || (H2 = {}));
    K2 = S3;
    (function(n) {
      n[n.InvalidSymbol = 1] = "InvalidSymbol", n[n.InvalidNumberFormat = 2] = "InvalidNumberFormat", n[n.PropertyNameExpected = 3] = "PropertyNameExpected", n[n.ValueExpected = 4] = "ValueExpected", n[n.ColonExpected = 5] = "ColonExpected", n[n.CommaExpected = 6] = "CommaExpected", n[n.CloseBraceExpected = 7] = "CloseBraceExpected", n[n.CloseBracketExpected = 8] = "CloseBracketExpected", n[n.EndOfFileExpected = 9] = "EndOfFileExpected", n[n.InvalidCommentToken = 10] = "InvalidCommentToken", n[n.UnexpectedEndOfComment = 11] = "UnexpectedEndOfComment", n[n.UnexpectedEndOfString = 12] = "UnexpectedEndOfString", n[n.UnexpectedEndOfNumber = 13] = "UnexpectedEndOfNumber", n[n.InvalidUnicode = 14] = "InvalidUnicode", n[n.InvalidEscapeCharacter = 15] = "InvalidEscapeCharacter", n[n.InvalidCharacter = 16] = "InvalidCharacter";
    })(q2 || (q2 = {}));
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/yaml.mjs
var yaml_exports = {};
__export(yaml_exports, {
  parseYAML: () => Ar,
  stringifyYAML: () => vr
});
function oe(e3) {
  return typeof e3 > "u" || e3 === null;
}
function We(e3) {
  return typeof e3 == "object" && e3 !== null;
}
function $e(e3) {
  return Array.isArray(e3) ? e3 : oe(e3) ? [] : [e3];
}
function Qe(e3, n) {
  var i2, l3, r6, u4;
  if (n) for (u4 = Object.keys(n), i2 = 0, l3 = u4.length; i2 < l3; i2 += 1) r6 = u4[i2], e3[r6] = n[r6];
  return e3;
}
function Ve(e3, n) {
  var i2 = "", l3;
  for (l3 = 0; l3 < n; l3 += 1) i2 += e3;
  return i2;
}
function Xe(e3) {
  return e3 === 0 && Number.NEGATIVE_INFINITY === 1 / e3;
}
function ue(e3, n) {
  var i2 = "", l3 = e3.reason || "(unknown reason)";
  return e3.mark ? (e3.mark.name && (i2 += 'in "' + e3.mark.name + '" '), i2 += "(" + (e3.mark.line + 1) + ":" + (e3.mark.column + 1) + ")", !n && e3.mark.snippet && (i2 += `

` + e3.mark.snippet), l3 + " " + i2) : l3;
}
function M2(e3, n) {
  Error.call(this), this.name = "YAMLException", this.reason = e3, this.mark = n, this.message = ue(this, false), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
function $3(e3, n, i2, l3, r6) {
  var u4 = "", o = "", f3 = Math.floor(r6 / 2) - 1;
  return l3 - n > f3 && (u4 = " ... ", n = l3 - f3 + u4.length), i2 - l3 > f3 && (o = " ...", i2 = l3 + f3 - o.length), { str: u4 + e3.slice(n, i2).replace(/\t/g, "\u2192") + o, pos: l3 - n + u4.length };
}
function Q3(e3, n) {
  return y2.repeat(" ", n - e3.length) + e3;
}
function ln(e3, n) {
  if (n = Object.create(n || null), !e3.buffer) return null;
  n.maxLength || (n.maxLength = 79), typeof n.indent != "number" && (n.indent = 1), typeof n.linesBefore != "number" && (n.linesBefore = 3), typeof n.linesAfter != "number" && (n.linesAfter = 2);
  for (var i2 = /\r?\n|\r|\0/g, l3 = [0], r6 = [], u4, o = -1; u4 = i2.exec(e3.buffer); ) r6.push(u4.index), l3.push(u4.index + u4[0].length), e3.position <= u4.index && o < 0 && (o = l3.length - 2);
  o < 0 && (o = l3.length - 1);
  var f3 = "", c2, a3, t2 = Math.min(e3.line + n.linesAfter, r6.length).toString().length, p3 = n.maxLength - (n.indent + t2 + 3);
  for (c2 = 1; c2 <= n.linesBefore && !(o - c2 < 0); c2++) a3 = $3(e3.buffer, l3[o - c2], r6[o - c2], e3.position - (l3[o] - l3[o - c2]), p3), f3 = y2.repeat(" ", n.indent) + Q3((e3.line - c2 + 1).toString(), t2) + " | " + a3.str + `
` + f3;
  for (a3 = $3(e3.buffer, l3[o], r6[o], e3.position, p3), f3 += y2.repeat(" ", n.indent) + Q3((e3.line + 1).toString(), t2) + " | " + a3.str + `
`, f3 += y2.repeat("-", n.indent + t2 + 3 + a3.pos) + `^
`, c2 = 1; c2 <= n.linesAfter && !(o + c2 >= r6.length); c2++) a3 = $3(e3.buffer, l3[o + c2], r6[o + c2], e3.position - (l3[o] - l3[o + c2]), p3), f3 += y2.repeat(" ", n.indent) + Q3((e3.line + c2 + 1).toString(), t2) + " | " + a3.str + `
`;
  return f3.replace(/\n$/, "");
}
function cn(e3) {
  var n = {};
  return e3 !== null && Object.keys(e3).forEach(function(i2) {
    e3[i2].forEach(function(l3) {
      n[String(l3)] = i2;
    });
  }), n;
}
function an(e3, n) {
  if (n = n || {}, Object.keys(n).forEach(function(i2) {
    if (un.indexOf(i2) === -1) throw new w3('Unknown option "' + i2 + '" is met in definition of "' + e3 + '" YAML type.');
  }), this.options = n, this.tag = e3, this.kind = n.kind || null, this.resolve = n.resolve || function() {
    return true;
  }, this.construct = n.construct || function(i2) {
    return i2;
  }, this.instanceOf = n.instanceOf || null, this.predicate = n.predicate || null, this.represent = n.represent || null, this.representName = n.representName || null, this.defaultStyle = n.defaultStyle || null, this.multi = n.multi || false, this.styleAliases = cn(n.styleAliases || null), fn.indexOf(this.kind) === -1) throw new w3('Unknown kind "' + this.kind + '" is specified for "' + e3 + '" YAML type.');
}
function fe(e3, n) {
  var i2 = [];
  return e3[n].forEach(function(l3) {
    var r6 = i2.length;
    i2.forEach(function(u4, o) {
      u4.tag === l3.tag && u4.kind === l3.kind && u4.multi === l3.multi && (r6 = o);
    }), i2[r6] = l3;
  }), i2;
}
function pn() {
  var e3 = { scalar: {}, sequence: {}, mapping: {}, fallback: {}, multi: { scalar: [], sequence: [], mapping: [], fallback: [] } }, n, i2;
  function l3(r6) {
    r6.multi ? (e3.multi[r6.kind].push(r6), e3.multi.fallback.push(r6)) : e3[r6.kind][r6.tag] = e3.fallback[r6.tag] = r6;
  }
  for (n = 0, i2 = arguments.length; n < i2; n += 1) arguments[n].forEach(l3);
  return e3;
}
function V2(e3) {
  return this.extend(e3);
}
function mn(e3) {
  if (e3 === null) return true;
  var n = e3.length;
  return n === 1 && e3 === "~" || n === 4 && (e3 === "null" || e3 === "Null" || e3 === "NULL");
}
function gn() {
  return null;
}
function An(e3) {
  return e3 === null;
}
function yn(e3) {
  if (e3 === null) return false;
  var n = e3.length;
  return n === 4 && (e3 === "true" || e3 === "True" || e3 === "TRUE") || n === 5 && (e3 === "false" || e3 === "False" || e3 === "FALSE");
}
function Cn(e3) {
  return e3 === "true" || e3 === "True" || e3 === "TRUE";
}
function _n(e3) {
  return Object.prototype.toString.call(e3) === "[object Boolean]";
}
function bn(e3) {
  return 48 <= e3 && e3 <= 57 || 65 <= e3 && e3 <= 70 || 97 <= e3 && e3 <= 102;
}
function Fn(e3) {
  return 48 <= e3 && e3 <= 55;
}
function Sn(e3) {
  return 48 <= e3 && e3 <= 57;
}
function En(e3) {
  if (e3 === null) return false;
  var n = e3.length, i2 = 0, l3 = false, r6;
  if (!n) return false;
  if (r6 = e3[i2], (r6 === "-" || r6 === "+") && (r6 = e3[++i2]), r6 === "0") {
    if (i2 + 1 === n) return true;
    if (r6 = e3[++i2], r6 === "b") {
      for (i2++; i2 < n; i2++) if (r6 = e3[i2], r6 !== "_") {
        if (r6 !== "0" && r6 !== "1") return false;
        l3 = true;
      }
      return l3 && r6 !== "_";
    }
    if (r6 === "x") {
      for (i2++; i2 < n; i2++) if (r6 = e3[i2], r6 !== "_") {
        if (!bn(e3.charCodeAt(i2))) return false;
        l3 = true;
      }
      return l3 && r6 !== "_";
    }
    if (r6 === "o") {
      for (i2++; i2 < n; i2++) if (r6 = e3[i2], r6 !== "_") {
        if (!Fn(e3.charCodeAt(i2))) return false;
        l3 = true;
      }
      return l3 && r6 !== "_";
    }
  }
  if (r6 === "_") return false;
  for (; i2 < n; i2++) if (r6 = e3[i2], r6 !== "_") {
    if (!Sn(e3.charCodeAt(i2))) return false;
    l3 = true;
  }
  return !(!l3 || r6 === "_");
}
function Tn(e3) {
  var n = e3, i2 = 1, l3;
  if (n.indexOf("_") !== -1 && (n = n.replace(/_/g, "")), l3 = n[0], (l3 === "-" || l3 === "+") && (l3 === "-" && (i2 = -1), n = n.slice(1), l3 = n[0]), n === "0") return 0;
  if (l3 === "0") {
    if (n[1] === "b") return i2 * parseInt(n.slice(2), 2);
    if (n[1] === "x") return i2 * parseInt(n.slice(2), 16);
    if (n[1] === "o") return i2 * parseInt(n.slice(2), 8);
  }
  return i2 * parseInt(n, 10);
}
function On(e3) {
  return Object.prototype.toString.call(e3) === "[object Number]" && e3 % 1 === 0 && !y2.isNegativeZero(e3);
}
function Ln(e3) {
  return !(e3 === null || !kn.test(e3) || e3[e3.length - 1] === "_");
}
function Nn(e3) {
  var n, i2;
  return n = e3.replace(/_/g, "").toLowerCase(), i2 = n[0] === "-" ? -1 : 1, "+-".indexOf(n[0]) >= 0 && (n = n.slice(1)), n === ".inf" ? i2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : n === ".nan" ? NaN : i2 * parseFloat(n, 10);
}
function Dn(e3, n) {
  var i2;
  if (isNaN(e3)) switch (n) {
    case "lowercase":
      return ".nan";
    case "uppercase":
      return ".NAN";
    case "camelcase":
      return ".NaN";
  }
  else if (Number.POSITIVE_INFINITY === e3) switch (n) {
    case "lowercase":
      return ".inf";
    case "uppercase":
      return ".INF";
    case "camelcase":
      return ".Inf";
  }
  else if (Number.NEGATIVE_INFINITY === e3) switch (n) {
    case "lowercase":
      return "-.inf";
    case "uppercase":
      return "-.INF";
    case "camelcase":
      return "-.Inf";
  }
  else if (y2.isNegativeZero(e3)) return "-0.0";
  return i2 = e3.toString(10), Rn.test(i2) ? i2.replace("e", ".e") : i2;
}
function Mn(e3) {
  return Object.prototype.toString.call(e3) === "[object Number]" && (e3 % 1 !== 0 || y2.isNegativeZero(e3));
}
function jn(e3) {
  return e3 === null ? false : ce.exec(e3) !== null || ae.exec(e3) !== null;
}
function Hn(e3) {
  var n, i2, l3, r6, u4, o, f3, c2 = 0, a3 = null, t2, p3, d4;
  if (n = ce.exec(e3), n === null && (n = ae.exec(e3)), n === null) throw new Error("Date resolve error");
  if (i2 = +n[1], l3 = +n[2] - 1, r6 = +n[3], !n[4]) return new Date(Date.UTC(i2, l3, r6));
  if (u4 = +n[4], o = +n[5], f3 = +n[6], n[7]) {
    for (c2 = n[7].slice(0, 3); c2.length < 3; ) c2 += "0";
    c2 = +c2;
  }
  return n[9] && (t2 = +n[10], p3 = +(n[11] || 0), a3 = (t2 * 60 + p3) * 6e4, n[9] === "-" && (a3 = -a3)), d4 = new Date(Date.UTC(i2, l3, r6, u4, o, f3, c2)), a3 && d4.setTime(d4.getTime() - a3), d4;
}
function Un(e3) {
  return e3.toISOString();
}
function qn(e3) {
  return e3 === "<<" || e3 === null;
}
function Wn(e3) {
  if (e3 === null) return false;
  var n, i2, l3 = 0, r6 = e3.length, u4 = X2;
  for (i2 = 0; i2 < r6; i2++) if (n = u4.indexOf(e3.charAt(i2)), !(n > 64)) {
    if (n < 0) return false;
    l3 += 6;
  }
  return l3 % 8 === 0;
}
function $n(e3) {
  var n, i2, l3 = e3.replace(/[\r\n=]/g, ""), r6 = l3.length, u4 = X2, o = 0, f3 = [];
  for (n = 0; n < r6; n++) n % 4 === 0 && n && (f3.push(o >> 16 & 255), f3.push(o >> 8 & 255), f3.push(o & 255)), o = o << 6 | u4.indexOf(l3.charAt(n));
  return i2 = r6 % 4 * 6, i2 === 0 ? (f3.push(o >> 16 & 255), f3.push(o >> 8 & 255), f3.push(o & 255)) : i2 === 18 ? (f3.push(o >> 10 & 255), f3.push(o >> 2 & 255)) : i2 === 12 && f3.push(o >> 4 & 255), new Uint8Array(f3);
}
function Qn(e3) {
  var n = "", i2 = 0, l3, r6, u4 = e3.length, o = X2;
  for (l3 = 0; l3 < u4; l3++) l3 % 3 === 0 && l3 && (n += o[i2 >> 18 & 63], n += o[i2 >> 12 & 63], n += o[i2 >> 6 & 63], n += o[i2 & 63]), i2 = (i2 << 8) + e3[l3];
  return r6 = u4 % 3, r6 === 0 ? (n += o[i2 >> 18 & 63], n += o[i2 >> 12 & 63], n += o[i2 >> 6 & 63], n += o[i2 & 63]) : r6 === 2 ? (n += o[i2 >> 10 & 63], n += o[i2 >> 4 & 63], n += o[i2 << 2 & 63], n += o[64]) : r6 === 1 && (n += o[i2 >> 2 & 63], n += o[i2 << 4 & 63], n += o[64], n += o[64]), n;
}
function Vn(e3) {
  return Object.prototype.toString.call(e3) === "[object Uint8Array]";
}
function Jn(e3) {
  if (e3 === null) return true;
  var n = [], i2, l3, r6, u4, o, f3 = e3;
  for (i2 = 0, l3 = f3.length; i2 < l3; i2 += 1) {
    if (r6 = f3[i2], o = false, zn.call(r6) !== "[object Object]") return false;
    for (u4 in r6) if (Zn.call(r6, u4)) if (!o) o = true;
    else return false;
    if (!o) return false;
    if (n.indexOf(u4) === -1) n.push(u4);
    else return false;
  }
  return true;
}
function ei(e3) {
  return e3 !== null ? e3 : [];
}
function ri(e3) {
  if (e3 === null) return true;
  var n, i2, l3, r6, u4, o = e3;
  for (u4 = new Array(o.length), n = 0, i2 = o.length; n < i2; n += 1) {
    if (l3 = o[n], ii.call(l3) !== "[object Object]" || (r6 = Object.keys(l3), r6.length !== 1)) return false;
    u4[n] = [r6[0], l3[r6[0]]];
  }
  return true;
}
function li(e3) {
  if (e3 === null) return [];
  var n, i2, l3, r6, u4, o = e3;
  for (u4 = new Array(o.length), n = 0, i2 = o.length; n < i2; n += 1) l3 = o[n], r6 = Object.keys(l3), u4[n] = [r6[0], l3[r6[0]]];
  return u4;
}
function fi(e3) {
  if (e3 === null) return true;
  var n, i2 = e3;
  for (n in i2) if (ui.call(i2, n) && i2[n] !== null) return false;
  return true;
}
function ci(e3) {
  return e3 !== null ? e3 : {};
}
function me(e3) {
  return Object.prototype.toString.call(e3);
}
function S4(e3) {
  return e3 === 10 || e3 === 13;
}
function I2(e3) {
  return e3 === 9 || e3 === 32;
}
function b3(e3) {
  return e3 === 9 || e3 === 32 || e3 === 10 || e3 === 13;
}
function k3(e3) {
  return e3 === 44 || e3 === 91 || e3 === 93 || e3 === 123 || e3 === 125;
}
function si(e3) {
  var n;
  return 48 <= e3 && e3 <= 57 ? e3 - 48 : (n = e3 | 32, 97 <= n && n <= 102 ? n - 97 + 10 : -1);
}
function xi(e3) {
  return e3 === 120 ? 2 : e3 === 117 ? 4 : e3 === 85 ? 8 : 0;
}
function mi(e3) {
  return 48 <= e3 && e3 <= 57 ? e3 - 48 : -1;
}
function ge(e3) {
  return e3 === 48 ? "\0" : e3 === 97 ? "\x07" : e3 === 98 ? "\b" : e3 === 116 || e3 === 9 ? "	" : e3 === 110 ? `
` : e3 === 118 ? "\v" : e3 === 102 ? "\f" : e3 === 114 ? "\r" : e3 === 101 ? "\x1B" : e3 === 32 ? " " : e3 === 34 ? '"' : e3 === 47 ? "/" : e3 === 92 ? "\\" : e3 === 78 ? "\x85" : e3 === 95 ? "\xA0" : e3 === 76 ? "\u2028" : e3 === 80 ? "\u2029" : "";
}
function gi(e3) {
  return e3 <= 65535 ? String.fromCharCode(e3) : String.fromCharCode((e3 - 65536 >> 10) + 55296, (e3 - 65536 & 1023) + 56320);
}
function Ai(e3, n) {
  this.input = e3, this.filename = n.filename || null, this.schema = n.schema || pe, this.onWarning = n.onWarning || null, this.legacy = n.legacy || false, this.json = n.json || false, this.listener = n.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e3.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function ye(e3, n) {
  var i2 = { name: e3.filename, buffer: e3.input.slice(0, -1), position: e3.position, line: e3.line, column: e3.position - e3.lineStart };
  return i2.snippet = on(i2), new w3(n, i2);
}
function h5(e3, n) {
  throw ye(e3, n);
}
function K3(e3, n) {
  e3.onWarning && e3.onWarning.call(null, ye(e3, n));
}
function O2(e3, n, i2, l3) {
  var r6, u4, o, f3;
  if (n < i2) {
    if (f3 = e3.input.slice(n, i2), l3) for (r6 = 0, u4 = f3.length; r6 < u4; r6 += 1) o = f3.charCodeAt(r6), o === 9 || 32 <= o && o <= 1114111 || h5(e3, "expected valid JSON character");
    else ti.test(f3) && h5(e3, "the stream contains non-printable characters");
    e3.result += f3;
  }
}
function _e(e3, n, i2, l3) {
  var r6, u4, o, f3;
  for (y2.isObject(i2) || h5(e3, "cannot merge mappings; the provided source object is unacceptable"), r6 = Object.keys(i2), o = 0, f3 = r6.length; o < f3; o += 1) u4 = r6[o], T3.call(n, u4) || (n[u4] = i2[u4], l3[u4] = true);
}
function N3(e3, n, i2, l3, r6, u4, o, f3, c2) {
  var a3, t2;
  if (Array.isArray(r6)) for (r6 = Array.prototype.slice.call(r6), a3 = 0, t2 = r6.length; a3 < t2; a3 += 1) Array.isArray(r6[a3]) && h5(e3, "nested arrays are not supported inside keys"), typeof r6 == "object" && me(r6[a3]) === "[object Object]" && (r6[a3] = "[object Object]");
  if (typeof r6 == "object" && me(r6) === "[object Object]" && (r6 = "[object Object]"), r6 = String(r6), n === null && (n = {}), l3 === "tag:yaml.org,2002:merge") if (Array.isArray(u4)) for (a3 = 0, t2 = u4.length; a3 < t2; a3 += 1) _e(e3, n, u4[a3], i2);
  else _e(e3, n, u4, i2);
  else !e3.json && !T3.call(i2, r6) && T3.call(n, r6) && (e3.line = o || e3.line, e3.lineStart = f3 || e3.lineStart, e3.position = c2 || e3.position, h5(e3, "duplicated mapping key")), r6 === "__proto__" ? Object.defineProperty(n, r6, { configurable: true, enumerable: true, writable: true, value: u4 }) : n[r6] = u4, delete i2[r6];
  return n;
}
function z3(e3) {
  var n;
  n = e3.input.charCodeAt(e3.position), n === 10 ? e3.position++ : n === 13 ? (e3.position++, e3.input.charCodeAt(e3.position) === 10 && e3.position++) : h5(e3, "a line break is expected"), e3.line += 1, e3.lineStart = e3.position, e3.firstTabInLine = -1;
}
function v2(e3, n, i2) {
  for (var l3 = 0, r6 = e3.input.charCodeAt(e3.position); r6 !== 0; ) {
    for (; I2(r6); ) r6 === 9 && e3.firstTabInLine === -1 && (e3.firstTabInLine = e3.position), r6 = e3.input.charCodeAt(++e3.position);
    if (n && r6 === 35) do
      r6 = e3.input.charCodeAt(++e3.position);
    while (r6 !== 10 && r6 !== 13 && r6 !== 0);
    if (S4(r6)) for (z3(e3), r6 = e3.input.charCodeAt(e3.position), l3++, e3.lineIndent = 0; r6 === 32; ) e3.lineIndent++, r6 = e3.input.charCodeAt(++e3.position);
    else break;
  }
  return i2 !== -1 && l3 !== 0 && e3.lineIndent < i2 && K3(e3, "deficient indentation"), l3;
}
function q3(e3) {
  var n = e3.position, i2;
  return i2 = e3.input.charCodeAt(n), !!((i2 === 45 || i2 === 46) && i2 === e3.input.charCodeAt(n + 1) && i2 === e3.input.charCodeAt(n + 2) && (n += 3, i2 = e3.input.charCodeAt(n), i2 === 0 || b3(i2)));
}
function J3(e3, n) {
  n === 1 ? e3.result += " " : n > 1 && (e3.result += y2.repeat(`
`, n - 1));
}
function vi(e3, n, i2) {
  var l3, r6, u4, o, f3, c2, a3, t2, p3 = e3.kind, d4 = e3.result, s4;
  if (s4 = e3.input.charCodeAt(e3.position), b3(s4) || k3(s4) || s4 === 35 || s4 === 38 || s4 === 42 || s4 === 33 || s4 === 124 || s4 === 62 || s4 === 39 || s4 === 34 || s4 === 37 || s4 === 64 || s4 === 96 || (s4 === 63 || s4 === 45) && (r6 = e3.input.charCodeAt(e3.position + 1), b3(r6) || i2 && k3(r6))) return false;
  for (e3.kind = "scalar", e3.result = "", u4 = o = e3.position, f3 = false; s4 !== 0; ) {
    if (s4 === 58) {
      if (r6 = e3.input.charCodeAt(e3.position + 1), b3(r6) || i2 && k3(r6)) break;
    } else if (s4 === 35) {
      if (l3 = e3.input.charCodeAt(e3.position - 1), b3(l3)) break;
    } else {
      if (e3.position === e3.lineStart && q3(e3) || i2 && k3(s4)) break;
      if (S4(s4)) if (c2 = e3.line, a3 = e3.lineStart, t2 = e3.lineIndent, v2(e3, false, -1), e3.lineIndent >= n) {
        f3 = true, s4 = e3.input.charCodeAt(e3.position);
        continue;
      } else {
        e3.position = o, e3.line = c2, e3.lineStart = a3, e3.lineIndent = t2;
        break;
      }
    }
    f3 && (O2(e3, u4, o, false), J3(e3, e3.line - c2), u4 = o = e3.position, f3 = false), I2(s4) || (o = e3.position + 1), s4 = e3.input.charCodeAt(++e3.position);
  }
  return O2(e3, u4, o, false), e3.result ? true : (e3.kind = p3, e3.result = d4, false);
}
function yi(e3, n) {
  var i2, l3, r6;
  if (i2 = e3.input.charCodeAt(e3.position), i2 !== 39) return false;
  for (e3.kind = "scalar", e3.result = "", e3.position++, l3 = r6 = e3.position; (i2 = e3.input.charCodeAt(e3.position)) !== 0; ) if (i2 === 39) if (O2(e3, l3, e3.position, true), i2 = e3.input.charCodeAt(++e3.position), i2 === 39) l3 = e3.position, e3.position++, r6 = e3.position;
  else return true;
  else S4(i2) ? (O2(e3, l3, r6, true), J3(e3, v2(e3, false, n)), l3 = r6 = e3.position) : e3.position === e3.lineStart && q3(e3) ? h5(e3, "unexpected end of the document within a single quoted scalar") : (e3.position++, r6 = e3.position);
  h5(e3, "unexpected end of the stream within a single quoted scalar");
}
function Ci(e3, n) {
  var i2, l3, r6, u4, o, f3;
  if (f3 = e3.input.charCodeAt(e3.position), f3 !== 34) return false;
  for (e3.kind = "scalar", e3.result = "", e3.position++, i2 = l3 = e3.position; (f3 = e3.input.charCodeAt(e3.position)) !== 0; ) {
    if (f3 === 34) return O2(e3, i2, e3.position, true), e3.position++, true;
    if (f3 === 92) {
      if (O2(e3, i2, e3.position, true), f3 = e3.input.charCodeAt(++e3.position), S4(f3)) v2(e3, false, n);
      else if (f3 < 256 && Ae[f3]) e3.result += ve2[f3], e3.position++;
      else if ((o = xi(f3)) > 0) {
        for (r6 = o, u4 = 0; r6 > 0; r6--) f3 = e3.input.charCodeAt(++e3.position), (o = si(f3)) >= 0 ? u4 = (u4 << 4) + o : h5(e3, "expected hexadecimal character");
        e3.result += gi(u4), e3.position++;
      } else h5(e3, "unknown escape sequence");
      i2 = l3 = e3.position;
    } else S4(f3) ? (O2(e3, i2, l3, true), J3(e3, v2(e3, false, n)), i2 = l3 = e3.position) : e3.position === e3.lineStart && q3(e3) ? h5(e3, "unexpected end of the document within a double quoted scalar") : (e3.position++, l3 = e3.position);
  }
  h5(e3, "unexpected end of the stream within a double quoted scalar");
}
function _i(e3, n) {
  var i2 = true, l3, r6, u4, o = e3.tag, f3, c2 = e3.anchor, a3, t2, p3, d4, s4, x5 = /* @__PURE__ */ Object.create(null), g4, A2, F2, m4;
  if (m4 = e3.input.charCodeAt(e3.position), m4 === 91) t2 = 93, s4 = false, f3 = [];
  else if (m4 === 123) t2 = 125, s4 = true, f3 = {};
  else return false;
  for (e3.anchor !== null && (e3.anchorMap[e3.anchor] = f3), m4 = e3.input.charCodeAt(++e3.position); m4 !== 0; ) {
    if (v2(e3, true, n), m4 = e3.input.charCodeAt(e3.position), m4 === t2) return e3.position++, e3.tag = o, e3.anchor = c2, e3.kind = s4 ? "mapping" : "sequence", e3.result = f3, true;
    i2 ? m4 === 44 && h5(e3, "expected the node content, but found ','") : h5(e3, "missed comma between flow collection entries"), A2 = g4 = F2 = null, p3 = d4 = false, m4 === 63 && (a3 = e3.input.charCodeAt(e3.position + 1), b3(a3) && (p3 = d4 = true, e3.position++, v2(e3, true, n))), l3 = e3.line, r6 = e3.lineStart, u4 = e3.position, R(e3, n, H3, false, true), A2 = e3.tag, g4 = e3.result, v2(e3, true, n), m4 = e3.input.charCodeAt(e3.position), (d4 || e3.line === l3) && m4 === 58 && (p3 = true, m4 = e3.input.charCodeAt(++e3.position), v2(e3, true, n), R(e3, n, H3, false, true), F2 = e3.result), s4 ? N3(e3, f3, x5, A2, g4, F2, l3, r6, u4) : p3 ? f3.push(N3(e3, null, x5, A2, g4, F2, l3, r6, u4)) : f3.push(g4), v2(e3, true, n), m4 = e3.input.charCodeAt(e3.position), m4 === 44 ? (i2 = true, m4 = e3.input.charCodeAt(++e3.position)) : i2 = false;
  }
  h5(e3, "unexpected end of the stream within a flow collection");
}
function wi(e3, n) {
  var i2, l3, r6 = Z2, u4 = false, o = false, f3 = n, c2 = 0, a3 = false, t2, p3;
  if (p3 = e3.input.charCodeAt(e3.position), p3 === 124) l3 = false;
  else if (p3 === 62) l3 = true;
  else return false;
  for (e3.kind = "scalar", e3.result = ""; p3 !== 0; ) if (p3 = e3.input.charCodeAt(++e3.position), p3 === 43 || p3 === 45) Z2 === r6 ? r6 = p3 === 43 ? de : pi : h5(e3, "repeat of a chomping mode identifier");
  else if ((t2 = mi(p3)) >= 0) t2 === 0 ? h5(e3, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? h5(e3, "repeat of an indentation width identifier") : (f3 = n + t2 - 1, o = true);
  else break;
  if (I2(p3)) {
    do
      p3 = e3.input.charCodeAt(++e3.position);
    while (I2(p3));
    if (p3 === 35) do
      p3 = e3.input.charCodeAt(++e3.position);
    while (!S4(p3) && p3 !== 0);
  }
  for (; p3 !== 0; ) {
    for (z3(e3), e3.lineIndent = 0, p3 = e3.input.charCodeAt(e3.position); (!o || e3.lineIndent < f3) && p3 === 32; ) e3.lineIndent++, p3 = e3.input.charCodeAt(++e3.position);
    if (!o && e3.lineIndent > f3 && (f3 = e3.lineIndent), S4(p3)) {
      c2++;
      continue;
    }
    if (e3.lineIndent < f3) {
      r6 === de ? e3.result += y2.repeat(`
`, u4 ? 1 + c2 : c2) : r6 === Z2 && u4 && (e3.result += `
`);
      break;
    }
    for (l3 ? I2(p3) ? (a3 = true, e3.result += y2.repeat(`
`, u4 ? 1 + c2 : c2)) : a3 ? (a3 = false, e3.result += y2.repeat(`
`, c2 + 1)) : c2 === 0 ? u4 && (e3.result += " ") : e3.result += y2.repeat(`
`, c2) : e3.result += y2.repeat(`
`, u4 ? 1 + c2 : c2), u4 = true, o = true, c2 = 0, i2 = e3.position; !S4(p3) && p3 !== 0; ) p3 = e3.input.charCodeAt(++e3.position);
    O2(e3, i2, e3.position, false);
  }
  return true;
}
function we(e3, n) {
  var i2, l3 = e3.tag, r6 = e3.anchor, u4 = [], o, f3 = false, c2;
  if (e3.firstTabInLine !== -1) return false;
  for (e3.anchor !== null && (e3.anchorMap[e3.anchor] = u4), c2 = e3.input.charCodeAt(e3.position); c2 !== 0 && (e3.firstTabInLine !== -1 && (e3.position = e3.firstTabInLine, h5(e3, "tab characters must not be used in indentation")), !(c2 !== 45 || (o = e3.input.charCodeAt(e3.position + 1), !b3(o)))); ) {
    if (f3 = true, e3.position++, v2(e3, true, -1) && e3.lineIndent <= n) {
      u4.push(null), c2 = e3.input.charCodeAt(e3.position);
      continue;
    }
    if (i2 = e3.line, R(e3, n, he, false, true), u4.push(e3.result), v2(e3, true, -1), c2 = e3.input.charCodeAt(e3.position), (e3.line === i2 || e3.lineIndent > n) && c2 !== 0) h5(e3, "bad indentation of a sequence entry");
    else if (e3.lineIndent < n) break;
  }
  return f3 ? (e3.tag = l3, e3.anchor = r6, e3.kind = "sequence", e3.result = u4, true) : false;
}
function bi(e3, n, i2) {
  var l3, r6, u4, o, f3, c2, a3 = e3.tag, t2 = e3.anchor, p3 = {}, d4 = /* @__PURE__ */ Object.create(null), s4 = null, x5 = null, g4 = null, A2 = false, F2 = false, m4;
  if (e3.firstTabInLine !== -1) return false;
  for (e3.anchor !== null && (e3.anchorMap[e3.anchor] = p3), m4 = e3.input.charCodeAt(e3.position); m4 !== 0; ) {
    if (!A2 && e3.firstTabInLine !== -1 && (e3.position = e3.firstTabInLine, h5(e3, "tab characters must not be used in indentation")), l3 = e3.input.charCodeAt(e3.position + 1), u4 = e3.line, (m4 === 63 || m4 === 58) && b3(l3)) m4 === 63 ? (A2 && (N3(e3, p3, d4, s4, x5, null, o, f3, c2), s4 = x5 = g4 = null), F2 = true, A2 = true, r6 = true) : A2 ? (A2 = false, r6 = true) : h5(e3, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e3.position += 1, m4 = l3;
    else {
      if (o = e3.line, f3 = e3.lineStart, c2 = e3.position, !R(e3, i2, te, false, true)) break;
      if (e3.line === u4) {
        for (m4 = e3.input.charCodeAt(e3.position); I2(m4); ) m4 = e3.input.charCodeAt(++e3.position);
        if (m4 === 58) m4 = e3.input.charCodeAt(++e3.position), b3(m4) || h5(e3, "a whitespace character is expected after the key-value separator within a block mapping"), A2 && (N3(e3, p3, d4, s4, x5, null, o, f3, c2), s4 = x5 = g4 = null), F2 = true, A2 = false, r6 = false, s4 = e3.tag, x5 = e3.result;
        else if (F2) h5(e3, "can not read an implicit mapping pair; a colon is missed");
        else return e3.tag = a3, e3.anchor = t2, true;
      } else if (F2) h5(e3, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else return e3.tag = a3, e3.anchor = t2, true;
    }
    if ((e3.line === u4 || e3.lineIndent > n) && (A2 && (o = e3.line, f3 = e3.lineStart, c2 = e3.position), R(e3, n, U3, true, r6) && (A2 ? x5 = e3.result : g4 = e3.result), A2 || (N3(e3, p3, d4, s4, x5, g4, o, f3, c2), s4 = x5 = g4 = null), v2(e3, true, -1), m4 = e3.input.charCodeAt(e3.position)), (e3.line === u4 || e3.lineIndent > n) && m4 !== 0) h5(e3, "bad indentation of a mapping entry");
    else if (e3.lineIndent < n) break;
  }
  return A2 && N3(e3, p3, d4, s4, x5, null, o, f3, c2), F2 && (e3.tag = a3, e3.anchor = t2, e3.kind = "mapping", e3.result = p3), F2;
}
function Fi(e3) {
  var n, i2 = false, l3 = false, r6, u4, o;
  if (o = e3.input.charCodeAt(e3.position), o !== 33) return false;
  if (e3.tag !== null && h5(e3, "duplication of a tag property"), o = e3.input.charCodeAt(++e3.position), o === 60 ? (i2 = true, o = e3.input.charCodeAt(++e3.position)) : o === 33 ? (l3 = true, r6 = "!!", o = e3.input.charCodeAt(++e3.position)) : r6 = "!", n = e3.position, i2) {
    do
      o = e3.input.charCodeAt(++e3.position);
    while (o !== 0 && o !== 62);
    e3.position < e3.length ? (u4 = e3.input.slice(n, e3.position), o = e3.input.charCodeAt(++e3.position)) : h5(e3, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !b3(o); ) o === 33 && (l3 ? h5(e3, "tag suffix cannot contain exclamation marks") : (r6 = e3.input.slice(n - 1, e3.position + 1), se.test(r6) || h5(e3, "named tag handle cannot contain such characters"), l3 = true, n = e3.position + 1)), o = e3.input.charCodeAt(++e3.position);
    u4 = e3.input.slice(n, e3.position), di.test(u4) && h5(e3, "tag suffix cannot contain flow indicator characters");
  }
  u4 && !xe.test(u4) && h5(e3, "tag name cannot contain such characters: " + u4);
  try {
    u4 = decodeURIComponent(u4);
  } catch {
    h5(e3, "tag name is malformed: " + u4);
  }
  return i2 ? e3.tag = u4 : T3.call(e3.tagMap, r6) ? e3.tag = e3.tagMap[r6] + u4 : r6 === "!" ? e3.tag = "!" + u4 : r6 === "!!" ? e3.tag = "tag:yaml.org,2002:" + u4 : h5(e3, 'undeclared tag handle "' + r6 + '"'), true;
}
function Si(e3) {
  var n, i2;
  if (i2 = e3.input.charCodeAt(e3.position), i2 !== 38) return false;
  for (e3.anchor !== null && h5(e3, "duplication of an anchor property"), i2 = e3.input.charCodeAt(++e3.position), n = e3.position; i2 !== 0 && !b3(i2) && !k3(i2); ) i2 = e3.input.charCodeAt(++e3.position);
  return e3.position === n && h5(e3, "name of an anchor node must contain at least one character"), e3.anchor = e3.input.slice(n, e3.position), true;
}
function Ei(e3) {
  var n, i2, l3;
  if (l3 = e3.input.charCodeAt(e3.position), l3 !== 42) return false;
  for (l3 = e3.input.charCodeAt(++e3.position), n = e3.position; l3 !== 0 && !b3(l3) && !k3(l3); ) l3 = e3.input.charCodeAt(++e3.position);
  return e3.position === n && h5(e3, "name of an alias node must contain at least one character"), i2 = e3.input.slice(n, e3.position), T3.call(e3.anchorMap, i2) || h5(e3, 'unidentified alias "' + i2 + '"'), e3.result = e3.anchorMap[i2], v2(e3, true, -1), true;
}
function R(e3, n, i2, l3, r6) {
  var u4, o, f3, c2 = 1, a3 = false, t2 = false, p3, d4, s4, x5, g4, A2;
  if (e3.listener !== null && e3.listener("open", e3), e3.tag = null, e3.anchor = null, e3.kind = null, e3.result = null, u4 = o = f3 = U3 === i2 || he === i2, l3 && v2(e3, true, -1) && (a3 = true, e3.lineIndent > n ? c2 = 1 : e3.lineIndent === n ? c2 = 0 : e3.lineIndent < n && (c2 = -1)), c2 === 1) for (; Fi(e3) || Si(e3); ) v2(e3, true, -1) ? (a3 = true, f3 = u4, e3.lineIndent > n ? c2 = 1 : e3.lineIndent === n ? c2 = 0 : e3.lineIndent < n && (c2 = -1)) : f3 = false;
  if (f3 && (f3 = a3 || r6), (c2 === 1 || U3 === i2) && (H3 === i2 || te === i2 ? g4 = n : g4 = n + 1, A2 = e3.position - e3.lineStart, c2 === 1 ? f3 && (we(e3, A2) || bi(e3, A2, g4)) || _i(e3, g4) ? t2 = true : (o && wi(e3, g4) || yi(e3, g4) || Ci(e3, g4) ? t2 = true : Ei(e3) ? (t2 = true, (e3.tag !== null || e3.anchor !== null) && h5(e3, "alias node should not have any properties")) : vi(e3, g4, H3 === i2) && (t2 = true, e3.tag === null && (e3.tag = "?")), e3.anchor !== null && (e3.anchorMap[e3.anchor] = e3.result)) : c2 === 0 && (t2 = f3 && we(e3, A2))), e3.tag === null) e3.anchor !== null && (e3.anchorMap[e3.anchor] = e3.result);
  else if (e3.tag === "?") {
    for (e3.result !== null && e3.kind !== "scalar" && h5(e3, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e3.kind + '"'), p3 = 0, d4 = e3.implicitTypes.length; p3 < d4; p3 += 1) if (x5 = e3.implicitTypes[p3], x5.resolve(e3.result)) {
      e3.result = x5.construct(e3.result), e3.tag = x5.tag, e3.anchor !== null && (e3.anchorMap[e3.anchor] = e3.result);
      break;
    }
  } else if (e3.tag !== "!") {
    if (T3.call(e3.typeMap[e3.kind || "fallback"], e3.tag)) x5 = e3.typeMap[e3.kind || "fallback"][e3.tag];
    else for (x5 = null, s4 = e3.typeMap.multi[e3.kind || "fallback"], p3 = 0, d4 = s4.length; p3 < d4; p3 += 1) if (e3.tag.slice(0, s4[p3].tag.length) === s4[p3].tag) {
      x5 = s4[p3];
      break;
    }
    x5 || h5(e3, "unknown tag !<" + e3.tag + ">"), e3.result !== null && x5.kind !== e3.kind && h5(e3, "unacceptable node kind for !<" + e3.tag + '> tag; it should be "' + x5.kind + '", not "' + e3.kind + '"'), x5.resolve(e3.result, e3.tag) ? (e3.result = x5.construct(e3.result, e3.tag), e3.anchor !== null && (e3.anchorMap[e3.anchor] = e3.result)) : h5(e3, "cannot resolve a node with !<" + e3.tag + "> explicit tag");
  }
  return e3.listener !== null && e3.listener("close", e3), e3.tag !== null || e3.anchor !== null || t2;
}
function Ti(e3) {
  var n = e3.position, i2, l3, r6, u4 = false, o;
  for (e3.version = null, e3.checkLineBreaks = e3.legacy, e3.tagMap = /* @__PURE__ */ Object.create(null), e3.anchorMap = /* @__PURE__ */ Object.create(null); (o = e3.input.charCodeAt(e3.position)) !== 0 && (v2(e3, true, -1), o = e3.input.charCodeAt(e3.position), !(e3.lineIndent > 0 || o !== 37)); ) {
    for (u4 = true, o = e3.input.charCodeAt(++e3.position), i2 = e3.position; o !== 0 && !b3(o); ) o = e3.input.charCodeAt(++e3.position);
    for (l3 = e3.input.slice(i2, e3.position), r6 = [], l3.length < 1 && h5(e3, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; I2(o); ) o = e3.input.charCodeAt(++e3.position);
      if (o === 35) {
        do
          o = e3.input.charCodeAt(++e3.position);
        while (o !== 0 && !S4(o));
        break;
      }
      if (S4(o)) break;
      for (i2 = e3.position; o !== 0 && !b3(o); ) o = e3.input.charCodeAt(++e3.position);
      r6.push(e3.input.slice(i2, e3.position));
    }
    o !== 0 && z3(e3), T3.call(Ce, l3) ? Ce[l3](e3, l3, r6) : K3(e3, 'unknown document directive "' + l3 + '"');
  }
  if (v2(e3, true, -1), e3.lineIndent === 0 && e3.input.charCodeAt(e3.position) === 45 && e3.input.charCodeAt(e3.position + 1) === 45 && e3.input.charCodeAt(e3.position + 2) === 45 ? (e3.position += 3, v2(e3, true, -1)) : u4 && h5(e3, "directives end mark is expected"), R(e3, e3.lineIndent - 1, U3, false, true), v2(e3, true, -1), e3.checkLineBreaks && hi.test(e3.input.slice(n, e3.position)) && K3(e3, "non-ASCII line breaks are interpreted as content"), e3.documents.push(e3.result), e3.position === e3.lineStart && q3(e3)) {
    e3.input.charCodeAt(e3.position) === 46 && (e3.position += 3, v2(e3, true, -1));
    return;
  }
  if (e3.position < e3.length - 1) h5(e3, "end of the stream or a document separator is expected");
  else return;
}
function be(e3, n) {
  e3 = String(e3), n = n || {}, e3.length !== 0 && (e3.charCodeAt(e3.length - 1) !== 10 && e3.charCodeAt(e3.length - 1) !== 13 && (e3 += `
`), e3.charCodeAt(0) === 65279 && (e3 = e3.slice(1)));
  var i2 = new Ai(e3, n), l3 = e3.indexOf("\0");
  for (l3 !== -1 && (i2.position = l3, h5(i2, "null byte is not allowed in input")), i2.input += "\0"; i2.input.charCodeAt(i2.position) === 32; ) i2.lineIndent += 1, i2.position += 1;
  for (; i2.position < i2.length - 1; ) Ti(i2);
  return i2.documents;
}
function Oi(e3, n, i2) {
  n !== null && typeof n == "object" && typeof i2 > "u" && (i2 = n, n = null);
  var l3 = be(e3, i2);
  if (typeof n != "function") return l3;
  for (var r6 = 0, u4 = l3.length; r6 < u4; r6 += 1) n(l3[r6]);
}
function Ii(e3, n) {
  var i2 = be(e3, n);
  if (i2.length !== 0) {
    if (i2.length === 1) return i2[0];
    throw new w3("expected a single document in the stream, but found more");
  }
}
function zi(e3, n) {
  var i2, l3, r6, u4, o, f3, c2;
  if (n === null) return {};
  for (i2 = {}, l3 = Object.keys(n), r6 = 0, u4 = l3.length; r6 < u4; r6 += 1) o = l3[r6], f3 = String(n[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), c2 = e3.compiledTypeMap.fallback[o], c2 && Se.call(c2.styleAliases, f3) && (f3 = c2.styleAliases[f3]), i2[o] = f3;
  return i2;
}
function Ji(e3) {
  var n, i2, l3;
  if (n = e3.toString(16).toUpperCase(), e3 <= 255) i2 = "x", l3 = 2;
  else if (e3 <= 65535) i2 = "u", l3 = 4;
  else if (e3 <= 4294967295) i2 = "U", l3 = 8;
  else throw new w3("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + i2 + y2.repeat("0", l3 - n.length) + n;
}
function nr(e3) {
  this.schema = e3.schema || pe, this.indent = Math.max(1, e3.indent || 2), this.noArrayIndent = e3.noArrayIndent || false, this.skipInvalid = e3.skipInvalid || false, this.flowLevel = y2.isNothing(e3.flowLevel) ? -1 : e3.flowLevel, this.styleMap = zi(this.schema, e3.styles || null), this.sortKeys = e3.sortKeys || false, this.lineWidth = e3.lineWidth || 80, this.noRefs = e3.noRefs || false, this.noCompatMode = e3.noCompatMode || false, this.condenseFlow = e3.condenseFlow || false, this.quotingType = e3.quotingType === '"' ? B : er, this.forceQuotes = e3.forceQuotes || false, this.replacer = typeof e3.replacer == "function" ? e3.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function Le(e3, n) {
  for (var i2 = y2.repeat(" ", n), l3 = 0, r6 = -1, u4 = "", o, f3 = e3.length; l3 < f3; ) r6 = e3.indexOf(`
`, l3), r6 === -1 ? (o = e3.slice(l3), l3 = f3) : (o = e3.slice(l3, r6 + 1), l3 = r6 + 1), o.length && o !== `
` && (u4 += i2), u4 += o;
  return u4;
}
function ie(e3, n) {
  return `
` + y2.repeat(" ", e3.indent * n);
}
function ir(e3, n) {
  var i2, l3, r6;
  for (i2 = 0, l3 = e3.implicitTypes.length; i2 < l3; i2 += 1) if (r6 = e3.implicitTypes[i2], r6.resolve(n)) return true;
  return false;
}
function W3(e3) {
  return e3 === Mi || e3 === Ri;
}
function P3(e3) {
  return 32 <= e3 && e3 <= 126 || 161 <= e3 && e3 <= 55295 && e3 !== 8232 && e3 !== 8233 || 57344 <= e3 && e3 <= 65533 && e3 !== ee || 65536 <= e3 && e3 <= 1114111;
}
function Ne(e3) {
  return P3(e3) && e3 !== ee && e3 !== Di && e3 !== Y2;
}
function Re(e3, n, i2) {
  var l3 = Ne(e3), r6 = l3 && !W3(e3);
  return (i2 ? l3 : l3 && e3 !== Ee && e3 !== Te && e3 !== Oe && e3 !== Ie && e3 !== ke) && e3 !== ne && !(n === G2 && !r6) || Ne(n) && !W3(n) && e3 === ne || n === G2 && r6;
}
function rr(e3) {
  return P3(e3) && e3 !== ee && !W3(e3) && e3 !== Ki && e3 !== Wi && e3 !== G2 && e3 !== Ee && e3 !== Te && e3 !== Oe && e3 !== Ie && e3 !== ke && e3 !== ne && e3 !== ji && e3 !== Ui && e3 !== Yi && e3 !== Vi && e3 !== qi && e3 !== Gi && e3 !== Hi && e3 !== Bi && e3 !== Pi && e3 !== $i && e3 !== Qi;
}
function lr(e3) {
  return !W3(e3) && e3 !== G2;
}
function j(e3, n) {
  var i2 = e3.charCodeAt(n), l3;
  return i2 >= 55296 && i2 <= 56319 && n + 1 < e3.length && (l3 = e3.charCodeAt(n + 1), l3 >= 56320 && l3 <= 57343) ? (i2 - 55296) * 1024 + l3 - 56320 + 65536 : i2;
}
function De(e3) {
  var n = /^\n* /;
  return n.test(e3);
}
function or(e3, n, i2, l3, r6, u4, o, f3) {
  var c2, a3 = 0, t2 = null, p3 = false, d4 = false, s4 = l3 !== -1, x5 = -1, g4 = rr(j(e3, 0)) && lr(j(e3, e3.length - 1));
  if (n || o) for (c2 = 0; c2 < e3.length; a3 >= 65536 ? c2 += 2 : c2++) {
    if (a3 = j(e3, c2), !P3(a3)) return D;
    g4 = g4 && Re(a3, t2, f3), t2 = a3;
  }
  else {
    for (c2 = 0; c2 < e3.length; a3 >= 65536 ? c2 += 2 : c2++) {
      if (a3 = j(e3, c2), a3 === Y2) p3 = true, s4 && (d4 = d4 || c2 - x5 - 1 > l3 && e3[x5 + 1] !== " ", x5 = c2);
      else if (!P3(a3)) return D;
      g4 = g4 && Re(a3, t2, f3), t2 = a3;
    }
    d4 = d4 || s4 && c2 - x5 - 1 > l3 && e3[x5 + 1] !== " ";
  }
  return !p3 && !d4 ? g4 && !o && !r6(e3) ? Me : u4 === B ? D : re : i2 > 9 && De(e3) ? D : o ? u4 === B ? D : re : d4 ? Be : Ye;
}
function ur(e3, n, i2, l3, r6) {
  e3.dump = (function() {
    if (n.length === 0) return e3.quotingType === B ? '""' : "''";
    if (!e3.noCompatMode && (Xi.indexOf(n) !== -1 || Zi.test(n))) return e3.quotingType === B ? '"' + n + '"' : "'" + n + "'";
    var u4 = e3.indent * Math.max(1, i2), o = e3.lineWidth === -1 ? -1 : Math.max(Math.min(e3.lineWidth, 40), e3.lineWidth - u4), f3 = l3 || e3.flowLevel > -1 && i2 >= e3.flowLevel;
    function c2(a3) {
      return ir(e3, a3);
    }
    switch (or(n, f3, e3.indent, o, c2, e3.quotingType, e3.forceQuotes && !l3, r6)) {
      case Me:
        return n;
      case re:
        return "'" + n.replace(/'/g, "''") + "'";
      case Ye:
        return "|" + Pe(n, e3.indent) + je(Le(n, u4));
      case Be:
        return ">" + Pe(n, e3.indent) + je(Le(fr(n, o), u4));
      case D:
        return '"' + cr(n) + '"';
      default:
        throw new w3("impossible error: invalid scalar style");
    }
  })();
}
function Pe(e3, n) {
  var i2 = De(e3) ? String(n) : "", l3 = e3[e3.length - 1] === `
`, r6 = l3 && (e3[e3.length - 2] === `
` || e3 === `
`), u4 = r6 ? "+" : l3 ? "" : "-";
  return i2 + u4 + `
`;
}
function je(e3) {
  return e3[e3.length - 1] === `
` ? e3.slice(0, -1) : e3;
}
function fr(e3, n) {
  for (var i2 = /(\n+)([^\n]*)/g, l3 = (function() {
    var a3 = e3.indexOf(`
`);
    return a3 = a3 !== -1 ? a3 : e3.length, i2.lastIndex = a3, He(e3.slice(0, a3), n);
  })(), r6 = e3[0] === `
` || e3[0] === " ", u4, o; o = i2.exec(e3); ) {
    var f3 = o[1], c2 = o[2];
    u4 = c2[0] === " ", l3 += f3 + (!r6 && !u4 && c2 !== "" ? `
` : "") + He(c2, n), r6 = u4;
  }
  return l3;
}
function He(e3, n) {
  if (e3 === "" || e3[0] === " ") return e3;
  for (var i2 = / [^ ]/g, l3, r6 = 0, u4, o = 0, f3 = 0, c2 = ""; l3 = i2.exec(e3); ) f3 = l3.index, f3 - r6 > n && (u4 = o > r6 ? o : f3, c2 += `
` + e3.slice(r6, u4), r6 = u4 + 1), o = f3;
  return c2 += `
`, e3.length - r6 > n && o > r6 ? c2 += e3.slice(r6, o) + `
` + e3.slice(o + 1) : c2 += e3.slice(r6), c2.slice(1);
}
function cr(e3) {
  for (var n = "", i2 = 0, l3, r6 = 0; r6 < e3.length; i2 >= 65536 ? r6 += 2 : r6++) i2 = j(e3, r6), l3 = _3[i2], !l3 && P3(i2) ? (n += e3[r6], i2 >= 65536 && (n += e3[r6 + 1])) : n += l3 || Ji(i2);
  return n;
}
function ar(e3, n, i2) {
  var l3 = "", r6 = e3.tag, u4, o, f3;
  for (u4 = 0, o = i2.length; u4 < o; u4 += 1) f3 = i2[u4], e3.replacer && (f3 = e3.replacer.call(i2, String(u4), f3)), (E2(e3, n, f3, false, false) || typeof f3 > "u" && E2(e3, n, null, false, false)) && (l3 !== "" && (l3 += "," + (e3.condenseFlow ? "" : " ")), l3 += e3.dump);
  e3.tag = r6, e3.dump = "[" + l3 + "]";
}
function Ue(e3, n, i2, l3) {
  var r6 = "", u4 = e3.tag, o, f3, c2;
  for (o = 0, f3 = i2.length; o < f3; o += 1) c2 = i2[o], e3.replacer && (c2 = e3.replacer.call(i2, String(o), c2)), (E2(e3, n + 1, c2, true, true, false, true) || typeof c2 > "u" && E2(e3, n + 1, null, true, true, false, true)) && ((!l3 || r6 !== "") && (r6 += ie(e3, n)), e3.dump && Y2 === e3.dump.charCodeAt(0) ? r6 += "-" : r6 += "- ", r6 += e3.dump);
  e3.tag = u4, e3.dump = r6 || "[]";
}
function pr(e3, n, i2) {
  var l3 = "", r6 = e3.tag, u4 = Object.keys(i2), o, f3, c2, a3, t2;
  for (o = 0, f3 = u4.length; o < f3; o += 1) t2 = "", l3 !== "" && (t2 += ", "), e3.condenseFlow && (t2 += '"'), c2 = u4[o], a3 = i2[c2], e3.replacer && (a3 = e3.replacer.call(i2, c2, a3)), E2(e3, n, c2, false, false) && (e3.dump.length > 1024 && (t2 += "? "), t2 += e3.dump + (e3.condenseFlow ? '"' : "") + ":" + (e3.condenseFlow ? "" : " "), E2(e3, n, a3, false, false) && (t2 += e3.dump, l3 += t2));
  e3.tag = r6, e3.dump = "{" + l3 + "}";
}
function tr(e3, n, i2, l3) {
  var r6 = "", u4 = e3.tag, o = Object.keys(i2), f3, c2, a3, t2, p3, d4;
  if (e3.sortKeys === true) o.sort();
  else if (typeof e3.sortKeys == "function") o.sort(e3.sortKeys);
  else if (e3.sortKeys) throw new w3("sortKeys must be a boolean or a function");
  for (f3 = 0, c2 = o.length; f3 < c2; f3 += 1) d4 = "", (!l3 || r6 !== "") && (d4 += ie(e3, n)), a3 = o[f3], t2 = i2[a3], e3.replacer && (t2 = e3.replacer.call(i2, a3, t2)), E2(e3, n + 1, a3, true, true, true) && (p3 = e3.tag !== null && e3.tag !== "?" || e3.dump && e3.dump.length > 1024, p3 && (e3.dump && Y2 === e3.dump.charCodeAt(0) ? d4 += "?" : d4 += "? "), d4 += e3.dump, p3 && (d4 += ie(e3, n)), E2(e3, n + 1, t2, true, p3) && (e3.dump && Y2 === e3.dump.charCodeAt(0) ? d4 += ":" : d4 += ": ", d4 += e3.dump, r6 += d4));
  e3.tag = u4, e3.dump = r6 || "{}";
}
function Ke(e3, n, i2) {
  var l3, r6, u4, o, f3, c2;
  for (r6 = i2 ? e3.explicitTypes : e3.implicitTypes, u4 = 0, o = r6.length; u4 < o; u4 += 1) if (f3 = r6[u4], (f3.instanceOf || f3.predicate) && (!f3.instanceOf || typeof n == "object" && n instanceof f3.instanceOf) && (!f3.predicate || f3.predicate(n))) {
    if (i2 ? f3.multi && f3.representName ? e3.tag = f3.representName(n) : e3.tag = f3.tag : e3.tag = "?", f3.represent) {
      if (c2 = e3.styleMap[f3.tag] || f3.defaultStyle, Fe.call(f3.represent) === "[object Function]") l3 = f3.represent(n, c2);
      else if (Se.call(f3.represent, c2)) l3 = f3.represent[c2](n, c2);
      else throw new w3("!<" + f3.tag + '> tag resolver accepts not "' + c2 + '" style');
      e3.dump = l3;
    }
    return true;
  }
  return false;
}
function E2(e3, n, i2, l3, r6, u4, o) {
  e3.tag = null, e3.dump = i2, Ke(e3, i2, false) || Ke(e3, i2, true);
  var f3 = Fe.call(e3.dump), c2 = l3, a3;
  l3 && (l3 = e3.flowLevel < 0 || e3.flowLevel > n);
  var t2 = f3 === "[object Object]" || f3 === "[object Array]", p3, d4;
  if (t2 && (p3 = e3.duplicates.indexOf(i2), d4 = p3 !== -1), (e3.tag !== null && e3.tag !== "?" || d4 || e3.indent !== 2 && n > 0) && (r6 = false), d4 && e3.usedDuplicates[p3]) e3.dump = "*ref_" + p3;
  else {
    if (t2 && d4 && !e3.usedDuplicates[p3] && (e3.usedDuplicates[p3] = true), f3 === "[object Object]") l3 && Object.keys(e3.dump).length !== 0 ? (tr(e3, n, e3.dump, r6), d4 && (e3.dump = "&ref_" + p3 + e3.dump)) : (pr(e3, n, e3.dump), d4 && (e3.dump = "&ref_" + p3 + " " + e3.dump));
    else if (f3 === "[object Array]") l3 && e3.dump.length !== 0 ? (e3.noArrayIndent && !o && n > 0 ? Ue(e3, n - 1, e3.dump, r6) : Ue(e3, n, e3.dump, r6), d4 && (e3.dump = "&ref_" + p3 + e3.dump)) : (ar(e3, n, e3.dump), d4 && (e3.dump = "&ref_" + p3 + " " + e3.dump));
    else if (f3 === "[object String]") e3.tag !== "?" && ur(e3, e3.dump, n, u4, c2);
    else {
      if (f3 === "[object Undefined]") return false;
      if (e3.skipInvalid) return false;
      throw new w3("unacceptable kind of an object to dump " + f3);
    }
    e3.tag !== null && e3.tag !== "?" && (a3 = encodeURI(e3.tag[0] === "!" ? e3.tag.slice(1) : e3.tag).replace(/!/g, "%21"), e3.tag[0] === "!" ? a3 = "!" + a3 : a3.slice(0, 18) === "tag:yaml.org,2002:" ? a3 = "!!" + a3.slice(18) : a3 = "!<" + a3 + ">", e3.dump = a3 + " " + e3.dump);
  }
  return true;
}
function hr(e3, n) {
  var i2 = [], l3 = [], r6, u4;
  for (le(e3, i2, l3), r6 = 0, u4 = l3.length; r6 < u4; r6 += 1) n.duplicates.push(i2[l3[r6]]);
  n.usedDuplicates = new Array(u4);
}
function le(e3, n, i2) {
  var l3, r6, u4;
  if (e3 !== null && typeof e3 == "object") if (r6 = n.indexOf(e3), r6 !== -1) i2.indexOf(r6) === -1 && i2.push(r6);
  else if (n.push(e3), Array.isArray(e3)) for (r6 = 0, u4 = e3.length; r6 < u4; r6 += 1) le(e3[r6], n, i2);
  else for (l3 = Object.keys(e3), r6 = 0, u4 = l3.length; r6 < u4; r6 += 1) le(e3[l3[r6]], n, i2);
}
function dr(e3, n) {
  n = n || {};
  var i2 = new nr(n);
  i2.noRefs || hr(e3, i2);
  var l3 = e3;
  return i2.replacer && (l3 = i2.replacer.call({ "": l3 }, "", l3)), E2(i2, 0, l3, true, true) ? i2.dump + `
` : "";
}
function Ar(e3, n) {
  const i2 = mr(e3, n);
  return N(e3, i2, n), i2;
}
function vr(e3, n) {
  const i2 = C2(e3, { preserveIndentation: false }), l3 = typeof i2.indent == "string" ? i2.indent.length : i2.indent, r6 = gr(e3, { indent: l3, ...n });
  return i2.whitespace.start + r6.trim() + i2.whitespace.end;
}
var Ze, ze, Je, en, nn, rn, y2, w3, on, un, fn, C3, tn, hn, dn, sn, xn, vn, wn, In, kn, Rn, Yn, Bn, Pn, ce, ae, Kn, Gn, X2, Xn, Zn, zn, ni, ii, oi, ui, ai, pe, T3, H3, te, he, U3, Z2, pi, de, ti, hi, di, se, xe, Ae, ve2, L4, Ce, ki, Li, Ni, Fe, Se, ee, Ri, Y2, Di, Mi, Yi, Bi, ne, Pi, ji, Hi, Ui, Ee, Ki, G2, qi, Gi, Wi, $i, Te, Oe, Qi, Ie, Vi, ke, _3, Xi, Zi, er, B, Me, re, Ye, Be, D, sr, xr, mr, gr;
var init_yaml = __esm({
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/yaml.mjs"() {
    "use strict";
    init_confbox_9388d834();
    Ze = oe;
    ze = We;
    Je = $e;
    en = Ve;
    nn = Xe;
    rn = Qe;
    y2 = { isNothing: Ze, isObject: ze, toArray: Je, repeat: en, isNegativeZero: nn, extend: rn };
    M2.prototype = Object.create(Error.prototype), M2.prototype.constructor = M2, M2.prototype.toString = function(n) {
      return this.name + ": " + ue(this, n);
    };
    w3 = M2;
    on = ln;
    un = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"];
    fn = ["scalar", "sequence", "mapping"];
    C3 = an;
    V2.prototype.extend = function(n) {
      var i2 = [], l3 = [];
      if (n instanceof C3) l3.push(n);
      else if (Array.isArray(n)) l3 = l3.concat(n);
      else if (n && (Array.isArray(n.implicit) || Array.isArray(n.explicit))) n.implicit && (i2 = i2.concat(n.implicit)), n.explicit && (l3 = l3.concat(n.explicit));
      else throw new w3("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      i2.forEach(function(u4) {
        if (!(u4 instanceof C3)) throw new w3("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        if (u4.loadKind && u4.loadKind !== "scalar") throw new w3("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        if (u4.multi) throw new w3("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
      }), l3.forEach(function(u4) {
        if (!(u4 instanceof C3)) throw new w3("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      });
      var r6 = Object.create(V2.prototype);
      return r6.implicit = (this.implicit || []).concat(i2), r6.explicit = (this.explicit || []).concat(l3), r6.compiledImplicit = fe(r6, "implicit"), r6.compiledExplicit = fe(r6, "explicit"), r6.compiledTypeMap = pn(r6.compiledImplicit, r6.compiledExplicit), r6;
    };
    tn = V2;
    hn = new C3("tag:yaml.org,2002:str", { kind: "scalar", construct: function(e3) {
      return e3 !== null ? e3 : "";
    } });
    dn = new C3("tag:yaml.org,2002:seq", { kind: "sequence", construct: function(e3) {
      return e3 !== null ? e3 : [];
    } });
    sn = new C3("tag:yaml.org,2002:map", { kind: "mapping", construct: function(e3) {
      return e3 !== null ? e3 : {};
    } });
    xn = new tn({ explicit: [hn, dn, sn] });
    vn = new C3("tag:yaml.org,2002:null", { kind: "scalar", resolve: mn, construct: gn, predicate: An, represent: { canonical: function() {
      return "~";
    }, lowercase: function() {
      return "null";
    }, uppercase: function() {
      return "NULL";
    }, camelcase: function() {
      return "Null";
    }, empty: function() {
      return "";
    } }, defaultStyle: "lowercase" });
    wn = new C3("tag:yaml.org,2002:bool", { kind: "scalar", resolve: yn, construct: Cn, predicate: _n, represent: { lowercase: function(e3) {
      return e3 ? "true" : "false";
    }, uppercase: function(e3) {
      return e3 ? "TRUE" : "FALSE";
    }, camelcase: function(e3) {
      return e3 ? "True" : "False";
    } }, defaultStyle: "lowercase" });
    In = new C3("tag:yaml.org,2002:int", { kind: "scalar", resolve: En, construct: Tn, predicate: On, represent: { binary: function(e3) {
      return e3 >= 0 ? "0b" + e3.toString(2) : "-0b" + e3.toString(2).slice(1);
    }, octal: function(e3) {
      return e3 >= 0 ? "0o" + e3.toString(8) : "-0o" + e3.toString(8).slice(1);
    }, decimal: function(e3) {
      return e3.toString(10);
    }, hexadecimal: function(e3) {
      return e3 >= 0 ? "0x" + e3.toString(16).toUpperCase() : "-0x" + e3.toString(16).toUpperCase().slice(1);
    } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } });
    kn = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    Rn = /^[-+]?[0-9]+e/;
    Yn = new C3("tag:yaml.org,2002:float", { kind: "scalar", resolve: Ln, construct: Nn, predicate: Mn, represent: Dn, defaultStyle: "lowercase" });
    Bn = xn.extend({ implicit: [vn, wn, In, Yn] });
    Pn = Bn;
    ce = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    ae = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    Kn = new C3("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: jn, construct: Hn, instanceOf: Date, represent: Un });
    Gn = new C3("tag:yaml.org,2002:merge", { kind: "scalar", resolve: qn });
    X2 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
    Xn = new C3("tag:yaml.org,2002:binary", { kind: "scalar", resolve: Wn, construct: $n, predicate: Vn, represent: Qn });
    Zn = Object.prototype.hasOwnProperty;
    zn = Object.prototype.toString;
    ni = new C3("tag:yaml.org,2002:omap", { kind: "sequence", resolve: Jn, construct: ei });
    ii = Object.prototype.toString;
    oi = new C3("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: ri, construct: li });
    ui = Object.prototype.hasOwnProperty;
    ai = new C3("tag:yaml.org,2002:set", { kind: "mapping", resolve: fi, construct: ci });
    pe = Pn.extend({ implicit: [Kn, Gn], explicit: [Xn, ni, oi, ai] });
    T3 = Object.prototype.hasOwnProperty;
    H3 = 1;
    te = 2;
    he = 3;
    U3 = 4;
    Z2 = 1;
    pi = 2;
    de = 3;
    ti = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    hi = /[\x85\u2028\u2029]/;
    di = /[,\[\]\{\}]/;
    se = /^(?:!|!!|![a-z\-]+!)$/i;
    xe = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    for (Ae = new Array(256), ve2 = new Array(256), L4 = 0; L4 < 256; L4++) Ae[L4] = ge(L4) ? 1 : 0, ve2[L4] = ge(L4);
    Ce = { YAML: function(n, i2, l3) {
      var r6, u4, o;
      n.version !== null && h5(n, "duplication of %YAML directive"), l3.length !== 1 && h5(n, "YAML directive accepts exactly one argument"), r6 = /^([0-9]+)\.([0-9]+)$/.exec(l3[0]), r6 === null && h5(n, "ill-formed argument of the YAML directive"), u4 = parseInt(r6[1], 10), o = parseInt(r6[2], 10), u4 !== 1 && h5(n, "unacceptable YAML version of the document"), n.version = l3[0], n.checkLineBreaks = o < 2, o !== 1 && o !== 2 && K3(n, "unsupported YAML version of the document");
    }, TAG: function(n, i2, l3) {
      var r6, u4;
      l3.length !== 2 && h5(n, "TAG directive accepts exactly two arguments"), r6 = l3[0], u4 = l3[1], se.test(r6) || h5(n, "ill-formed tag handle (first argument) of the TAG directive"), T3.call(n.tagMap, r6) && h5(n, 'there is a previously declared suffix for "' + r6 + '" tag handle'), xe.test(u4) || h5(n, "ill-formed tag prefix (second argument) of the TAG directive");
      try {
        u4 = decodeURIComponent(u4);
      } catch {
        h5(n, "tag prefix is malformed: " + u4);
      }
      n.tagMap[r6] = u4;
    } };
    ki = Oi;
    Li = Ii;
    Ni = { loadAll: ki, load: Li };
    Fe = Object.prototype.toString;
    Se = Object.prototype.hasOwnProperty;
    ee = 65279;
    Ri = 9;
    Y2 = 10;
    Di = 13;
    Mi = 32;
    Yi = 33;
    Bi = 34;
    ne = 35;
    Pi = 37;
    ji = 38;
    Hi = 39;
    Ui = 42;
    Ee = 44;
    Ki = 45;
    G2 = 58;
    qi = 61;
    Gi = 62;
    Wi = 63;
    $i = 64;
    Te = 91;
    Oe = 93;
    Qi = 96;
    Ie = 123;
    Vi = 124;
    ke = 125;
    _3 = {};
    _3[0] = "\\0", _3[7] = "\\a", _3[8] = "\\b", _3[9] = "\\t", _3[10] = "\\n", _3[11] = "\\v", _3[12] = "\\f", _3[13] = "\\r", _3[27] = "\\e", _3[34] = '\\"', _3[92] = "\\\\", _3[133] = "\\N", _3[160] = "\\_", _3[8232] = "\\L", _3[8233] = "\\P";
    Xi = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"];
    Zi = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    er = 1;
    B = 2;
    Me = 1;
    re = 2;
    Ye = 3;
    Be = 4;
    D = 5;
    sr = dr;
    xr = { dump: sr };
    mr = Ni.load;
    gr = xr.dump;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/toml.mjs
var toml_exports = {};
__export(toml_exports, {
  parseTOML: () => ae2,
  stringifyTOML: () => ue2
});
function U4(e3, n) {
  let t2 = e3.slice(0, n).split(/\r\n|\n|\r/g);
  return [t2.length, t2.pop().length + 1];
}
function X3(e3, n, t2) {
  let i2 = e3.split(/\r\n|\n|\r/g), l3 = "", r6 = (Math.log10(n + 1) | 0) + 1;
  for (let f3 = n - 1; f3 <= n + 1; f3++) {
    let o = i2[f3 - 1];
    o && (l3 += f3.toString().padEnd(r6, " "), l3 += ":  ", l3 += o, l3 += `
`, f3 === n && (l3 += " ".repeat(r6 + t2 + 2), l3 += `^
`));
  }
  return l3;
}
function x3(e3, n = 0, t2 = e3.length) {
  let i2 = e3.indexOf(`
`, n);
  return e3[i2 - 1] === "\r" && i2--, i2 <= t2 ? i2 : -1;
}
function A(e3, n) {
  for (let t2 = n; t2 < e3.length; t2++) {
    let i2 = e3[t2];
    if (i2 === `
`) return t2;
    if (i2 === "\r" && e3[t2 + 1] === `
`) return t2 + 1;
    if (i2 < " " && i2 !== "	" || i2 === "\x7F") throw new u3("control characters are not allowed in comments", { toml: e3, ptr: n });
  }
  return e3.length;
}
function g3(e3, n, t2, i2) {
  let l3;
  for (; (l3 = e3[n]) === " " || l3 === "	" || !t2 && (l3 === `
` || l3 === "\r" && e3[n + 1] === `
`); ) n++;
  return i2 || l3 !== "#" ? n : g3(e3, A(e3, n), t2);
}
function P4(e3, n, t2, i2, l3 = false) {
  if (!i2) return n = x3(e3, n), n < 0 ? e3.length : n;
  for (let r6 = n; r6 < e3.length; r6++) {
    let f3 = e3[r6];
    if (f3 === "#") r6 = x3(e3, r6);
    else {
      if (f3 === t2) return r6 + 1;
      if (f3 === i2) return r6;
      if (l3 && (f3 === `
` || f3 === "\r" && e3[r6 + 1] === `
`)) return r6;
    }
  }
  throw new u3("cannot find end of structure", { toml: e3, ptr: n });
}
function v3(e3, n) {
  let t2 = e3[n], i2 = t2 === e3[n + 1] && e3[n + 1] === e3[n + 2] ? e3.slice(n, n + 3) : t2;
  n += i2.length - 1;
  do
    n = e3.indexOf(i2, ++n);
  while (n > -1 && t2 !== "'" && e3[n - 1] === "\\" && e3[n - 2] !== "\\");
  return n > -1 && (n += i2.length, i2.length > 1 && (e3[n] === t2 && n++, e3[n] === t2 && n++)), n;
}
function C4(e3, n = 0, t2 = e3.length) {
  let i2 = e3[n] === "'", l3 = e3[n++] === e3[n] && e3[n] === e3[n + 1];
  l3 && (t2 -= 2, e3[n += 2] === "\r" && n++, e3[n] === `
` && n++);
  let r6 = 0, f3, o = "", a3 = n;
  for (; n < t2 - 1; ) {
    let c2 = e3[n++];
    if (c2 === `
` || c2 === "\r" && e3[n] === `
`) {
      if (!l3) throw new u3("newlines are not allowed in strings", { toml: e3, ptr: n - 1 });
    } else if (c2 < " " && c2 !== "	" || c2 === "\x7F") throw new u3("control characters are not allowed in strings", { toml: e3, ptr: n - 1 });
    if (f3) {
      if (f3 = false, c2 === "u" || c2 === "U") {
        let y3 = e3.slice(n, n += c2 === "u" ? 4 : 8);
        if (!J4.test(y3)) throw new u3("invalid unicode escape", { toml: e3, ptr: r6 });
        try {
          o += String.fromCodePoint(parseInt(y3, 16));
        } catch {
          throw new u3("invalid unicode escape", { toml: e3, ptr: r6 });
        }
      } else if (l3 && (c2 === `
` || c2 === " " || c2 === "	" || c2 === "\r")) {
        if (n = g3(e3, n - 1, true), e3[n] !== `
` && e3[n] !== "\r") throw new u3("invalid escape: only line-ending whitespace may be escaped", { toml: e3, ptr: r6 });
        n = g3(e3, n);
      } else if (c2 in R2) o += R2[c2];
      else throw new u3("unrecognized escape sequence", { toml: e3, ptr: r6 });
      a3 = n;
    } else !i2 && c2 === "\\" && (r6 = n - 1, f3 = true, o += e3.slice(a3, r6));
  }
  return o + e3.slice(a3, t2 - 1);
}
function H4(e3, n, t2) {
  if (e3 === "true") return true;
  if (e3 === "false") return false;
  if (e3 === "-inf") return -1 / 0;
  if (e3 === "inf" || e3 === "+inf") return 1 / 0;
  if (e3 === "nan" || e3 === "+nan" || e3 === "-nan") return NaN;
  if (e3 === "-0") return 0;
  let i2;
  if ((i2 = Y3.test(e3)) || j2.test(e3)) {
    if (q4.test(e3)) throw new u3("leading zeroes are not allowed", { toml: n, ptr: t2 });
    let r6 = +e3.replace(/_/g, "");
    if (isNaN(r6)) throw new u3("invalid number", { toml: n, ptr: t2 });
    if (i2 && !Number.isSafeInteger(r6)) throw new u3("integer value cannot be represented losslessly", { toml: n, ptr: t2 });
    return r6;
  }
  let l3 = new S5(e3);
  if (!l3.isValid()) throw new u3("invalid value", { toml: n, ptr: t2 });
  return l3;
}
function Q4(e3, n, t2, i2) {
  let l3 = e3.slice(n, t2), r6 = l3.indexOf("#");
  r6 > -1 && (A(e3, r6), l3 = l3.slice(0, r6));
  let f3 = l3.trimEnd();
  if (!i2) {
    let o = l3.indexOf(`
`, f3.length);
    if (o > -1) throw new u3("newlines are not allowed in inline tables", { toml: e3, ptr: n + o });
  }
  return [f3, r6];
}
function I3(e3, n, t2) {
  let i2 = e3[n];
  if (i2 === "[" || i2 === "{") {
    let [f3, o] = i2 === "[" ? ne2(e3, n) : ee2(e3, n), a3 = P4(e3, o, ",", t2);
    if (t2 === "}") {
      let c2 = x3(e3, o, a3);
      if (c2 > -1) throw new u3("newlines are not allowed in inline tables", { toml: e3, ptr: c2 });
    }
    return [f3, a3];
  }
  let l3;
  if (i2 === '"' || i2 === "'") {
    l3 = v3(e3, n);
    let f3 = C4(e3, n, l3);
    if (t2) {
      if (l3 = g3(e3, l3, t2 !== "]"), e3[l3] && e3[l3] !== "," && e3[l3] !== t2 && e3[l3] !== `
` && e3[l3] !== "\r") throw new u3("unexpected character encountered", { toml: e3, ptr: l3 });
      l3 += +(e3[l3] === ",");
    }
    return [f3, l3];
  }
  l3 = P4(e3, n, ",", t2);
  let r6 = Q4(e3, n, l3 - +(e3[l3 - 1] === ","), t2 === "]");
  if (!r6[0]) throw new u3("incomplete key-value declaration: no value specified", { toml: e3, ptr: n });
  return t2 && r6[1] > -1 && (l3 = g3(e3, n + r6[1]), l3 += +(e3[l3] === ",")), [H4(r6[0], e3, n), l3];
}
function p2(e3, n, t2 = "=") {
  let i2 = n - 1, l3 = [], r6 = e3.indexOf(t2, n);
  if (r6 < 0) throw new u3("incomplete key-value: cannot find end of key", { toml: e3, ptr: n });
  do {
    let f3 = e3[n = ++i2];
    if (f3 !== " " && f3 !== "	") if (f3 === '"' || f3 === "'") {
      if (f3 === e3[n + 1] && f3 === e3[n + 2]) throw new u3("multiline strings are not allowed in keys", { toml: e3, ptr: n });
      let o = v3(e3, n);
      if (o < 0) throw new u3("unfinished string encountered", { toml: e3, ptr: n });
      i2 = e3.indexOf(".", o);
      let a3 = e3.slice(o, i2 < 0 || i2 > r6 ? r6 : i2), c2 = x3(a3);
      if (c2 > -1) throw new u3("newlines are not allowed in keys", { toml: e3, ptr: n + i2 + c2 });
      if (a3.trimStart()) throw new u3("found extra tokens after the string part", { toml: e3, ptr: o });
      if (r6 < o && (r6 = e3.indexOf(t2, o), r6 < 0)) throw new u3("incomplete key-value: cannot find end of key", { toml: e3, ptr: n });
      l3.push(C4(e3, n, o));
    } else {
      i2 = e3.indexOf(".", n);
      let o = e3.slice(n, i2 < 0 || i2 > r6 ? r6 : i2);
      if (!W4.test(o)) throw new u3("only letter, numbers, dashes and underscores are allowed in keys", { toml: e3, ptr: n });
      l3.push(o.trimEnd());
    }
  } while (i2 + 1 && i2 < r6);
  return [l3, g3(e3, r6 + 1, true, true)];
}
function ee2(e3, n) {
  let t2 = {}, i2 = /* @__PURE__ */ new Set(), l3, r6 = 0;
  for (n++; (l3 = e3[n++]) !== "}" && l3; ) {
    if (l3 === `
`) throw new u3("newlines are not allowed in inline tables", { toml: e3, ptr: n - 1 });
    if (l3 === "#") throw new u3("inline tables cannot contain comments", { toml: e3, ptr: n - 1 });
    if (l3 === ",") throw new u3("expected key-value, found comma", { toml: e3, ptr: n - 1 });
    if (l3 !== " " && l3 !== "	") {
      let f3, o = t2, a3 = false, [c2, y3] = p2(e3, n - 1);
      for (let E3 = 0; E3 < c2.length; E3++) {
        if (E3 && (o = a3 ? o[f3] : o[f3] = {}), f3 = c2[E3], (a3 = Object.hasOwn(o, f3)) && (typeof o[f3] != "object" || i2.has(o[f3]))) throw new u3("trying to redefine an already defined value", { toml: e3, ptr: n });
        !a3 && f3 === "__proto__" && Object.defineProperty(o, f3, { enumerable: true, configurable: true, writable: true });
      }
      if (a3) throw new u3("trying to redefine an already defined value", { toml: e3, ptr: n });
      let [k4, z4] = I3(e3, y3, "}");
      i2.add(k4), o[f3] = k4, n = z4, r6 = e3[n - 1] === "," ? n - 1 : 0;
    }
  }
  if (r6) throw new u3("trailing commas are not allowed in inline tables", { toml: e3, ptr: r6 });
  if (!l3) throw new u3("unfinished table encountered", { toml: e3, ptr: n });
  return [t2, n];
}
function ne2(e3, n) {
  let t2 = [], i2;
  for (n++; (i2 = e3[n++]) !== "]" && i2; ) {
    if (i2 === ",") throw new u3("expected value, found comma", { toml: e3, ptr: n - 1 });
    if (i2 === "#") n = A(e3, n);
    else if (i2 !== " " && i2 !== "	" && i2 !== `
` && i2 !== "\r") {
      let l3 = I3(e3, n - 1, "]");
      t2.push(l3[0]), n = l3[1];
    }
  }
  if (!i2) throw new u3("unfinished array encountered", { toml: e3, ptr: n });
  return [t2, n];
}
function M3(e3, n, t2, i2) {
  let l3 = n, r6 = t2, f3, o = false, a3;
  for (let c2 = 0; c2 < e3.length; c2++) {
    if (c2) {
      if (l3 = o ? l3[f3] : l3[f3] = {}, r6 = (a3 = r6[f3]).c, i2 === 0 && (a3.t === 1 || a3.t === 2)) return null;
      if (a3.t === 2) {
        let y3 = l3.length - 1;
        l3 = l3[y3], r6 = r6[y3].c;
      }
    }
    if (f3 = e3[c2], (o = Object.hasOwn(l3, f3)) && r6[f3]?.t === 0 && r6[f3]?.d) return null;
    o || (f3 === "__proto__" && (Object.defineProperty(l3, f3, { enumerable: true, configurable: true, writable: true }), Object.defineProperty(r6, f3, { enumerable: true, configurable: true, writable: true })), r6[f3] = { t: c2 < e3.length - 1 && i2 === 2 ? 3 : i2, d: false, i: 0, c: {} });
  }
  if (a3 = r6[f3], a3.t !== i2 && !(i2 === 1 && a3.t === 3) || (i2 === 2 && (a3.d || (a3.d = true, l3[f3] = []), l3[f3].push(l3 = {}), a3.c[a3.i++] = a3 = { t: 1, d: false, i: 0, c: {} }), a3.d)) return null;
  if (a3.d = true, i2 === 1) l3 = o ? l3[f3] : l3[f3] = {};
  else if (i2 === 0 && o) return null;
  return [f3, l3, a3.c];
}
function te2(e3) {
  let n = {}, t2 = {}, i2 = n, l3 = t2;
  for (let r6 = g3(e3, 0); r6 < e3.length; ) {
    if (e3[r6] === "[") {
      let f3 = e3[++r6] === "[", o = p2(e3, r6 += +f3, "]");
      if (f3) {
        if (e3[o[1] - 1] !== "]") throw new u3("expected end of table declaration", { toml: e3, ptr: o[1] - 1 });
        o[1]++;
      }
      let a3 = M3(o[0], n, t2, f3 ? 2 : 1);
      if (!a3) throw new u3("trying to redefine an already defined table or value", { toml: e3, ptr: r6 });
      l3 = a3[2], i2 = a3[1], r6 = o[1];
    } else {
      let f3 = p2(e3, r6), o = M3(f3[0], i2, l3, 0);
      if (!o) throw new u3("trying to redefine an already defined table or value", { toml: e3, ptr: r6 });
      let a3 = I3(e3, f3[1]);
      o[1][o[0]] = a3[0], r6 = a3[1];
    }
    if (r6 = g3(e3, r6, true), e3[r6] && e3[r6] !== `
` && e3[r6] !== "\r") throw new u3("each key-value declaration must be followed by an end-of-line", { toml: e3, ptr: r6 });
    r6 = g3(e3, r6);
  }
  return n;
}
function _4(e3) {
  let n = typeof e3;
  if (n === "object") {
    if (Array.isArray(e3)) return "array";
    if (e3 instanceof Date) return "date";
  }
  return n;
}
function ie2(e3) {
  for (let n = 0; n < e3.length; n++) if (_4(e3[n]) !== "object") return false;
  return e3.length != 0;
}
function $4(e3) {
  return JSON.stringify(e3).replace(/\x7f/g, "\\u007f");
}
function N4(e3, n = _4(e3)) {
  if (n === "number") return isNaN(e3) ? "nan" : e3 === 1 / 0 ? "inf" : e3 === -1 / 0 ? "-inf" : e3.toString();
  if (n === "bigint" || n === "boolean") return e3.toString();
  if (n === "string") return $4(e3);
  if (n === "date") {
    if (isNaN(e3.getTime())) throw new TypeError("cannot serialize invalid date");
    return e3.toISOString();
  }
  if (n === "object") return le2(e3);
  if (n === "array") return re2(e3);
}
function le2(e3) {
  let n = Object.keys(e3);
  if (n.length === 0) return "{}";
  let t2 = "{ ";
  for (let i2 = 0; i2 < n.length; i2++) {
    let l3 = n[i2];
    i2 && (t2 += ", "), t2 += Z3.test(l3) ? l3 : $4(l3), t2 += " = ", t2 += N4(e3[l3]);
  }
  return t2 + " }";
}
function re2(e3) {
  if (e3.length === 0) return "[]";
  let n = "[ ";
  for (let t2 = 0; t2 < e3.length; t2++) {
    if (t2 && (n += ", "), e3[t2] === null || e3[t2] === void 0) throw new TypeError("arrays cannot contain null or undefined values");
    n += N4(e3[t2]);
  }
  return n + " ]";
}
function fe2(e3, n) {
  let t2 = "";
  for (let i2 = 0; i2 < e3.length; i2++) t2 += `[[${n}]]
`, t2 += D2(e3[i2], n), t2 += `

`;
  return t2;
}
function D2(e3, n = "") {
  let t2 = "", i2 = "", l3 = Object.keys(e3);
  for (let r6 = 0; r6 < l3.length; r6++) {
    let f3 = l3[r6];
    if (e3[f3] !== null && e3[f3] !== void 0) {
      let o = _4(e3[f3]);
      if (o === "symbol" || o === "function") throw new TypeError(`cannot serialize values of type '${o}'`);
      let a3 = Z3.test(f3) ? f3 : $4(f3);
      if (o === "array" && ie2(e3[f3])) i2 += fe2(e3[f3], n ? `${n}.${a3}` : a3);
      else if (o === "object") {
        let c2 = n ? `${n}.${a3}` : a3;
        i2 += `[${c2}]
`, i2 += D2(e3[f3], c2), i2 += `

`;
      } else t2 += a3, t2 += " = ", t2 += N4(e3[f3], o), t2 += `
`;
    }
  }
  return `${t2}
${i2}`.trim();
}
function oe2(e3) {
  if (_4(e3) !== "object") throw new TypeError("stringify can only be called with an object");
  return D2(e3);
}
function ae2(e3) {
  const n = te2(e3);
  return N(e3, n, { preserveIndentation: false }), n;
}
function ue2(e3) {
  const n = C2(e3, { preserveIndentation: false }), t2 = oe2(e3);
  return n.whitespace.start + t2 + n.whitespace.end;
}
var F, V3, O3, L2, d3, T4, w4, h6, m3, s2, u3, B2, b4, S5, Y3, j2, q4, J4, R2, W4, Z3;
var init_toml = __esm({
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/toml.mjs"() {
    "use strict";
    init_confbox_9388d834();
    F = Object.defineProperty;
    V3 = (e3, n, t2) => n in e3 ? F(e3, n, { enumerable: true, configurable: true, writable: true, value: t2 }) : e3[n] = t2;
    O3 = (e3, n, t2) => (V3(e3, typeof n != "symbol" ? n + "" : n, t2), t2);
    L2 = (e3, n, t2) => {
      if (!n.has(e3)) throw TypeError("Cannot " + t2);
    };
    d3 = (e3, n, t2) => (L2(e3, n, "read from private field"), t2 ? t2.call(e3) : n.get(e3));
    T4 = (e3, n, t2) => {
      if (n.has(e3)) throw TypeError("Cannot add the same private member more than once");
      n instanceof WeakSet ? n.add(e3) : n.set(e3, t2);
    };
    w4 = (e3, n, t2, i2) => (L2(e3, n, "write to private field"), i2 ? i2.call(e3, t2) : n.set(e3, t2), t2);
    u3 = class extends Error {
      constructor(t2, i2) {
        const [l3, r6] = U4(i2.toml, i2.ptr), f3 = X3(i2.toml, l3, r6);
        super(`Invalid TOML document: ${t2}

${f3}`, i2);
        O3(this, "line");
        O3(this, "column");
        O3(this, "codeblock");
        this.line = l3, this.column = r6, this.codeblock = f3;
      }
    };
    B2 = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
    b4 = class b5 extends Date {
      constructor(t2) {
        let i2 = true, l3 = true, r6 = "Z";
        if (typeof t2 == "string") {
          let f3 = t2.match(B2);
          f3 ? (f3[1] || (i2 = false, t2 = `0000-01-01T${t2}`), l3 = !!f3[2], f3[2] && +f3[2] > 23 ? t2 = "" : (r6 = f3[3] || null, t2 = t2.toUpperCase(), !r6 && l3 && (t2 += "Z"))) : t2 = "";
        }
        super(t2);
        T4(this, h6, false);
        T4(this, m3, false);
        T4(this, s2, null);
        isNaN(this.getTime()) || (w4(this, h6, i2), w4(this, m3, l3), w4(this, s2, r6));
      }
      isDateTime() {
        return d3(this, h6) && d3(this, m3);
      }
      isLocal() {
        return !d3(this, h6) || !d3(this, m3) || !d3(this, s2);
      }
      isDate() {
        return d3(this, h6) && !d3(this, m3);
      }
      isTime() {
        return d3(this, m3) && !d3(this, h6);
      }
      isValid() {
        return d3(this, h6) || d3(this, m3);
      }
      toISOString() {
        let t2 = super.toISOString();
        if (this.isDate()) return t2.slice(0, 10);
        if (this.isTime()) return t2.slice(11, 23);
        if (d3(this, s2) === null) return t2.slice(0, -1);
        if (d3(this, s2) === "Z") return t2;
        let i2 = +d3(this, s2).slice(1, 3) * 60 + +d3(this, s2).slice(4, 6);
        return i2 = d3(this, s2)[0] === "-" ? i2 : -i2, new Date(this.getTime() - i2 * 6e4).toISOString().slice(0, -1) + d3(this, s2);
      }
      static wrapAsOffsetDateTime(t2, i2 = "Z") {
        let l3 = new b5(t2);
        return w4(l3, s2, i2), l3;
      }
      static wrapAsLocalDateTime(t2) {
        let i2 = new b5(t2);
        return w4(i2, s2, null), i2;
      }
      static wrapAsLocalDate(t2) {
        let i2 = new b5(t2);
        return w4(i2, m3, false), w4(i2, s2, null), i2;
      }
      static wrapAsLocalTime(t2) {
        let i2 = new b5(t2);
        return w4(i2, h6, false), w4(i2, s2, null), i2;
      }
    };
    h6 = /* @__PURE__ */ new WeakMap(), m3 = /* @__PURE__ */ new WeakMap(), s2 = /* @__PURE__ */ new WeakMap();
    S5 = b4;
    Y3 = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/;
    j2 = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/;
    q4 = /^[+-]?0[0-9_]/;
    J4 = /^[0-9a-f]{4,8}$/i;
    R2 = { b: "\b", t: "	", n: `
`, f: "\f", r: "\r", '"': '"', "\\": "\\" };
    W4 = /^[a-zA-Z0-9-_]+[ \t]*$/;
    Z3 = /^[a-z0-9-_]+$/i;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/index.mjs
var init_dist3 = __esm({
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/index.mjs"() {
    "use strict";
    init_confbox_f9f03f05();
  }
});

// ../../node_modules/.pnpm/pkg-types@1.3.1/node_modules/pkg-types/dist/index.mjs
async function findFile(filename, _options = {}) {
  const filenames = Array.isArray(filename) ? filename : [filename];
  const options = { ...defaultFindOptions, ..._options };
  const basePath = resolve2(options.startingFrom);
  const leadingSlash = basePath[0] === "/";
  const segments = basePath.split("/").filter(Boolean);
  if (leadingSlash) {
    segments[0] = "/" + segments[0];
  }
  let root = segments.findIndex((r6) => r6.match(options.rootPattern));
  if (root === -1) {
    root = 0;
  }
  if (options.reverse) {
    for (let index = root + 1; index <= segments.length; index++) {
      for (const filename2 of filenames) {
        const filePath = join(...segments.slice(0, index), filename2);
        if (await options.test(filePath)) {
          return filePath;
        }
      }
    }
  } else {
    for (let index = segments.length; index > root; index--) {
      for (const filename2 of filenames) {
        const filePath = join(...segments.slice(0, index), filename2);
        if (await options.test(filePath)) {
          return filePath;
        }
      }
    }
  }
  throw new Error(
    `Cannot find matching ${filename} in ${options.startingFrom} or parent directories`
  );
}
function findNearestFile(filename, _options = {}) {
  return findFile(filename, _options);
}
async function readPackageJSON(id, options = {}) {
  const resolvedPath = await resolvePackageJSON(id, options);
  const cache2 = options.cache && typeof options.cache !== "boolean" ? options.cache : FileCache;
  if (options.cache && cache2.has(resolvedPath)) {
    return cache2.get(resolvedPath);
  }
  const blob = await import_node_fs.promises.readFile(resolvedPath, "utf8");
  let parsed;
  try {
    parsed = x2(blob);
  } catch {
    parsed = h4(blob);
  }
  cache2.set(resolvedPath, parsed);
  return parsed;
}
async function resolvePackageJSON(id = process.cwd(), options = {}) {
  const resolvedPath = isAbsolute(id) ? id : await resolvePath(id, options);
  return findNearestFile("package.json", {
    startingFrom: resolvedPath,
    ...options
  });
}
async function resolveLockfile(id = process.cwd(), options = {}) {
  const resolvedPath = isAbsolute(id) ? id : await resolvePath(id, options);
  const _options = { startingFrom: resolvedPath, ...options };
  try {
    return await findNearestFile(lockFiles, _options);
  } catch {
  }
  throw new Error("No lockfile found from " + id);
}
async function findWorkspaceDir(id = process.cwd(), options = {}) {
  const resolvedPath = isAbsolute(id) ? id : await resolvePath(id, options);
  const _options = { startingFrom: resolvedPath, ...options };
  try {
    const r6 = await findNearestFile(".git/config", _options);
    return resolve2(r6, "../..");
  } catch {
  }
  try {
    const r6 = await resolveLockfile(resolvedPath, {
      ..._options,
      reverse: true
    });
    return dirname(r6);
  } catch {
  }
  try {
    const r6 = await findFile(resolvedPath, _options);
    return dirname(r6);
  } catch {
  }
  throw new Error("Cannot detect workspace root from " + id);
}
var import_node_fs, defaultFindOptions, FileCache, lockFiles;
var init_dist4 = __esm({
  "../../node_modules/.pnpm/pkg-types@1.3.1/node_modules/pkg-types/dist/index.mjs"() {
    "use strict";
    import_node_fs = require("fs");
    init_dist();
    init_dist5();
    init_dist3();
    defaultFindOptions = {
      startingFrom: ".",
      rootPattern: /^node_modules$/,
      reverse: false,
      test: (filePath) => {
        try {
          if ((0, import_node_fs.statSync)(filePath).isFile()) {
            return true;
          }
        } catch {
        }
      }
    };
    FileCache = /* @__PURE__ */ new Map();
    lockFiles = [
      "yarn.lock",
      "package-lock.json",
      "pnpm-lock.yaml",
      "npm-shrinkwrap.json",
      "bun.lockb",
      "bun.lock"
    ];
  }
});

// ../../node_modules/.pnpm/mlly@1.7.4/node_modules/mlly/dist/index.mjs
function normalizeSlash(path4) {
  return path4.replace(/\\/g, "/");
}
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (import_node_v8.default.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
function getMessage(key, parameters, self2) {
  const message = messages.get(key);
  (0, import_node_assert.default)(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    (0, import_node_assert.default)(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, parameters);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  (0, import_node_assert.default)(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(import_node_util.format, null, parameters);
}
function determineSpecificType(value) {
  if (value === null || value === void 0) {
    return String(value);
  }
  if (typeof value === "function" && value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === "object") {
    if (value.constructor && value.constructor.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${(0, import_node_util.inspect)(value, { depth: -1 })}`;
  }
  let inspected = (0, import_node_util.inspect)(value, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}
function read(jsonPath, { base, specifier }) {
  const existing = cache.get(jsonPath);
  if (existing) {
    return existing;
  }
  let string;
  try {
    string = import_node_fs2.default.readFileSync(import_node_path3.default.toNamespacedPath(jsonPath), "utf8");
  } catch (error) {
    const exception = (
      /** @type {ErrnoException} */
      error
    );
    if (exception.code !== "ENOENT") {
      throw exception;
    }
  }
  const result = {
    exists: false,
    pjsonPath: jsonPath,
    main: void 0,
    name: void 0,
    type: "none",
    // Ignore unknown types for forwards compatibility
    exports: void 0,
    imports: void 0
  };
  if (string !== void 0) {
    let parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      const cause = (
        /** @type {ErrnoException} */
        error_
      );
      const error = new ERR_INVALID_PACKAGE_CONFIG$1(
        jsonPath,
        (base ? `"${specifier}" from ` : "") + (0, import_node_url.fileURLToPath)(base || specifier),
        cause.message
      );
      error.cause = cause;
      throw error;
    }
    result.exists = true;
    if (hasOwnProperty$1.call(parsed, "name") && typeof parsed.name === "string") {
      result.name = parsed.name;
    }
    if (hasOwnProperty$1.call(parsed, "main") && typeof parsed.main === "string") {
      result.main = parsed.main;
    }
    if (hasOwnProperty$1.call(parsed, "exports")) {
      result.exports = parsed.exports;
    }
    if (hasOwnProperty$1.call(parsed, "imports")) {
      result.imports = parsed.imports;
    }
    if (hasOwnProperty$1.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
      result.type = parsed.type;
    }
  }
  cache.set(jsonPath, result);
  return result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new URL("package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (packageJSONPath2.endsWith("node_modules/package.json")) {
      break;
    }
    const packageConfig = read((0, import_node_url.fileURLToPath)(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists) {
      return packageConfig;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = (0, import_node_url.fileURLToPath)(packageJSONUrl);
  return {
    pjsonPath: packageJSONPath,
    exists: false,
    type: "none"
  };
}
function getPackageType(url) {
  return getPackageScopeConfig(url).type;
}
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
    return "module";
  if (mime === "application/json") return "json";
  return null;
}
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function extname2(url) {
  const pathname = url.pathname;
  let index = pathname.length;
  while (index--) {
    const code = pathname.codePointAt(index);
    if (code === 47) {
      return "";
    }
    if (code === 46) {
      return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
    }
  }
  return "";
}
function getFileProtocolModuleFormat(url, _context, ignoreErrors) {
  const value = extname2(url);
  if (value === ".js") {
    const packageType = getPackageType(url);
    if (packageType !== "none") {
      return packageType;
    }
    return "commonjs";
  }
  if (value === "") {
    const packageType = getPackageType(url);
    if (packageType === "none" || packageType === "commonjs") {
      return "commonjs";
    }
    return "module";
  }
  const format3 = extensionFormatMap[value];
  if (format3) return format3;
  if (ignoreErrors) {
    return void 0;
  }
  const filepath = (0, import_node_url.fileURLToPath)(url);
  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url, context4) {
  const protocol = url.protocol;
  if (!hasOwnProperty2.call(protocolHandlers, protocol)) {
    return null;
  }
  return protocolHandlers[protocol](url, context4, true) || null;
}
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {
  if (import_node_process.default.noDeprecation) {
    return;
  }
  const pjsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  import_node_process.default.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url.fileURLToPath)(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url, packageJsonUrl, base, main) {
  if (import_node_process.default.noDeprecation) {
    return;
  }
  const format3 = defaultGetFormatWithoutErrors(url, { parentURL: base.href });
  if (format3 !== "module") return;
  const urlPath = (0, import_node_url.fileURLToPath)(url.href);
  const packagePath = (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl));
  const basePath = (0, import_node_url.fileURLToPath)(base);
  if (!main) {
    import_node_process.default.emitWarning(
      `No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  } else if (import_node_path3.default.resolve(packagePath, main) !== urlPath) {
    import_node_process.default.emitWarning(
      `Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  }
}
function tryStatSync(path4) {
  try {
    return (0, import_node_fs2.statSync)(path4);
  } catch {
  }
}
function fileExists(url) {
  const stats = (0, import_node_fs2.statSync)(url, { throwIfNoEntry: false });
  const isFile = stats ? stats.isFile() : void 0;
  return isFile === null || isFile === void 0 ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new import_node_url.URL(packageConfig.main, packageJsonUrl);
    if (fileExists(guess)) return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i3 = -1;
    while (++i3 < tries2.length) {
      guess = new import_node_url.URL(tries2[i3], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      );
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i2 = -1;
  while (++i2 < tries.length) {
    guess = new import_node_url.URL(tries[i2], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(
    (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    (0, import_node_url.fileURLToPath)(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      (0, import_node_url.fileURLToPath)(base)
    );
  }
  let filePath;
  try {
    filePath = (0, import_node_url.fileURLToPath)(resolved);
  } catch (error) {
    const cause = (
      /** @type {ErrnoException} */
      error
    );
    Object.defineProperty(cause, "input", { value: String(resolved) });
    Object.defineProperty(cause, "module", { value: String(base) });
    throw cause;
  }
  const stats = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats && stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, import_node_url.fileURLToPath)(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats || !stats.isFile()) {
    const error = new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && (0, import_node_url.fileURLToPath)(base),
      true
    );
    error.url = String(resolved);
    throw error;
  }
  {
    const real = (0, import_node_fs2.realpathSync)(filePath);
    const { search, hash: hash2 } = resolved;
    resolved = (0, import_node_url.pathToFileURL)(real + (filePath.endsWith(import_node_path3.default.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash2;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    (0, import_node_url.fileURLToPath)(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    subpath,
    base && (0, import_node_url.fileURLToPath)(base)
  );
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${(0, import_node_url.fileURLToPath)(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && (0, import_node_url.fileURLToPath)(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(
    (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base && (0, import_node_url.fileURLToPath)(base)
  );
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL = false;
      try {
        new import_node_url.URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match.replace("*", () => subpath) : match + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          true
        );
      }
    } else {
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
    }
  }
  const resolved = new import_node_url.URL(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new import_node_url.URL(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);
  if (subpath === "") return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace("*", () => subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base,
          false
        );
      }
    } else {
      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new import_node_url.URL(
      RegExpPrototypeSymbolReplace.call(
        patternRegEx,
        resolved.href,
        () => subpath
      )
    );
  }
  return new import_node_url.URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key) return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0) return null;
    let lastException;
    let i2 = -1;
    while (++i2 < targetList.length) {
      const targetItem = targetList[i2];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error) {
        const exception = (
          /** @type {ErrnoException} */
          error
        );
        lastException = exception;
        if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
        throw error;
      }
      if (resolveResult === void 0) continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys = Object.getOwnPropertyNames(target);
    let i2 = -1;
    while (++i2 < keys.length) {
      const key = keys[i2];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          (0, import_node_url.fileURLToPath)(packageJsonUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    i2 = -1;
    while (++i2 < keys.length) {
      const key = keys[i2];
      if (key === "default" || conditions && conditions.has(key)) {
        const conditionalTarget = (
          /** @type {unknown} */
          target[key]
        );
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0) continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base
  );
}
function isConditionalExportsMainSugar(exports2, packageJsonUrl, base) {
  if (typeof exports2 === "string" || Array.isArray(exports2)) return true;
  if (typeof exports2 !== "object" || exports2 === null) return false;
  const keys = Object.getOwnPropertyNames(exports2);
  let isConditionalSugar = false;
  let i2 = 0;
  let keyIndex = -1;
  while (++keyIndex < keys.length) {
    const key = keys[keyIndex];
    const currentIsConditionalSugar = key === "" || key[0] !== ".";
    if (i2++ === 0) {
      isConditionalSugar = currentIsConditionalSugar;
    } else if (isConditionalSugar !== currentIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG(
        (0, import_node_url.fileURLToPath)(packageJsonUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {
  if (import_node_process.default.noDeprecation) {
    return;
  }
  const pjsonPath = (0, import_node_url.fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match)) return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  import_node_process.default.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, import_node_url.fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports2 = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports2, packageJsonUrl, base)) {
    exports2 = { ".": exports2 };
  }
  if (own.call(exports2, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports2[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      false,
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys = Object.getOwnPropertyNames(exports2);
  let i2 = -1;
  while (++i2 < keys.length) {
    const key = keys[i2];
    const patternIndex = key.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJsonUrl,
          base
        );
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = (
      /** @type {unknown} */
      exports2[bestMatch]
    );
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a3, b6) {
  const aPatternIndex = a3.indexOf("*");
  const bPatternIndex = b6.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a3.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b6.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB) return -1;
  if (baseLengthB > baseLengthA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a3.length > b6.length) return -1;
  if (b6.length > a3.length) return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, import_node_url.fileURLToPath)(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = (0, import_node_url.pathToFileURL)(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          false,
          conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys = Object.getOwnPropertyNames(imports);
        let i2 = -1;
        while (++i2 < keys.length) {
          const key = keys[i2];
          const patternIndex = key.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            false,
            conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      (0, import_node_url.fileURLToPath)(base)
    );
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (import_node_module3.builtinModules.includes(specifier)) {
    return new import_node_url.URL("node:" + specifier);
  }
  const { packageName, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  );
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl2 = (0, import_node_url.pathToFileURL)(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base,
        conditions
      );
    }
  }
  let packageJsonUrl = new import_node_url.URL(
    "./node_modules/" + packageName + "/package.json",
    base
  );
  let packageJsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
  let lastPath;
  do {
    const stat = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat || !stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new import_node_url.URL(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
        packageJsonUrl
      );
      packageJsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
      continue;
    }
    const packageConfig2 = read(packageJsonPath, { base, specifier });
    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl,
        packageSubpath,
        packageConfig2,
        base,
        conditions
      );
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base);
    }
    return new import_node_url.URL(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, (0, import_node_url.fileURLToPath)(base), false);
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/") return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "") return false;
  if (specifier[0] === "/") return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol;
  const isData = protocol === "data:";
  const isRemote = isData || protocol === "http:" || protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    try {
      resolved = new import_node_url.URL(specifier, base);
    } catch (error_) {
      const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
      error.cause = error_;
      throw error;
    }
  } else if (protocol === "file:" && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new import_node_url.URL(specifier);
    } catch (error_) {
      if (isRemote && !import_node_module3.builtinModules.includes(specifier)) {
        const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
        error.cause = error_;
        throw error;
      }
      resolved = packageResolve(specifier, base, conditions);
    }
  }
  (0, import_node_assert.default)(resolved !== void 0, "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base);
}
function fileURLToPath(id) {
  if (typeof id === "string" && !id.startsWith("file://")) {
    return normalizeSlash(id);
  }
  return normalizeSlash((0, import_node_url.fileURLToPath)(id));
}
function pathToFileURL(id) {
  return (0, import_node_url.pathToFileURL)(fileURLToPath(id)).toString();
}
function normalizeid(id) {
  if (typeof id !== "string") {
    id = id.toString();
  }
  if (/(node|data|http|https|file):/.test(id)) {
    return id;
  }
  if (BUILTIN_MODULES.has(id)) {
    return "node:" + id;
  }
  return "file://" + encodeURI(normalizeSlash(id));
}
function _tryModuleResolve(id, url, conditions) {
  try {
    return moduleResolve(id, url, conditions);
  } catch (error) {
    if (!NOT_FOUND_ERRORS.has(error?.code)) {
      throw error;
    }
  }
}
function _resolve(id, options = {}) {
  if (typeof id !== "string") {
    if (id instanceof URL) {
      id = fileURLToPath(id);
    } else {
      throw new TypeError("input must be a `string` or `URL`");
    }
  }
  if (/(node|data|http|https):/.test(id)) {
    return id;
  }
  if (BUILTIN_MODULES.has(id)) {
    return "node:" + id;
  }
  if (id.startsWith("file://")) {
    id = fileURLToPath(id);
  }
  if (isAbsolute(id)) {
    try {
      const stat = (0, import_node_fs2.statSync)(id);
      if (stat.isFile()) {
        return pathToFileURL(id);
      }
    } catch (error) {
      if (error?.code !== "ENOENT") {
        throw error;
      }
    }
  }
  const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
  const _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((url) => new URL(normalizeid(url.toString())));
  if (_urls.length === 0) {
    _urls.push(new URL(pathToFileURL(process.cwd())));
  }
  const urls = [..._urls];
  for (const url of _urls) {
    if (url.protocol === "file:") {
      urls.push(
        new URL("./", url),
        // If url is directory
        new URL(joinURL(url.pathname, "_index.js"), url),
        // TODO: Remove in next major version?
        new URL("node_modules", url)
      );
    }
  }
  let resolved;
  for (const url of urls) {
    resolved = _tryModuleResolve(id, url, conditionsSet);
    if (resolved) {
      break;
    }
    for (const prefix of ["", "/index"]) {
      for (const extension of options.extensions || DEFAULT_EXTENSIONS) {
        resolved = _tryModuleResolve(
          joinURL(id, prefix) + extension,
          url,
          conditionsSet
        );
        if (resolved) {
          break;
        }
      }
      if (resolved) {
        break;
      }
    }
    if (resolved) {
      break;
    }
  }
  if (!resolved) {
    const error = new Error(
      `Cannot find module ${id} imported from ${urls.join(", ")}`
    );
    error.code = "ERR_MODULE_NOT_FOUND";
    throw error;
  }
  return pathToFileURL(resolved);
}
function resolveSync(id, options) {
  return _resolve(id, options);
}
function resolvePathSync(id, options) {
  return fileURLToPath(resolveSync(id, options));
}
function resolvePath(id, options) {
  try {
    return Promise.resolve(resolvePathSync(id, options));
  } catch (error) {
    return Promise.reject(error);
  }
}
var import_node_module3, import_node_fs2, import_node_url, import_node_assert, import_node_process, import_node_path3, import_node_v8, import_node_util, BUILTIN_MODULES, own$1, classRegExp, kTypes, codes, messages, nodeInternalPrefix, userStackTraceLimit, captureLargerStackTrace, hasOwnProperty$1, ERR_INVALID_PACKAGE_CONFIG$1, cache, ERR_UNKNOWN_FILE_EXTENSION, hasOwnProperty2, extensionFormatMap, protocolHandlers, RegExpPrototypeSymbolReplace, ERR_NETWORK_IMPORT_DISALLOWED, ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_RESOLVE_REQUEST, own, invalidSegmentRegEx, deprecatedInvalidSegmentRegEx, invalidPackageNameRegEx, patternRegEx, encodedSeparatorRegEx, emittedPackageWarnings, doubleSlashRegEx, DEFAULT_CONDITIONS_SET, DEFAULT_EXTENSIONS, NOT_FOUND_ERRORS;
var init_dist5 = __esm({
  "../../node_modules/.pnpm/mlly@1.7.4/node_modules/mlly/dist/index.mjs"() {
    "use strict";
    init_acorn();
    import_node_module3 = require("module");
    import_node_fs2 = __toESM(require("fs"), 1);
    init_dist2();
    init_dist();
    import_node_url = require("url");
    import_node_assert = __toESM(require("assert"), 1);
    import_node_process = __toESM(require("process"), 1);
    import_node_path3 = __toESM(require("path"), 1);
    import_node_v8 = __toESM(require("v8"), 1);
    import_node_util = require("util");
    BUILTIN_MODULES = new Set(import_node_module3.builtinModules);
    own$1 = {}.hasOwnProperty;
    classRegExp = /^([A-Z][a-z\d]*)+$/;
    kTypes = /* @__PURE__ */ new Set([
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ]);
    codes = {};
    messages = /* @__PURE__ */ new Map();
    nodeInternalPrefix = "__node_internal_";
    codes.ERR_INVALID_ARG_TYPE = createError(
      "ERR_INVALID_ARG_TYPE",
      /**
       * @param {string} name
       * @param {Array<string> | string} expected
       * @param {unknown} actual
       */
      (name, expected, actual) => {
        (0, import_node_assert.default)(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let message = "The ";
        if (name.endsWith(" argument")) {
          message += `${name} `;
        } else {
          const type = name.includes(".") ? "property" : "argument";
          message += `"${name}" ${type} `;
        }
        message += "must be ";
        const types2 = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          (0, import_node_assert.default)(
            typeof value === "string",
            "All expected entries have to be of type string"
          );
          if (kTypes.has(value)) {
            types2.push(value.toLowerCase());
          } else if (classRegExp.exec(value) === null) {
            (0, import_node_assert.default)(
              value !== "object",
              'The value "object" should be written as "Object"'
            );
            other.push(value);
          } else {
            instances.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types2.indexOf("object");
          if (pos !== -1) {
            types2.slice(pos, 1);
            instances.push("Object");
          }
        }
        if (types2.length > 0) {
          message += `${types2.length > 1 ? "one of type" : "of type"} ${formatList(
            types2,
            "or"
          )}`;
          if (instances.length > 0 || other.length > 0) message += " or ";
        }
        if (instances.length > 0) {
          message += `an instance of ${formatList(instances, "or")}`;
          if (other.length > 0) message += " or ";
        }
        if (other.length > 0) {
          if (other.length > 1) {
            message += `one of ${formatList(other, "or")}`;
          } else {
            if (other[0].toLowerCase() !== other[0]) message += "an ";
            message += `${other[0]}`;
          }
        }
        message += `. Received ${determineSpecificType(actual)}`;
        return message;
      },
      TypeError
    );
    codes.ERR_INVALID_MODULE_SPECIFIER = createError(
      "ERR_INVALID_MODULE_SPECIFIER",
      /**
       * @param {string} request
       * @param {string} reason
       * @param {string} [base]
       */
      (request, reason, base = void 0) => {
        return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
      },
      TypeError
    );
    codes.ERR_INVALID_PACKAGE_CONFIG = createError(
      "ERR_INVALID_PACKAGE_CONFIG",
      /**
       * @param {string} path
       * @param {string} [base]
       * @param {string} [message]
       */
      (path4, base, message) => {
        return `Invalid package config ${path4}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
      },
      Error
    );
    codes.ERR_INVALID_PACKAGE_TARGET = createError(
      "ERR_INVALID_PACKAGE_TARGET",
      /**
       * @param {string} packagePath
       * @param {string} key
       * @param {unknown} target
       * @param {boolean} [isImport=false]
       * @param {string} [base]
       */
      (packagePath, key, target, isImport = false, base = void 0) => {
        const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
        if (key === ".") {
          (0, import_node_assert.default)(isImport === false);
          return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
        }
        return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
          target
        )} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
      },
      Error
    );
    codes.ERR_MODULE_NOT_FOUND = createError(
      "ERR_MODULE_NOT_FOUND",
      /**
       * @param {string} path
       * @param {string} base
       * @param {boolean} [exactUrl]
       */
      (path4, base, exactUrl = false) => {
        return `Cannot find ${exactUrl ? "module" : "package"} '${path4}' imported from ${base}`;
      },
      Error
    );
    codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
      "ERR_NETWORK_IMPORT_DISALLOWED",
      "import of '%s' by %s is not supported: %s",
      Error
    );
    codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
      "ERR_PACKAGE_IMPORT_NOT_DEFINED",
      /**
       * @param {string} specifier
       * @param {string} packagePath
       * @param {string} base
       */
      (specifier, packagePath, base) => {
        return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
      },
      TypeError
    );
    codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
      "ERR_PACKAGE_PATH_NOT_EXPORTED",
      /**
       * @param {string} packagePath
       * @param {string} subpath
       * @param {string} [base]
       */
      (packagePath, subpath, base = void 0) => {
        if (subpath === ".")
          return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
        return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
      },
      Error
    );
    codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "Directory import '%s' is not supported resolving ES modules imported from %s",
      Error
    );
    codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(
      "ERR_UNSUPPORTED_RESOLVE_REQUEST",
      'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
      TypeError
    );
    codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
      "ERR_UNKNOWN_FILE_EXTENSION",
      /**
       * @param {string} extension
       * @param {string} path
       */
      (extension, path4) => {
        return `Unknown file extension "${extension}" for ${path4}`;
      },
      TypeError
    );
    codes.ERR_INVALID_ARG_VALUE = createError(
      "ERR_INVALID_ARG_VALUE",
      /**
       * @param {string} name
       * @param {unknown} value
       * @param {string} [reason='is invalid']
       */
      (name, value, reason = "is invalid") => {
        let inspected = (0, import_node_util.inspect)(value);
        if (inspected.length > 128) {
          inspected = `${inspected.slice(0, 128)}...`;
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
      // Note: extra classes have been shaken out.
      // , RangeError
    );
    captureLargerStackTrace = hideStackFrames(
      /**
       * @param {Error} error
       * @returns {Error}
       */
      // @ts-expect-error: fine
      function(error) {
        const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
        if (stackTraceLimitIsWritable) {
          userStackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = Number.POSITIVE_INFINITY;
        }
        Error.captureStackTrace(error);
        if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
        return error;
      }
    );
    hasOwnProperty$1 = {}.hasOwnProperty;
    ({ ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1 } = codes);
    cache = /* @__PURE__ */ new Map();
    ({ ERR_UNKNOWN_FILE_EXTENSION } = codes);
    hasOwnProperty2 = {}.hasOwnProperty;
    extensionFormatMap = {
      // @ts-expect-error: hush.
      __proto__: null,
      ".cjs": "commonjs",
      ".js": "module",
      ".json": "json",
      ".mjs": "module"
    };
    protocolHandlers = {
      // @ts-expect-error: hush.
      __proto__: null,
      "data:": getDataProtocolModuleFormat,
      "file:": getFileProtocolModuleFormat,
      "http:": getHttpProtocolModuleFormat,
      "https:": getHttpProtocolModuleFormat,
      "node:"() {
        return "builtin";
      }
    };
    RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
    ({
      ERR_NETWORK_IMPORT_DISALLOWED,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_PACKAGE_CONFIG,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_MODULE_NOT_FOUND,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_RESOLVE_REQUEST
    } = codes);
    own = {}.hasOwnProperty;
    invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
    deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
    invalidPackageNameRegEx = /^\.|%|\\/;
    patternRegEx = /\*/g;
    encodedSeparatorRegEx = /%2f|%5c/i;
    emittedPackageWarnings = /* @__PURE__ */ new Set();
    doubleSlashRegEx = /[/\\]{2}/;
    DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
    DEFAULT_EXTENSIONS = [".mjs", ".cjs", ".js", ".json"];
    NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
      "ERR_MODULE_NOT_FOUND",
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "MODULE_NOT_FOUND",
      "ERR_PACKAGE_PATH_NOT_EXPORTED"
    ]);
  }
});

// ../../node_modules/.pnpm/defu@6.1.4/node_modules/defu/dist/defu.mjs
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults2, namespace = ".", merger) {
  if (!isPlainObject(defaults2)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults2);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p3, c2) => _defu(p3, c2, "", merger), {})
  );
}
var defu, defuFn, defuArrayFn;
var init_defu = __esm({
  "../../node_modules/.pnpm/defu@6.1.4/node_modules/defu/dist/defu.mjs"() {
    "use strict";
    defu = createDefu();
    defuFn = createDefu((object, key, currentValue) => {
      if (object[key] !== void 0 && typeof currentValue === "function") {
        object[key] = currentValue(object[key]);
        return true;
      }
    });
    defuArrayFn = createDefu((object, key, currentValue) => {
      if (Array.isArray(object[key]) && typeof currentValue === "function") {
        object[key] = currentValue(object[key]);
        return true;
      }
    });
  }
});

// ../../node_modules/.pnpm/dotenv@16.6.1/node_modules/dotenv/package.json
var require_package = __commonJS({
  "../../node_modules/.pnpm/dotenv@16.6.1/node_modules/dotenv/package.json"(exports2, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.6.1",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      homepage: "https://github.com/motdotla/dotenv#readme",
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// ../../node_modules/.pnpm/dotenv@16.6.1/node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "../../node_modules/.pnpm/dotenv@16.6.1/node_modules/dotenv/lib/main.js"(exports2, module2) {
    "use strict";
    var fs6 = require("fs");
    var path4 = require("path");
    var os2 = require("os");
    var crypto = require("crypto");
    var packageJson = require_package();
    var version2 = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse6(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      options = options || {};
      const vaultPath = _vaultPath(options);
      options.path = vaultPath;
      const result = DotenvModule.configDotenv(options);
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i2 = 0; i2 < length; i2++) {
        try {
          const key = keys[i2].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i2 + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _warn(message) {
      console.log(`[dotenv@${version2}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version2}][DEBUG] ${message}`);
    }
    function _log(message) {
      console.log(`[dotenv@${version2}] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs6.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path4.resolve(process.cwd(), ".env.vault");
      }
      if (fs6.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path4.join(os2.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      const debug2 = Boolean(options && options.debug);
      const quiet = options && "quiet" in options ? options.quiet : true;
      if (debug2 || !quiet) {
        _log("Loading env from encrypted .env.vault");
      }
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path4.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug2 = Boolean(options && options.debug);
      const quiet = options && "quiet" in options ? options.quiet : true;
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug2) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path5 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs6.readFileSync(path5, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e3) {
          if (debug2) {
            _debug(`Failed to load ${path5} ${e3.message}`);
          }
          lastError = e3;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (debug2 || !quiet) {
        const keysCount = Object.keys(parsedAll).length;
        const shortPaths = [];
        for (const filePath of optionPaths) {
          try {
            const relative2 = path4.relative(process.cwd(), filePath);
            shortPaths.push(relative2);
          } catch (e3) {
            if (debug2) {
              _debug(`Failed to load ${filePath} ${e3.message}`);
            }
            lastError = e3;
          }
        }
        _log(`injecting env (${keysCount}) from ${shortPaths.join(",")}`);
      }
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug2 = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug2) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse: parse6,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// ../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/jsonc.mjs
var jsonc_exports = {};
__export(jsonc_exports, {
  parseJSONC: () => h4,
  stringifyJSONC: () => d2
});
var init_jsonc = __esm({
  "../../node_modules/.pnpm/confbox@0.1.8/node_modules/confbox/dist/jsonc.mjs"() {
    "use strict";
    init_confbox_f9f03f05();
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/high-level-opt.js"(exports2, module2) {
    "use strict";
    var argmap = /* @__PURE__ */ new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    module2.exports = (opt) => opt ? Object.keys(opt).map((k4) => [
      argmap.has(k4) ? argmap.get(k4) : k4,
      opt[k4]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), /* @__PURE__ */ Object.create(null)) : {};
  }
});

// ../../node_modules/.pnpm/minipass@5.0.0/node_modules/minipass/index.js
var require_minipass = __commonJS({
  "../../node_modules/.pnpm/minipass@5.0.0/node_modules/minipass/index.js"(exports2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var stringdecoder = require("string_decoder");
    var SD = stringdecoder.StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var defer = (fn2) => Promise.resolve().then(fn2);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b6) => b6 instanceof ArrayBuffer || typeof b6 === "object" && b6.constructor && b6.constructor.name === "ArrayBuffer" && b6.byteLength >= 0;
    var isArrayBufferView = (b6) => !Buffer.isBuffer(b6) && ArrayBuffer.isView(b6);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end) this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er2) => dest.emit("error", er2);
        src.on("error", this.proxyErrors);
      }
    };
    var Minipass = class _Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this[PIPES] = [];
        this[BUFFER] = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE]) this[ENCODING] = null;
        else this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer") this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
        if (options && options.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options && options.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        this[SIGNAL] = options && options.signal;
        this[ABORTED] = false;
        if (this[SIGNAL]) {
          this[SIGNAL].addEventListener("abort", () => this[ABORT]());
          if (this[SIGNAL].aborted) {
            this[ABORT]();
          }
        }
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE]) throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this[BUFFER].length)
            this[BUFFER] = this[BUFFER].map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a3) {
        this[ASYNC] = this[ASYNC] || !!a3;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL].reason);
        this.destroy(this[SIGNAL].reason);
      }
      get aborted() {
        return this[ABORTED];
      }
      set aborted(_5) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED]) return false;
        if (this[EOF]) throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit(
            "error",
            Object.assign(
              new Error("Cannot call write after a stream was destroyed"),
              { code: "ERR_STREAM_DESTROYED" }
            )
          );
          return true;
        }
        if (typeof encoding === "function") cb = encoding, encoding = "utf8";
        if (!encoding) encoding = "utf8";
        const fn2 = this[ASYNC] ? defer : (f3) => f3();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn2(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn2(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
        if (this.flowing) this.emit("data", chunk);
        else this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0) this.emit("readable");
        if (cb) fn2(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED]) return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE]) n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          if (this.encoding) this[BUFFER] = [this[BUFFER].join("")];
          else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null) this[BUFFERSHIFT]();
        else {
          this[BUFFER][0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF]) this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") cb = chunk, chunk = null;
        if (typeof encoding === "function") cb = encoding, encoding = "utf8";
        if (chunk) this.write(chunk, encoding);
        if (cb) this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED]) return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length) this[FLUSH]();
        else if (this[EOF]) this[MAYBE_EMIT_END]();
        else this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
        else this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
        else this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this.flowing;
      }
      pipe(dest, opts) {
        if (this[DESTROYED]) return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
        else opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end) dest.end();
        } else {
          this[PIPES].push(
            !opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts)
          );
          if (this[ASYNC]) defer(() => this[RESUME]());
          else this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p3 = this[PIPES].find((p4) => p4.dest === dest);
        if (p3) {
          this[PIPES].splice(this[PIPES].indexOf(p3), 1);
          p3.unpipe();
        }
      }
      addListener(ev, fn2) {
        return this.on(ev, fn2);
      }
      on(ev, fn2) {
        const ret = super.on(ev, fn2);
        if (ev === "data" && !this[PIPES].length && !this.flowing) this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC]) defer(() => fn2.call(this, this[EMITTED_ERROR]));
          else fn2.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED]) this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data2, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !this[OBJECTMODE] && !data2 ? false : this[ASYNC] ? defer(() => this[EMITDATA](data2)) : this[EMITDATA](data2);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED]) return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data2;
          super.emit(ERROR, data2);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data2) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data2, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data2) {
        for (const p3 of this[PIPES]) {
          if (p3.dest.write(data2) === false) this.pause();
        }
        const ret = super.emit("data", data2);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END]) return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC]) defer(() => this[EMITEND2]());
        else this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data2 = this[DECODER].end();
          if (data2) {
            for (const p3 of this[PIPES]) {
              p3.dest.write(data2);
            }
            super.emit("data", data2);
          }
        }
        for (const p3 of this[PIPES]) {
          p3.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE]) buf.dataLength = 0;
        const p3 = this.promise();
        this.on("data", (c2) => {
          buf.push(c2);
          if (!this[OBJECTMODE]) buf.dataLength += c2.length;
        });
        return p3.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then(
          (buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
        );
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve5, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er2) => reject(er2));
          this.on("end", () => resolve5());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          stopped = true;
          return Promise.resolve({ done: true });
        };
        const next = () => {
          if (stopped) return stop();
          const res = this.read();
          if (res !== null) return Promise.resolve({ done: false, value: res });
          if (this[EOF]) return stop();
          let resolve5 = null;
          let reject = null;
          const onerr = (er2) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            reject(er2);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            this.pause();
            resolve5({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            resolve5({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve5 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [ASYNCITERATOR]() {
            return this;
          }
        };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          this.removeListener(ERROR, stop);
          this.removeListener(DESTROYED, stop);
          this.removeListener("end", stop);
          stopped = true;
          return { done: true };
        };
        const next = () => {
          if (stopped) return stop();
          const value = this.read();
          return value === null ? stop() : { value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [ITERATOR]() {
            return this;
          }
        };
      }
      destroy(er2) {
        if (this[DESTROYED]) {
          if (er2) this.emit("error", er2);
          else this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED]) this.close();
        if (er2) this.emit("error", er2);
        else this.emit(DESTROYED);
        return this;
      }
      static isStream(s4) {
        return !!s4 && (s4 instanceof _Minipass || s4 instanceof Stream || s4 instanceof EE && // readable
        (typeof s4.pipe === "function" || // writable
        typeof s4.write === "function" && typeof s4.end === "function"));
      }
    };
    exports2.Minipass = Minipass;
  }
});

// ../../node_modules/.pnpm/minizlib@2.1.2/node_modules/minizlib/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/minizlib@2.1.2/node_modules/minizlib/constants.js"(exports2, module2) {
    "use strict";
    var realZlibConstants = require("zlib").constants || /* istanbul ignore next */
    { ZLIB_VERNUM: 4736 };
    module2.exports = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// ../../node_modules/.pnpm/minipass@3.3.6/node_modules/minipass/index.js
var require_minipass2 = __commonJS({
  "../../node_modules/.pnpm/minipass@3.3.6/node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn2) => Promise.resolve().then(fn2);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b6) => b6 instanceof ArrayBuffer || typeof b6 === "object" && b6.constructor && b6.constructor.name === "ArrayBuffer" && b6.byteLength >= 0;
    var isArrayBufferView = (b6) => !Buffer.isBuffer(b6) && ArrayBuffer.isView(b6);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er2) => dest.emit("error", er2);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a3) {
        this[ASYNC] = this[ASYNC] || !!a3;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn2 = this[ASYNC] ? defer : (f3) => f3();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn2(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn2(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn2(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p3 = this.pipes.find((p4) => p4.dest === dest);
        if (p3) {
          this.pipes.splice(this.pipes.indexOf(p3), 1);
          p3.unpipe();
        }
      }
      addListener(ev, fn2) {
        return this.on(ev, fn2);
      }
      on(ev, fn2) {
        const ret = super.on(ev, fn2);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn2.call(this, this[EMITTED_ERROR]));
          else
            fn2.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data2, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data2 ? false : this[ASYNC] ? defer(() => this[EMITDATA](data2)) : this[EMITDATA](data2);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data2;
          const ret2 = super.emit("error", data2);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data2, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data2) {
        for (const p3 of this.pipes) {
          if (p3.dest.write(data2) === false)
            this.pause();
        }
        const ret = super.emit("data", data2);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data2 = this[DECODER].end();
          if (data2) {
            for (const p3 of this.pipes) {
              p3.dest.write(data2);
            }
            super.emit("data", data2);
          }
        }
        for (const p3 of this.pipes) {
          p3.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p3 = this.promise();
        this.on("data", (c2) => {
          buf.push(c2);
          if (!this[OBJECTMODE])
            buf.dataLength += c2.length;
        });
        return p3.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve5, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er2) => reject(er2));
          this.on("end", () => resolve5());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve5 = null;
          let reject = null;
          const onerr = (er2) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er2);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve5({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve5({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve5 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er2) {
        if (this[DESTROYED]) {
          if (er2)
            this.emit("error", er2);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er2)
          this.emit("error", er2);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s4) {
        return !!s4 && (s4 instanceof Minipass || s4 instanceof Stream || s4 instanceof EE && (typeof s4.pipe === "function" || // readable
        typeof s4.write === "function" && typeof s4.end === "function"));
      }
    };
  }
});

// ../../node_modules/.pnpm/minizlib@2.1.2/node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "../../node_modules/.pnpm/minizlib@2.1.2/node_modules/minizlib/index.js"(exports2) {
    "use strict";
    var assert2 = require("assert");
    var Buffer2 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants = exports2.constants = require_constants();
    var Minipass = require_minipass2();
    var OriginalBufferConcat = Buffer2.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er2) {
          throw new ZlibError(er2);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er2) => this[_onError](new ZlibError(er2)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert2(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer2.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer2.from(chunk, encoding);
        if (this[_sawError])
          return;
        assert2(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer2.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer2.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer2.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er2) => this[_onError](new ZlibError(er2)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer2.from(result[0]));
            for (let i2 = 1; i2 < result.length; i2++) {
              writeReturn = this[_superWrite](result[i2]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer2.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data2) {
        return super.write(data2);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants.Z_SYNC_FLUSH);
          assert2(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data2) {
        if (!this[_portable])
          return super[_superWrite](data2);
        this[_portable] = false;
        data2[9] = 255;
        return super[_superWrite](data2);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports2.Deflate = Deflate;
    exports2.Inflate = Inflate;
    exports2.Gzip = Gzip;
    exports2.Gunzip = Gunzip;
    exports2.DeflateRaw = DeflateRaw;
    exports2.InflateRaw = InflateRaw;
    exports2.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports2.BrotliCompress = BrotliCompress;
      exports2.BrotliDecompress = BrotliDecompress;
    } else {
      exports2.BrotliCompress = exports2.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/normalize-windows-path.js"(exports2, module2) {
    "use strict";
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    module2.exports = platform !== "win32" ? (p3) => p3 : (p3) => p3 && p3.replace(/\\/g, "/");
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/read-entry.js"(exports2, module2) {
    "use strict";
    var { Minipass } = require_minipass();
    var normPath = require_normalize_windows_path();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends Minipass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          // NOTE: gnutar and bsdtar treat unrecognized types as 'File'
          // it may be worth doing the same, but with a warning.
          default:
            this.ignore = true;
        }
        this.path = normPath(header.path);
        this.mode = header.mode;
        if (this.mode) {
          this.mode = this.mode & 4095;
        }
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = normPath(header.linkpath);
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex) {
          this[SLURP](ex);
        }
        if (gex) {
          this[SLURP](gex, true);
        }
      }
      write(data2) {
        const writeLen = data2.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        const r6 = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r6 - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore) {
          return true;
        }
        if (r6 >= writeLen) {
          return super.write(data2);
        }
        return super.write(data2.slice(0, r6));
      }
      [SLURP](ex, global2) {
        for (const k4 in ex) {
          if (ex[k4] !== null && ex[k4] !== void 0 && !(global2 && k4 === "path")) {
            this[k4] = k4 === "path" || k4 === "linkpath" ? normPath(ex[k4]) : ex[k4];
          }
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/types.js"(exports2) {
    "use strict";
    exports2.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      // same as File
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      // Devices and FIFOs aren't fully supported
      // they are parsed, but skipped when unpacking
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      // same as File
      ["7", "ContiguousFile"],
      // pax headers
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      // vendor-specific stuff
      // skip
      ["A", "SolarisACL"],
      // like 5, but with data, which should be skipped
      ["D", "GNUDumpDir"],
      // metadata only, skip
      ["I", "Inode"],
      // data = link path of next file
      ["K", "NextFileHasLongLinkpath"],
      // data = path of next file
      ["L", "NextFileHasLongPath"],
      // skip
      ["M", "ContinuationFile"],
      // like L
      ["N", "OldGnuLongPath"],
      // skip
      ["S", "SparseFile"],
      // skip
      ["V", "TapeVolumeHeader"],
      // like x
      ["X", "OldExtendedHeader"]
    ]);
    exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/large-numbers.js"(exports2, module2) {
    "use strict";
    var encode = (num, buf) => {
      if (!Number.isSafeInteger(num)) {
        throw Error("cannot encode number outside of javascript safe integer range");
      } else if (num < 0) {
        encodeNegative(num, buf);
      } else {
        encodePositive(num, buf);
      }
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i2 = buf.length; i2 > 1; i2--) {
        buf[i2 - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i2 = buf.length; i2 > 1; i2--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped) {
          buf[i2 - 1] = onesComp(byte);
        } else if (byte === 0) {
          buf[i2 - 1] = 0;
        } else {
          flipped = true;
          buf[i2 - 1] = twosComp(byte);
        }
      }
    };
    var parse6 = (buf) => {
      const pre = buf[0];
      const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
      if (value === null) {
        throw Error("invalid base256 encoding");
      }
      if (!Number.isSafeInteger(value)) {
        throw Error("parsed number outside of javascript safe integer range");
      }
      return value;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i2 = len - 1; i2 > -1; i2--) {
        var byte = buf[i2];
        var f3;
        if (flipped) {
          f3 = onesComp(byte);
        } else if (byte === 0) {
          f3 = byte;
        } else {
          flipped = true;
          f3 = twosComp(byte);
        }
        if (f3 !== 0) {
          sum -= f3 * Math.pow(256, len - i2 - 1);
        }
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i2 = len - 1; i2 > -1; i2--) {
        var byte = buf[i2];
        if (byte !== 0) {
          sum += byte * Math.pow(256, len - i2 - 1);
        }
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
    module2.exports = {
      encode,
      parse: parse6
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/header.js
var require_header = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/header.js"(exports2, module2) {
    "use strict";
    var types2 = require_types();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data2, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data2)) {
          this.decode(data2, off || 0, ex, gex);
        } else if (data2) {
          this.set(data2);
        }
      }
      decode(buf, off, ex, gex) {
        if (!off) {
          off = 0;
        }
        if (!buf || !(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "") {
          this[TYPE] = "0";
        }
        if (this[TYPE] === "0" && this.path.slice(-1) === "/") {
          this[TYPE] = "5";
        }
        if (this[TYPE] === "5") {
          this.size = 0;
        }
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix) {
              this.path = prefix + "/" + this.path;
            }
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i2 = off; i2 < off + 148; i2++) {
          sum += buf[i2];
        }
        for (let i2 = off + 156; i2 < off + 512; i2++) {
          sum += buf[i2];
        }
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32) {
          this.nullBlock = true;
        }
      }
      [SLURP](ex, global2) {
        for (const k4 in ex) {
          if (ex[k4] !== null && ex[k4] !== void 0 && !(global2 && k4 === "path")) {
            this[k4] = ex[k4];
          }
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off) {
          off = 0;
        }
        if (!(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split = splitPrefix(this.path || "", prefixSize);
        const path4 = split[0];
        const prefix = split[1];
        this.needPax = split[2];
        this.needPax = encString(buf, off, 100, path4) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0) {
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        } else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i2 = off; i2 < off + 148; i2++) {
          sum += buf[i2];
        }
        for (let i2 = off + 156; i2 < off + 512; i2++) {
          sum += buf[i2];
        }
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data2) {
        for (const i2 in data2) {
          if (data2[i2] !== null && data2[i2] !== void 0) {
            this[i2] = data2[i2];
          }
        }
      }
      get type() {
        return types2.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types2.code.has(type)) {
          this[TYPE] = types2.code.get(type);
        } else {
          this[TYPE] = type;
        }
      }
    };
    var splitPrefix = (p3, prefixSize) => {
      const pathSize = 100;
      let pp2 = p3;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p3).root || ".";
      if (Buffer.byteLength(pp2) < pathSize) {
        ret = [pp2, prefix, false];
      } else {
        prefix = pathModule.dirname(pp2);
        pp2 = pathModule.basename(pp2);
        do {
          if (Buffer.byteLength(pp2) <= pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp2, prefix, false];
          } else if (Buffer.byteLength(pp2) > pathSize && Buffer.byteLength(prefix) <= prefixSize) {
            ret = [pp2.slice(0, pathSize - 1), prefix, true];
          } else {
            pp2 = pathModule.join(pathModule.basename(prefix), pp2);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret) {
          ret = [p3.slice(0, pathSize - 1), "", true];
        }
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value) => isNaN(value) ? null : value;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(
      buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(),
      8
    ));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number) => number === null ? false : number > MAXNUM[size] || number < 0 ? (large.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);
    var encSmallNumber = (buf, off, size, number) => buf.write(octalString(number, size), off, size, "ascii");
    var octalString = (number, size) => padOctal(Math.floor(number).toString(8), size);
    var padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string) => string === null ? false : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
    module2.exports = Header;
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/pax.js"(exports2, module2) {
    "use strict";
    var Header = require_header();
    var path4 = require("path");
    var Pax = class {
      constructor(obj, global2) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global2 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "") {
          return null;
        }
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i2 = 0; i2 < 512; i2++) {
          buf[i2] = 0;
        }
        new Header({
          // XXX split the path
          // then the path should be PaxHeader + basename, but less than 99,
          // prepend with the dirname
          path: ("PaxHeader/" + path4.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i2 = bodyLen + 512; i2 < buf.length; i2++) {
          buf[i2] = 0;
        }
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0) {
          return "";
        }
        const v4 = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s4 = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v4 + "\n";
        const byteLen = Buffer.byteLength(s4);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits)) {
          digits += 1;
        }
        const len = digits + byteLen;
        return len + s4;
      }
    };
    Pax.parse = (string, ex, g4) => new Pax(merge(parseKV(string), ex), g4);
    var merge = (a3, b6) => b6 ? Object.keys(a3).reduce((s4, k4) => (s4[k4] = a3[k4], s4), b6) : a3;
    var parseKV = (string) => string.replace(/\n$/, "").split("\n").reduce(parseKVLine, /* @__PURE__ */ Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1) {
        return set;
      }
      line = line.slice((n + " ").length);
      const kv = line.split("=");
      const k4 = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k4) {
        return set;
      }
      const v4 = kv.join("=");
      set[k4] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k4) ? new Date(v4 * 1e3) : /^[0-9]+$/.test(v4) ? +v4 : v4;
      return set;
    };
    module2.exports = Pax;
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/strip-trailing-slashes.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => {
      let i2 = str.length - 1;
      let slashesStart = -1;
      while (i2 > -1 && str.charAt(i2) === "/") {
        slashesStart = i2;
        i2--;
      }
      return slashesStart === -1 ? str : str.slice(0, slashesStart);
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/warn-mixin.js"(exports2, module2) {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data2 = {}) {
        if (this.file) {
          data2.file = this.file;
        }
        if (this.cwd) {
          data2.cwd = this.cwd;
        }
        data2.code = message instanceof Error && message.code || code;
        data2.tarCode = code;
        if (!this.strict && data2.recoverable !== false) {
          if (message instanceof Error) {
            data2 = Object.assign(message, data2);
            message = message.message;
          }
          this.emit("warn", data2.tarCode, message, data2);
        } else if (message instanceof Error) {
          this.emit("error", Object.assign(message, data2));
        } else {
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data2));
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/winchars.js"(exports2, module2) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i2) => [char, win[i2]]));
    var toRaw = new Map(win.map((char, i2) => [char, raw[i2]]));
    module2.exports = {
      encode: (s4) => raw.reduce((s5, c2) => s5.split(c2).join(toWin.get(c2)), s4),
      decode: (s4) => win.reduce((s5, c2) => s5.split(c2).join(toRaw.get(c2)), s4)
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/strip-absolute-path.js"(exports2, module2) {
    "use strict";
    var { isAbsolute: isAbsolute2, parse: parse6 } = require("path").win32;
    module2.exports = (path4) => {
      let r6 = "";
      let parsed = parse6(path4);
      while (isAbsolute2(path4) || parsed.root) {
        const root = path4.charAt(0) === "/" && path4.slice(0, 4) !== "//?/" ? "/" : parsed.root;
        path4 = path4.slice(root.length);
        r6 += root;
        parsed = parse6(path4);
      }
      return [r6, path4];
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/mode-fix.js"(exports2, module2) {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable) {
        mode = (mode | 384) & ~18;
      }
      if (isDir) {
        if (mode & 256) {
          mode |= 64;
        }
        if (mode & 32) {
          mode |= 8;
        }
        if (mode & 4) {
          mode |= 1;
        }
      }
      return mode;
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/write-entry.js"(exports2, module2) {
    "use strict";
    var { Minipass } = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var fs6 = require("fs");
    var path4 = require("path");
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var prefixPath = (path5, prefix) => {
      if (!prefix) {
        return normPath(path5);
      }
      path5 = normPath(path5).replace(/^\.(\/|$)/, "");
      return stripSlash(prefix) + "/" + path5;
    };
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var AWAITDRAIN = Symbol("awaitDrain");
    var ONDRAIN = Symbol("ondrain");
    var PREFIX = Symbol("prefix");
    var HAD_ERROR = Symbol("hadError");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var stripAbsolutePath = require_strip_absolute_path();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends Minipass {
      constructor(p3, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p3 !== "string") {
          throw new TypeError("path is required");
        }
        this.path = normPath(p3);
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid() || 0;
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.prefix = opt.prefix ? normPath(opt.prefix) : null;
        this.fd = null;
        this.blockLen = null;
        this.blockRemain = null;
        this.buf = null;
        this.offset = null;
        this.length = null;
        this.pos = null;
        this.remain = null;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p3 = p3.replace(/\\/g, "/");
        }
        this.absolute = normPath(opt.absolute || path4.resolve(this.cwd, p3));
        if (this.path === "") {
          this.path = "./";
        }
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute)) {
          this[ONLSTAT](this.statCache.get(this.absolute));
        } else {
          this[LSTAT]();
        }
      }
      emit(ev, ...data2) {
        if (ev === "error") {
          this[HAD_ERROR] = true;
        }
        return super.emit(ev, ...data2);
      }
      [LSTAT]() {
        fs6.lstat(this.absolute, (er2, stat) => {
          if (er2) {
            return this.emit("error", er2);
          }
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile()) {
          stat.size = 0;
        }
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          // unsupported types are ignored.
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [PREFIX](path5) {
        return prefixPath(path5, this.prefix);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.header = new Header({
          path: this[PREFIX](this.path),
          // only apply the prefix to hard links.
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        }
        super.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.slice(-1) !== "/") {
          this.path += "/";
        }
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs6.readlink(this.absolute, (er2, linkpath) => {
          if (er2) {
            return this.emit("error", er2);
          }
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = normPath(linkpath);
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = normPath(path4.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0) {
              return this[HARDLINK](linkpath);
            }
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0) {
          return this.end();
        }
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs6.open(this.absolute, "r", (er2, fd) => {
          if (er2) {
            return this.emit("error", er2);
          }
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        this.fd = fd;
        if (this[HAD_ERROR]) {
          return this[CLOSE]();
        }
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
      }
      [READ]() {
        const { fd, buf, offset: offset2, length, pos } = this;
        fs6.read(fd, buf, offset2, length, pos, (er2, bytesRead) => {
          if (er2) {
            return this[CLOSE](() => this.emit("error", er2));
          }
          this[ONREAD](bytesRead);
        });
      }
      [CLOSE](cb) {
        fs6.close(this.fd, cb);
      }
      [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
          const er2 = new Error("encountered unexpected EOF");
          er2.path = this.absolute;
          er2.syscall = "read";
          er2.code = "EOF";
          return this[CLOSE](() => this.emit("error", er2));
        }
        if (bytesRead > this.remain) {
          const er2 = new Error("did not encounter expected EOF");
          er2.path = this.absolute;
          er2.syscall = "read";
          er2.code = "EOF";
          return this[CLOSE](() => this.emit("error", er2));
        }
        if (bytesRead === this.remain) {
          for (let i2 = bytesRead; i2 < this.length && bytesRead < this.blockRemain; i2++) {
            this.buf[i2 + this.offset] = 0;
            bytesRead++;
            this.remain++;
          }
        }
        const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
        const flushed = this.write(writeBuf);
        if (!flushed) {
          this[AWAITDRAIN](() => this[ONDRAIN]());
        } else {
          this[ONDRAIN]();
        }
      }
      [AWAITDRAIN](cb) {
        this.once("drain", cb);
      }
      write(writeBuf) {
        if (this.blockRemain < writeBuf.length) {
          const er2 = new Error("writing more data than expected");
          er2.path = this.absolute;
          return this.emit("error", er2);
        }
        this.remain -= writeBuf.length;
        this.blockRemain -= writeBuf.length;
        this.pos += writeBuf.length;
        this.offset += writeBuf.length;
        return super.write(writeBuf);
      }
      [ONDRAIN]() {
        if (!this.remain) {
          if (this.blockRemain) {
            super.write(Buffer.alloc(this.blockRemain));
          }
          return this[CLOSE]((er2) => er2 ? this.emit("error", er2) : this.end());
        }
        if (this.offset >= this.length) {
          this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
          this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      [LSTAT]() {
        this[ONLSTAT](fs6.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs6.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs6.openSync(this.absolute, "r"));
      }
      [READ]() {
        let threw = true;
        try {
          const { fd, buf, offset: offset2, length, pos } = this;
          const bytesRead = fs6.readSync(fd, buf, offset2, length, pos);
          this[ONREAD](bytesRead);
          threw = false;
        } finally {
          if (threw) {
            try {
              this[CLOSE](() => {
              });
            } catch (er2) {
            }
          }
        }
      }
      [AWAITDRAIN](cb) {
        cb();
      }
      [CLOSE](cb) {
        fs6.closeSync(this.fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends Minipass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.prefix = opt.prefix || null;
        this.path = normPath(readEntry.path);
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = normPath(readEntry.linkpath);
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        }
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [PREFIX](path5) {
        return prefixPath(path5, this.prefix);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data2) {
        const writeLen = data2.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        this.blockRemain -= writeLen;
        return super.write(data2);
      }
      end() {
        if (this.blockRemain) {
          super.write(Buffer.alloc(this.blockRemain));
        }
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  }
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node3;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i2 = 0, l3 = arguments.length; i2 < l3; i2++) {
          self2.push(arguments[i2]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i2 = 0, l3 = arguments.length; i2 < l3; i2++) {
        push(this, arguments[i2]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i2 = 0, l3 = arguments.length; i2 < l3; i2++) {
        unshift(this, arguments[i2]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i2 = 0; walker !== null; i2++) {
        fn2.call(thisp, walker.value, i2, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
        fn2.call(thisp, walker.value, i2, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i2 = 0, walker = this.head; walker !== null && i2 < n; i2++) {
        walker = walker.next;
      }
      if (i2 === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i2 = 0, walker = this.tail; walker !== null && i2 < n; i2++) {
        walker = walker.prev;
      }
      if (i2 === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn2, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i2 = 0; walker !== null; i2++) {
        acc = fn2(acc, walker.value, i2);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn2, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i2 = this.length - 1; walker !== null; i2--) {
        acc = fn2(acc, walker.value, i2);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i2 = 0, walker = this.head; walker !== null; i2++) {
        arr[i2] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
        arr[i2] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i2 = 0, walker = this.head; walker !== null && i2 < from; i2++) {
        walker = walker.next;
      }
      for (; walker !== null && i2 < to; i2++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
        walker = walker.prev;
      }
      for (; walker !== null && i2 > from; i2--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i2 = 0, walker = this.head; walker !== null && i2 < start; i2++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i2 = 0; walker && i2 < deleteCount; i2++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i2 = 0; i2 < nodes.length; i2++) {
        walker = insert(this, walker, nodes[i2]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p3 = walker.prev;
        walker.prev = walker.next;
        walker.next = p3;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node3(value, null, node, self2) : new Node3(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node3(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node3(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node3(value, prev, next, list) {
      if (!(this instanceof Node3)) {
        return new Node3(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er2) {
    }
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/pack.js"(exports2, module2) {
    "use strict";
    var PackJob = class {
      constructor(path5, absolute) {
        this.path = path5 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var { Minipass } = require_minipass();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs6 = require("fs");
    var path4 = require("path");
    var warner = require_warn_mixin();
    var normPath = require_normalize_windows_path();
    var Pack = warner(class Pack extends Minipass {
      constructor(opt) {
        super(opt);
        opt = opt || /* @__PURE__ */ Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normPath(opt.prefix || "");
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip || opt.brotli) {
          if (opt.gzip && opt.brotli) {
            throw new TypeError("gzip and brotli are mutually exclusive");
          }
          if (opt.gzip) {
            if (typeof opt.gzip !== "object") {
              opt.gzip = {};
            }
            if (this.portable) {
              opt.gzip.portable = true;
            }
            this.zip = new zlib.Gzip(opt.gzip);
          }
          if (opt.brotli) {
            if (typeof opt.brotli !== "object") {
              opt.brotli = {};
            }
            this.zip = new zlib.BrotliCompress(opt.brotli);
          }
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_5) => super.end());
          this.zip.on("drain", (_5) => this[ONDRAIN]());
          this.on("resume", (_5) => this.zip.resume());
        } else {
          this.on("drain", this[ONDRAIN]);
        }
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_5) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path5) {
        this.write(path5);
        return this;
      }
      end(path5) {
        if (path5) {
          this.write(path5);
        }
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path5) {
        if (this[ENDED]) {
          throw new Error("write after end");
        }
        if (path5 instanceof ReadEntry) {
          this[ADDTARENTRY](path5);
        } else {
          this[ADDFSENTRY](path5);
        }
        return this.flowing;
      }
      [ADDTARENTRY](p3) {
        const absolute = normPath(path4.resolve(this.cwd, p3.path));
        if (!this.filter(p3.path, p3)) {
          p3.resume();
        } else {
          const job = new PackJob(p3.path, absolute, false);
          job.entry = new WriteEntryTar(p3, this[ENTRYOPT](job));
          job.entry.on("end", (_5) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p3) {
        const absolute = normPath(path4.resolve(this.cwd, p3));
        this[QUEUE].push(new PackJob(p3, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs6[stat](job.absolute, (er2, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er2) {
            this.emit("error", er2);
          } else {
            this[ONSTAT](job, stat2);
          }
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat)) {
          job.ignore = true;
        }
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs6.readdir(job.absolute, (er2, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er2) {
            return this.emit("error", er2);
          }
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING]) {
          return;
        }
        this[PROCESSING] = true;
        for (let w5 = this[QUEUE].head; w5 !== null && this[JOBS] < this.jobs; w5 = w5.next) {
          this[PROCESSJOB](w5.value);
          if (w5.value.ignore) {
            const p3 = w5.next;
            this[QUEUE].removeNode(w5);
            w5.next = p3;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip) {
            this.zip.end(EOF);
          } else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending) {
          return;
        }
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped) {
            this[PIPE](job);
          }
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute)) {
            this[ONSTAT](job, this.statCache.get(job.absolute));
          } else {
            this[STAT](job);
          }
        }
        if (!job.stat) {
          return;
        }
        if (job.ignore) {
          return;
        }
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute)) {
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          } else {
            this[READDIR](job);
          }
          if (!job.readdir) {
            return;
          }
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped) {
          this[PIPE](job);
        }
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data2) => this.warn(code, msg, data2),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime,
          prefix: this.prefix
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er2) => this.emit("error", er2));
        } catch (er2) {
          this.emit("error", er2);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry) {
          this[CURRENT].entry.resume();
        }
      }
      // like .pipe() but using super, because our write() is special
      [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p3 = job.path;
            const base = p3 === "./" ? "" : p3.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        const source = job.entry;
        const zip = this.zip;
        if (zip) {
          source.on("data", (chunk) => {
            if (!zip.write(chunk)) {
              source.pause();
            }
          });
        } else {
          source.on("data", (chunk) => {
            if (!super.write(chunk)) {
              source.pause();
            }
          });
        }
      }
      pause() {
        if (this.zip) {
          this.zip.pause();
        }
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      // pause/resume are no-ops in sync streams.
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs6[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs6.readdirSync(job.absolute));
      }
      // gotta get it all in this tick
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p3 = job.path;
            const base = p3 === "./" ? "" : p3.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        if (zip) {
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        } else {
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
        }
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  }
});

// ../../node_modules/.pnpm/fs-minipass@2.1.0/node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "../../node_modules/.pnpm/fs-minipass@2.1.0/node_modules/fs-minipass/index.js"(exports2) {
    "use strict";
    var MiniPass = require_minipass2();
    var EE = require("events").EventEmitter;
    var fs6 = require("fs");
    var writev = fs6.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er2, bw) => cb(er2, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path4, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path4 !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path4;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs6.open(this[_path], "r", (er2, fd) => this[_onopen](er2, fd));
      }
      [_onopen](er2, fd) {
        if (er2)
          this[_onerror](er2);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs6.read(this[_fd], buf, 0, buf.length, null, (er2, br, buf2) => this[_onread](er2, br, buf2));
        }
      }
      [_onread](er2, br, buf) {
        this[_reading] = false;
        if (er2)
          this[_onerror](er2);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs6.close(fd, (er2) => er2 ? this.emit("error", er2) : this.emit("close"));
        }
      }
      [_onerror](er2) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er2);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data2) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data2);
          default:
            return super.emit(ev, data2);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs6.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs6.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs6.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path4, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path4;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data2) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data2);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er2) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er2);
      }
      [_open]() {
        fs6.open(
          this[_path],
          this[_flags],
          this[_mode],
          (er2, fd) => this[_onopen](er2, fd)
        );
      }
      [_onopen](er2, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er2 && er2.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er2)
          this[_onerror](er2);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs6.write(this[_fd], buf, 0, buf.length, this[_pos], (er2, bw) => this[_onwrite](er2, bw));
      }
      [_onwrite](er2, bw) {
        if (er2)
          this[_onerror](er2);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(
            this[_fd],
            iovec,
            this[_pos],
            (er2, bw) => this[_onwrite](er2, bw)
          );
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs6.close(fd, (er2) => er2 ? this.emit("error", er2) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs6.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er2) {
            if (er2.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er2;
          }
        } else
          fd = fs6.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs6.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](
            null,
            fs6.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
          );
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_5) {
            }
        }
      }
    };
    exports2.ReadStream = ReadStream;
    exports2.ReadStreamSync = ReadStreamSync;
    exports2.WriteStream = WriteStream;
    exports2.WriteStreamSync = WriteStreamSync;
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/parse.js"(exports2, module2) {
    "use strict";
    var warner = require_warn_mixin();
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var { nextTick } = require("process");
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var CLOSESTREAM = Symbol("closeStream");
    var noop = (_5) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_5) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone) {
          this.on(DONE, opt.ondone);
        } else {
          this.on(DONE, (_5) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
          });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        const isTBR = opt.file && (opt.file.endsWith(".tar.br") || opt.file.endsWith(".tbr"));
        this.brotli = !opt.gzip && opt.brotli !== void 0 ? opt.brotli : isTBR ? void 0 : false;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        this.on("end", () => this[CLOSESTREAM]());
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        if (typeof opt.onentry === "function") {
          this.on("entry", opt.onentry);
        }
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null) {
          this[SAW_VALID_ENTRY] = false;
        }
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er2) {
          return this.warn("TAR_ENTRY_INVALID", er2);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin") {
              this[STATE] = "header";
            }
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid) {
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          } else if (!header.path) {
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          } else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            } else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid) {
                      this[SAW_VALID_ENTRY] = true;
                    }
                  };
                  entry.on("end", onend);
                } else {
                  this[SAW_VALID_ENTRY] = true;
                }
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c2) => this[META] += c2);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain) {
                    this[STATE] = "body";
                  } else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else {
                    this[QUEUE].push(entry);
                  }
                }
              }
            }
          }
        }
      }
      [CLOSESTREAM]() {
        nextTick(() => this.emit("close"));
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry)) {
          this.emit.apply(this, entry);
        } else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_5) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re3 = this[READENTRY];
          const drainNow = !re3 || re3.flowing || re3.size === re3.remain;
          if (drainNow) {
            if (!this[WRITING]) {
              this.emit("drain");
            }
          } else {
            re3.once("drain", (_5) => this.emit("drain"));
          }
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c2 = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c2);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c2.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY]) {
          this[EMITMETA](entry);
        }
        return ret;
      }
      [EMIT](ev, data2, extra) {
        if (!this[QUEUE].length && !this[READENTRY]) {
          this.emit(ev, data2, extra);
        } else {
          this[QUEUE].push([ev, data2, extra]);
        }
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          /* istanbul ignore next */
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED]) {
          return;
        }
        const needSniff = this[UNZIP] === null || this.brotli === void 0 && this[UNZIP] === false;
        if (needSniff && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i2 = 0; this[UNZIP] === null && i2 < gzipHeader.length; i2++) {
            if (chunk[i2] !== gzipHeader[i2]) {
              this[UNZIP] = false;
            }
          }
          const maybeBrotli = this.brotli === void 0;
          if (this[UNZIP] === false && maybeBrotli) {
            if (chunk.length < 512) {
              if (this[ENDED]) {
                this.brotli = true;
              } else {
                this[BUFFER] = chunk;
                return true;
              }
            } else {
              try {
                new Header(chunk.slice(0, 512));
                this.brotli = false;
              } catch (_5) {
                this.brotli = true;
              }
            }
          }
          if (this[UNZIP] === null || this[UNZIP] === false && this.brotli) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = this[UNZIP] === null ? new zlib.Unzip() : new zlib.BrotliDecompress();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er2) => this.abort(er2));
            this[UNZIP].on("end", (_5) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP]) {
          this[UNZIP].write(chunk);
        } else {
          this[CONSUMECHUNK](chunk);
        }
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length) {
          this[READENTRY].once("drain", (_5) => this.emit("drain"));
        }
        return ret;
      }
      [BUFFERCONCAT](c2) {
        if (c2 && !this[ABORTED]) {
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c2]) : c2;
        }
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER]) {
              entry.write(this[BUFFER]);
            }
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING]) {
          this[BUFFERCONCAT](chunk);
        } else if (!chunk && !this[BUFFER]) {
          this[MAYBEEND]();
        } else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c2 = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c2);
          } else {
            this[CONSUMECHUNKSUB](chunk);
          }
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c2 = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c2);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED]) {
          this[MAYBEEND]();
        }
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        const length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            /* istanbul ignore next */
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER]) {
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          } else {
            this[BUFFER] = chunk.slice(position);
          }
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP]) {
            this[UNZIP].end(chunk);
          } else {
            this[ENDED] = true;
            if (this.brotli === void 0) chunk = chunk || Buffer.alloc(0);
            this.write(chunk);
          }
        }
      }
    });
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/list.js
var require_list = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/list.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser3 = require_parse();
    var fs6 = require("fs");
    var fsm = require_fs_minipass();
    var path4 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      if (!opt.noResume) {
        onentryFunction(opt);
      }
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e3) => {
        onentry(e3);
        e3.resume();
      } : (e3) => e3.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f3) => [stripSlash(f3), true]));
      const filter = opt.filter;
      const mapHas = (file, r6) => {
        const root = r6 || path4.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path4.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var listFileSync = (opt) => {
      const p3 = list(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs6.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize) {
          p3.end(fs6.readFileSync(file));
        } else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs6.openSync(file, "r");
          while (pos < stat.size) {
            const bytesRead = fs6.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p3.write(buf.slice(0, bytesRead));
          }
          p3.end();
        }
        threw = false;
      } finally {
        if (threw && fd) {
          try {
            fs6.closeSync(fd);
          } catch (er2) {
          }
        }
      }
    };
    var listFile = (opt, cb) => {
      const parse6 = new Parser3(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p3 = new Promise((resolve5, reject) => {
        parse6.on("error", reject);
        parse6.on("end", resolve5);
        fs6.stat(file, (er2, stat) => {
          if (er2) {
            reject(er2);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse6);
          }
        });
      });
      return cb ? p3.then(cb, cb) : p3;
    };
    var list = (opt) => new Parser3(opt);
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/create.js
var require_create = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/create.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fsm = require_fs_minipass();
    var t2 = require_list();
    var path4 = require("path");
    module2.exports = (opt_, files, cb) => {
      if (typeof files === "function") {
        cb = files;
      }
      if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p3 = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p3.pipe(stream);
      addFilesSync(p3, files);
    };
    var createFile = (opt, files, cb) => {
      const p3 = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p3.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p3.on("error", rej);
      });
      addFilesAsync(p3, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p3, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t2({
            file: path4.resolve(p3.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p3.add(entry)
          });
        } else {
          p3.add(file);
        }
      });
      p3.end();
    };
    var addFilesAsync = (p3, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t2({
            file: path4.resolve(p3.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p3.add(entry)
          }).then((_5) => addFilesAsync(p3, files));
        } else {
          p3.add(file);
        }
      }
      p3.end();
    };
    var createSync = (opt, files) => {
      const p3 = new Pack.Sync(opt);
      addFilesSync(p3, files);
      return p3;
    };
    var create = (opt, files) => {
      const p3 = new Pack(opt);
      addFilesAsync(p3, files);
      return p3;
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/replace.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs6 = require("fs");
    var fsm = require_fs_minipass();
    var t2 = require_list();
    var path4 = require("path");
    var Header = require_header();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p3 = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs6.openSync(opt.file, "r+");
        } catch (er2) {
          if (er2.code === "ENOENT") {
            fd = fs6.openSync(opt.file, "w+");
          } else {
            throw er2;
          }
        }
        const st = fs6.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION: for (position = 0; position < st.size; position += 512) {
          for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
            bytes = fs6.readSync(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position + bufPos
            );
            if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
              throw new Error("cannot append to compressed archives");
            }
            if (!bytes) {
              break POSITION;
            }
          }
          const h8 = new Header(headBuf);
          if (!h8.cksumValid) {
            break;
          }
          const entryBlockSize = 512 * Math.ceil(h8.size / 512);
          if (position + entryBlockSize + 512 > st.size) {
            break;
          }
          position += entryBlockSize;
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h8.path, h8.mtime);
          }
        }
        threw = false;
        streamSync(opt, p3, position, fd, files);
      } finally {
        if (threw) {
          try {
            fs6.closeSync(fd);
          } catch (er2) {
          }
        }
      }
    };
    var streamSync = (opt, p3, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p3.pipe(stream);
      addFilesSync(p3, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p3 = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er2, pos) => {
          if (er2) {
            fs6.close(fd, (_5) => cb_(er2));
          } else {
            cb_(null, pos);
          }
        };
        let position = 0;
        if (size === 0) {
          return cb2(null, 0);
        }
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er2, bytes) => {
          if (er2) {
            return cb2(er2);
          }
          bufPos += bytes;
          if (bufPos < 512 && bytes) {
            return fs6.read(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position + bufPos,
              onread
            );
          }
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
            return cb2(new Error("cannot append to compressed archives"));
          }
          if (bufPos < 512) {
            return cb2(null, position);
          }
          const h8 = new Header(headBuf);
          if (!h8.cksumValid) {
            return cb2(null, position);
          }
          const entryBlockSize = 512 * Math.ceil(h8.size / 512);
          if (position + entryBlockSize + 512 > size) {
            return cb2(null, position);
          }
          position += entryBlockSize + 512;
          if (position >= size) {
            return cb2(null, position);
          }
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h8.path, h8.mtime);
          }
          bufPos = 0;
          fs6.read(fd, headBuf, 0, 512, position, onread);
        };
        fs6.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve5, reject) => {
        p3.on("error", reject);
        let flag = "r+";
        const onopen = (er2, fd) => {
          if (er2 && er2.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs6.open(opt.file, flag, onopen);
          }
          if (er2) {
            return reject(er2);
          }
          fs6.fstat(fd, (er3, st) => {
            if (er3) {
              return fs6.close(fd, () => reject(er3));
            }
            getPos(fd, st.size, (er4, position) => {
              if (er4) {
                return reject(er4);
              }
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p3.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve5);
              addFilesAsync(p3, files);
            });
          });
        };
        fs6.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p3, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t2({
            file: path4.resolve(p3.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p3.add(entry)
          });
        } else {
          p3.add(file);
        }
      });
      p3.end();
    };
    var addFilesAsync = (p3, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t2({
            file: path4.resolve(p3.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p3.add(entry)
          }).then((_5) => addFilesAsync(p3, files));
        } else {
          p3.add(file);
        }
      }
      p3.end();
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/update.js
var require_update = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/update.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var r6 = require_replace();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip || opt.brotli || opt.file.endsWith(".br") || opt.file.endsWith(".tbr")) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      mtimeFilter(opt);
      return r6(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter = opt.filter;
      if (!opt.mtimeCache) {
        opt.mtimeCache = /* @__PURE__ */ new Map();
      }
      opt.filter = filter ? (path4, stat) => filter(path4, stat) && !(opt.mtimeCache.get(path4) > stat.mtime) : (path4, stat) => !(opt.mtimeCache.get(path4) > stat.mtime);
    };
  }
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/opts-arg.js"(exports2, module2) {
    "use strict";
    var { promisify: promisify2 } = require("util");
    var fs6 = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs: fs6 };
      else if (typeof opts === "object")
        opts = { mode: 511, fs: fs6, ...opts };
      else if (typeof opts === "number")
        opts = { mode: opts, fs: fs6 };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs: fs6 };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs6.mkdir;
      opts.mkdirAsync = promisify2(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs6.stat;
      opts.statAsync = promisify2(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs6.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs6.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  }
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/path-arg.js"(exports2, module2) {
    "use strict";
    var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve: resolve5, parse: parse6 } = require("path");
    var pathArg = (path4) => {
      if (/\0/.test(path4)) {
        throw Object.assign(
          new TypeError("path must be a string without null bytes"),
          {
            path: path4,
            code: "ERR_INVALID_ARG_VALUE"
          }
        );
      }
      path4 = resolve5(path4);
      if (platform === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse6(path4);
        if (badWinChars.test(path4.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path4,
            code: "EINVAL"
          });
        }
      }
      return path4;
    };
    module2.exports = pathArg;
  }
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/find-made.js"(exports2, module2) {
    "use strict";
    var { dirname: dirname3 } = require("path");
    var findMade = (opts, parent, path4 = void 0) => {
      if (path4 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then(
        (st) => st.isDirectory() ? path4 : void 0,
        // will fail later
        (er2) => er2.code === "ENOENT" ? findMade(opts, dirname3(parent), parent) : void 0
      );
    };
    var findMadeSync = (opts, parent, path4 = void 0) => {
      if (path4 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path4 : void 0;
      } catch (er2) {
        return er2.code === "ENOENT" ? findMadeSync(opts, dirname3(parent), parent) : void 0;
      }
    };
    module2.exports = { findMade, findMadeSync };
  }
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-manual.js"(exports2, module2) {
    "use strict";
    var { dirname: dirname3 } = require("path");
    var mkdirpManual = (path4, opts, made) => {
      opts.recursive = false;
      const parent = dirname3(path4);
      if (parent === path4) {
        return opts.mkdirAsync(path4, opts).catch((er2) => {
          if (er2.code !== "EISDIR")
            throw er2;
        });
      }
      return opts.mkdirAsync(path4, opts).then(() => made || path4, (er2) => {
        if (er2.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path4, opts, made2));
        if (er2.code !== "EEXIST" && er2.code !== "EROFS")
          throw er2;
        return opts.statAsync(path4).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er2;
        }, () => {
          throw er2;
        });
      });
    };
    var mkdirpManualSync = (path4, opts, made) => {
      const parent = dirname3(path4);
      opts.recursive = false;
      if (parent === path4) {
        try {
          return opts.mkdirSync(path4, opts);
        } catch (er2) {
          if (er2.code !== "EISDIR")
            throw er2;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path4, opts);
        return made || path4;
      } catch (er2) {
        if (er2.code === "ENOENT")
          return mkdirpManualSync(path4, opts, mkdirpManualSync(parent, opts, made));
        if (er2.code !== "EEXIST" && er2.code !== "EROFS")
          throw er2;
        try {
          if (!opts.statSync(path4).isDirectory())
            throw er2;
        } catch (_5) {
          throw er2;
        }
      }
    };
    module2.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-native.js"(exports2, module2) {
    "use strict";
    var { dirname: dirname3 } = require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path4, opts) => {
      opts.recursive = true;
      const parent = dirname3(path4);
      if (parent === path4)
        return opts.mkdirAsync(path4, opts);
      return findMade(opts, path4).then((made) => opts.mkdirAsync(path4, opts).then(() => made).catch((er2) => {
        if (er2.code === "ENOENT")
          return mkdirpManual(path4, opts);
        else
          throw er2;
      }));
    };
    var mkdirpNativeSync = (path4, opts) => {
      opts.recursive = true;
      const parent = dirname3(path4);
      if (parent === path4)
        return opts.mkdirSync(path4, opts);
      const made = findMadeSync(opts, path4);
      try {
        opts.mkdirSync(path4, opts);
        return made;
      } catch (er2) {
        if (er2.code === "ENOENT")
          return mkdirpManualSync(path4, opts);
        else
          throw er2;
      }
    };
    module2.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/use-native.js"(exports2, module2) {
    "use strict";
    var fs6 = require("fs");
    var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version2.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs6.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs6.mkdirSync;
    module2.exports = { useNative, useNativeSync };
  }
});

// ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/index.js"(exports2, module2) {
    "use strict";
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp = (path4, opts) => {
      path4 = pathArg(path4);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path4, opts) : mkdirpManual(path4, opts);
    };
    var mkdirpSync = (path4, opts) => {
      path4 = pathArg(path4);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path4, opts) : mkdirpManualSync(path4, opts);
    };
    mkdirp.sync = mkdirpSync;
    mkdirp.native = (path4, opts) => mkdirpNative(pathArg(path4), optsArg(opts));
    mkdirp.manual = (path4, opts) => mkdirpManual(pathArg(path4), optsArg(opts));
    mkdirp.nativeSync = (path4, opts) => mkdirpNativeSync(pathArg(path4), optsArg(opts));
    mkdirp.manualSync = (path4, opts) => mkdirpManualSync(pathArg(path4), optsArg(opts));
    module2.exports = mkdirp;
  }
});

// ../../node_modules/.pnpm/chownr@2.0.0/node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "../../node_modules/.pnpm/chownr@2.0.0/node_modules/chownr/chownr.js"(exports2, module2) {
    "use strict";
    var fs6 = require("fs");
    var path4 = require("path");
    var LCHOWN = fs6.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs6.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs6.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path5, uid, gid) => {
      try {
        return fs6[LCHOWNSYNC](path5, uid, gid);
      } catch (er2) {
        if (er2.code !== "ENOENT")
          throw er2;
      }
    };
    var chownSync = (path5, uid, gid) => {
      try {
        return fs6.chownSync(path5, uid, gid);
      } catch (er2) {
        if (er2.code !== "ENOENT")
          throw er2;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path5, uid, gid, cb) => (er2) => {
      if (!er2 || er2.code !== "EISDIR")
        cb(er2);
      else
        fs6.chown(path5, uid, gid, cb);
    } : (_5, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path5, uid, gid) => {
      try {
        return lchownSync(path5, uid, gid);
      } catch (er2) {
        if (er2.code !== "EISDIR")
          throw er2;
        chownSync(path5, uid, gid);
      }
    } : (path5, uid, gid) => lchownSync(path5, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path5, options, cb) => fs6.readdir(path5, options, cb);
    var readdirSync2 = (path5, options) => fs6.readdirSync(path5, options);
    if (/^v4\./.test(nodeVersion))
      readdir = (path5, options, cb) => fs6.readdir(path5, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs6[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er2) => {
        cb(er2 && er2.code !== "ENOENT" ? er2 : null);
      }));
    };
    var chownrKid = (p3, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs6.lstat(path4.resolve(p3, child), (er2, stats) => {
          if (er2)
            return cb(er2.code !== "ENOENT" ? er2 : null);
          stats.name = child;
          chownrKid(p3, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path4.resolve(p3, child.name), uid, gid, (er2) => {
          if (er2)
            return cb(er2);
          const cpath = path4.resolve(p3, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path4.resolve(p3, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p3, uid, gid, cb) => {
      readdir(p3, { withFileTypes: true }, (er2, children) => {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb();
          else if (er2.code !== "ENOTDIR" && er2.code !== "ENOTSUP")
            return cb(er2);
        }
        if (er2 || !children.length)
          return chown(p3, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er3) => {
          if (errState)
            return;
          if (er3)
            return cb(errState = er3);
          if (--len === 0)
            return chown(p3, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p3, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p3, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs6.lstatSync(path4.resolve(p3, child));
          stats.name = child;
          child = stats;
        } catch (er2) {
          if (er2.code === "ENOENT")
            return;
          else
            throw er2;
        }
      }
      if (child.isDirectory())
        chownrSync(path4.resolve(p3, child.name), uid, gid);
      handleEISDirSync(path4.resolve(p3, child.name), uid, gid);
    };
    var chownrSync = (p3, uid, gid) => {
      let children;
      try {
        children = readdirSync2(p3, { withFileTypes: true });
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else if (er2.code === "ENOTDIR" || er2.code === "ENOTSUP")
          return handleEISDirSync(p3, uid, gid);
        else
          throw er2;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p3, child, uid, gid));
      return handleEISDirSync(p3, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/mkdir.js"(exports2, module2) {
    "use strict";
    var mkdirp = require_mkdirp();
    var fs6 = require("fs");
    var path4 = require("path");
    var chownr = require_chownr();
    var normPath = require_normalize_windows_path();
    var SymlinkError = class extends Error {
      constructor(symlink, path5) {
        super("Cannot extract through symbolic link");
        this.path = path5;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path5, code) {
        super(code + ": Cannot cd into '" + path5 + "'");
        this.path = path5;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var cGet = (cache2, key) => cache2.get(normPath(key));
    var cSet = (cache2, key, val) => cache2.set(normPath(key), val);
    var checkCwd = (dir, cb) => {
      fs6.stat(dir, (er2, st) => {
        if (er2 || !st.isDirectory()) {
          er2 = new CwdError(dir, er2 && er2.code || "ENOTDIR");
        }
        cb(er2);
      });
    };
    module2.exports = (dir, opt, cb) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache2 = opt.cache;
      const cwd2 = normPath(opt.cwd);
      const done = (er2, created) => {
        if (er2) {
          cb(er2);
        } else {
          cSet(cache2, dir, true);
          if (created && doChown) {
            chownr(created, uid, gid, (er3) => done(er3));
          } else if (needChmod) {
            fs6.chmod(dir, mode, cb);
          } else {
            cb();
          }
        }
      };
      if (cache2 && cGet(cache2, dir) === true) {
        return done();
      }
      if (dir === cwd2) {
        return checkCwd(dir, done);
      }
      if (preserve) {
        return mkdirp(dir, { mode }).then((made) => done(null, made), done);
      }
      const sub = normPath(path4.relative(cwd2, dir));
      const parts = sub.split("/");
      mkdir_(cwd2, parts, mode, cache2, unlink, cwd2, null, done);
    };
    var mkdir_ = (base, parts, mode, cache2, unlink, cwd2, created, cb) => {
      if (!parts.length) {
        return cb(null, created);
      }
      const p3 = parts.shift();
      const part = normPath(path4.resolve(base + "/" + p3));
      if (cGet(cache2, part)) {
        return mkdir_(part, parts, mode, cache2, unlink, cwd2, created, cb);
      }
      fs6.mkdir(part, mode, onmkdir(part, parts, mode, cache2, unlink, cwd2, created, cb));
    };
    var onmkdir = (part, parts, mode, cache2, unlink, cwd2, created, cb) => (er2) => {
      if (er2) {
        fs6.lstat(part, (statEr, st) => {
          if (statEr) {
            statEr.path = statEr.path && normPath(statEr.path);
            cb(statEr);
          } else if (st.isDirectory()) {
            mkdir_(part, parts, mode, cache2, unlink, cwd2, created, cb);
          } else if (unlink) {
            fs6.unlink(part, (er3) => {
              if (er3) {
                return cb(er3);
              }
              fs6.mkdir(part, mode, onmkdir(part, parts, mode, cache2, unlink, cwd2, created, cb));
            });
          } else if (st.isSymbolicLink()) {
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          } else {
            cb(er2);
          }
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache2, unlink, cwd2, created, cb);
      }
    };
    var checkCwdSync = (dir) => {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs6.statSync(dir).isDirectory();
      } catch (er2) {
        code = er2.code;
      } finally {
        if (!ok) {
          throw new CwdError(dir, code);
        }
      }
    };
    module2.exports.sync = (dir, opt) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache2 = opt.cache;
      const cwd2 = normPath(opt.cwd);
      const done = (created2) => {
        cSet(cache2, dir, true);
        if (created2 && doChown) {
          chownr.sync(created2, uid, gid);
        }
        if (needChmod) {
          fs6.chmodSync(dir, mode);
        }
      };
      if (cache2 && cGet(cache2, dir) === true) {
        return done();
      }
      if (dir === cwd2) {
        checkCwdSync(cwd2);
        return done();
      }
      if (preserve) {
        return done(mkdirp.sync(dir, mode));
      }
      const sub = normPath(path4.relative(cwd2, dir));
      const parts = sub.split("/");
      let created = null;
      for (let p3 = parts.shift(), part = cwd2; p3 && (part += "/" + p3); p3 = parts.shift()) {
        part = normPath(path4.resolve(part));
        if (cGet(cache2, part)) {
          continue;
        }
        try {
          fs6.mkdirSync(part, mode);
          created = created || part;
          cSet(cache2, part, true);
        } catch (er2) {
          const st = fs6.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache2, part, true);
            continue;
          } else if (unlink) {
            fs6.unlinkSync(part);
            fs6.mkdirSync(part, mode);
            created = created || part;
            cSet(cache2, part, true);
            continue;
          } else if (st.isSymbolicLink()) {
            return new SymlinkError(part, part + "/" + parts.join("/"));
          }
        }
      }
      return done(created);
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/normalize-unicode.js"(exports2, module2) {
    "use strict";
    var normalizeCache = /* @__PURE__ */ Object.create(null);
    var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
    module2.exports = (s4) => {
      if (!hasOwnProperty3.call(normalizeCache, s4)) {
        normalizeCache[s4] = s4.normalize("NFD");
      }
      return normalizeCache[s4];
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/path-reservations.js"(exports2, module2) {
    "use strict";
    var assert2 = require("assert");
    var normalize2 = require_normalize_unicode();
    var stripSlashes = require_strip_trailing_slashes();
    var { join: join2 } = require("path");
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows = platform === "win32";
    module2.exports = () => {
      const queues = /* @__PURE__ */ new Map();
      const reservations = /* @__PURE__ */ new Map();
      const getDirs = (path4) => {
        const dirs = path4.split("/").slice(0, -1).reduce((set, path5) => {
          if (set.length) {
            path5 = join2(set[set.length - 1], path5);
          }
          set.push(path5 || "/");
          return set;
        }, []);
        return dirs;
      };
      const running = /* @__PURE__ */ new Set();
      const getQueues = (fn2) => {
        const res = reservations.get(fn2);
        if (!res) {
          throw new Error("function does not have any path reservations");
        }
        return {
          paths: res.paths.map((path4) => queues.get(path4)),
          dirs: [...res.dirs].map((path4) => queues.get(path4))
        };
      };
      const check = (fn2) => {
        const { paths, dirs } = getQueues(fn2);
        return paths.every((q6) => q6[0] === fn2) && dirs.every((q6) => q6[0] instanceof Set && q6[0].has(fn2));
      };
      const run = (fn2) => {
        if (running.has(fn2) || !check(fn2)) {
          return false;
        }
        running.add(fn2);
        fn2(() => clear(fn2));
        return true;
      };
      const clear = (fn2) => {
        if (!running.has(fn2)) {
          return false;
        }
        const { paths, dirs } = reservations.get(fn2);
        const next = /* @__PURE__ */ new Set();
        paths.forEach((path4) => {
          const q6 = queues.get(path4);
          assert2.equal(q6[0], fn2);
          if (q6.length === 1) {
            queues.delete(path4);
          } else {
            q6.shift();
            if (typeof q6[0] === "function") {
              next.add(q6[0]);
            } else {
              q6[0].forEach((fn3) => next.add(fn3));
            }
          }
        });
        dirs.forEach((dir) => {
          const q6 = queues.get(dir);
          assert2(q6[0] instanceof Set);
          if (q6[0].size === 1 && q6.length === 1) {
            queues.delete(dir);
          } else if (q6[0].size === 1) {
            q6.shift();
            next.add(q6[0]);
          } else {
            q6[0].delete(fn2);
          }
        });
        running.delete(fn2);
        next.forEach((fn3) => run(fn3));
        return true;
      };
      const reserve = (paths, fn2) => {
        paths = isWindows ? ["win32 parallelization disabled"] : paths.map((p3) => {
          return stripSlashes(join2(normalize2(p3))).toLowerCase();
        });
        const dirs = new Set(
          paths.map((path4) => getDirs(path4)).reduce((a3, b6) => a3.concat(b6))
        );
        reservations.set(fn2, { dirs, paths });
        paths.forEach((path4) => {
          const q6 = queues.get(path4);
          if (!q6) {
            queues.set(path4, [fn2]);
          } else {
            q6.push(fn2);
          }
        });
        dirs.forEach((dir) => {
          const q6 = queues.get(dir);
          if (!q6) {
            queues.set(dir, [/* @__PURE__ */ new Set([fn2])]);
          } else if (q6[q6.length - 1] instanceof Set) {
            q6[q6.length - 1].add(fn2);
          } else {
            q6.push(/* @__PURE__ */ new Set([fn2]));
          }
        });
        return run(fn2);
      };
      return { check, reserve };
    };
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/get-write-flag.js"(exports2, module2) {
    "use strict";
    var platform = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows = platform === "win32";
    var fs6 = global.__FAKE_TESTING_FS__ || require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs6.constants;
    var fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/unpack.js"(exports2, module2) {
    "use strict";
    var assert2 = require("assert");
    var Parser3 = require_parse();
    var fs6 = require("fs");
    var fsm = require_fs_minipass();
    var path4 = require("path");
    var mkdir2 = require_mkdir();
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var stripAbsolutePath = require_strip_absolute_path();
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var normalize2 = require_normalize_unicode();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var PRUNECACHE = Symbol("pruneCache");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var CHECKED_CWD = Symbol("checkedCwd");
    var crypto = require("crypto");
    var getFlag = require_get_write_flag();
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows = platform === "win32";
    var DEFAULT_MAX_DEPTH = 1024;
    var unlinkFile = (path5, cb) => {
      if (!isWindows) {
        return fs6.unlink(path5, cb);
      }
      const name = path5 + ".DELETE." + crypto.randomBytes(16).toString("hex");
      fs6.rename(path5, name, (er2) => {
        if (er2) {
          return cb(er2);
        }
        fs6.unlink(name, cb);
      });
    };
    var unlinkFileSync = (path5) => {
      if (!isWindows) {
        return fs6.unlinkSync(path5);
      }
      const name = path5 + ".DELETE." + crypto.randomBytes(16).toString("hex");
      fs6.renameSync(path5, name);
      fs6.unlinkSync(name);
    };
    var uint32 = (a3, b6, c2) => a3 === a3 >>> 0 ? a3 : b6 === b6 >>> 0 ? b6 : c2;
    var cacheKeyNormalize = (path5) => stripSlash(normPath(normalize2(path5))).toLowerCase();
    var pruneCache = (cache2, abs) => {
      abs = cacheKeyNormalize(abs);
      for (const path5 of cache2.keys()) {
        const pnorm = cacheKeyNormalize(path5);
        if (pnorm === abs || pnorm.indexOf(abs + "/") === 0) {
          cache2.delete(path5);
        }
      }
    };
    var dropCache = (cache2) => {
      for (const key of cache2.keys()) {
        cache2.delete(key);
      }
    };
    var Unpack = class extends Parser3 {
      constructor(opt) {
        if (!opt) {
          opt = {};
        }
        opt.ondone = (_5) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this[CHECKED_CWD] = false;
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || /* @__PURE__ */ new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
            throw new TypeError("cannot set owner without number uid and gid");
          }
          if (opt.preserveOwner) {
            throw new TypeError(
              "cannot preserve owner in archive and also set owner explicitly"
            );
          }
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number") {
          this.preserveOwner = process.getuid && process.getuid() === 0;
        } else {
          this.preserveOwner = !!opt.preserveOwner;
        }
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.maxDepth = typeof opt.maxDepth === "number" ? opt.maxDepth : DEFAULT_MAX_DEPTH;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || isWindows;
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = normPath(path4.resolve(opt.cwd || process.cwd()));
        this.strip = +opt.strip || 0;
        this.processUmask = opt.noChmod ? 0 : process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      // a bad or damaged archive is a warning for Parser, but an error
      // when extracting.  Mark those errors as unrecoverable, because
      // the Unpack contract cannot be met.
      warn(code, msg, data2 = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") {
          data2.recoverable = false;
        }
        return super.warn(code, msg, data2);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
        }
      }
      [CHECKPATH](entry) {
        const p3 = normPath(entry.path);
        const parts = p3.split("/");
        if (this.strip) {
          if (parts.length < this.strip) {
            return false;
          }
          if (entry.type === "Link") {
            const linkparts = normPath(entry.linkpath).split("/");
            if (linkparts.length >= this.strip) {
              entry.linkpath = linkparts.slice(this.strip).join("/");
            } else {
              return false;
            }
          }
          parts.splice(0, this.strip);
          entry.path = parts.join("/");
        }
        if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {
          this.warn("TAR_ENTRY_ERROR", "path excessively deep", {
            entry,
            path: p3,
            depth: parts.length,
            maxDepth: this.maxDepth
          });
          return false;
        }
        if (!this.preservePaths) {
          if (parts.includes("..") || isWindows && /^[a-z]:\.\.$/i.test(parts[0])) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p3
            });
            return false;
          }
          const [root, stripped] = stripAbsolutePath(p3);
          if (root) {
            entry.path = stripped;
            this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
              entry,
              path: p3
            });
          }
        }
        if (path4.isAbsolute(entry.path)) {
          entry.absolute = normPath(path4.resolve(entry.path));
        } else {
          entry.absolute = normPath(path4.resolve(this.cwd, entry.path));
        }
        if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
          this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
            entry,
            path: normPath(entry.path),
            resolvedPath: entry.absolute,
            cwd: this.cwd
          });
          return false;
        }
        if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
          return false;
        }
        if (this.win32) {
          const { root: aRoot } = path4.win32.parse(entry.absolute);
          entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
          const { root: pRoot } = path4.win32.parse(entry.path);
          entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
        }
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry)) {
          return entry.resume();
        }
        assert2.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode) {
              entry.mode = entry.mode | 448;
            }
          // eslint-disable-next-line no-fallthrough
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
          default:
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er2, entry) {
        if (er2.name === "CwdError") {
          this.emit("error", er2);
        } else {
          this.warn("TAR_ENTRY_ERROR", er2, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir2(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode,
          noChmod: this.noChmod
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er2) => {
          if (stream.fd) {
            fs6.close(stream.fd, () => {
            });
          }
          stream.write = () => true;
          this[ONERROR](er2, entry);
          fullyDone();
        });
        let actions = 1;
        const done = (er2) => {
          if (er2) {
            if (stream.fd) {
              fs6.close(stream.fd, () => {
              });
            }
            this[ONERROR](er2, entry);
            fullyDone();
            return;
          }
          if (--actions === 0) {
            fs6.close(stream.fd, (er3) => {
              if (er3) {
                this[ONERROR](er3, entry);
              } else {
                this[UNPEND]();
              }
              fullyDone();
            });
          }
        };
        stream.on("finish", (_5) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            fs6.futimes(fd, atime, mtime, (er2) => er2 ? fs6.utimes(abs, atime, mtime, (er22) => done(er22 && er2)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs6.fchown(fd, uid, gid, (er2) => er2 ? fs6.chown(abs, uid, gid, (er22) => done(er22 && er2)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er2) => {
            this[ONERROR](er2, entry);
            fullyDone();
          });
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er2) => {
          if (er2) {
            this[ONERROR](er2, entry);
            fullyDone();
            return;
          }
          let actions = 1;
          const done = (_5) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs6.utimes(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs6.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn(
          "TAR_ENTRY_UNSUPPORTED",
          `unsupported entry type: ${entry.type}`,
          { entry }
        );
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        const linkpath = normPath(path4.resolve(this.cwd, entry.linkpath));
        this[LINK](entry, linkpath, "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      // Check if we can reuse an existing filesystem entry safely and
      // overwrite it, rather than unlinking and recreating
      // Windows doesn't report a useful nlink, so we just never reuse entries
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;
      }
      // check if a thing is there, and if so, try to clobber it
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath) {
          paths.push(entry.linkpath);
        }
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [PRUNECACHE](entry) {
        if (entry.type === "SymbolicLink") {
          dropCache(this.dirCache);
        } else if (entry.type !== "Directory") {
          pruneCache(this.dirCache, entry.absolute);
        }
      }
      [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er2) => {
          this[PRUNECACHE](entry);
          fullyDone(er2);
        };
        const checkCwd = () => {
          this[MKDIR](this.cwd, this.dmode, (er2) => {
            if (er2) {
              this[ONERROR](er2, entry);
              done();
              return;
            }
            this[CHECKED_CWD] = true;
            start();
          });
        };
        const start = () => {
          if (entry.absolute !== this.cwd) {
            const parent = normPath(path4.dirname(entry.absolute));
            if (parent !== this.cwd) {
              return this[MKDIR](parent, this.dmode, (er2) => {
                if (er2) {
                  this[ONERROR](er2, entry);
                  done();
                  return;
                }
                afterMakeParent();
              });
            }
          }
          afterMakeParent();
        };
        const afterMakeParent = () => {
          fs6.lstat(entry.absolute, (lstatEr, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
              return;
            }
            if (lstatEr || this[ISREUSABLE](entry, st)) {
              return this[MAKEFS](null, entry, done);
            }
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
                const afterChmod = (er2) => this[MAKEFS](er2, entry, done);
                if (!needChmod) {
                  return afterChmod();
                }
                return fs6.chmod(entry.absolute, entry.mode, afterChmod);
              }
              if (entry.absolute !== this.cwd) {
                return fs6.rmdir(entry.absolute, (er2) => this[MAKEFS](er2, entry, done));
              }
            }
            if (entry.absolute === this.cwd) {
              return this[MAKEFS](null, entry, done);
            }
            unlinkFile(entry.absolute, (er2) => this[MAKEFS](er2, entry, done));
          });
        };
        if (this[CHECKED_CWD]) {
          start();
        } else {
          checkCwd();
        }
      }
      [MAKEFS](er2, entry, done) {
        if (er2) {
          this[ONERROR](er2, entry);
          done();
          return;
        }
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs6[link](linkpath, entry.absolute, (er2) => {
          if (er2) {
            this[ONERROR](er2, entry);
          } else {
            this[UNPEND]();
            entry.resume();
          }
          done();
        });
      }
    };
    var callSync = (fn2) => {
      try {
        return [null, fn2()];
      } catch (er2) {
        return [er2, null];
      }
    };
    var UnpackSync = class extends Unpack {
      [MAKEFS](er2, entry) {
        return super[MAKEFS](er2, entry, () => {
        });
      }
      [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
          const er3 = this[MKDIR](this.cwd, this.dmode);
          if (er3) {
            return this[ONERROR](er3, entry);
          }
          this[CHECKED_CWD] = true;
        }
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path4.dirname(entry.absolute));
          if (parent !== this.cwd) {
            const mkParent = this[MKDIR](parent, this.dmode);
            if (mkParent) {
              return this[ONERROR](mkParent, entry);
            }
          }
        }
        const [lstatEr, st] = callSync(() => fs6.lstatSync(entry.absolute));
        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
          return this[SKIP](entry);
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry);
        }
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const [er4] = needChmod ? callSync(() => {
              fs6.chmodSync(entry.absolute, entry.mode);
            }) : [];
            return this[MAKEFS](er4, entry);
          }
          const [er3] = callSync(() => fs6.rmdirSync(entry.absolute));
          this[MAKEFS](er3, entry);
        }
        const [er2] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
        this[MAKEFS](er2, entry);
      }
      [FILE](entry, done) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er2) => {
          let closeError;
          try {
            fs6.closeSync(fd);
          } catch (e3) {
            closeError = e3;
          }
          if (er2 || closeError) {
            this[ONERROR](er2 || closeError, entry);
          }
          done();
        };
        let fd;
        try {
          fd = fs6.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er2) {
          return oner(er2);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er2) => this[ONERROR](er2, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs6.writeSync(fd, chunk, 0, chunk.length);
          } catch (er2) {
            oner(er2);
          }
        });
        tx.on("end", (_5) => {
          let er2 = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            try {
              fs6.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs6.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er2 = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs6.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs6.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er2 = er2 || fchowner;
              }
            }
          }
          oner(er2);
        });
      }
      [DIRECTORY](entry, done) {
        const mode = entry.mode & 4095 || this.dmode;
        const er2 = this[MKDIR](entry.absolute, mode);
        if (er2) {
          this[ONERROR](er2, entry);
          done();
          return;
        }
        if (entry.mtime && !this.noMtime) {
          try {
            fs6.utimesSync(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime);
          } catch (er3) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs6.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er3) {
          }
        }
        done();
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir2.sync(normPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er2) {
          return er2;
        }
      }
      [LINK](entry, linkpath, link, done) {
        try {
          fs6[link + "Sync"](linkpath, entry.absolute);
          done();
          entry.resume();
        } catch (er2) {
          return this[ONERROR](er2, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/lib/extract.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs6 = require("fs");
    var fsm = require_fs_minipass();
    var path4 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract2(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f3) => [stripSlash(f3), true]));
      const filter = opt.filter;
      const mapHas = (file, r6) => {
        const root = r6 || path4.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path4.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var extractFileSync = (opt) => {
      const u4 = new Unpack.Sync(opt);
      const file = opt.file;
      const stat = fs6.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u4);
    };
    var extractFile = (opt, cb) => {
      const u4 = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p3 = new Promise((resolve5, reject) => {
        u4.on("error", reject);
        u4.on("close", resolve5);
        fs6.stat(file, (er2, stat) => {
          if (er2) {
            reject(er2);
          } else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u4);
          }
        });
      });
      return cb ? p3.then(cb, cb) : p3;
    };
    var extractSync = (opt) => new Unpack.Sync(opt);
    var extract2 = (opt) => new Unpack(opt);
  }
});

// ../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/index.js
var require_tar = __commonJS({
  "../../node_modules/.pnpm/tar@6.2.1/node_modules/tar/index.js"(exports2) {
    "use strict";
    exports2.c = exports2.create = require_create();
    exports2.r = exports2.replace = require_replace();
    exports2.t = exports2.list = require_list();
    exports2.u = exports2.update = require_update();
    exports2.x = exports2.extract = require_extract();
    exports2.Pack = require_pack();
    exports2.Unpack = require_unpack();
    exports2.Parse = require_parse();
    exports2.ReadEntry = require_read_entry();
    exports2.WriteEntry = require_write_entry();
    exports2.Header = require_header();
    exports2.Pax = require_pax();
    exports2.types = require_types();
  }
});

// ../../node_modules/.pnpm/tinyexec@0.3.2/node_modules/tinyexec/dist/main.js
function jt(t2) {
  for (let e3 in t2) {
    if (!Object.prototype.hasOwnProperty.call(t2, e3) || !Lt.test(e3))
      continue;
    let n = t2[e3];
    return n ? { key: e3, value: n } : q5;
  }
  return q5;
}
function Ft(t2, e3) {
  let n = e3.value.split(import_path2.delimiter), r6 = t2, s4;
  do
    n.push((0, import_path2.resolve)(r6, "node_modules", ".bin")), s4 = r6, r6 = (0, import_path2.dirname)(r6);
  while (r6 !== s4);
  return { key: e3.key, value: n.join(import_path2.delimiter) };
}
function I4(t2, e3) {
  let n = {
    ...process.env,
    ...e3
  }, r6 = Ft(t2, jt(n));
  return n[r6.key] = r6.value, n;
}
function we2(t2, e3) {
  return {
    command: (0, import_path.normalize)(t2),
    args: e3 ?? []
  };
}
function xe2(t2) {
  let e3 = new AbortController();
  for (let n of t2) {
    if (n.aborted)
      return e3.abort(), n;
    let r6 = () => {
      e3.abort(n.reason);
    };
    n.addEventListener("abort", r6, {
      signal: e3.signal
    });
  }
  return e3.signal;
}
var import_node_module4, import_child_process, import_path, import_process, import_path2, import_stream, import_readline, import_meta3, require2, St, $5, kt, Tt, At, Rt, h7, l2, $t, Nt, W5, X4, U5, et, rt, ct, ut, lt, dt, ht, wt, bt, Ct, Lt, q5, L3, Pt, x4, ge2, Ee2, R3, ve, be2;
var init_main = __esm({
  "../../node_modules/.pnpm/tinyexec@0.3.2/node_modules/tinyexec/dist/main.js"() {
    "use strict";
    import_node_module4 = require("module");
    import_child_process = require("child_process");
    import_path = require("path");
    import_process = require("process");
    import_path2 = require("path");
    import_stream = require("stream");
    import_readline = __toESM(require("readline"), 1);
    import_meta3 = {};
    require2 = (0, import_node_module4.createRequire)(import_meta3.url);
    St = Object.create;
    $5 = Object.defineProperty;
    kt = Object.getOwnPropertyDescriptor;
    Tt = Object.getOwnPropertyNames;
    At = Object.getPrototypeOf;
    Rt = Object.prototype.hasOwnProperty;
    h7 = /* @__PURE__ */ ((t2) => typeof require2 < "u" ? require2 : typeof Proxy < "u" ? new Proxy(t2, {
      get: (e3, n) => (typeof require2 < "u" ? require2 : e3)[n]
    }) : t2)(function(t2) {
      if (typeof require2 < "u") return require2.apply(this, arguments);
      throw Error('Dynamic require of "' + t2 + '" is not supported');
    });
    l2 = (t2, e3) => () => (e3 || t2((e3 = { exports: {} }).exports, e3), e3.exports);
    $t = (t2, e3, n, r6) => {
      if (e3 && typeof e3 == "object" || typeof e3 == "function")
        for (let s4 of Tt(e3))
          !Rt.call(t2, s4) && s4 !== n && $5(t2, s4, { get: () => e3[s4], enumerable: !(r6 = kt(e3, s4)) || r6.enumerable });
      return t2;
    };
    Nt = (t2, e3, n) => (n = t2 != null ? St(At(t2)) : {}, $t(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      e3 || !t2 || !t2.__esModule ? $5(n, "default", { value: t2, enumerable: true }) : n,
      t2
    ));
    W5 = l2((Se2, H5) => {
      "use strict";
      H5.exports = z4;
      z4.sync = Wt;
      var j3 = h7("fs");
      function Ht(t2, e3) {
        var n = e3.pathExt !== void 0 ? e3.pathExt : process.env.PATHEXT;
        if (!n || (n = n.split(";"), n.indexOf("") !== -1))
          return true;
        for (var r6 = 0; r6 < n.length; r6++) {
          var s4 = n[r6].toLowerCase();
          if (s4 && t2.substr(-s4.length).toLowerCase() === s4)
            return true;
        }
        return false;
      }
      function F2(t2, e3, n) {
        return !t2.isSymbolicLink() && !t2.isFile() ? false : Ht(e3, n);
      }
      function z4(t2, e3, n) {
        j3.stat(t2, function(r6, s4) {
          n(r6, r6 ? false : F2(s4, t2, e3));
        });
      }
      function Wt(t2, e3) {
        return F2(j3.statSync(t2), t2, e3);
      }
    });
    X4 = l2((ke2, B3) => {
      "use strict";
      B3.exports = K4;
      K4.sync = Dt;
      var D3 = h7("fs");
      function K4(t2, e3, n) {
        D3.stat(t2, function(r6, s4) {
          n(r6, r6 ? false : M4(s4, e3));
        });
      }
      function Dt(t2, e3) {
        return M4(D3.statSync(t2), e3);
      }
      function M4(t2, e3) {
        return t2.isFile() && Kt(t2, e3);
      }
      function Kt(t2, e3) {
        var n = t2.mode, r6 = t2.uid, s4 = t2.gid, o = e3.uid !== void 0 ? e3.uid : process.getuid && process.getuid(), i2 = e3.gid !== void 0 ? e3.gid : process.getgid && process.getgid(), a3 = parseInt("100", 8), c2 = parseInt("010", 8), u4 = parseInt("001", 8), f3 = a3 | c2, p3 = n & u4 || n & c2 && s4 === i2 || n & a3 && r6 === o || n & f3 && o === 0;
        return p3;
      }
    });
    U5 = l2((Ae, G3) => {
      "use strict";
      var Te2 = h7("fs"), v4;
      process.platform === "win32" || global.TESTING_WINDOWS ? v4 = W5() : v4 = X4();
      G3.exports = y3;
      y3.sync = Mt;
      function y3(t2, e3, n) {
        if (typeof e3 == "function" && (n = e3, e3 = {}), !n) {
          if (typeof Promise != "function")
            throw new TypeError("callback not provided");
          return new Promise(function(r6, s4) {
            y3(t2, e3 || {}, function(o, i2) {
              o ? s4(o) : r6(i2);
            });
          });
        }
        v4(t2, e3 || {}, function(r6, s4) {
          r6 && (r6.code === "EACCES" || e3 && e3.ignoreErrors) && (r6 = null, s4 = false), n(r6, s4);
        });
      }
      function Mt(t2, e3) {
        try {
          return v4.sync(t2, e3 || {});
        } catch (n) {
          if (e3 && e3.ignoreErrors || n.code === "EACCES")
            return false;
          throw n;
        }
      }
    });
    et = l2((Re2, tt) => {
      "use strict";
      var g4 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", Y4 = h7("path"), Bt = g4 ? ";" : ":", V4 = U5(), J5 = (t2) => Object.assign(new Error(`not found: ${t2}`), { code: "ENOENT" }), Q5 = (t2, e3) => {
        let n = e3.colon || Bt, r6 = t2.match(/\//) || g4 && t2.match(/\\/) ? [""] : [
          // windows always checks the cwd first
          ...g4 ? [process.cwd()] : [],
          ...(e3.path || process.env.PATH || /* istanbul ignore next: very unusual */
          "").split(n)
        ], s4 = g4 ? e3.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", o = g4 ? s4.split(n) : [""];
        return g4 && t2.indexOf(".") !== -1 && o[0] !== "" && o.unshift(""), {
          pathEnv: r6,
          pathExt: o,
          pathExtExe: s4
        };
      }, Z4 = (t2, e3, n) => {
        typeof e3 == "function" && (n = e3, e3 = {}), e3 || (e3 = {});
        let { pathEnv: r6, pathExt: s4, pathExtExe: o } = Q5(t2, e3), i2 = [], a3 = (u4) => new Promise((f3, p3) => {
          if (u4 === r6.length)
            return e3.all && i2.length ? f3(i2) : p3(J5(t2));
          let d4 = r6[u4], w5 = /^".*"$/.test(d4) ? d4.slice(1, -1) : d4, m4 = Y4.join(w5, t2), b6 = !w5 && /^\.[\\\/]/.test(t2) ? t2.slice(0, 2) + m4 : m4;
          f3(c2(b6, u4, 0));
        }), c2 = (u4, f3, p3) => new Promise((d4, w5) => {
          if (p3 === s4.length)
            return d4(a3(f3 + 1));
          let m4 = s4[p3];
          V4(u4 + m4, { pathExt: o }, (b6, Ot) => {
            if (!b6 && Ot)
              if (e3.all)
                i2.push(u4 + m4);
              else
                return d4(u4 + m4);
            return d4(c2(u4, f3, p3 + 1));
          });
        });
        return n ? a3(0).then((u4) => n(null, u4), n) : a3(0);
      }, Xt = (t2, e3) => {
        e3 = e3 || {};
        let { pathEnv: n, pathExt: r6, pathExtExe: s4 } = Q5(t2, e3), o = [];
        for (let i2 = 0; i2 < n.length; i2++) {
          let a3 = n[i2], c2 = /^".*"$/.test(a3) ? a3.slice(1, -1) : a3, u4 = Y4.join(c2, t2), f3 = !c2 && /^\.[\\\/]/.test(t2) ? t2.slice(0, 2) + u4 : u4;
          for (let p3 = 0; p3 < r6.length; p3++) {
            let d4 = f3 + r6[p3];
            try {
              if (V4.sync(d4, { pathExt: s4 }))
                if (e3.all)
                  o.push(d4);
                else
                  return d4;
            } catch {
            }
          }
        }
        if (e3.all && o.length)
          return o;
        if (e3.nothrow)
          return null;
        throw J5(t2);
      };
      tt.exports = Z4;
      Z4.sync = Xt;
    });
    rt = l2(($e2, _5) => {
      "use strict";
      var nt = (t2 = {}) => {
        let e3 = t2.env || process.env;
        return (t2.platform || process.platform) !== "win32" ? "PATH" : Object.keys(e3).reverse().find((r6) => r6.toUpperCase() === "PATH") || "Path";
      };
      _5.exports = nt;
      _5.exports.default = nt;
    });
    ct = l2((Ne2, it) => {
      "use strict";
      var st = h7("path"), Gt = et(), Ut = rt();
      function ot(t2, e3) {
        let n = t2.options.env || process.env, r6 = process.cwd(), s4 = t2.options.cwd != null, o = s4 && process.chdir !== void 0 && !process.chdir.disabled;
        if (o)
          try {
            process.chdir(t2.options.cwd);
          } catch {
          }
        let i2;
        try {
          i2 = Gt.sync(t2.command, {
            path: n[Ut({ env: n })],
            pathExt: e3 ? st.delimiter : void 0
          });
        } catch {
        } finally {
          o && process.chdir(r6);
        }
        return i2 && (i2 = st.resolve(s4 ? t2.options.cwd : "", i2)), i2;
      }
      function Yt(t2) {
        return ot(t2) || ot(t2, true);
      }
      it.exports = Yt;
    });
    ut = l2((qe, P5) => {
      "use strict";
      var C5 = /([()\][%!^"`<>&|;, *?])/g;
      function Vt(t2) {
        return t2 = t2.replace(C5, "^$1"), t2;
      }
      function Jt(t2, e3) {
        return t2 = `${t2}`, t2 = t2.replace(/(\\*)"/g, '$1$1\\"'), t2 = t2.replace(/(\\*)$/, "$1$1"), t2 = `"${t2}"`, t2 = t2.replace(C5, "^$1"), e3 && (t2 = t2.replace(C5, "^$1")), t2;
      }
      P5.exports.command = Vt;
      P5.exports.argument = Jt;
    });
    lt = l2((Ie2, at2) => {
      "use strict";
      at2.exports = /^#!(.*)/;
    });
    dt = l2((Le2, pt) => {
      "use strict";
      var Qt = lt();
      pt.exports = (t2 = "") => {
        let e3 = t2.match(Qt);
        if (!e3)
          return null;
        let [n, r6] = e3[0].replace(/#! ?/, "").split(" "), s4 = n.split("/").pop();
        return s4 === "env" ? r6 : r6 ? `${s4} ${r6}` : s4;
      };
    });
    ht = l2((je2, ft) => {
      "use strict";
      var O4 = h7("fs"), Zt = dt();
      function te3(t2) {
        let n = Buffer.alloc(150), r6;
        try {
          r6 = O4.openSync(t2, "r"), O4.readSync(r6, n, 0, 150, 0), O4.closeSync(r6);
        } catch {
        }
        return Zt(n.toString());
      }
      ft.exports = te3;
    });
    wt = l2((Fe2, Et) => {
      "use strict";
      var ee3 = h7("path"), mt = ct(), gt = ut(), ne3 = ht(), re3 = process.platform === "win32", se2 = /\.(?:com|exe)$/i, oe3 = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
      function ie3(t2) {
        t2.file = mt(t2);
        let e3 = t2.file && ne3(t2.file);
        return e3 ? (t2.args.unshift(t2.file), t2.command = e3, mt(t2)) : t2.file;
      }
      function ce2(t2) {
        if (!re3)
          return t2;
        let e3 = ie3(t2), n = !se2.test(e3);
        if (t2.options.forceShell || n) {
          let r6 = oe3.test(e3);
          t2.command = ee3.normalize(t2.command), t2.command = gt.command(t2.command), t2.args = t2.args.map((o) => gt.argument(o, r6));
          let s4 = [t2.command].concat(t2.args).join(" ");
          t2.args = ["/d", "/s", "/c", `"${s4}"`], t2.command = process.env.comspec || "cmd.exe", t2.options.windowsVerbatimArguments = true;
        }
        return t2;
      }
      function ue3(t2, e3, n) {
        e3 && !Array.isArray(e3) && (n = e3, e3 = null), e3 = e3 ? e3.slice(0) : [], n = Object.assign({}, n);
        let r6 = {
          command: t2,
          args: e3,
          options: n,
          file: void 0,
          original: {
            command: t2,
            args: e3
          }
        };
        return n.shell ? r6 : ce2(r6);
      }
      Et.exports = ue3;
    });
    bt = l2((ze2, vt) => {
      "use strict";
      var S6 = process.platform === "win32";
      function k4(t2, e3) {
        return Object.assign(new Error(`${e3} ${t2.command} ENOENT`), {
          code: "ENOENT",
          errno: "ENOENT",
          syscall: `${e3} ${t2.command}`,
          path: t2.command,
          spawnargs: t2.args
        });
      }
      function ae3(t2, e3) {
        if (!S6)
          return;
        let n = t2.emit;
        t2.emit = function(r6, s4) {
          if (r6 === "exit") {
            let o = xt(s4, e3, "spawn");
            if (o)
              return n.call(t2, "error", o);
          }
          return n.apply(t2, arguments);
        };
      }
      function xt(t2, e3) {
        return S6 && t2 === 1 && !e3.file ? k4(e3.original, "spawn") : null;
      }
      function le3(t2, e3) {
        return S6 && t2 === 1 && !e3.file ? k4(e3.original, "spawnSync") : null;
      }
      vt.exports = {
        hookChildProcess: ae3,
        verifyENOENT: xt,
        verifyENOENTSync: le3,
        notFoundError: k4
      };
    });
    Ct = l2((He2, E3) => {
      "use strict";
      var yt = h7("child_process"), T5 = wt(), A2 = bt();
      function _t(t2, e3, n) {
        let r6 = T5(t2, e3, n), s4 = yt.spawn(r6.command, r6.args, r6.options);
        return A2.hookChildProcess(s4, r6), s4;
      }
      function pe2(t2, e3, n) {
        let r6 = T5(t2, e3, n), s4 = yt.spawnSync(r6.command, r6.args, r6.options);
        return s4.error = s4.error || A2.verifyENOENTSync(s4.status, r6), s4;
      }
      E3.exports = _t;
      E3.exports.spawn = _t;
      E3.exports.sync = pe2;
      E3.exports._parse = T5;
      E3.exports._enoent = A2;
    });
    Lt = /^path$/i;
    q5 = { key: "PATH", value: "" };
    L3 = (t2) => {
      let e3 = t2.length, n = new import_stream.PassThrough(), r6 = () => {
        --e3 === 0 && n.emit("end");
      };
      for (let s4 of t2)
        s4.pipe(n, { end: false }), s4.on("end", r6);
      return n;
    };
    Pt = Nt(Ct(), 1);
    x4 = class extends Error {
      constructor(e3, n) {
        super(`Process exited with non-zero status (${e3.exitCode})`);
        __publicField(this, "result");
        __publicField(this, "output");
        this.result = e3, this.output = n;
      }
      get exitCode() {
        if (this.result.exitCode !== null)
          return this.result.exitCode;
      }
    };
    ge2 = {
      timeout: void 0,
      persist: false
    };
    Ee2 = {
      windowsHide: true
    };
    R3 = class {
      constructor(e3, n, r6) {
        __publicField(this, "_process");
        __publicField(this, "_aborted", false);
        __publicField(this, "_options");
        __publicField(this, "_command");
        __publicField(this, "_args");
        __publicField(this, "_resolveClose");
        __publicField(this, "_processClosed");
        __publicField(this, "_thrownError");
        __publicField(this, "_streamOut");
        __publicField(this, "_streamErr");
        __publicField(this, "_onError", (e3) => {
          if (e3.name === "AbortError" && (!(e3.cause instanceof Error) || e3.cause.name !== "TimeoutError")) {
            this._aborted = true;
            return;
          }
          this._thrownError = e3;
        });
        __publicField(this, "_onClose", () => {
          this._resolveClose && this._resolveClose();
        });
        this._options = {
          ...ge2,
          ...r6
        }, this._command = e3, this._args = n ?? [], this._processClosed = new Promise((s4) => {
          this._resolveClose = s4;
        });
      }
      get process() {
        return this._process;
      }
      get pid() {
        return this._process?.pid;
      }
      get exitCode() {
        if (this._process && this._process.exitCode !== null)
          return this._process.exitCode;
      }
      kill(e3) {
        return this._process?.kill(e3) === true;
      }
      get aborted() {
        return this._aborted;
      }
      get killed() {
        return this._process?.killed === true;
      }
      pipe(e3, n, r6) {
        return be2(e3, n, {
          ...r6,
          stdin: this
        });
      }
      async *[Symbol.asyncIterator]() {
        let e3 = this._process;
        if (!e3)
          return;
        let n = [];
        this._streamErr && n.push(this._streamErr), this._streamOut && n.push(this._streamOut);
        let r6 = L3(n), s4 = import_readline.default.createInterface({
          input: r6
        });
        for await (let o of s4)
          yield o.toString();
        if (await this._processClosed, e3.removeAllListeners(), this._thrownError)
          throw this._thrownError;
        if (this._options?.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0)
          throw new x4(this);
      }
      async _waitForOutput() {
        let e3 = this._process;
        if (!e3)
          throw new Error("No process was started");
        let n = "", r6 = "";
        if (this._streamOut)
          for await (let o of this._streamOut)
            r6 += o.toString();
        if (this._streamErr)
          for await (let o of this._streamErr)
            n += o.toString();
        if (await this._processClosed, this._options?.stdin && await this._options.stdin, e3.removeAllListeners(), this._thrownError)
          throw this._thrownError;
        let s4 = {
          stderr: n,
          stdout: r6,
          exitCode: this.exitCode
        };
        if (this._options.throwOnError && this.exitCode !== 0 && this.exitCode !== void 0)
          throw new x4(this, s4);
        return s4;
      }
      then(e3, n) {
        return this._waitForOutput().then(e3, n);
      }
      spawn() {
        let e3 = (0, import_process.cwd)(), n = this._options, r6 = {
          ...Ee2,
          ...n.nodeOptions
        }, s4 = [];
        this._resetState(), n.timeout !== void 0 && s4.push(AbortSignal.timeout(n.timeout)), n.signal !== void 0 && s4.push(n.signal), n.persist === true && (r6.detached = true), s4.length > 0 && (r6.signal = xe2(s4)), r6.env = I4(e3, r6.env);
        let { command: o, args: i2 } = we2(this._command, this._args), a3 = (0, Pt._parse)(o, i2, r6), c2 = (0, import_child_process.spawn)(
          a3.command,
          a3.args,
          a3.options
        );
        if (c2.stderr && (this._streamErr = c2.stderr), c2.stdout && (this._streamOut = c2.stdout), this._process = c2, c2.once("error", this._onError), c2.once("close", this._onClose), n.stdin !== void 0 && c2.stdin && n.stdin.process) {
          let { stdout: u4 } = n.stdin.process;
          u4 && u4.pipe(c2.stdin);
        }
      }
      _resetState() {
        this._aborted = false, this._processClosed = new Promise((e3) => {
          this._resolveClose = e3;
        }), this._thrownError = void 0;
      }
    };
    ve = (t2, e3, n) => {
      let r6 = new R3(t2, e3, n);
      return r6.spawn(), r6;
    };
    be2 = ve;
  }
});

// ../../node_modules/.pnpm/nypm@0.5.4/node_modules/nypm/dist/shared/nypm.BwVzLgAA.mjs
async function findup(cwd2, match, options = {}) {
  const segments = normalize(cwd2).split("/");
  while (segments.length > 0) {
    const path4 = segments.join("/") || "/";
    const result = await match(path4);
    if (result || !options.includeParentDirs) {
      return result;
    }
    segments.pop();
  }
}
function cached(fn2) {
  let v4;
  return () => {
    if (v4 === void 0) {
      v4 = fn2().then((r6) => {
        v4 = r6;
        return v4;
      });
    }
    return v4;
  };
}
async function executeCommand(command, args, options = {}) {
  const xArgs = command === "npm" || command === "bun" || command === "deno" || !await hasCorepack() ? [command, args] : ["corepack", [command, ...args]];
  await ve(xArgs[0], xArgs[1], {
    nodeOptions: {
      cwd: resolve2(options.cwd || process.cwd()),
      stdio: options.silent ? "pipe" : "inherit"
    }
  });
}
async function resolveOperationOptions(options = {}) {
  const cwd2 = options.cwd || process.cwd();
  const packageManager = (typeof options.packageManager === "string" ? packageManagers.find((pm) => pm.name === options.packageManager) : options.packageManager) || await detectPackageManager(options.cwd || process.cwd());
  if (!packageManager) {
    throw new Error(NO_PACKAGE_MANAGER_DETECTED_ERROR_MSG);
  }
  return {
    cwd: cwd2,
    silent: options.silent ?? false,
    packageManager,
    dev: options.dev ?? false,
    workspace: options.workspace,
    global: options.global ?? false
  };
}
function parsePackageManagerField(packageManager) {
  const [name, _version] = (packageManager || "").split("@");
  const [version2, buildMeta] = _version?.split("+") || [];
  if (name && name !== "-" && /^(@[a-z0-9-~][a-z0-9-._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$/.test(name)) {
    return { name, version: version2, buildMeta };
  }
  const sanitized = name.replace(/\W+/g, "");
  const warnings = [
    `Abnormal characters found in \`packageManager\` field, sanitizing from \`${name}\` to \`${sanitized}\``
  ];
  return {
    name: sanitized,
    version: version2,
    buildMeta,
    warnings
  };
}
async function detectPackageManager(cwd2, options = {}) {
  const detected = await findup(
    resolve2(cwd2 || "."),
    async (path4) => {
      if (!options.ignorePackageJSON) {
        const packageJSONPath = join(path4, "package.json");
        if ((0, import_node_fs4.existsSync)(packageJSONPath)) {
          const packageJSON = JSON.parse(
            await (0, import_promises3.readFile)(packageJSONPath, "utf8")
          );
          if (packageJSON?.packageManager) {
            const {
              name,
              version: version2 = "0.0.0",
              buildMeta,
              warnings
            } = parsePackageManagerField(packageJSON.packageManager);
            if (name) {
              const majorVersion = version2.split(".")[0];
              const packageManager = packageManagers.find(
                (pm) => pm.name === name && pm.majorVersion === majorVersion
              ) || packageManagers.find((pm) => pm.name === name);
              return {
                name,
                command: name,
                version: version2,
                majorVersion,
                buildMeta,
                warnings,
                ...packageManager
              };
            }
          }
        }
        const denoJSONPath = join(path4, "deno.json");
        if ((0, import_node_fs4.existsSync)(denoJSONPath)) {
          return packageManagers.find((pm) => pm.name === "deno");
        }
      }
      if (!options.ignoreLockFile) {
        for (const packageManager of packageManagers) {
          const detectionsFiles = [
            packageManager.lockFile,
            packageManager.files
          ].flat().filter(Boolean);
          if (detectionsFiles.some((file) => (0, import_node_fs4.existsSync)(resolve2(path4, file)))) {
            return {
              ...packageManager
            };
          }
        }
      }
    },
    {
      includeParentDirs: options.includeParentDirs ?? true
    }
  );
  if (!detected && !options.ignoreArgv) {
    const scriptArg = process.argv[1];
    if (scriptArg) {
      for (const packageManager of packageManagers) {
        const re3 = new RegExp(`[/\\\\]\\.?${packageManager.command}`);
        if (re3.test(scriptArg)) {
          return packageManager;
        }
      }
    }
  }
  return detected;
}
async function installDependencies(options = {}) {
  const resolvedOptions = await resolveOperationOptions(options);
  const pmToFrozenLockfileInstallCommand = {
    npm: ["ci"],
    yarn: ["install", "--immutable"],
    bun: ["install", "--frozen-lockfile"],
    pnpm: ["install", "--frozen-lockfile"],
    deno: ["install", "--frozen"]
  };
  const commandArgs = options.frozenLockFile ? pmToFrozenLockfileInstallCommand[resolvedOptions.packageManager.name] : ["install"];
  await executeCommand(resolvedOptions.packageManager.command, commandArgs, {
    cwd: resolvedOptions.cwd,
    silent: resolvedOptions.silent
  });
}
var import_node_module5, fs5, import_node_fs4, import_promises3, hasCorepack, NO_PACKAGE_MANAGER_DETECTED_ERROR_MSG, packageManagers;
var init_nypm_BwVzLgAA = __esm({
  "../../node_modules/.pnpm/nypm@0.5.4/node_modules/nypm/dist/shared/nypm.BwVzLgAA.mjs"() {
    "use strict";
    import_node_module5 = require("module");
    init_dist();
    init_main();
    fs5 = __toESM(require("fs"), 1);
    import_node_fs4 = require("fs");
    import_promises3 = require("fs/promises");
    hasCorepack = cached(async () => {
      if (globalThis.process?.versions?.webcontainer) {
        return false;
      }
      try {
        const { exitCode } = await ve("corepack", ["--version"]);
        return exitCode === 0;
      } catch {
        return false;
      }
    });
    NO_PACKAGE_MANAGER_DETECTED_ERROR_MSG = "No package manager auto-detected.";
    packageManagers = [
      {
        name: "npm",
        command: "npm",
        lockFile: "package-lock.json"
      },
      {
        name: "pnpm",
        command: "pnpm",
        lockFile: "pnpm-lock.yaml",
        files: ["pnpm-workspace.yaml"]
      },
      {
        name: "bun",
        command: "bun",
        lockFile: ["bun.lockb", "bun.lock"]
      },
      {
        name: "yarn",
        command: "yarn",
        majorVersion: "1",
        lockFile: "yarn.lock"
      },
      {
        name: "yarn",
        command: "yarn",
        majorVersion: "3",
        lockFile: "yarn.lock",
        files: [".yarnrc.yml"]
      },
      {
        name: "deno",
        command: "deno",
        lockFile: "deno.lock",
        files: ["deno.json"]
      }
    ];
  }
});

// ../../node_modules/.pnpm/nypm@0.5.4/node_modules/nypm/dist/index.mjs
var import_node_module6, import_node_fs5, import_promises4;
var init_dist6 = __esm({
  "../../node_modules/.pnpm/nypm@0.5.4/node_modules/nypm/dist/index.mjs"() {
    "use strict";
    init_nypm_BwVzLgAA();
    import_node_module6 = require("module");
    init_main();
    import_node_fs5 = require("fs");
    import_promises4 = require("fs/promises");
  }
});

// ../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/shared/node-fetch-native.DhEqb06g.cjs
var require_node_fetch_native_DhEqb06g = __commonJS({
  "../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/shared/node-fetch-native.DhEqb06g.cjs"(exports2) {
    "use strict";
    var l3 = Object.defineProperty;
    var o = (e3, t2) => l3(e3, "name", { value: t2, configurable: true });
    var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function getDefaultExportFromCjs(e3) {
      return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
    }
    o(getDefaultExportFromCjs, "getDefaultExportFromCjs"), exports2.commonjsGlobal = commonjsGlobal, exports2.getDefaultExportFromCjs = getDefaultExportFromCjs;
  }
});

// ../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs
var require_multipart_parser = __commonJS({
  "../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/chunks/multipart-parser.cjs"(exports2) {
    "use strict";
    var y3 = Object.defineProperty;
    var c2 = (R4, o) => y3(R4, "name", { value: o, configurable: true });
    var node = require_node();
    require("http"), require("https"), require("zlib"), require("stream"), require("buffer"), require("util"), require_node_fetch_native_DhEqb06g(), require("url"), require("net"), require("fs"), require("path");
    var s4 = 0;
    var S6 = { START_BOUNDARY: s4++, HEADER_FIELD_START: s4++, HEADER_FIELD: s4++, HEADER_VALUE_START: s4++, HEADER_VALUE: s4++, HEADER_VALUE_ALMOST_DONE: s4++, HEADERS_ALMOST_DONE: s4++, PART_DATA_START: s4++, PART_DATA: s4++, END: s4++ };
    var f3 = 1;
    var F2 = { PART_BOUNDARY: f3, LAST_BOUNDARY: f3 *= 2 };
    var LF = 10;
    var CR = 13;
    var SPACE = 32;
    var HYPHEN = 45;
    var COLON = 58;
    var A2 = 97;
    var Z4 = 122;
    var lower = c2((R4) => R4 | 32, "lower");
    var noop = c2(() => {
    }, "noop");
    var g4 = class g {
      constructor(o) {
        this.index = 0, this.flags = 0, this.onHeaderEnd = noop, this.onHeaderField = noop, this.onHeadersEnd = noop, this.onHeaderValue = noop, this.onPartBegin = noop, this.onPartData = noop, this.onPartEnd = noop, this.boundaryChars = {}, o = `\r
--` + o;
        const t2 = new Uint8Array(o.length);
        for (let n = 0; n < o.length; n++) t2[n] = o.charCodeAt(n), this.boundaryChars[t2[n]] = true;
        this.boundary = t2, this.lookbehind = new Uint8Array(this.boundary.length + 8), this.state = S6.START_BOUNDARY;
      }
      write(o) {
        let t2 = 0;
        const n = o.length;
        let E3 = this.index, { lookbehind: l3, boundary: h8, boundaryChars: H5, index: e3, state: a3, flags: d4 } = this;
        const b6 = this.boundary.length, m4 = b6 - 1, O4 = o.length;
        let r6, P5;
        const u4 = c2((D3) => {
          this[D3 + "Mark"] = t2;
        }, "mark"), i2 = c2((D3) => {
          delete this[D3 + "Mark"];
        }, "clear"), T5 = c2((D3, p3, _5, N6) => {
          (p3 === void 0 || p3 !== _5) && this[D3](N6 && N6.subarray(p3, _5));
        }, "callback"), L4 = c2((D3, p3) => {
          const _5 = D3 + "Mark";
          _5 in this && (p3 ? (T5(D3, this[_5], t2, o), delete this[_5]) : (T5(D3, this[_5], o.length, o), this[_5] = 0));
        }, "dataCallback");
        for (t2 = 0; t2 < n; t2++) switch (r6 = o[t2], a3) {
          case S6.START_BOUNDARY:
            if (e3 === h8.length - 2) {
              if (r6 === HYPHEN) d4 |= F2.LAST_BOUNDARY;
              else if (r6 !== CR) return;
              e3++;
              break;
            } else if (e3 - 1 === h8.length - 2) {
              if (d4 & F2.LAST_BOUNDARY && r6 === HYPHEN) a3 = S6.END, d4 = 0;
              else if (!(d4 & F2.LAST_BOUNDARY) && r6 === LF) e3 = 0, T5("onPartBegin"), a3 = S6.HEADER_FIELD_START;
              else return;
              break;
            }
            r6 !== h8[e3 + 2] && (e3 = -2), r6 === h8[e3 + 2] && e3++;
            break;
          case S6.HEADER_FIELD_START:
            a3 = S6.HEADER_FIELD, u4("onHeaderField"), e3 = 0;
          case S6.HEADER_FIELD:
            if (r6 === CR) {
              i2("onHeaderField"), a3 = S6.HEADERS_ALMOST_DONE;
              break;
            }
            if (e3++, r6 === HYPHEN) break;
            if (r6 === COLON) {
              if (e3 === 1) return;
              L4("onHeaderField", true), a3 = S6.HEADER_VALUE_START;
              break;
            }
            if (P5 = lower(r6), P5 < A2 || P5 > Z4) return;
            break;
          case S6.HEADER_VALUE_START:
            if (r6 === SPACE) break;
            u4("onHeaderValue"), a3 = S6.HEADER_VALUE;
          case S6.HEADER_VALUE:
            r6 === CR && (L4("onHeaderValue", true), T5("onHeaderEnd"), a3 = S6.HEADER_VALUE_ALMOST_DONE);
            break;
          case S6.HEADER_VALUE_ALMOST_DONE:
            if (r6 !== LF) return;
            a3 = S6.HEADER_FIELD_START;
            break;
          case S6.HEADERS_ALMOST_DONE:
            if (r6 !== LF) return;
            T5("onHeadersEnd"), a3 = S6.PART_DATA_START;
            break;
          case S6.PART_DATA_START:
            a3 = S6.PART_DATA, u4("onPartData");
          case S6.PART_DATA:
            if (E3 = e3, e3 === 0) {
              for (t2 += m4; t2 < O4 && !(o[t2] in H5); ) t2 += b6;
              t2 -= m4, r6 = o[t2];
            }
            if (e3 < h8.length) h8[e3] === r6 ? (e3 === 0 && L4("onPartData", true), e3++) : e3 = 0;
            else if (e3 === h8.length) e3++, r6 === CR ? d4 |= F2.PART_BOUNDARY : r6 === HYPHEN ? d4 |= F2.LAST_BOUNDARY : e3 = 0;
            else if (e3 - 1 === h8.length) if (d4 & F2.PART_BOUNDARY) {
              if (e3 = 0, r6 === LF) {
                d4 &= ~F2.PART_BOUNDARY, T5("onPartEnd"), T5("onPartBegin"), a3 = S6.HEADER_FIELD_START;
                break;
              }
            } else d4 & F2.LAST_BOUNDARY && r6 === HYPHEN ? (T5("onPartEnd"), a3 = S6.END, d4 = 0) : e3 = 0;
            if (e3 > 0) l3[e3 - 1] = r6;
            else if (E3 > 0) {
              const D3 = new Uint8Array(l3.buffer, l3.byteOffset, l3.byteLength);
              T5("onPartData", 0, E3, D3), E3 = 0, u4("onPartData"), t2--;
            }
            break;
          case S6.END:
            break;
          default:
            throw new Error(`Unexpected state entered: ${a3}`);
        }
        L4("onHeaderField"), L4("onHeaderValue"), L4("onPartData"), this.index = e3, this.state = a3, this.flags = d4;
      }
      end() {
        if (this.state === S6.HEADER_FIELD_START && this.index === 0 || this.state === S6.PART_DATA && this.index === this.boundary.length) this.onPartEnd();
        else if (this.state !== S6.END) throw new Error("MultipartParser.end(): stream ended unexpectedly");
      }
    };
    c2(g4, "MultipartParser");
    var MultipartParser = g4;
    function _fileName(R4) {
      const o = R4.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
      if (!o) return;
      const t2 = o[2] || o[3] || "";
      let n = t2.slice(t2.lastIndexOf("\\") + 1);
      return n = n.replace(/%22/g, '"'), n = n.replace(/&#(\d{4});/g, (E3, l3) => String.fromCharCode(l3)), n;
    }
    c2(_fileName, "_fileName");
    async function toFormData(R4, o) {
      if (!/multipart/i.test(o)) throw new TypeError("Failed to fetch");
      const t2 = o.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
      if (!t2) throw new TypeError("no or bad content-type header, no multipart boundary");
      const n = new MultipartParser(t2[1] || t2[2]);
      let E3, l3, h8, H5, e3, a3;
      const d4 = [], b6 = new node.FormData(), m4 = c2((i2) => {
        h8 += u4.decode(i2, { stream: true });
      }, "onPartData"), O4 = c2((i2) => {
        d4.push(i2);
      }, "appendToFile"), r6 = c2(() => {
        const i2 = new node.File(d4, a3, { type: e3 });
        b6.append(H5, i2);
      }, "appendFileToFormData"), P5 = c2(() => {
        b6.append(H5, h8);
      }, "appendEntryToFormData"), u4 = new TextDecoder("utf-8");
      u4.decode(), n.onPartBegin = function() {
        n.onPartData = m4, n.onPartEnd = P5, E3 = "", l3 = "", h8 = "", H5 = "", e3 = "", a3 = null, d4.length = 0;
      }, n.onHeaderField = function(i2) {
        E3 += u4.decode(i2, { stream: true });
      }, n.onHeaderValue = function(i2) {
        l3 += u4.decode(i2, { stream: true });
      }, n.onHeaderEnd = function() {
        if (l3 += u4.decode(), E3 = E3.toLowerCase(), E3 === "content-disposition") {
          const i2 = l3.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
          i2 && (H5 = i2[2] || i2[3] || ""), a3 = _fileName(l3), a3 && (n.onPartData = O4, n.onPartEnd = r6);
        } else E3 === "content-type" && (e3 = l3);
        l3 = "", E3 = "";
      };
      for await (const i2 of R4) n.write(i2);
      return n.end(), b6;
    }
    c2(toFormData, "toFormData"), exports2.toFormData = toFormData;
  }
});

// ../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/node.cjs
var require_node = __commonJS({
  "../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/node.cjs"(exports2) {
    "use strict";
    var ys = Object.defineProperty;
    var Po = (c2) => {
      throw TypeError(c2);
    };
    var u4 = (c2, l3) => ys(c2, "name", { value: l3, configurable: true });
    var vo = (c2, l3, d4) => l3.has(c2) || Po("Cannot " + d4);
    var D3 = (c2, l3, d4) => (vo(c2, l3, "read from private field"), d4 ? d4.call(c2) : l3.get(c2));
    var ye2 = (c2, l3, d4) => l3.has(c2) ? Po("Cannot add the same private member more than once") : l3 instanceof WeakSet ? l3.add(c2) : l3.set(c2, d4);
    var ne3 = (c2, l3, d4, g4) => (vo(c2, l3, "write to private field"), g4 ? g4.call(c2, d4) : l3.set(c2, d4), d4);
    var Pe2;
    var gt;
    var ot;
    var Zt;
    var Oe2;
    var _t;
    var St2;
    var it;
    var oe3;
    var st;
    var xe3;
    var Ue2;
    var at2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    var http2 = require("http");
    var https = require("https");
    var zlib = require("zlib");
    var Stream = require("stream");
    var require$$0 = require("buffer");
    var require$$0$1 = require("util");
    var _commonjsHelpers = require_node_fetch_native_DhEqb06g();
    var require$$1 = require("url");
    var require$$0$2 = require("net");
    var node_fs = require("fs");
    var node_path = require("path");
    function _interopDefaultCompat(c2) {
      return c2 && typeof c2 == "object" && "default" in c2 ? c2.default : c2;
    }
    u4(_interopDefaultCompat, "_interopDefaultCompat");
    var http__default = _interopDefaultCompat(http2);
    var https__default = _interopDefaultCompat(https);
    var zlib__default = _interopDefaultCompat(zlib);
    var Stream__default = _interopDefaultCompat(Stream);
    function dataUriToBuffer(c2) {
      if (!/^data:/i.test(c2)) throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      c2 = c2.replace(/\r?\n/g, "");
      const l3 = c2.indexOf(",");
      if (l3 === -1 || l3 <= 4) throw new TypeError("malformed data: URI");
      const d4 = c2.substring(5, l3).split(";");
      let g4 = "", b6 = false;
      const R4 = d4[0] || "text/plain";
      let w5 = R4;
      for (let I5 = 1; I5 < d4.length; I5++) d4[I5] === "base64" ? b6 = true : d4[I5] && (w5 += `;${d4[I5]}`, d4[I5].indexOf("charset=") === 0 && (g4 = d4[I5].substring(8)));
      !d4[0] && !g4.length && (w5 += ";charset=US-ASCII", g4 = "US-ASCII");
      const A2 = b6 ? "base64" : "ascii", z4 = unescape(c2.substring(l3 + 1)), B3 = Buffer.from(z4, A2);
      return B3.type = R4, B3.typeFull = w5, B3.charset = g4, B3;
    }
    u4(dataUriToBuffer, "dataUriToBuffer");
    var streams = {};
    var ponyfill_es2018$1 = { exports: {} };
    var ponyfill_es2018 = ponyfill_es2018$1.exports;
    var hasRequiredPonyfill_es2018;
    function requirePonyfill_es2018() {
      return hasRequiredPonyfill_es2018 || (hasRequiredPonyfill_es2018 = 1, (function(c2, l3) {
        (function(d4, g4) {
          g4(l3);
        })(ponyfill_es2018, function(d4) {
          function g4() {
          }
          u4(g4, "noop");
          function b6(n) {
            return typeof n == "object" && n !== null || typeof n == "function";
          }
          u4(b6, "typeIsObject");
          const R4 = g4;
          function w5(n, o) {
            try {
              Object.defineProperty(n, "name", { value: o, configurable: true });
            } catch {
            }
          }
          u4(w5, "setFunctionName");
          const A2 = Promise, z4 = Promise.prototype.then, B3 = Promise.reject.bind(A2);
          function I5(n) {
            return new A2(n);
          }
          u4(I5, "newPromise");
          function k4(n) {
            return I5((o) => o(n));
          }
          u4(k4, "promiseResolvedWith");
          function T5(n) {
            return B3(n);
          }
          u4(T5, "promiseRejectedWith");
          function $6(n, o, a3) {
            return z4.call(n, o, a3);
          }
          u4($6, "PerformPromiseThen");
          function v4(n, o, a3) {
            $6($6(n, o, a3), void 0, R4);
          }
          u4(v4, "uponPromise");
          function K4(n, o) {
            v4(n, o);
          }
          u4(K4, "uponFulfillment");
          function U6(n, o) {
            v4(n, void 0, o);
          }
          u4(U6, "uponRejection");
          function N6(n, o, a3) {
            return $6(n, o, a3);
          }
          u4(N6, "transformPromiseWith");
          function J5(n) {
            $6(n, void 0, R4);
          }
          u4(J5, "setPromiseIsHandledToTrue");
          let ge3 = u4((n) => {
            if (typeof queueMicrotask == "function") ge3 = queueMicrotask;
            else {
              const o = k4(void 0);
              ge3 = u4((a3) => $6(o, a3), "_queueMicrotask");
            }
            return ge3(n);
          }, "_queueMicrotask");
          function M4(n, o, a3) {
            if (typeof n != "function") throw new TypeError("Argument is not a function");
            return Function.prototype.apply.call(n, o, a3);
          }
          u4(M4, "reflectCall");
          function H5(n, o, a3) {
            try {
              return k4(M4(n, o, a3));
            } catch (p3) {
              return T5(p3);
            }
          }
          u4(H5, "promiseCall");
          const Y4 = 16384, Dr = class Dr {
            constructor() {
              this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
            }
            get length() {
              return this._size;
            }
            push(o) {
              const a3 = this._back;
              let p3 = a3;
              a3._elements.length === Y4 - 1 && (p3 = { _elements: [], _next: void 0 }), a3._elements.push(o), p3 !== a3 && (this._back = p3, a3._next = p3), ++this._size;
            }
            shift() {
              const o = this._front;
              let a3 = o;
              const p3 = this._cursor;
              let y3 = p3 + 1;
              const _5 = o._elements, S6 = _5[p3];
              return y3 === Y4 && (a3 = o._next, y3 = 0), --this._size, this._cursor = y3, o !== a3 && (this._front = a3), _5[p3] = void 0, S6;
            }
            forEach(o) {
              let a3 = this._cursor, p3 = this._front, y3 = p3._elements;
              for (; (a3 !== y3.length || p3._next !== void 0) && !(a3 === y3.length && (p3 = p3._next, y3 = p3._elements, a3 = 0, y3.length === 0)); ) o(y3[a3]), ++a3;
            }
            peek() {
              const o = this._front, a3 = this._cursor;
              return o._elements[a3];
            }
          };
          u4(Dr, "SimpleQueue");
          let Q5 = Dr;
          const wt2 = Symbol("[[AbortSteps]]"), un2 = Symbol("[[ErrorSteps]]"), er2 = Symbol("[[CancelSteps]]"), tr2 = Symbol("[[PullSteps]]"), rr2 = Symbol("[[ReleaseSteps]]");
          function ln2(n, o) {
            n._ownerReadableStream = o, o._reader = n, o._state === "readable" ? or2(n) : o._state === "closed" ? Eo(n) : fn2(n, o._storedError);
          }
          u4(ln2, "ReadableStreamReaderGenericInitialize");
          function nr2(n, o) {
            const a3 = n._ownerReadableStream;
            return le3(a3, o);
          }
          u4(nr2, "ReadableStreamReaderGenericCancel");
          function _e2(n) {
            const o = n._ownerReadableStream;
            o._state === "readable" ? ir2(n, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : Ao(n, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), o._readableStreamController[rr2](), o._reader = void 0, n._ownerReadableStream = void 0;
          }
          u4(_e2, "ReadableStreamReaderGenericRelease");
          function Rt2(n) {
            return new TypeError("Cannot " + n + " a stream using a released reader");
          }
          u4(Rt2, "readerLockException");
          function or2(n) {
            n._closedPromise = I5((o, a3) => {
              n._closedPromise_resolve = o, n._closedPromise_reject = a3;
            });
          }
          u4(or2, "defaultReaderClosedPromiseInitialize");
          function fn2(n, o) {
            or2(n), ir2(n, o);
          }
          u4(fn2, "defaultReaderClosedPromiseInitializeAsRejected");
          function Eo(n) {
            or2(n), cn2(n);
          }
          u4(Eo, "defaultReaderClosedPromiseInitializeAsResolved");
          function ir2(n, o) {
            n._closedPromise_reject !== void 0 && (J5(n._closedPromise), n._closedPromise_reject(o), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0);
          }
          u4(ir2, "defaultReaderClosedPromiseReject");
          function Ao(n, o) {
            fn2(n, o);
          }
          u4(Ao, "defaultReaderClosedPromiseResetToRejected");
          function cn2(n) {
            n._closedPromise_resolve !== void 0 && (n._closedPromise_resolve(void 0), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0);
          }
          u4(cn2, "defaultReaderClosedPromiseResolve");
          const dn2 = Number.isFinite || function(n) {
            return typeof n == "number" && isFinite(n);
          }, Bo = Math.trunc || function(n) {
            return n < 0 ? Math.ceil(n) : Math.floor(n);
          };
          function qo(n) {
            return typeof n == "object" || typeof n == "function";
          }
          u4(qo, "isDictionary");
          function ce2(n, o) {
            if (n !== void 0 && !qo(n)) throw new TypeError(`${o} is not an object.`);
          }
          u4(ce2, "assertDictionary");
          function ee3(n, o) {
            if (typeof n != "function") throw new TypeError(`${o} is not a function.`);
          }
          u4(ee3, "assertFunction");
          function ko(n) {
            return typeof n == "object" && n !== null || typeof n == "function";
          }
          u4(ko, "isObject");
          function hn2(n, o) {
            if (!ko(n)) throw new TypeError(`${o} is not an object.`);
          }
          u4(hn2, "assertObject");
          function Se2(n, o, a3) {
            if (n === void 0) throw new TypeError(`Parameter ${o} is required in '${a3}'.`);
          }
          u4(Se2, "assertRequiredArgument");
          function sr2(n, o, a3) {
            if (n === void 0) throw new TypeError(`${o} is required in '${a3}'.`);
          }
          u4(sr2, "assertRequiredField");
          function ar2(n) {
            return Number(n);
          }
          u4(ar2, "convertUnrestrictedDouble");
          function pn2(n) {
            return n === 0 ? 0 : n;
          }
          u4(pn2, "censorNegativeZero");
          function Wo(n) {
            return pn2(Bo(n));
          }
          u4(Wo, "integerPart");
          function ur2(n, o) {
            const p3 = Number.MAX_SAFE_INTEGER;
            let y3 = Number(n);
            if (y3 = pn2(y3), !dn2(y3)) throw new TypeError(`${o} is not a finite number`);
            if (y3 = Wo(y3), y3 < 0 || y3 > p3) throw new TypeError(`${o} is outside the accepted range of 0 to ${p3}, inclusive`);
            return !dn2(y3) || y3 === 0 ? 0 : y3;
          }
          u4(ur2, "convertUnsignedLongLongWithEnforceRange");
          function lr2(n, o) {
            if (!qe(n)) throw new TypeError(`${o} is not a ReadableStream.`);
          }
          u4(lr2, "assertReadableStream");
          function Ne2(n) {
            return new de3(n);
          }
          u4(Ne2, "AcquireReadableStreamDefaultReader");
          function bn2(n, o) {
            n._reader._readRequests.push(o);
          }
          u4(bn2, "ReadableStreamAddReadRequest");
          function fr2(n, o, a3) {
            const y3 = n._reader._readRequests.shift();
            a3 ? y3._closeSteps() : y3._chunkSteps(o);
          }
          u4(fr2, "ReadableStreamFulfillReadRequest");
          function Tt2(n) {
            return n._reader._readRequests.length;
          }
          u4(Tt2, "ReadableStreamGetNumReadRequests");
          function mn2(n) {
            const o = n._reader;
            return !(o === void 0 || !ve2(o));
          }
          u4(mn2, "ReadableStreamHasDefaultReader");
          const Mr = class Mr {
            constructor(o) {
              if (Se2(o, 1, "ReadableStreamDefaultReader"), lr2(o, "First parameter"), ke2(o)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              ln2(this, o), this._readRequests = new Q5();
            }
            get closed() {
              return ve2(this) ? this._closedPromise : T5(Ct2("closed"));
            }
            cancel(o = void 0) {
              return ve2(this) ? this._ownerReadableStream === void 0 ? T5(Rt2("cancel")) : nr2(this, o) : T5(Ct2("cancel"));
            }
            read() {
              if (!ve2(this)) return T5(Ct2("read"));
              if (this._ownerReadableStream === void 0) return T5(Rt2("read from"));
              let o, a3;
              const p3 = I5((_5, S6) => {
                o = _5, a3 = S6;
              });
              return ut2(this, { _chunkSteps: u4((_5) => o({ value: _5, done: false }), "_chunkSteps"), _closeSteps: u4(() => o({ value: void 0, done: true }), "_closeSteps"), _errorSteps: u4((_5) => a3(_5), "_errorSteps") }), p3;
            }
            releaseLock() {
              if (!ve2(this)) throw Ct2("releaseLock");
              this._ownerReadableStream !== void 0 && Oo(this);
            }
          };
          u4(Mr, "ReadableStreamDefaultReader");
          let de3 = Mr;
          Object.defineProperties(de3.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), w5(de3.prototype.cancel, "cancel"), w5(de3.prototype.read, "read"), w5(de3.prototype.releaseLock, "releaseLock"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(de3.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
          function ve2(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_readRequests") ? false : n instanceof de3;
          }
          u4(ve2, "IsReadableStreamDefaultReader");
          function ut2(n, o) {
            const a3 = n._ownerReadableStream;
            a3._disturbed = true, a3._state === "closed" ? o._closeSteps() : a3._state === "errored" ? o._errorSteps(a3._storedError) : a3._readableStreamController[tr2](o);
          }
          u4(ut2, "ReadableStreamDefaultReaderRead");
          function Oo(n) {
            _e2(n);
            const o = new TypeError("Reader was released");
            yn2(n, o);
          }
          u4(Oo, "ReadableStreamDefaultReaderRelease");
          function yn2(n, o) {
            const a3 = n._readRequests;
            n._readRequests = new Q5(), a3.forEach((p3) => {
              p3._errorSteps(o);
            });
          }
          u4(yn2, "ReadableStreamDefaultReaderErrorReadRequests");
          function Ct2(n) {
            return new TypeError(`ReadableStreamDefaultReader.prototype.${n} can only be used on a ReadableStreamDefaultReader`);
          }
          u4(Ct2, "defaultReaderBrandCheckException");
          const zo = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
          }).prototype), xr2 = class xr {
            constructor(o, a3) {
              this._ongoingPromise = void 0, this._isFinished = false, this._reader = o, this._preventCancel = a3;
            }
            next() {
              const o = u4(() => this._nextSteps(), "nextSteps");
              return this._ongoingPromise = this._ongoingPromise ? N6(this._ongoingPromise, o, o) : o(), this._ongoingPromise;
            }
            return(o) {
              const a3 = u4(() => this._returnSteps(o), "returnSteps");
              return this._ongoingPromise ? N6(this._ongoingPromise, a3, a3) : a3();
            }
            _nextSteps() {
              if (this._isFinished) return Promise.resolve({ value: void 0, done: true });
              const o = this._reader;
              let a3, p3;
              const y3 = I5((S6, C5) => {
                a3 = S6, p3 = C5;
              });
              return ut2(o, { _chunkSteps: u4((S6) => {
                this._ongoingPromise = void 0, ge3(() => a3({ value: S6, done: false }));
              }, "_chunkSteps"), _closeSteps: u4(() => {
                this._ongoingPromise = void 0, this._isFinished = true, _e2(o), a3({ value: void 0, done: true });
              }, "_closeSteps"), _errorSteps: u4((S6) => {
                this._ongoingPromise = void 0, this._isFinished = true, _e2(o), p3(S6);
              }, "_errorSteps") }), y3;
            }
            _returnSteps(o) {
              if (this._isFinished) return Promise.resolve({ value: o, done: true });
              this._isFinished = true;
              const a3 = this._reader;
              if (!this._preventCancel) {
                const p3 = nr2(a3, o);
                return _e2(a3), N6(p3, () => ({ value: o, done: true }));
              }
              return _e2(a3), k4({ value: o, done: true });
            }
          };
          u4(xr2, "ReadableStreamAsyncIteratorImpl");
          let Pt2 = xr2;
          const gn2 = { next() {
            return _n2(this) ? this._asyncIteratorImpl.next() : T5(Sn2("next"));
          }, return(n) {
            return _n2(this) ? this._asyncIteratorImpl.return(n) : T5(Sn2("return"));
          } };
          Object.setPrototypeOf(gn2, zo);
          function Fo(n, o) {
            const a3 = Ne2(n), p3 = new Pt2(a3, o), y3 = Object.create(gn2);
            return y3._asyncIteratorImpl = p3, y3;
          }
          u4(Fo, "AcquireReadableStreamAsyncIterator");
          function _n2(n) {
            if (!b6(n) || !Object.prototype.hasOwnProperty.call(n, "_asyncIteratorImpl")) return false;
            try {
              return n._asyncIteratorImpl instanceof Pt2;
            } catch {
              return false;
            }
          }
          u4(_n2, "IsReadableStreamAsyncIterator");
          function Sn2(n) {
            return new TypeError(`ReadableStreamAsyncIterator.${n} can only be used on a ReadableSteamAsyncIterator`);
          }
          u4(Sn2, "streamAsyncIteratorBrandCheckException");
          const wn2 = Number.isNaN || function(n) {
            return n !== n;
          };
          var cr2, dr2, hr2;
          function lt2(n) {
            return n.slice();
          }
          u4(lt2, "CreateArrayFromList");
          function Rn2(n, o, a3, p3, y3) {
            new Uint8Array(n).set(new Uint8Array(a3, p3, y3), o);
          }
          u4(Rn2, "CopyDataBlockBytes");
          let we3 = u4((n) => (typeof n.transfer == "function" ? we3 = u4((o) => o.transfer(), "TransferArrayBuffer") : typeof structuredClone == "function" ? we3 = u4((o) => structuredClone(o, { transfer: [o] }), "TransferArrayBuffer") : we3 = u4((o) => o, "TransferArrayBuffer"), we3(n)), "TransferArrayBuffer"), Ee3 = u4((n) => (typeof n.detached == "boolean" ? Ee3 = u4((o) => o.detached, "IsDetachedBuffer") : Ee3 = u4((o) => o.byteLength === 0, "IsDetachedBuffer"), Ee3(n)), "IsDetachedBuffer");
          function Tn2(n, o, a3) {
            if (n.slice) return n.slice(o, a3);
            const p3 = a3 - o, y3 = new ArrayBuffer(p3);
            return Rn2(y3, 0, n, o, p3), y3;
          }
          u4(Tn2, "ArrayBufferSlice");
          function vt(n, o) {
            const a3 = n[o];
            if (a3 != null) {
              if (typeof a3 != "function") throw new TypeError(`${String(o)} is not a function`);
              return a3;
            }
          }
          u4(vt, "GetMethod");
          function Io(n) {
            const o = { [Symbol.iterator]: () => n.iterator }, a3 = (async function* () {
              return yield* o;
            })(), p3 = a3.next;
            return { iterator: a3, nextMethod: p3, done: false };
          }
          u4(Io, "CreateAsyncFromSyncIterator");
          const pr2 = (hr2 = (cr2 = Symbol.asyncIterator) !== null && cr2 !== void 0 ? cr2 : (dr2 = Symbol.for) === null || dr2 === void 0 ? void 0 : dr2.call(Symbol, "Symbol.asyncIterator")) !== null && hr2 !== void 0 ? hr2 : "@@asyncIterator";
          function Cn2(n, o = "sync", a3) {
            if (a3 === void 0) if (o === "async") {
              if (a3 = vt(n, pr2), a3 === void 0) {
                const _5 = vt(n, Symbol.iterator), S6 = Cn2(n, "sync", _5);
                return Io(S6);
              }
            } else a3 = vt(n, Symbol.iterator);
            if (a3 === void 0) throw new TypeError("The object is not iterable");
            const p3 = M4(a3, n, []);
            if (!b6(p3)) throw new TypeError("The iterator method must return an object");
            const y3 = p3.next;
            return { iterator: p3, nextMethod: y3, done: false };
          }
          u4(Cn2, "GetIterator");
          function jo(n) {
            const o = M4(n.nextMethod, n.iterator, []);
            if (!b6(o)) throw new TypeError("The iterator.next() method must return an object");
            return o;
          }
          u4(jo, "IteratorNext");
          function Lo(n) {
            return !!n.done;
          }
          u4(Lo, "IteratorComplete");
          function $o(n) {
            return n.value;
          }
          u4($o, "IteratorValue");
          function Do(n) {
            return !(typeof n != "number" || wn2(n) || n < 0);
          }
          u4(Do, "IsNonNegativeNumber");
          function Pn2(n) {
            const o = Tn2(n.buffer, n.byteOffset, n.byteOffset + n.byteLength);
            return new Uint8Array(o);
          }
          u4(Pn2, "CloneAsUint8Array");
          function br(n) {
            const o = n._queue.shift();
            return n._queueTotalSize -= o.size, n._queueTotalSize < 0 && (n._queueTotalSize = 0), o.value;
          }
          u4(br, "DequeueValue");
          function mr2(n, o, a3) {
            if (!Do(a3) || a3 === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
            n._queue.push({ value: o, size: a3 }), n._queueTotalSize += a3;
          }
          u4(mr2, "EnqueueValueWithSize");
          function Mo(n) {
            return n._queue.peek().value;
          }
          u4(Mo, "PeekQueueValue");
          function Ae(n) {
            n._queue = new Q5(), n._queueTotalSize = 0;
          }
          u4(Ae, "ResetQueue");
          function vn2(n) {
            return n === DataView;
          }
          u4(vn2, "isDataViewConstructor");
          function xo(n) {
            return vn2(n.constructor);
          }
          u4(xo, "isDataView");
          function Uo(n) {
            return vn2(n) ? 1 : n.BYTES_PER_ELEMENT;
          }
          u4(Uo, "arrayBufferViewElementSize");
          const Ur = class Ur {
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get view() {
              if (!yr(this)) throw Rr("view");
              return this._view;
            }
            respond(o) {
              if (!yr(this)) throw Rr("respond");
              if (Se2(o, 1, "respond"), o = ur2(o, "First parameter"), this._associatedReadableByteStreamController === void 0) throw new TypeError("This BYOB request has been invalidated");
              if (Ee3(this._view.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
              qt2(this._associatedReadableByteStreamController, o);
            }
            respondWithNewView(o) {
              if (!yr(this)) throw Rr("respondWithNewView");
              if (Se2(o, 1, "respondWithNewView"), !ArrayBuffer.isView(o)) throw new TypeError("You can only respond with array buffer views");
              if (this._associatedReadableByteStreamController === void 0) throw new TypeError("This BYOB request has been invalidated");
              if (Ee3(o.buffer)) throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
              kt2(this._associatedReadableByteStreamController, o);
            }
          };
          u4(Ur, "ReadableStreamBYOBRequest");
          let Re2 = Ur;
          Object.defineProperties(Re2.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), w5(Re2.prototype.respond, "respond"), w5(Re2.prototype.respondWithNewView, "respondWithNewView"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Re2.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
          const Nr = class Nr {
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get byobRequest() {
              if (!ze2(this)) throw ct2("byobRequest");
              return wr(this);
            }
            get desiredSize() {
              if (!ze2(this)) throw ct2("desiredSize");
              return In2(this);
            }
            close() {
              if (!ze2(this)) throw ct2("close");
              if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
              const o = this._controlledReadableByteStream._state;
              if (o !== "readable") throw new TypeError(`The stream (in ${o} state) is not in the readable state and cannot be closed`);
              ft(this);
            }
            enqueue(o) {
              if (!ze2(this)) throw ct2("enqueue");
              if (Se2(o, 1, "enqueue"), !ArrayBuffer.isView(o)) throw new TypeError("chunk must be an array buffer view");
              if (o.byteLength === 0) throw new TypeError("chunk must have non-zero byteLength");
              if (o.buffer.byteLength === 0) throw new TypeError("chunk's buffer must have non-zero byteLength");
              if (this._closeRequested) throw new TypeError("stream is closed or draining");
              const a3 = this._controlledReadableByteStream._state;
              if (a3 !== "readable") throw new TypeError(`The stream (in ${a3} state) is not in the readable state and cannot be enqueued to`);
              Bt(this, o);
            }
            error(o = void 0) {
              if (!ze2(this)) throw ct2("error");
              te3(this, o);
            }
            [er2](o) {
              En2(this), Ae(this);
              const a3 = this._cancelAlgorithm(o);
              return At2(this), a3;
            }
            [tr2](o) {
              const a3 = this._controlledReadableByteStream;
              if (this._queueTotalSize > 0) {
                Fn2(this, o);
                return;
              }
              const p3 = this._autoAllocateChunkSize;
              if (p3 !== void 0) {
                let y3;
                try {
                  y3 = new ArrayBuffer(p3);
                } catch (S6) {
                  o._errorSteps(S6);
                  return;
                }
                const _5 = { buffer: y3, bufferByteLength: p3, byteOffset: 0, byteLength: p3, bytesFilled: 0, minimumFill: 1, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
                this._pendingPullIntos.push(_5);
              }
              bn2(a3, o), Fe2(this);
            }
            [rr2]() {
              if (this._pendingPullIntos.length > 0) {
                const o = this._pendingPullIntos.peek();
                o.readerType = "none", this._pendingPullIntos = new Q5(), this._pendingPullIntos.push(o);
              }
            }
          };
          u4(Nr, "ReadableByteStreamController");
          let ie3 = Nr;
          Object.defineProperties(ie3.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), w5(ie3.prototype.close, "close"), w5(ie3.prototype.enqueue, "enqueue"), w5(ie3.prototype.error, "error"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(ie3.prototype, Symbol.toStringTag, { value: "ReadableByteStreamController", configurable: true });
          function ze2(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_controlledReadableByteStream") ? false : n instanceof ie3;
          }
          u4(ze2, "IsReadableByteStreamController");
          function yr(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_associatedReadableByteStreamController") ? false : n instanceof Re2;
          }
          u4(yr, "IsReadableStreamBYOBRequest");
          function Fe2(n) {
            if (!Yo(n)) return;
            if (n._pulling) {
              n._pullAgain = true;
              return;
            }
            n._pulling = true;
            const a3 = n._pullAlgorithm();
            v4(a3, () => (n._pulling = false, n._pullAgain && (n._pullAgain = false, Fe2(n)), null), (p3) => (te3(n, p3), null));
          }
          u4(Fe2, "ReadableByteStreamControllerCallPullIfNeeded");
          function En2(n) {
            _r(n), n._pendingPullIntos = new Q5();
          }
          u4(En2, "ReadableByteStreamControllerClearPendingPullIntos");
          function gr2(n, o) {
            let a3 = false;
            n._state === "closed" && (a3 = true);
            const p3 = An2(o);
            o.readerType === "default" ? fr2(n, p3, a3) : ei2(n, p3, a3);
          }
          u4(gr2, "ReadableByteStreamControllerCommitPullIntoDescriptor");
          function An2(n) {
            const o = n.bytesFilled, a3 = n.elementSize;
            return new n.viewConstructor(n.buffer, n.byteOffset, o / a3);
          }
          u4(An2, "ReadableByteStreamControllerConvertPullIntoDescriptor");
          function Et(n, o, a3, p3) {
            n._queue.push({ buffer: o, byteOffset: a3, byteLength: p3 }), n._queueTotalSize += p3;
          }
          u4(Et, "ReadableByteStreamControllerEnqueueChunkToQueue");
          function Bn2(n, o, a3, p3) {
            let y3;
            try {
              y3 = Tn2(o, a3, a3 + p3);
            } catch (_5) {
              throw te3(n, _5), _5;
            }
            Et(n, y3, 0, p3);
          }
          u4(Bn2, "ReadableByteStreamControllerEnqueueClonedChunkToQueue");
          function qn2(n, o) {
            o.bytesFilled > 0 && Bn2(n, o.buffer, o.byteOffset, o.bytesFilled), He2(n);
          }
          u4(qn2, "ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue");
          function kn2(n, o) {
            const a3 = Math.min(n._queueTotalSize, o.byteLength - o.bytesFilled), p3 = o.bytesFilled + a3;
            let y3 = a3, _5 = false;
            const S6 = p3 % o.elementSize, C5 = p3 - S6;
            C5 >= o.minimumFill && (y3 = C5 - o.bytesFilled, _5 = true);
            const q6 = n._queue;
            for (; y3 > 0; ) {
              const P5 = q6.peek(), W6 = Math.min(y3, P5.byteLength), O4 = o.byteOffset + o.bytesFilled;
              Rn2(o.buffer, O4, P5.buffer, P5.byteOffset, W6), P5.byteLength === W6 ? q6.shift() : (P5.byteOffset += W6, P5.byteLength -= W6), n._queueTotalSize -= W6, Wn2(n, W6, o), y3 -= W6;
            }
            return _5;
          }
          u4(kn2, "ReadableByteStreamControllerFillPullIntoDescriptorFromQueue");
          function Wn2(n, o, a3) {
            a3.bytesFilled += o;
          }
          u4(Wn2, "ReadableByteStreamControllerFillHeadPullIntoDescriptor");
          function On2(n) {
            n._queueTotalSize === 0 && n._closeRequested ? (At2(n), yt(n._controlledReadableByteStream)) : Fe2(n);
          }
          u4(On2, "ReadableByteStreamControllerHandleQueueDrain");
          function _r(n) {
            n._byobRequest !== null && (n._byobRequest._associatedReadableByteStreamController = void 0, n._byobRequest._view = null, n._byobRequest = null);
          }
          u4(_r, "ReadableByteStreamControllerInvalidateBYOBRequest");
          function Sr(n) {
            for (; n._pendingPullIntos.length > 0; ) {
              if (n._queueTotalSize === 0) return;
              const o = n._pendingPullIntos.peek();
              kn2(n, o) && (He2(n), gr2(n._controlledReadableByteStream, o));
            }
          }
          u4(Sr, "ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue");
          function No(n) {
            const o = n._controlledReadableByteStream._reader;
            for (; o._readRequests.length > 0; ) {
              if (n._queueTotalSize === 0) return;
              const a3 = o._readRequests.shift();
              Fn2(n, a3);
            }
          }
          u4(No, "ReadableByteStreamControllerProcessReadRequestsUsingQueue");
          function Ho(n, o, a3, p3) {
            const y3 = n._controlledReadableByteStream, _5 = o.constructor, S6 = Uo(_5), { byteOffset: C5, byteLength: q6 } = o, P5 = a3 * S6;
            let W6;
            try {
              W6 = we3(o.buffer);
            } catch (j3) {
              p3._errorSteps(j3);
              return;
            }
            const O4 = { buffer: W6, bufferByteLength: W6.byteLength, byteOffset: C5, byteLength: q6, bytesFilled: 0, minimumFill: P5, elementSize: S6, viewConstructor: _5, readerType: "byob" };
            if (n._pendingPullIntos.length > 0) {
              n._pendingPullIntos.push(O4), $n2(y3, p3);
              return;
            }
            if (y3._state === "closed") {
              const j3 = new _5(O4.buffer, O4.byteOffset, 0);
              p3._closeSteps(j3);
              return;
            }
            if (n._queueTotalSize > 0) {
              if (kn2(n, O4)) {
                const j3 = An2(O4);
                On2(n), p3._chunkSteps(j3);
                return;
              }
              if (n._closeRequested) {
                const j3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                te3(n, j3), p3._errorSteps(j3);
                return;
              }
            }
            n._pendingPullIntos.push(O4), $n2(y3, p3), Fe2(n);
          }
          u4(Ho, "ReadableByteStreamControllerPullInto");
          function Vo(n, o) {
            o.readerType === "none" && He2(n);
            const a3 = n._controlledReadableByteStream;
            if (Tr(a3)) for (; Dn2(a3) > 0; ) {
              const p3 = He2(n);
              gr2(a3, p3);
            }
          }
          u4(Vo, "ReadableByteStreamControllerRespondInClosedState");
          function Qo(n, o, a3) {
            if (Wn2(n, o, a3), a3.readerType === "none") {
              qn2(n, a3), Sr(n);
              return;
            }
            if (a3.bytesFilled < a3.minimumFill) return;
            He2(n);
            const p3 = a3.bytesFilled % a3.elementSize;
            if (p3 > 0) {
              const y3 = a3.byteOffset + a3.bytesFilled;
              Bn2(n, a3.buffer, y3 - p3, p3);
            }
            a3.bytesFilled -= p3, gr2(n._controlledReadableByteStream, a3), Sr(n);
          }
          u4(Qo, "ReadableByteStreamControllerRespondInReadableState");
          function zn2(n, o) {
            const a3 = n._pendingPullIntos.peek();
            _r(n), n._controlledReadableByteStream._state === "closed" ? Vo(n, a3) : Qo(n, o, a3), Fe2(n);
          }
          u4(zn2, "ReadableByteStreamControllerRespondInternal");
          function He2(n) {
            return n._pendingPullIntos.shift();
          }
          u4(He2, "ReadableByteStreamControllerShiftPendingPullInto");
          function Yo(n) {
            const o = n._controlledReadableByteStream;
            return o._state !== "readable" || n._closeRequested || !n._started ? false : !!(mn2(o) && Tt2(o) > 0 || Tr(o) && Dn2(o) > 0 || In2(n) > 0);
          }
          u4(Yo, "ReadableByteStreamControllerShouldCallPull");
          function At2(n) {
            n._pullAlgorithm = void 0, n._cancelAlgorithm = void 0;
          }
          u4(At2, "ReadableByteStreamControllerClearAlgorithms");
          function ft(n) {
            const o = n._controlledReadableByteStream;
            if (!(n._closeRequested || o._state !== "readable")) {
              if (n._queueTotalSize > 0) {
                n._closeRequested = true;
                return;
              }
              if (n._pendingPullIntos.length > 0) {
                const a3 = n._pendingPullIntos.peek();
                if (a3.bytesFilled % a3.elementSize !== 0) {
                  const p3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                  throw te3(n, p3), p3;
                }
              }
              At2(n), yt(o);
            }
          }
          u4(ft, "ReadableByteStreamControllerClose");
          function Bt(n, o) {
            const a3 = n._controlledReadableByteStream;
            if (n._closeRequested || a3._state !== "readable") return;
            const { buffer: p3, byteOffset: y3, byteLength: _5 } = o;
            if (Ee3(p3)) throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
            const S6 = we3(p3);
            if (n._pendingPullIntos.length > 0) {
              const C5 = n._pendingPullIntos.peek();
              if (Ee3(C5.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
              _r(n), C5.buffer = we3(C5.buffer), C5.readerType === "none" && qn2(n, C5);
            }
            if (mn2(a3)) if (No(n), Tt2(a3) === 0) Et(n, S6, y3, _5);
            else {
              n._pendingPullIntos.length > 0 && He2(n);
              const C5 = new Uint8Array(S6, y3, _5);
              fr2(a3, C5, false);
            }
            else Tr(a3) ? (Et(n, S6, y3, _5), Sr(n)) : Et(n, S6, y3, _5);
            Fe2(n);
          }
          u4(Bt, "ReadableByteStreamControllerEnqueue");
          function te3(n, o) {
            const a3 = n._controlledReadableByteStream;
            a3._state === "readable" && (En2(n), Ae(n), At2(n), fo(a3, o));
          }
          u4(te3, "ReadableByteStreamControllerError");
          function Fn2(n, o) {
            const a3 = n._queue.shift();
            n._queueTotalSize -= a3.byteLength, On2(n);
            const p3 = new Uint8Array(a3.buffer, a3.byteOffset, a3.byteLength);
            o._chunkSteps(p3);
          }
          u4(Fn2, "ReadableByteStreamControllerFillReadRequestFromQueue");
          function wr(n) {
            if (n._byobRequest === null && n._pendingPullIntos.length > 0) {
              const o = n._pendingPullIntos.peek(), a3 = new Uint8Array(o.buffer, o.byteOffset + o.bytesFilled, o.byteLength - o.bytesFilled), p3 = Object.create(Re2.prototype);
              Zo(p3, n, a3), n._byobRequest = p3;
            }
            return n._byobRequest;
          }
          u4(wr, "ReadableByteStreamControllerGetBYOBRequest");
          function In2(n) {
            const o = n._controlledReadableByteStream._state;
            return o === "errored" ? null : o === "closed" ? 0 : n._strategyHWM - n._queueTotalSize;
          }
          u4(In2, "ReadableByteStreamControllerGetDesiredSize");
          function qt2(n, o) {
            const a3 = n._pendingPullIntos.peek();
            if (n._controlledReadableByteStream._state === "closed") {
              if (o !== 0) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            } else {
              if (o === 0) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
              if (a3.bytesFilled + o > a3.byteLength) throw new RangeError("bytesWritten out of range");
            }
            a3.buffer = we3(a3.buffer), zn2(n, o);
          }
          u4(qt2, "ReadableByteStreamControllerRespond");
          function kt2(n, o) {
            const a3 = n._pendingPullIntos.peek();
            if (n._controlledReadableByteStream._state === "closed") {
              if (o.byteLength !== 0) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            } else if (o.byteLength === 0) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            if (a3.byteOffset + a3.bytesFilled !== o.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
            if (a3.bufferByteLength !== o.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
            if (a3.bytesFilled + o.byteLength > a3.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
            const y3 = o.byteLength;
            a3.buffer = we3(o.buffer), zn2(n, y3);
          }
          u4(kt2, "ReadableByteStreamControllerRespondWithNewView");
          function jn2(n, o, a3, p3, y3, _5, S6) {
            o._controlledReadableByteStream = n, o._pullAgain = false, o._pulling = false, o._byobRequest = null, o._queue = o._queueTotalSize = void 0, Ae(o), o._closeRequested = false, o._started = false, o._strategyHWM = _5, o._pullAlgorithm = p3, o._cancelAlgorithm = y3, o._autoAllocateChunkSize = S6, o._pendingPullIntos = new Q5(), n._readableStreamController = o;
            const C5 = a3();
            v4(k4(C5), () => (o._started = true, Fe2(o), null), (q6) => (te3(o, q6), null));
          }
          u4(jn2, "SetUpReadableByteStreamController");
          function Go(n, o, a3) {
            const p3 = Object.create(ie3.prototype);
            let y3, _5, S6;
            o.start !== void 0 ? y3 = u4(() => o.start(p3), "startAlgorithm") : y3 = u4(() => {
            }, "startAlgorithm"), o.pull !== void 0 ? _5 = u4(() => o.pull(p3), "pullAlgorithm") : _5 = u4(() => k4(void 0), "pullAlgorithm"), o.cancel !== void 0 ? S6 = u4((q6) => o.cancel(q6), "cancelAlgorithm") : S6 = u4(() => k4(void 0), "cancelAlgorithm");
            const C5 = o.autoAllocateChunkSize;
            if (C5 === 0) throw new TypeError("autoAllocateChunkSize must be greater than 0");
            jn2(n, p3, y3, _5, S6, a3, C5);
          }
          u4(Go, "SetUpReadableByteStreamControllerFromUnderlyingSource");
          function Zo(n, o, a3) {
            n._associatedReadableByteStreamController = o, n._view = a3;
          }
          u4(Zo, "SetUpReadableStreamBYOBRequest");
          function Rr(n) {
            return new TypeError(`ReadableStreamBYOBRequest.prototype.${n} can only be used on a ReadableStreamBYOBRequest`);
          }
          u4(Rr, "byobRequestBrandCheckException");
          function ct2(n) {
            return new TypeError(`ReadableByteStreamController.prototype.${n} can only be used on a ReadableByteStreamController`);
          }
          u4(ct2, "byteStreamControllerBrandCheckException");
          function Ko(n, o) {
            ce2(n, o);
            const a3 = n?.mode;
            return { mode: a3 === void 0 ? void 0 : Jo(a3, `${o} has member 'mode' that`) };
          }
          u4(Ko, "convertReaderOptions");
          function Jo(n, o) {
            if (n = `${n}`, n !== "byob") throw new TypeError(`${o} '${n}' is not a valid enumeration value for ReadableStreamReaderMode`);
            return n;
          }
          u4(Jo, "convertReadableStreamReaderMode");
          function Xo(n, o) {
            var a3;
            ce2(n, o);
            const p3 = (a3 = n?.min) !== null && a3 !== void 0 ? a3 : 1;
            return { min: ur2(p3, `${o} has member 'min' that`) };
          }
          u4(Xo, "convertByobReadOptions");
          function Ln2(n) {
            return new he3(n);
          }
          u4(Ln2, "AcquireReadableStreamBYOBReader");
          function $n2(n, o) {
            n._reader._readIntoRequests.push(o);
          }
          u4($n2, "ReadableStreamAddReadIntoRequest");
          function ei2(n, o, a3) {
            const y3 = n._reader._readIntoRequests.shift();
            a3 ? y3._closeSteps(o) : y3._chunkSteps(o);
          }
          u4(ei2, "ReadableStreamFulfillReadIntoRequest");
          function Dn2(n) {
            return n._reader._readIntoRequests.length;
          }
          u4(Dn2, "ReadableStreamGetNumReadIntoRequests");
          function Tr(n) {
            const o = n._reader;
            return !(o === void 0 || !Ie2(o));
          }
          u4(Tr, "ReadableStreamHasBYOBReader");
          const Hr = class Hr {
            constructor(o) {
              if (Se2(o, 1, "ReadableStreamBYOBReader"), lr2(o, "First parameter"), ke2(o)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              if (!ze2(o._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
              ln2(this, o), this._readIntoRequests = new Q5();
            }
            get closed() {
              return Ie2(this) ? this._closedPromise : T5(Wt("closed"));
            }
            cancel(o = void 0) {
              return Ie2(this) ? this._ownerReadableStream === void 0 ? T5(Rt2("cancel")) : nr2(this, o) : T5(Wt("cancel"));
            }
            read(o, a3 = {}) {
              if (!Ie2(this)) return T5(Wt("read"));
              if (!ArrayBuffer.isView(o)) return T5(new TypeError("view must be an array buffer view"));
              if (o.byteLength === 0) return T5(new TypeError("view must have non-zero byteLength"));
              if (o.buffer.byteLength === 0) return T5(new TypeError("view's buffer must have non-zero byteLength"));
              if (Ee3(o.buffer)) return T5(new TypeError("view's buffer has been detached"));
              let p3;
              try {
                p3 = Xo(a3, "options");
              } catch (P5) {
                return T5(P5);
              }
              const y3 = p3.min;
              if (y3 === 0) return T5(new TypeError("options.min must be greater than 0"));
              if (xo(o)) {
                if (y3 > o.byteLength) return T5(new RangeError("options.min must be less than or equal to view's byteLength"));
              } else if (y3 > o.length) return T5(new RangeError("options.min must be less than or equal to view's length"));
              if (this._ownerReadableStream === void 0) return T5(Rt2("read from"));
              let _5, S6;
              const C5 = I5((P5, W6) => {
                _5 = P5, S6 = W6;
              });
              return Mn2(this, o, y3, { _chunkSteps: u4((P5) => _5({ value: P5, done: false }), "_chunkSteps"), _closeSteps: u4((P5) => _5({ value: P5, done: true }), "_closeSteps"), _errorSteps: u4((P5) => S6(P5), "_errorSteps") }), C5;
            }
            releaseLock() {
              if (!Ie2(this)) throw Wt("releaseLock");
              this._ownerReadableStream !== void 0 && ti2(this);
            }
          };
          u4(Hr, "ReadableStreamBYOBReader");
          let he3 = Hr;
          Object.defineProperties(he3.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), w5(he3.prototype.cancel, "cancel"), w5(he3.prototype.read, "read"), w5(he3.prototype.releaseLock, "releaseLock"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(he3.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
          function Ie2(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_readIntoRequests") ? false : n instanceof he3;
          }
          u4(Ie2, "IsReadableStreamBYOBReader");
          function Mn2(n, o, a3, p3) {
            const y3 = n._ownerReadableStream;
            y3._disturbed = true, y3._state === "errored" ? p3._errorSteps(y3._storedError) : Ho(y3._readableStreamController, o, a3, p3);
          }
          u4(Mn2, "ReadableStreamBYOBReaderRead");
          function ti2(n) {
            _e2(n);
            const o = new TypeError("Reader was released");
            xn2(n, o);
          }
          u4(ti2, "ReadableStreamBYOBReaderRelease");
          function xn2(n, o) {
            const a3 = n._readIntoRequests;
            n._readIntoRequests = new Q5(), a3.forEach((p3) => {
              p3._errorSteps(o);
            });
          }
          u4(xn2, "ReadableStreamBYOBReaderErrorReadIntoRequests");
          function Wt(n) {
            return new TypeError(`ReadableStreamBYOBReader.prototype.${n} can only be used on a ReadableStreamBYOBReader`);
          }
          u4(Wt, "byobReaderBrandCheckException");
          function dt2(n, o) {
            const { highWaterMark: a3 } = n;
            if (a3 === void 0) return o;
            if (wn2(a3) || a3 < 0) throw new RangeError("Invalid highWaterMark");
            return a3;
          }
          u4(dt2, "ExtractHighWaterMark");
          function Ot(n) {
            const { size: o } = n;
            return o || (() => 1);
          }
          u4(Ot, "ExtractSizeAlgorithm");
          function zt2(n, o) {
            ce2(n, o);
            const a3 = n?.highWaterMark, p3 = n?.size;
            return { highWaterMark: a3 === void 0 ? void 0 : ar2(a3), size: p3 === void 0 ? void 0 : ri2(p3, `${o} has member 'size' that`) };
          }
          u4(zt2, "convertQueuingStrategy");
          function ri2(n, o) {
            return ee3(n, o), (a3) => ar2(n(a3));
          }
          u4(ri2, "convertQueuingStrategySize");
          function ni2(n, o) {
            ce2(n, o);
            const a3 = n?.abort, p3 = n?.close, y3 = n?.start, _5 = n?.type, S6 = n?.write;
            return { abort: a3 === void 0 ? void 0 : oi2(a3, n, `${o} has member 'abort' that`), close: p3 === void 0 ? void 0 : ii2(p3, n, `${o} has member 'close' that`), start: y3 === void 0 ? void 0 : si2(y3, n, `${o} has member 'start' that`), write: S6 === void 0 ? void 0 : ai2(S6, n, `${o} has member 'write' that`), type: _5 };
          }
          u4(ni2, "convertUnderlyingSink");
          function oi2(n, o, a3) {
            return ee3(n, a3), (p3) => H5(n, o, [p3]);
          }
          u4(oi2, "convertUnderlyingSinkAbortCallback");
          function ii2(n, o, a3) {
            return ee3(n, a3), () => H5(n, o, []);
          }
          u4(ii2, "convertUnderlyingSinkCloseCallback");
          function si2(n, o, a3) {
            return ee3(n, a3), (p3) => M4(n, o, [p3]);
          }
          u4(si2, "convertUnderlyingSinkStartCallback");
          function ai2(n, o, a3) {
            return ee3(n, a3), (p3, y3) => H5(n, o, [p3, y3]);
          }
          u4(ai2, "convertUnderlyingSinkWriteCallback");
          function Un2(n, o) {
            if (!Ve2(n)) throw new TypeError(`${o} is not a WritableStream.`);
          }
          u4(Un2, "assertWritableStream");
          function ui2(n) {
            if (typeof n != "object" || n === null) return false;
            try {
              return typeof n.aborted == "boolean";
            } catch {
              return false;
            }
          }
          u4(ui2, "isAbortSignal");
          const li2 = typeof AbortController == "function";
          function fi2() {
            if (li2) return new AbortController();
          }
          u4(fi2, "createAbortController");
          const Vr = class Vr {
            constructor(o = {}, a3 = {}) {
              o === void 0 ? o = null : hn2(o, "First parameter");
              const p3 = zt2(a3, "Second parameter"), y3 = ni2(o, "First parameter");
              if (Hn2(this), y3.type !== void 0) throw new RangeError("Invalid type is specified");
              const S6 = Ot(p3), C5 = dt2(p3, 1);
              Ci2(this, y3, C5, S6);
            }
            get locked() {
              if (!Ve2(this)) throw $t2("locked");
              return Qe2(this);
            }
            abort(o = void 0) {
              return Ve2(this) ? Qe2(this) ? T5(new TypeError("Cannot abort a stream that already has a writer")) : Ft2(this, o) : T5($t2("abort"));
            }
            close() {
              return Ve2(this) ? Qe2(this) ? T5(new TypeError("Cannot close a stream that already has a writer")) : be3(this) ? T5(new TypeError("Cannot close an already-closing stream")) : Vn2(this) : T5($t2("close"));
            }
            getWriter() {
              if (!Ve2(this)) throw $t2("getWriter");
              return Nn2(this);
            }
          };
          u4(Vr, "WritableStream");
          let pe2 = Vr;
          Object.defineProperties(pe2.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), w5(pe2.prototype.abort, "abort"), w5(pe2.prototype.close, "close"), w5(pe2.prototype.getWriter, "getWriter"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(pe2.prototype, Symbol.toStringTag, { value: "WritableStream", configurable: true });
          function Nn2(n) {
            return new se2(n);
          }
          u4(Nn2, "AcquireWritableStreamDefaultWriter");
          function ci2(n, o, a3, p3, y3 = 1, _5 = () => 1) {
            const S6 = Object.create(pe2.prototype);
            Hn2(S6);
            const C5 = Object.create(Be2.prototype);
            return Jn2(S6, C5, n, o, a3, p3, y3, _5), S6;
          }
          u4(ci2, "CreateWritableStream");
          function Hn2(n) {
            n._state = "writable", n._storedError = void 0, n._writer = void 0, n._writableStreamController = void 0, n._writeRequests = new Q5(), n._inFlightWriteRequest = void 0, n._closeRequest = void 0, n._inFlightCloseRequest = void 0, n._pendingAbortRequest = void 0, n._backpressure = false;
          }
          u4(Hn2, "InitializeWritableStream");
          function Ve2(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_writableStreamController") ? false : n instanceof pe2;
          }
          u4(Ve2, "IsWritableStream");
          function Qe2(n) {
            return n._writer !== void 0;
          }
          u4(Qe2, "IsWritableStreamLocked");
          function Ft2(n, o) {
            var a3;
            if (n._state === "closed" || n._state === "errored") return k4(void 0);
            n._writableStreamController._abortReason = o, (a3 = n._writableStreamController._abortController) === null || a3 === void 0 || a3.abort(o);
            const p3 = n._state;
            if (p3 === "closed" || p3 === "errored") return k4(void 0);
            if (n._pendingAbortRequest !== void 0) return n._pendingAbortRequest._promise;
            let y3 = false;
            p3 === "erroring" && (y3 = true, o = void 0);
            const _5 = I5((S6, C5) => {
              n._pendingAbortRequest = { _promise: void 0, _resolve: S6, _reject: C5, _reason: o, _wasAlreadyErroring: y3 };
            });
            return n._pendingAbortRequest._promise = _5, y3 || Pr(n, o), _5;
          }
          u4(Ft2, "WritableStreamAbort");
          function Vn2(n) {
            const o = n._state;
            if (o === "closed" || o === "errored") return T5(new TypeError(`The stream (in ${o} state) is not in the writable state and cannot be closed`));
            const a3 = I5((y3, _5) => {
              const S6 = { _resolve: y3, _reject: _5 };
              n._closeRequest = S6;
            }), p3 = n._writer;
            return p3 !== void 0 && n._backpressure && o === "writable" && Or(p3), Pi2(n._writableStreamController), a3;
          }
          u4(Vn2, "WritableStreamClose");
          function di2(n) {
            return I5((a3, p3) => {
              const y3 = { _resolve: a3, _reject: p3 };
              n._writeRequests.push(y3);
            });
          }
          u4(di2, "WritableStreamAddWriteRequest");
          function Cr(n, o) {
            if (n._state === "writable") {
              Pr(n, o);
              return;
            }
            vr2(n);
          }
          u4(Cr, "WritableStreamDealWithRejection");
          function Pr(n, o) {
            const a3 = n._writableStreamController;
            n._state = "erroring", n._storedError = o;
            const p3 = n._writer;
            p3 !== void 0 && Yn2(p3, o), !yi2(n) && a3._started && vr2(n);
          }
          u4(Pr, "WritableStreamStartErroring");
          function vr2(n) {
            n._state = "errored", n._writableStreamController[un2]();
            const o = n._storedError;
            if (n._writeRequests.forEach((y3) => {
              y3._reject(o);
            }), n._writeRequests = new Q5(), n._pendingAbortRequest === void 0) {
              It2(n);
              return;
            }
            const a3 = n._pendingAbortRequest;
            if (n._pendingAbortRequest = void 0, a3._wasAlreadyErroring) {
              a3._reject(o), It2(n);
              return;
            }
            const p3 = n._writableStreamController[wt2](a3._reason);
            v4(p3, () => (a3._resolve(), It2(n), null), (y3) => (a3._reject(y3), It2(n), null));
          }
          u4(vr2, "WritableStreamFinishErroring");
          function hi2(n) {
            n._inFlightWriteRequest._resolve(void 0), n._inFlightWriteRequest = void 0;
          }
          u4(hi2, "WritableStreamFinishInFlightWrite");
          function pi2(n, o) {
            n._inFlightWriteRequest._reject(o), n._inFlightWriteRequest = void 0, Cr(n, o);
          }
          u4(pi2, "WritableStreamFinishInFlightWriteWithError");
          function bi2(n) {
            n._inFlightCloseRequest._resolve(void 0), n._inFlightCloseRequest = void 0, n._state === "erroring" && (n._storedError = void 0, n._pendingAbortRequest !== void 0 && (n._pendingAbortRequest._resolve(), n._pendingAbortRequest = void 0)), n._state = "closed";
            const a3 = n._writer;
            a3 !== void 0 && ro(a3);
          }
          u4(bi2, "WritableStreamFinishInFlightClose");
          function mi2(n, o) {
            n._inFlightCloseRequest._reject(o), n._inFlightCloseRequest = void 0, n._pendingAbortRequest !== void 0 && (n._pendingAbortRequest._reject(o), n._pendingAbortRequest = void 0), Cr(n, o);
          }
          u4(mi2, "WritableStreamFinishInFlightCloseWithError");
          function be3(n) {
            return !(n._closeRequest === void 0 && n._inFlightCloseRequest === void 0);
          }
          u4(be3, "WritableStreamCloseQueuedOrInFlight");
          function yi2(n) {
            return !(n._inFlightWriteRequest === void 0 && n._inFlightCloseRequest === void 0);
          }
          u4(yi2, "WritableStreamHasOperationMarkedInFlight");
          function gi2(n) {
            n._inFlightCloseRequest = n._closeRequest, n._closeRequest = void 0;
          }
          u4(gi2, "WritableStreamMarkCloseRequestInFlight");
          function _i2(n) {
            n._inFlightWriteRequest = n._writeRequests.shift();
          }
          u4(_i2, "WritableStreamMarkFirstWriteRequestInFlight");
          function It2(n) {
            n._closeRequest !== void 0 && (n._closeRequest._reject(n._storedError), n._closeRequest = void 0);
            const o = n._writer;
            o !== void 0 && kr(o, n._storedError);
          }
          u4(It2, "WritableStreamRejectCloseAndClosedPromiseIfNeeded");
          function Er(n, o) {
            const a3 = n._writer;
            a3 !== void 0 && o !== n._backpressure && (o ? Wi2(a3) : Or(a3)), n._backpressure = o;
          }
          u4(Er, "WritableStreamUpdateBackpressure");
          const Qr = class Qr {
            constructor(o) {
              if (Se2(o, 1, "WritableStreamDefaultWriter"), Un2(o, "First parameter"), Qe2(o)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
              this._ownerWritableStream = o, o._writer = this;
              const a3 = o._state;
              if (a3 === "writable") !be3(o) && o._backpressure ? Mt(this) : no(this), Dt(this);
              else if (a3 === "erroring") Wr(this, o._storedError), Dt(this);
              else if (a3 === "closed") no(this), qi2(this);
              else {
                const p3 = o._storedError;
                Wr(this, p3), to(this, p3);
              }
            }
            get closed() {
              return je2(this) ? this._closedPromise : T5(Le2("closed"));
            }
            get desiredSize() {
              if (!je2(this)) throw Le2("desiredSize");
              if (this._ownerWritableStream === void 0) throw pt("desiredSize");
              return Ti2(this);
            }
            get ready() {
              return je2(this) ? this._readyPromise : T5(Le2("ready"));
            }
            abort(o = void 0) {
              return je2(this) ? this._ownerWritableStream === void 0 ? T5(pt("abort")) : Si2(this, o) : T5(Le2("abort"));
            }
            close() {
              if (!je2(this)) return T5(Le2("close"));
              const o = this._ownerWritableStream;
              return o === void 0 ? T5(pt("close")) : be3(o) ? T5(new TypeError("Cannot close an already-closing stream")) : Qn2(this);
            }
            releaseLock() {
              if (!je2(this)) throw Le2("releaseLock");
              this._ownerWritableStream !== void 0 && Gn2(this);
            }
            write(o = void 0) {
              return je2(this) ? this._ownerWritableStream === void 0 ? T5(pt("write to")) : Zn2(this, o) : T5(Le2("write"));
            }
          };
          u4(Qr, "WritableStreamDefaultWriter");
          let se2 = Qr;
          Object.defineProperties(se2.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), w5(se2.prototype.abort, "abort"), w5(se2.prototype.close, "close"), w5(se2.prototype.releaseLock, "releaseLock"), w5(se2.prototype.write, "write"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(se2.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
          function je2(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_ownerWritableStream") ? false : n instanceof se2;
          }
          u4(je2, "IsWritableStreamDefaultWriter");
          function Si2(n, o) {
            const a3 = n._ownerWritableStream;
            return Ft2(a3, o);
          }
          u4(Si2, "WritableStreamDefaultWriterAbort");
          function Qn2(n) {
            const o = n._ownerWritableStream;
            return Vn2(o);
          }
          u4(Qn2, "WritableStreamDefaultWriterClose");
          function wi2(n) {
            const o = n._ownerWritableStream, a3 = o._state;
            return be3(o) || a3 === "closed" ? k4(void 0) : a3 === "errored" ? T5(o._storedError) : Qn2(n);
          }
          u4(wi2, "WritableStreamDefaultWriterCloseWithErrorPropagation");
          function Ri2(n, o) {
            n._closedPromiseState === "pending" ? kr(n, o) : ki2(n, o);
          }
          u4(Ri2, "WritableStreamDefaultWriterEnsureClosedPromiseRejected");
          function Yn2(n, o) {
            n._readyPromiseState === "pending" ? oo(n, o) : Oi2(n, o);
          }
          u4(Yn2, "WritableStreamDefaultWriterEnsureReadyPromiseRejected");
          function Ti2(n) {
            const o = n._ownerWritableStream, a3 = o._state;
            return a3 === "errored" || a3 === "erroring" ? null : a3 === "closed" ? 0 : Xn2(o._writableStreamController);
          }
          u4(Ti2, "WritableStreamDefaultWriterGetDesiredSize");
          function Gn2(n) {
            const o = n._ownerWritableStream, a3 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
            Yn2(n, a3), Ri2(n, a3), o._writer = void 0, n._ownerWritableStream = void 0;
          }
          u4(Gn2, "WritableStreamDefaultWriterRelease");
          function Zn2(n, o) {
            const a3 = n._ownerWritableStream, p3 = a3._writableStreamController, y3 = vi2(p3, o);
            if (a3 !== n._ownerWritableStream) return T5(pt("write to"));
            const _5 = a3._state;
            if (_5 === "errored") return T5(a3._storedError);
            if (be3(a3) || _5 === "closed") return T5(new TypeError("The stream is closing or closed and cannot be written to"));
            if (_5 === "erroring") return T5(a3._storedError);
            const S6 = di2(a3);
            return Ei2(p3, o, y3), S6;
          }
          u4(Zn2, "WritableStreamDefaultWriterWrite");
          const Kn2 = {}, Yr = class Yr {
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get abortReason() {
              if (!Ar2(this)) throw qr("abortReason");
              return this._abortReason;
            }
            get signal() {
              if (!Ar2(this)) throw qr("signal");
              if (this._abortController === void 0) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
              return this._abortController.signal;
            }
            error(o = void 0) {
              if (!Ar2(this)) throw qr("error");
              this._controlledWritableStream._state === "writable" && eo(this, o);
            }
            [wt2](o) {
              const a3 = this._abortAlgorithm(o);
              return jt2(this), a3;
            }
            [un2]() {
              Ae(this);
            }
          };
          u4(Yr, "WritableStreamDefaultController");
          let Be2 = Yr;
          Object.defineProperties(Be2.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Be2.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
          function Ar2(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_controlledWritableStream") ? false : n instanceof Be2;
          }
          u4(Ar2, "IsWritableStreamDefaultController");
          function Jn2(n, o, a3, p3, y3, _5, S6, C5) {
            o._controlledWritableStream = n, n._writableStreamController = o, o._queue = void 0, o._queueTotalSize = void 0, Ae(o), o._abortReason = void 0, o._abortController = fi2(), o._started = false, o._strategySizeAlgorithm = C5, o._strategyHWM = S6, o._writeAlgorithm = p3, o._closeAlgorithm = y3, o._abortAlgorithm = _5;
            const q6 = Br(o);
            Er(n, q6);
            const P5 = a3(), W6 = k4(P5);
            v4(W6, () => (o._started = true, Lt2(o), null), (O4) => (o._started = true, Cr(n, O4), null));
          }
          u4(Jn2, "SetUpWritableStreamDefaultController");
          function Ci2(n, o, a3, p3) {
            const y3 = Object.create(Be2.prototype);
            let _5, S6, C5, q6;
            o.start !== void 0 ? _5 = u4(() => o.start(y3), "startAlgorithm") : _5 = u4(() => {
            }, "startAlgorithm"), o.write !== void 0 ? S6 = u4((P5) => o.write(P5, y3), "writeAlgorithm") : S6 = u4(() => k4(void 0), "writeAlgorithm"), o.close !== void 0 ? C5 = u4(() => o.close(), "closeAlgorithm") : C5 = u4(() => k4(void 0), "closeAlgorithm"), o.abort !== void 0 ? q6 = u4((P5) => o.abort(P5), "abortAlgorithm") : q6 = u4(() => k4(void 0), "abortAlgorithm"), Jn2(n, y3, _5, S6, C5, q6, a3, p3);
          }
          u4(Ci2, "SetUpWritableStreamDefaultControllerFromUnderlyingSink");
          function jt2(n) {
            n._writeAlgorithm = void 0, n._closeAlgorithm = void 0, n._abortAlgorithm = void 0, n._strategySizeAlgorithm = void 0;
          }
          u4(jt2, "WritableStreamDefaultControllerClearAlgorithms");
          function Pi2(n) {
            mr2(n, Kn2, 0), Lt2(n);
          }
          u4(Pi2, "WritableStreamDefaultControllerClose");
          function vi2(n, o) {
            try {
              return n._strategySizeAlgorithm(o);
            } catch (a3) {
              return ht2(n, a3), 1;
            }
          }
          u4(vi2, "WritableStreamDefaultControllerGetChunkSize");
          function Xn2(n) {
            return n._strategyHWM - n._queueTotalSize;
          }
          u4(Xn2, "WritableStreamDefaultControllerGetDesiredSize");
          function Ei2(n, o, a3) {
            try {
              mr2(n, o, a3);
            } catch (y3) {
              ht2(n, y3);
              return;
            }
            const p3 = n._controlledWritableStream;
            if (!be3(p3) && p3._state === "writable") {
              const y3 = Br(n);
              Er(p3, y3);
            }
            Lt2(n);
          }
          u4(Ei2, "WritableStreamDefaultControllerWrite");
          function Lt2(n) {
            const o = n._controlledWritableStream;
            if (!n._started || o._inFlightWriteRequest !== void 0) return;
            if (o._state === "erroring") {
              vr2(o);
              return;
            }
            if (n._queue.length === 0) return;
            const p3 = Mo(n);
            p3 === Kn2 ? Ai2(n) : Bi2(n, p3);
          }
          u4(Lt2, "WritableStreamDefaultControllerAdvanceQueueIfNeeded");
          function ht2(n, o) {
            n._controlledWritableStream._state === "writable" && eo(n, o);
          }
          u4(ht2, "WritableStreamDefaultControllerErrorIfNeeded");
          function Ai2(n) {
            const o = n._controlledWritableStream;
            gi2(o), br(n);
            const a3 = n._closeAlgorithm();
            jt2(n), v4(a3, () => (bi2(o), null), (p3) => (mi2(o, p3), null));
          }
          u4(Ai2, "WritableStreamDefaultControllerProcessClose");
          function Bi2(n, o) {
            const a3 = n._controlledWritableStream;
            _i2(a3);
            const p3 = n._writeAlgorithm(o);
            v4(p3, () => {
              hi2(a3);
              const y3 = a3._state;
              if (br(n), !be3(a3) && y3 === "writable") {
                const _5 = Br(n);
                Er(a3, _5);
              }
              return Lt2(n), null;
            }, (y3) => (a3._state === "writable" && jt2(n), pi2(a3, y3), null));
          }
          u4(Bi2, "WritableStreamDefaultControllerProcessWrite");
          function Br(n) {
            return Xn2(n) <= 0;
          }
          u4(Br, "WritableStreamDefaultControllerGetBackpressure");
          function eo(n, o) {
            const a3 = n._controlledWritableStream;
            jt2(n), Pr(a3, o);
          }
          u4(eo, "WritableStreamDefaultControllerError");
          function $t2(n) {
            return new TypeError(`WritableStream.prototype.${n} can only be used on a WritableStream`);
          }
          u4($t2, "streamBrandCheckException$2");
          function qr(n) {
            return new TypeError(`WritableStreamDefaultController.prototype.${n} can only be used on a WritableStreamDefaultController`);
          }
          u4(qr, "defaultControllerBrandCheckException$2");
          function Le2(n) {
            return new TypeError(`WritableStreamDefaultWriter.prototype.${n} can only be used on a WritableStreamDefaultWriter`);
          }
          u4(Le2, "defaultWriterBrandCheckException");
          function pt(n) {
            return new TypeError("Cannot " + n + " a stream using a released writer");
          }
          u4(pt, "defaultWriterLockException");
          function Dt(n) {
            n._closedPromise = I5((o, a3) => {
              n._closedPromise_resolve = o, n._closedPromise_reject = a3, n._closedPromiseState = "pending";
            });
          }
          u4(Dt, "defaultWriterClosedPromiseInitialize");
          function to(n, o) {
            Dt(n), kr(n, o);
          }
          u4(to, "defaultWriterClosedPromiseInitializeAsRejected");
          function qi2(n) {
            Dt(n), ro(n);
          }
          u4(qi2, "defaultWriterClosedPromiseInitializeAsResolved");
          function kr(n, o) {
            n._closedPromise_reject !== void 0 && (J5(n._closedPromise), n._closedPromise_reject(o), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0, n._closedPromiseState = "rejected");
          }
          u4(kr, "defaultWriterClosedPromiseReject");
          function ki2(n, o) {
            to(n, o);
          }
          u4(ki2, "defaultWriterClosedPromiseResetToRejected");
          function ro(n) {
            n._closedPromise_resolve !== void 0 && (n._closedPromise_resolve(void 0), n._closedPromise_resolve = void 0, n._closedPromise_reject = void 0, n._closedPromiseState = "resolved");
          }
          u4(ro, "defaultWriterClosedPromiseResolve");
          function Mt(n) {
            n._readyPromise = I5((o, a3) => {
              n._readyPromise_resolve = o, n._readyPromise_reject = a3;
            }), n._readyPromiseState = "pending";
          }
          u4(Mt, "defaultWriterReadyPromiseInitialize");
          function Wr(n, o) {
            Mt(n), oo(n, o);
          }
          u4(Wr, "defaultWriterReadyPromiseInitializeAsRejected");
          function no(n) {
            Mt(n), Or(n);
          }
          u4(no, "defaultWriterReadyPromiseInitializeAsResolved");
          function oo(n, o) {
            n._readyPromise_reject !== void 0 && (J5(n._readyPromise), n._readyPromise_reject(o), n._readyPromise_resolve = void 0, n._readyPromise_reject = void 0, n._readyPromiseState = "rejected");
          }
          u4(oo, "defaultWriterReadyPromiseReject");
          function Wi2(n) {
            Mt(n);
          }
          u4(Wi2, "defaultWriterReadyPromiseReset");
          function Oi2(n, o) {
            Wr(n, o);
          }
          u4(Oi2, "defaultWriterReadyPromiseResetToRejected");
          function Or(n) {
            n._readyPromise_resolve !== void 0 && (n._readyPromise_resolve(void 0), n._readyPromise_resolve = void 0, n._readyPromise_reject = void 0, n._readyPromiseState = "fulfilled");
          }
          u4(Or, "defaultWriterReadyPromiseResolve");
          function zi2() {
            if (typeof globalThis < "u") return globalThis;
            if (typeof self < "u") return self;
            if (typeof _commonjsHelpers.commonjsGlobal < "u") return _commonjsHelpers.commonjsGlobal;
          }
          u4(zi2, "getGlobals");
          const zr = zi2();
          function Fi2(n) {
            if (!(typeof n == "function" || typeof n == "object") || n.name !== "DOMException") return false;
            try {
              return new n(), true;
            } catch {
              return false;
            }
          }
          u4(Fi2, "isDOMExceptionConstructor");
          function Ii2() {
            const n = zr?.DOMException;
            return Fi2(n) ? n : void 0;
          }
          u4(Ii2, "getFromGlobal");
          function ji2() {
            const n = u4(function(a3, p3) {
              this.message = a3 || "", this.name = p3 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
            }, "DOMException");
            return w5(n, "DOMException"), n.prototype = Object.create(Error.prototype), Object.defineProperty(n.prototype, "constructor", { value: n, writable: true, configurable: true }), n;
          }
          u4(ji2, "createPolyfill");
          const Li2 = Ii2() || ji2();
          function io(n, o, a3, p3, y3, _5) {
            const S6 = Ne2(n), C5 = Nn2(o);
            n._disturbed = true;
            let q6 = false, P5 = k4(void 0);
            return I5((W6, O4) => {
              let j3;
              if (_5 !== void 0) {
                if (j3 = u4(() => {
                  const E3 = _5.reason !== void 0 ? _5.reason : new Li2("Aborted", "AbortError"), F2 = [];
                  p3 || F2.push(() => o._state === "writable" ? Ft2(o, E3) : k4(void 0)), y3 || F2.push(() => n._state === "readable" ? le3(n, E3) : k4(void 0)), Z4(() => Promise.all(F2.map((L4) => L4())), true, E3);
                }, "abortAlgorithm"), _5.aborted) {
                  j3();
                  return;
                }
                _5.addEventListener("abort", j3);
              }
              function fe4() {
                return I5((E3, F2) => {
                  function L4(X5) {
                    X5 ? E3() : $6(et2(), L4, F2);
                  }
                  u4(L4, "next"), L4(false);
                });
              }
              u4(fe4, "pipeLoop");
              function et2() {
                return q6 ? k4(true) : $6(C5._readyPromise, () => I5((E3, F2) => {
                  ut2(S6, { _chunkSteps: u4((L4) => {
                    P5 = $6(Zn2(C5, L4), void 0, g4), E3(false);
                  }, "_chunkSteps"), _closeSteps: u4(() => E3(true), "_closeSteps"), _errorSteps: F2 });
                }));
              }
              if (u4(et2, "pipeStep"), Te2(n, S6._closedPromise, (E3) => (p3 ? re3(true, E3) : Z4(() => Ft2(o, E3), true, E3), null)), Te2(o, C5._closedPromise, (E3) => (y3 ? re3(true, E3) : Z4(() => le3(n, E3), true, E3), null)), G3(n, S6._closedPromise, () => (a3 ? re3() : Z4(() => wi2(C5)), null)), be3(o) || o._state === "closed") {
                const E3 = new TypeError("the destination writable stream closed before all data could be piped to it");
                y3 ? re3(true, E3) : Z4(() => le3(n, E3), true, E3);
              }
              J5(fe4());
              function We2() {
                const E3 = P5;
                return $6(P5, () => E3 !== P5 ? We2() : void 0);
              }
              u4(We2, "waitForWritesToFinish");
              function Te2(E3, F2, L4) {
                E3._state === "errored" ? L4(E3._storedError) : U6(F2, L4);
              }
              u4(Te2, "isOrBecomesErrored");
              function G3(E3, F2, L4) {
                E3._state === "closed" ? L4() : K4(F2, L4);
              }
              u4(G3, "isOrBecomesClosed");
              function Z4(E3, F2, L4) {
                if (q6) return;
                q6 = true, o._state === "writable" && !be3(o) ? K4(We2(), X5) : X5();
                function X5() {
                  return v4(E3(), () => Ce2(F2, L4), (tt) => Ce2(true, tt)), null;
                }
                u4(X5, "doTheRest");
              }
              u4(Z4, "shutdownWithAction");
              function re3(E3, F2) {
                q6 || (q6 = true, o._state === "writable" && !be3(o) ? K4(We2(), () => Ce2(E3, F2)) : Ce2(E3, F2));
              }
              u4(re3, "shutdown");
              function Ce2(E3, F2) {
                return Gn2(C5), _e2(S6), _5 !== void 0 && _5.removeEventListener("abort", j3), E3 ? O4(F2) : W6(void 0), null;
              }
              u4(Ce2, "finalize");
            });
          }
          u4(io, "ReadableStreamPipeTo");
          const Gr = class Gr {
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get desiredSize() {
              if (!xt(this)) throw Nt2("desiredSize");
              return Fr(this);
            }
            close() {
              if (!xt(this)) throw Nt2("close");
              if (!Ge(this)) throw new TypeError("The stream is not in a state that permits close");
              $e2(this);
            }
            enqueue(o = void 0) {
              if (!xt(this)) throw Nt2("enqueue");
              if (!Ge(this)) throw new TypeError("The stream is not in a state that permits enqueue");
              return Ye2(this, o);
            }
            error(o = void 0) {
              if (!xt(this)) throw Nt2("error");
              ue3(this, o);
            }
            [er2](o) {
              Ae(this);
              const a3 = this._cancelAlgorithm(o);
              return Ut(this), a3;
            }
            [tr2](o) {
              const a3 = this._controlledReadableStream;
              if (this._queue.length > 0) {
                const p3 = br(this);
                this._closeRequested && this._queue.length === 0 ? (Ut(this), yt(a3)) : bt2(this), o._chunkSteps(p3);
              } else bn2(a3, o), bt2(this);
            }
            [rr2]() {
            }
          };
          u4(Gr, "ReadableStreamDefaultController");
          let ae3 = Gr;
          Object.defineProperties(ae3.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), w5(ae3.prototype.close, "close"), w5(ae3.prototype.enqueue, "enqueue"), w5(ae3.prototype.error, "error"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(ae3.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
          function xt(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_controlledReadableStream") ? false : n instanceof ae3;
          }
          u4(xt, "IsReadableStreamDefaultController");
          function bt2(n) {
            if (!so(n)) return;
            if (n._pulling) {
              n._pullAgain = true;
              return;
            }
            n._pulling = true;
            const a3 = n._pullAlgorithm();
            v4(a3, () => (n._pulling = false, n._pullAgain && (n._pullAgain = false, bt2(n)), null), (p3) => (ue3(n, p3), null));
          }
          u4(bt2, "ReadableStreamDefaultControllerCallPullIfNeeded");
          function so(n) {
            const o = n._controlledReadableStream;
            return !Ge(n) || !n._started ? false : !!(ke2(o) && Tt2(o) > 0 || Fr(n) > 0);
          }
          u4(so, "ReadableStreamDefaultControllerShouldCallPull");
          function Ut(n) {
            n._pullAlgorithm = void 0, n._cancelAlgorithm = void 0, n._strategySizeAlgorithm = void 0;
          }
          u4(Ut, "ReadableStreamDefaultControllerClearAlgorithms");
          function $e2(n) {
            if (!Ge(n)) return;
            const o = n._controlledReadableStream;
            n._closeRequested = true, n._queue.length === 0 && (Ut(n), yt(o));
          }
          u4($e2, "ReadableStreamDefaultControllerClose");
          function Ye2(n, o) {
            if (!Ge(n)) return;
            const a3 = n._controlledReadableStream;
            if (ke2(a3) && Tt2(a3) > 0) fr2(a3, o, false);
            else {
              let p3;
              try {
                p3 = n._strategySizeAlgorithm(o);
              } catch (y3) {
                throw ue3(n, y3), y3;
              }
              try {
                mr2(n, o, p3);
              } catch (y3) {
                throw ue3(n, y3), y3;
              }
            }
            bt2(n);
          }
          u4(Ye2, "ReadableStreamDefaultControllerEnqueue");
          function ue3(n, o) {
            const a3 = n._controlledReadableStream;
            a3._state === "readable" && (Ae(n), Ut(n), fo(a3, o));
          }
          u4(ue3, "ReadableStreamDefaultControllerError");
          function Fr(n) {
            const o = n._controlledReadableStream._state;
            return o === "errored" ? null : o === "closed" ? 0 : n._strategyHWM - n._queueTotalSize;
          }
          u4(Fr, "ReadableStreamDefaultControllerGetDesiredSize");
          function $i2(n) {
            return !so(n);
          }
          u4($i2, "ReadableStreamDefaultControllerHasBackpressure");
          function Ge(n) {
            const o = n._controlledReadableStream._state;
            return !n._closeRequested && o === "readable";
          }
          u4(Ge, "ReadableStreamDefaultControllerCanCloseOrEnqueue");
          function ao(n, o, a3, p3, y3, _5, S6) {
            o._controlledReadableStream = n, o._queue = void 0, o._queueTotalSize = void 0, Ae(o), o._started = false, o._closeRequested = false, o._pullAgain = false, o._pulling = false, o._strategySizeAlgorithm = S6, o._strategyHWM = _5, o._pullAlgorithm = p3, o._cancelAlgorithm = y3, n._readableStreamController = o;
            const C5 = a3();
            v4(k4(C5), () => (o._started = true, bt2(o), null), (q6) => (ue3(o, q6), null));
          }
          u4(ao, "SetUpReadableStreamDefaultController");
          function Di2(n, o, a3, p3) {
            const y3 = Object.create(ae3.prototype);
            let _5, S6, C5;
            o.start !== void 0 ? _5 = u4(() => o.start(y3), "startAlgorithm") : _5 = u4(() => {
            }, "startAlgorithm"), o.pull !== void 0 ? S6 = u4(() => o.pull(y3), "pullAlgorithm") : S6 = u4(() => k4(void 0), "pullAlgorithm"), o.cancel !== void 0 ? C5 = u4((q6) => o.cancel(q6), "cancelAlgorithm") : C5 = u4(() => k4(void 0), "cancelAlgorithm"), ao(n, y3, _5, S6, C5, a3, p3);
          }
          u4(Di2, "SetUpReadableStreamDefaultControllerFromUnderlyingSource");
          function Nt2(n) {
            return new TypeError(`ReadableStreamDefaultController.prototype.${n} can only be used on a ReadableStreamDefaultController`);
          }
          u4(Nt2, "defaultControllerBrandCheckException$1");
          function Mi2(n, o) {
            return ze2(n._readableStreamController) ? Ui2(n) : xi2(n);
          }
          u4(Mi2, "ReadableStreamTee");
          function xi2(n, o) {
            const a3 = Ne2(n);
            let p3 = false, y3 = false, _5 = false, S6 = false, C5, q6, P5, W6, O4;
            const j3 = I5((G3) => {
              O4 = G3;
            });
            function fe4() {
              return p3 ? (y3 = true, k4(void 0)) : (p3 = true, ut2(a3, { _chunkSteps: u4((Z4) => {
                ge3(() => {
                  y3 = false;
                  const re3 = Z4, Ce2 = Z4;
                  _5 || Ye2(P5._readableStreamController, re3), S6 || Ye2(W6._readableStreamController, Ce2), p3 = false, y3 && fe4();
                });
              }, "_chunkSteps"), _closeSteps: u4(() => {
                p3 = false, _5 || $e2(P5._readableStreamController), S6 || $e2(W6._readableStreamController), (!_5 || !S6) && O4(void 0);
              }, "_closeSteps"), _errorSteps: u4(() => {
                p3 = false;
              }, "_errorSteps") }), k4(void 0));
            }
            u4(fe4, "pullAlgorithm");
            function et2(G3) {
              if (_5 = true, C5 = G3, S6) {
                const Z4 = lt2([C5, q6]), re3 = le3(n, Z4);
                O4(re3);
              }
              return j3;
            }
            u4(et2, "cancel1Algorithm");
            function We2(G3) {
              if (S6 = true, q6 = G3, _5) {
                const Z4 = lt2([C5, q6]), re3 = le3(n, Z4);
                O4(re3);
              }
              return j3;
            }
            u4(We2, "cancel2Algorithm");
            function Te2() {
            }
            return u4(Te2, "startAlgorithm"), P5 = mt(Te2, fe4, et2), W6 = mt(Te2, fe4, We2), U6(a3._closedPromise, (G3) => (ue3(P5._readableStreamController, G3), ue3(W6._readableStreamController, G3), (!_5 || !S6) && O4(void 0), null)), [P5, W6];
          }
          u4(xi2, "ReadableStreamDefaultTee");
          function Ui2(n) {
            let o = Ne2(n), a3 = false, p3 = false, y3 = false, _5 = false, S6 = false, C5, q6, P5, W6, O4;
            const j3 = I5((E3) => {
              O4 = E3;
            });
            function fe4(E3) {
              U6(E3._closedPromise, (F2) => (E3 !== o || (te3(P5._readableStreamController, F2), te3(W6._readableStreamController, F2), (!_5 || !S6) && O4(void 0)), null));
            }
            u4(fe4, "forwardReaderError");
            function et2() {
              Ie2(o) && (_e2(o), o = Ne2(n), fe4(o)), ut2(o, { _chunkSteps: u4((F2) => {
                ge3(() => {
                  p3 = false, y3 = false;
                  const L4 = F2;
                  let X5 = F2;
                  if (!_5 && !S6) try {
                    X5 = Pn2(F2);
                  } catch (tt) {
                    te3(P5._readableStreamController, tt), te3(W6._readableStreamController, tt), O4(le3(n, tt));
                    return;
                  }
                  _5 || Bt(P5._readableStreamController, L4), S6 || Bt(W6._readableStreamController, X5), a3 = false, p3 ? Te2() : y3 && G3();
                });
              }, "_chunkSteps"), _closeSteps: u4(() => {
                a3 = false, _5 || ft(P5._readableStreamController), S6 || ft(W6._readableStreamController), P5._readableStreamController._pendingPullIntos.length > 0 && qt2(P5._readableStreamController, 0), W6._readableStreamController._pendingPullIntos.length > 0 && qt2(W6._readableStreamController, 0), (!_5 || !S6) && O4(void 0);
              }, "_closeSteps"), _errorSteps: u4(() => {
                a3 = false;
              }, "_errorSteps") });
            }
            u4(et2, "pullWithDefaultReader");
            function We2(E3, F2) {
              ve2(o) && (_e2(o), o = Ln2(n), fe4(o));
              const L4 = F2 ? W6 : P5, X5 = F2 ? P5 : W6;
              Mn2(o, E3, 1, { _chunkSteps: u4((rt2) => {
                ge3(() => {
                  p3 = false, y3 = false;
                  const nt = F2 ? S6 : _5;
                  if (F2 ? _5 : S6) nt || kt2(L4._readableStreamController, rt2);
                  else {
                    let Co;
                    try {
                      Co = Pn2(rt2);
                    } catch (tn2) {
                      te3(L4._readableStreamController, tn2), te3(X5._readableStreamController, tn2), O4(le3(n, tn2));
                      return;
                    }
                    nt || kt2(L4._readableStreamController, rt2), Bt(X5._readableStreamController, Co);
                  }
                  a3 = false, p3 ? Te2() : y3 && G3();
                });
              }, "_chunkSteps"), _closeSteps: u4((rt2) => {
                a3 = false;
                const nt = F2 ? S6 : _5, Gt = F2 ? _5 : S6;
                nt || ft(L4._readableStreamController), Gt || ft(X5._readableStreamController), rt2 !== void 0 && (nt || kt2(L4._readableStreamController, rt2), !Gt && X5._readableStreamController._pendingPullIntos.length > 0 && qt2(X5._readableStreamController, 0)), (!nt || !Gt) && O4(void 0);
              }, "_closeSteps"), _errorSteps: u4(() => {
                a3 = false;
              }, "_errorSteps") });
            }
            u4(We2, "pullWithBYOBReader");
            function Te2() {
              if (a3) return p3 = true, k4(void 0);
              a3 = true;
              const E3 = wr(P5._readableStreamController);
              return E3 === null ? et2() : We2(E3._view, false), k4(void 0);
            }
            u4(Te2, "pull1Algorithm");
            function G3() {
              if (a3) return y3 = true, k4(void 0);
              a3 = true;
              const E3 = wr(W6._readableStreamController);
              return E3 === null ? et2() : We2(E3._view, true), k4(void 0);
            }
            u4(G3, "pull2Algorithm");
            function Z4(E3) {
              if (_5 = true, C5 = E3, S6) {
                const F2 = lt2([C5, q6]), L4 = le3(n, F2);
                O4(L4);
              }
              return j3;
            }
            u4(Z4, "cancel1Algorithm");
            function re3(E3) {
              if (S6 = true, q6 = E3, _5) {
                const F2 = lt2([C5, q6]), L4 = le3(n, F2);
                O4(L4);
              }
              return j3;
            }
            u4(re3, "cancel2Algorithm");
            function Ce2() {
            }
            return u4(Ce2, "startAlgorithm"), P5 = lo(Ce2, Te2, Z4), W6 = lo(Ce2, G3, re3), fe4(o), [P5, W6];
          }
          u4(Ui2, "ReadableByteStreamTee");
          function Ni2(n) {
            return b6(n) && typeof n.getReader < "u";
          }
          u4(Ni2, "isReadableStreamLike");
          function Hi2(n) {
            return Ni2(n) ? Qi2(n.getReader()) : Vi2(n);
          }
          u4(Hi2, "ReadableStreamFrom");
          function Vi2(n) {
            let o;
            const a3 = Cn2(n, "async"), p3 = g4;
            function y3() {
              let S6;
              try {
                S6 = jo(a3);
              } catch (q6) {
                return T5(q6);
              }
              const C5 = k4(S6);
              return N6(C5, (q6) => {
                if (!b6(q6)) throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
                if (Lo(q6)) $e2(o._readableStreamController);
                else {
                  const W6 = $o(q6);
                  Ye2(o._readableStreamController, W6);
                }
              });
            }
            u4(y3, "pullAlgorithm");
            function _5(S6) {
              const C5 = a3.iterator;
              let q6;
              try {
                q6 = vt(C5, "return");
              } catch (O4) {
                return T5(O4);
              }
              if (q6 === void 0) return k4(void 0);
              let P5;
              try {
                P5 = M4(q6, C5, [S6]);
              } catch (O4) {
                return T5(O4);
              }
              const W6 = k4(P5);
              return N6(W6, (O4) => {
                if (!b6(O4)) throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
              });
            }
            return u4(_5, "cancelAlgorithm"), o = mt(p3, y3, _5, 0), o;
          }
          u4(Vi2, "ReadableStreamFromIterable");
          function Qi2(n) {
            let o;
            const a3 = g4;
            function p3() {
              let _5;
              try {
                _5 = n.read();
              } catch (S6) {
                return T5(S6);
              }
              return N6(_5, (S6) => {
                if (!b6(S6)) throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
                if (S6.done) $e2(o._readableStreamController);
                else {
                  const C5 = S6.value;
                  Ye2(o._readableStreamController, C5);
                }
              });
            }
            u4(p3, "pullAlgorithm");
            function y3(_5) {
              try {
                return k4(n.cancel(_5));
              } catch (S6) {
                return T5(S6);
              }
            }
            return u4(y3, "cancelAlgorithm"), o = mt(a3, p3, y3, 0), o;
          }
          u4(Qi2, "ReadableStreamFromDefaultReader");
          function Yi2(n, o) {
            ce2(n, o);
            const a3 = n, p3 = a3?.autoAllocateChunkSize, y3 = a3?.cancel, _5 = a3?.pull, S6 = a3?.start, C5 = a3?.type;
            return { autoAllocateChunkSize: p3 === void 0 ? void 0 : ur2(p3, `${o} has member 'autoAllocateChunkSize' that`), cancel: y3 === void 0 ? void 0 : Gi2(y3, a3, `${o} has member 'cancel' that`), pull: _5 === void 0 ? void 0 : Zi2(_5, a3, `${o} has member 'pull' that`), start: S6 === void 0 ? void 0 : Ki2(S6, a3, `${o} has member 'start' that`), type: C5 === void 0 ? void 0 : Ji2(C5, `${o} has member 'type' that`) };
          }
          u4(Yi2, "convertUnderlyingDefaultOrByteSource");
          function Gi2(n, o, a3) {
            return ee3(n, a3), (p3) => H5(n, o, [p3]);
          }
          u4(Gi2, "convertUnderlyingSourceCancelCallback");
          function Zi2(n, o, a3) {
            return ee3(n, a3), (p3) => H5(n, o, [p3]);
          }
          u4(Zi2, "convertUnderlyingSourcePullCallback");
          function Ki2(n, o, a3) {
            return ee3(n, a3), (p3) => M4(n, o, [p3]);
          }
          u4(Ki2, "convertUnderlyingSourceStartCallback");
          function Ji2(n, o) {
            if (n = `${n}`, n !== "bytes") throw new TypeError(`${o} '${n}' is not a valid enumeration value for ReadableStreamType`);
            return n;
          }
          u4(Ji2, "convertReadableStreamType");
          function Xi2(n, o) {
            return ce2(n, o), { preventCancel: !!n?.preventCancel };
          }
          u4(Xi2, "convertIteratorOptions");
          function uo(n, o) {
            ce2(n, o);
            const a3 = n?.preventAbort, p3 = n?.preventCancel, y3 = n?.preventClose, _5 = n?.signal;
            return _5 !== void 0 && es(_5, `${o} has member 'signal' that`), { preventAbort: !!a3, preventCancel: !!p3, preventClose: !!y3, signal: _5 };
          }
          u4(uo, "convertPipeOptions");
          function es(n, o) {
            if (!ui2(n)) throw new TypeError(`${o} is not an AbortSignal.`);
          }
          u4(es, "assertAbortSignal");
          function ts(n, o) {
            ce2(n, o);
            const a3 = n?.readable;
            sr2(a3, "readable", "ReadableWritablePair"), lr2(a3, `${o} has member 'readable' that`);
            const p3 = n?.writable;
            return sr2(p3, "writable", "ReadableWritablePair"), Un2(p3, `${o} has member 'writable' that`), { readable: a3, writable: p3 };
          }
          u4(ts, "convertReadableWritablePair");
          const Zr = class Zr {
            constructor(o = {}, a3 = {}) {
              o === void 0 ? o = null : hn2(o, "First parameter");
              const p3 = zt2(a3, "Second parameter"), y3 = Yi2(o, "First parameter");
              if (Ir(this), y3.type === "bytes") {
                if (p3.size !== void 0) throw new RangeError("The strategy for a byte stream cannot have a size function");
                const _5 = dt2(p3, 0);
                Go(this, y3, _5);
              } else {
                const _5 = Ot(p3), S6 = dt2(p3, 1);
                Di2(this, y3, S6, _5);
              }
            }
            get locked() {
              if (!qe(this)) throw De2("locked");
              return ke2(this);
            }
            cancel(o = void 0) {
              return qe(this) ? ke2(this) ? T5(new TypeError("Cannot cancel a stream that already has a reader")) : le3(this, o) : T5(De2("cancel"));
            }
            getReader(o = void 0) {
              if (!qe(this)) throw De2("getReader");
              return Ko(o, "First parameter").mode === void 0 ? Ne2(this) : Ln2(this);
            }
            pipeThrough(o, a3 = {}) {
              if (!qe(this)) throw De2("pipeThrough");
              Se2(o, 1, "pipeThrough");
              const p3 = ts(o, "First parameter"), y3 = uo(a3, "Second parameter");
              if (ke2(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
              if (Qe2(p3.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
              const _5 = io(this, p3.writable, y3.preventClose, y3.preventAbort, y3.preventCancel, y3.signal);
              return J5(_5), p3.readable;
            }
            pipeTo(o, a3 = {}) {
              if (!qe(this)) return T5(De2("pipeTo"));
              if (o === void 0) return T5("Parameter 1 is required in 'pipeTo'.");
              if (!Ve2(o)) return T5(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
              let p3;
              try {
                p3 = uo(a3, "Second parameter");
              } catch (y3) {
                return T5(y3);
              }
              return ke2(this) ? T5(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : Qe2(o) ? T5(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : io(this, o, p3.preventClose, p3.preventAbort, p3.preventCancel, p3.signal);
            }
            tee() {
              if (!qe(this)) throw De2("tee");
              const o = Mi2(this);
              return lt2(o);
            }
            values(o = void 0) {
              if (!qe(this)) throw De2("values");
              const a3 = Xi2(o, "First parameter");
              return Fo(this, a3.preventCancel);
            }
            [pr2](o) {
              return this.values(o);
            }
            static from(o) {
              return Hi2(o);
            }
          };
          u4(Zr, "ReadableStream");
          let V4 = Zr;
          Object.defineProperties(V4, { from: { enumerable: true } }), Object.defineProperties(V4.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), w5(V4.from, "from"), w5(V4.prototype.cancel, "cancel"), w5(V4.prototype.getReader, "getReader"), w5(V4.prototype.pipeThrough, "pipeThrough"), w5(V4.prototype.pipeTo, "pipeTo"), w5(V4.prototype.tee, "tee"), w5(V4.prototype.values, "values"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(V4.prototype, Symbol.toStringTag, { value: "ReadableStream", configurable: true }), Object.defineProperty(V4.prototype, pr2, { value: V4.prototype.values, writable: true, configurable: true });
          function mt(n, o, a3, p3 = 1, y3 = () => 1) {
            const _5 = Object.create(V4.prototype);
            Ir(_5);
            const S6 = Object.create(ae3.prototype);
            return ao(_5, S6, n, o, a3, p3, y3), _5;
          }
          u4(mt, "CreateReadableStream");
          function lo(n, o, a3) {
            const p3 = Object.create(V4.prototype);
            Ir(p3);
            const y3 = Object.create(ie3.prototype);
            return jn2(p3, y3, n, o, a3, 0, void 0), p3;
          }
          u4(lo, "CreateReadableByteStream");
          function Ir(n) {
            n._state = "readable", n._reader = void 0, n._storedError = void 0, n._disturbed = false;
          }
          u4(Ir, "InitializeReadableStream");
          function qe(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_readableStreamController") ? false : n instanceof V4;
          }
          u4(qe, "IsReadableStream");
          function ke2(n) {
            return n._reader !== void 0;
          }
          u4(ke2, "IsReadableStreamLocked");
          function le3(n, o) {
            if (n._disturbed = true, n._state === "closed") return k4(void 0);
            if (n._state === "errored") return T5(n._storedError);
            yt(n);
            const a3 = n._reader;
            if (a3 !== void 0 && Ie2(a3)) {
              const y3 = a3._readIntoRequests;
              a3._readIntoRequests = new Q5(), y3.forEach((_5) => {
                _5._closeSteps(void 0);
              });
            }
            const p3 = n._readableStreamController[er2](o);
            return N6(p3, g4);
          }
          u4(le3, "ReadableStreamCancel");
          function yt(n) {
            n._state = "closed";
            const o = n._reader;
            if (o !== void 0 && (cn2(o), ve2(o))) {
              const a3 = o._readRequests;
              o._readRequests = new Q5(), a3.forEach((p3) => {
                p3._closeSteps();
              });
            }
          }
          u4(yt, "ReadableStreamClose");
          function fo(n, o) {
            n._state = "errored", n._storedError = o;
            const a3 = n._reader;
            a3 !== void 0 && (ir2(a3, o), ve2(a3) ? yn2(a3, o) : xn2(a3, o));
          }
          u4(fo, "ReadableStreamError");
          function De2(n) {
            return new TypeError(`ReadableStream.prototype.${n} can only be used on a ReadableStream`);
          }
          u4(De2, "streamBrandCheckException$1");
          function co(n, o) {
            ce2(n, o);
            const a3 = n?.highWaterMark;
            return sr2(a3, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: ar2(a3) };
          }
          u4(co, "convertQueuingStrategyInit");
          const ho = u4((n) => n.byteLength, "byteLengthSizeFunction");
          w5(ho, "size");
          const Kr = class Kr {
            constructor(o) {
              Se2(o, 1, "ByteLengthQueuingStrategy"), o = co(o, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = o.highWaterMark;
            }
            get highWaterMark() {
              if (!bo(this)) throw po("highWaterMark");
              return this._byteLengthQueuingStrategyHighWaterMark;
            }
            get size() {
              if (!bo(this)) throw po("size");
              return ho;
            }
          };
          u4(Kr, "ByteLengthQueuingStrategy");
          let Ze2 = Kr;
          Object.defineProperties(Ze2.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Ze2.prototype, Symbol.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
          function po(n) {
            return new TypeError(`ByteLengthQueuingStrategy.prototype.${n} can only be used on a ByteLengthQueuingStrategy`);
          }
          u4(po, "byteLengthBrandCheckException");
          function bo(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_byteLengthQueuingStrategyHighWaterMark") ? false : n instanceof Ze2;
          }
          u4(bo, "IsByteLengthQueuingStrategy");
          const mo = u4(() => 1, "countSizeFunction");
          w5(mo, "size");
          const Jr = class Jr {
            constructor(o) {
              Se2(o, 1, "CountQueuingStrategy"), o = co(o, "First parameter"), this._countQueuingStrategyHighWaterMark = o.highWaterMark;
            }
            get highWaterMark() {
              if (!go(this)) throw yo("highWaterMark");
              return this._countQueuingStrategyHighWaterMark;
            }
            get size() {
              if (!go(this)) throw yo("size");
              return mo;
            }
          };
          u4(Jr, "CountQueuingStrategy");
          let Ke2 = Jr;
          Object.defineProperties(Ke2.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Ke2.prototype, Symbol.toStringTag, { value: "CountQueuingStrategy", configurable: true });
          function yo(n) {
            return new TypeError(`CountQueuingStrategy.prototype.${n} can only be used on a CountQueuingStrategy`);
          }
          u4(yo, "countBrandCheckException");
          function go(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_countQueuingStrategyHighWaterMark") ? false : n instanceof Ke2;
          }
          u4(go, "IsCountQueuingStrategy");
          function rs(n, o) {
            ce2(n, o);
            const a3 = n?.cancel, p3 = n?.flush, y3 = n?.readableType, _5 = n?.start, S6 = n?.transform, C5 = n?.writableType;
            return { cancel: a3 === void 0 ? void 0 : ss(a3, n, `${o} has member 'cancel' that`), flush: p3 === void 0 ? void 0 : ns(p3, n, `${o} has member 'flush' that`), readableType: y3, start: _5 === void 0 ? void 0 : os2(_5, n, `${o} has member 'start' that`), transform: S6 === void 0 ? void 0 : is(S6, n, `${o} has member 'transform' that`), writableType: C5 };
          }
          u4(rs, "convertTransformer");
          function ns(n, o, a3) {
            return ee3(n, a3), (p3) => H5(n, o, [p3]);
          }
          u4(ns, "convertTransformerFlushCallback");
          function os2(n, o, a3) {
            return ee3(n, a3), (p3) => M4(n, o, [p3]);
          }
          u4(os2, "convertTransformerStartCallback");
          function is(n, o, a3) {
            return ee3(n, a3), (p3, y3) => H5(n, o, [p3, y3]);
          }
          u4(is, "convertTransformerTransformCallback");
          function ss(n, o, a3) {
            return ee3(n, a3), (p3) => H5(n, o, [p3]);
          }
          u4(ss, "convertTransformerCancelCallback");
          const Xr = class Xr {
            constructor(o = {}, a3 = {}, p3 = {}) {
              o === void 0 && (o = null);
              const y3 = zt2(a3, "Second parameter"), _5 = zt2(p3, "Third parameter"), S6 = rs(o, "First parameter");
              if (S6.readableType !== void 0) throw new RangeError("Invalid readableType specified");
              if (S6.writableType !== void 0) throw new RangeError("Invalid writableType specified");
              const C5 = dt2(_5, 0), q6 = Ot(_5), P5 = dt2(y3, 1), W6 = Ot(y3);
              let O4;
              const j3 = I5((fe4) => {
                O4 = fe4;
              });
              as(this, j3, P5, W6, C5, q6), ls(this, S6), S6.start !== void 0 ? O4(S6.start(this._transformStreamController)) : O4(void 0);
            }
            get readable() {
              if (!_o(this)) throw To("readable");
              return this._readable;
            }
            get writable() {
              if (!_o(this)) throw To("writable");
              return this._writable;
            }
          };
          u4(Xr, "TransformStream");
          let Je2 = Xr;
          Object.defineProperties(Je2.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Je2.prototype, Symbol.toStringTag, { value: "TransformStream", configurable: true });
          function as(n, o, a3, p3, y3, _5) {
            function S6() {
              return o;
            }
            u4(S6, "startAlgorithm");
            function C5(j3) {
              return ds(n, j3);
            }
            u4(C5, "writeAlgorithm");
            function q6(j3) {
              return hs(n, j3);
            }
            u4(q6, "abortAlgorithm");
            function P5() {
              return ps(n);
            }
            u4(P5, "closeAlgorithm"), n._writable = ci2(S6, C5, P5, q6, a3, p3);
            function W6() {
              return bs(n);
            }
            u4(W6, "pullAlgorithm");
            function O4(j3) {
              return ms(n, j3);
            }
            u4(O4, "cancelAlgorithm"), n._readable = mt(S6, W6, O4, y3, _5), n._backpressure = void 0, n._backpressureChangePromise = void 0, n._backpressureChangePromise_resolve = void 0, Ht(n, true), n._transformStreamController = void 0;
          }
          u4(as, "InitializeTransformStream");
          function _o(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_transformStreamController") ? false : n instanceof Je2;
          }
          u4(_o, "IsTransformStream");
          function So(n, o) {
            ue3(n._readable._readableStreamController, o), jr(n, o);
          }
          u4(So, "TransformStreamError");
          function jr(n, o) {
            Qt(n._transformStreamController), ht2(n._writable._writableStreamController, o), Lr(n);
          }
          u4(jr, "TransformStreamErrorWritableAndUnblockWrite");
          function Lr(n) {
            n._backpressure && Ht(n, false);
          }
          u4(Lr, "TransformStreamUnblockWrite");
          function Ht(n, o) {
            n._backpressureChangePromise !== void 0 && n._backpressureChangePromise_resolve(), n._backpressureChangePromise = I5((a3) => {
              n._backpressureChangePromise_resolve = a3;
            }), n._backpressure = o;
          }
          u4(Ht, "TransformStreamSetBackpressure");
          const en2 = class en {
            constructor() {
              throw new TypeError("Illegal constructor");
            }
            get desiredSize() {
              if (!Vt(this)) throw Yt("desiredSize");
              const o = this._controlledTransformStream._readable._readableStreamController;
              return Fr(o);
            }
            enqueue(o = void 0) {
              if (!Vt(this)) throw Yt("enqueue");
              wo(this, o);
            }
            error(o = void 0) {
              if (!Vt(this)) throw Yt("error");
              fs6(this, o);
            }
            terminate() {
              if (!Vt(this)) throw Yt("terminate");
              cs(this);
            }
          };
          u4(en2, "TransformStreamDefaultController");
          let me3 = en2;
          Object.defineProperties(me3.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), w5(me3.prototype.enqueue, "enqueue"), w5(me3.prototype.error, "error"), w5(me3.prototype.terminate, "terminate"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(me3.prototype, Symbol.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
          function Vt(n) {
            return !b6(n) || !Object.prototype.hasOwnProperty.call(n, "_controlledTransformStream") ? false : n instanceof me3;
          }
          u4(Vt, "IsTransformStreamDefaultController");
          function us(n, o, a3, p3, y3) {
            o._controlledTransformStream = n, n._transformStreamController = o, o._transformAlgorithm = a3, o._flushAlgorithm = p3, o._cancelAlgorithm = y3, o._finishPromise = void 0, o._finishPromise_resolve = void 0, o._finishPromise_reject = void 0;
          }
          u4(us, "SetUpTransformStreamDefaultController");
          function ls(n, o) {
            const a3 = Object.create(me3.prototype);
            let p3, y3, _5;
            o.transform !== void 0 ? p3 = u4((S6) => o.transform(S6, a3), "transformAlgorithm") : p3 = u4((S6) => {
              try {
                return wo(a3, S6), k4(void 0);
              } catch (C5) {
                return T5(C5);
              }
            }, "transformAlgorithm"), o.flush !== void 0 ? y3 = u4(() => o.flush(a3), "flushAlgorithm") : y3 = u4(() => k4(void 0), "flushAlgorithm"), o.cancel !== void 0 ? _5 = u4((S6) => o.cancel(S6), "cancelAlgorithm") : _5 = u4(() => k4(void 0), "cancelAlgorithm"), us(n, a3, p3, y3, _5);
          }
          u4(ls, "SetUpTransformStreamDefaultControllerFromTransformer");
          function Qt(n) {
            n._transformAlgorithm = void 0, n._flushAlgorithm = void 0, n._cancelAlgorithm = void 0;
          }
          u4(Qt, "TransformStreamDefaultControllerClearAlgorithms");
          function wo(n, o) {
            const a3 = n._controlledTransformStream, p3 = a3._readable._readableStreamController;
            if (!Ge(p3)) throw new TypeError("Readable side is not in a state that permits enqueue");
            try {
              Ye2(p3, o);
            } catch (_5) {
              throw jr(a3, _5), a3._readable._storedError;
            }
            $i2(p3) !== a3._backpressure && Ht(a3, true);
          }
          u4(wo, "TransformStreamDefaultControllerEnqueue");
          function fs6(n, o) {
            So(n._controlledTransformStream, o);
          }
          u4(fs6, "TransformStreamDefaultControllerError");
          function Ro(n, o) {
            const a3 = n._transformAlgorithm(o);
            return N6(a3, void 0, (p3) => {
              throw So(n._controlledTransformStream, p3), p3;
            });
          }
          u4(Ro, "TransformStreamDefaultControllerPerformTransform");
          function cs(n) {
            const o = n._controlledTransformStream, a3 = o._readable._readableStreamController;
            $e2(a3);
            const p3 = new TypeError("TransformStream terminated");
            jr(o, p3);
          }
          u4(cs, "TransformStreamDefaultControllerTerminate");
          function ds(n, o) {
            const a3 = n._transformStreamController;
            if (n._backpressure) {
              const p3 = n._backpressureChangePromise;
              return N6(p3, () => {
                const y3 = n._writable;
                if (y3._state === "erroring") throw y3._storedError;
                return Ro(a3, o);
              });
            }
            return Ro(a3, o);
          }
          u4(ds, "TransformStreamDefaultSinkWriteAlgorithm");
          function hs(n, o) {
            const a3 = n._transformStreamController;
            if (a3._finishPromise !== void 0) return a3._finishPromise;
            const p3 = n._readable;
            a3._finishPromise = I5((_5, S6) => {
              a3._finishPromise_resolve = _5, a3._finishPromise_reject = S6;
            });
            const y3 = a3._cancelAlgorithm(o);
            return Qt(a3), v4(y3, () => (p3._state === "errored" ? Xe2(a3, p3._storedError) : (ue3(p3._readableStreamController, o), $r(a3)), null), (_5) => (ue3(p3._readableStreamController, _5), Xe2(a3, _5), null)), a3._finishPromise;
          }
          u4(hs, "TransformStreamDefaultSinkAbortAlgorithm");
          function ps(n) {
            const o = n._transformStreamController;
            if (o._finishPromise !== void 0) return o._finishPromise;
            const a3 = n._readable;
            o._finishPromise = I5((y3, _5) => {
              o._finishPromise_resolve = y3, o._finishPromise_reject = _5;
            });
            const p3 = o._flushAlgorithm();
            return Qt(o), v4(p3, () => (a3._state === "errored" ? Xe2(o, a3._storedError) : ($e2(a3._readableStreamController), $r(o)), null), (y3) => (ue3(a3._readableStreamController, y3), Xe2(o, y3), null)), o._finishPromise;
          }
          u4(ps, "TransformStreamDefaultSinkCloseAlgorithm");
          function bs(n) {
            return Ht(n, false), n._backpressureChangePromise;
          }
          u4(bs, "TransformStreamDefaultSourcePullAlgorithm");
          function ms(n, o) {
            const a3 = n._transformStreamController;
            if (a3._finishPromise !== void 0) return a3._finishPromise;
            const p3 = n._writable;
            a3._finishPromise = I5((_5, S6) => {
              a3._finishPromise_resolve = _5, a3._finishPromise_reject = S6;
            });
            const y3 = a3._cancelAlgorithm(o);
            return Qt(a3), v4(y3, () => (p3._state === "errored" ? Xe2(a3, p3._storedError) : (ht2(p3._writableStreamController, o), Lr(n), $r(a3)), null), (_5) => (ht2(p3._writableStreamController, _5), Lr(n), Xe2(a3, _5), null)), a3._finishPromise;
          }
          u4(ms, "TransformStreamDefaultSourceCancelAlgorithm");
          function Yt(n) {
            return new TypeError(`TransformStreamDefaultController.prototype.${n} can only be used on a TransformStreamDefaultController`);
          }
          u4(Yt, "defaultControllerBrandCheckException");
          function $r(n) {
            n._finishPromise_resolve !== void 0 && (n._finishPromise_resolve(), n._finishPromise_resolve = void 0, n._finishPromise_reject = void 0);
          }
          u4($r, "defaultControllerFinishPromiseResolve");
          function Xe2(n, o) {
            n._finishPromise_reject !== void 0 && (J5(n._finishPromise), n._finishPromise_reject(o), n._finishPromise_resolve = void 0, n._finishPromise_reject = void 0);
          }
          u4(Xe2, "defaultControllerFinishPromiseReject");
          function To(n) {
            return new TypeError(`TransformStream.prototype.${n} can only be used on a TransformStream`);
          }
          u4(To, "streamBrandCheckException"), d4.ByteLengthQueuingStrategy = Ze2, d4.CountQueuingStrategy = Ke2, d4.ReadableByteStreamController = ie3, d4.ReadableStream = V4, d4.ReadableStreamBYOBReader = he3, d4.ReadableStreamBYOBRequest = Re2, d4.ReadableStreamDefaultController = ae3, d4.ReadableStreamDefaultReader = de3, d4.TransformStream = Je2, d4.TransformStreamDefaultController = me3, d4.WritableStream = pe2, d4.WritableStreamDefaultController = Be2, d4.WritableStreamDefaultWriter = se2;
        });
      })(ponyfill_es2018$1, ponyfill_es2018$1.exports)), ponyfill_es2018$1.exports;
    }
    u4(requirePonyfill_es2018, "requirePonyfill_es2018");
    var hasRequiredStreams;
    function requireStreams() {
      if (hasRequiredStreams) return streams;
      hasRequiredStreams = 1;
      const c2 = 65536;
      if (!globalThis.ReadableStream) try {
        const l3 = require("process"), { emitWarning: d4 } = l3;
        try {
          l3.emitWarning = () => {
          }, Object.assign(globalThis, require("stream/web")), l3.emitWarning = d4;
        } catch (g4) {
          throw l3.emitWarning = d4, g4;
        }
      } catch {
        Object.assign(globalThis, requirePonyfill_es2018());
      }
      try {
        const { Blob: l3 } = require("buffer");
        l3 && !l3.prototype.stream && (l3.prototype.stream = u4(function(g4) {
          let b6 = 0;
          const R4 = this;
          return new ReadableStream({ type: "bytes", async pull(w5) {
            const z4 = await R4.slice(b6, Math.min(R4.size, b6 + c2)).arrayBuffer();
            b6 += z4.byteLength, w5.enqueue(new Uint8Array(z4)), b6 === R4.size && w5.close();
          } });
        }, "name"));
      } catch {
      }
      return streams;
    }
    u4(requireStreams, "requireStreams"), requireStreams();
    var POOL_SIZE = 65536;
    async function* toIterator(c2, l3 = true) {
      for (const d4 of c2) if ("stream" in d4) yield* d4.stream();
      else if (ArrayBuffer.isView(d4)) if (l3) {
        let g4 = d4.byteOffset;
        const b6 = d4.byteOffset + d4.byteLength;
        for (; g4 !== b6; ) {
          const R4 = Math.min(b6 - g4, POOL_SIZE), w5 = d4.buffer.slice(g4, g4 + R4);
          g4 += w5.byteLength, yield new Uint8Array(w5);
        }
      } else yield d4;
      else {
        let g4 = 0, b6 = d4;
        for (; g4 !== b6.size; ) {
          const w5 = await b6.slice(g4, Math.min(b6.size, g4 + POOL_SIZE)).arrayBuffer();
          g4 += w5.byteLength, yield new Uint8Array(w5);
        }
      }
    }
    u4(toIterator, "toIterator");
    var _Blob = (Oe2 = class {
      constructor(l3 = [], d4 = {}) {
        ye2(this, Pe2, []);
        ye2(this, gt, "");
        ye2(this, ot, 0);
        ye2(this, Zt, "transparent");
        if (typeof l3 != "object" || l3 === null) throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        if (typeof l3[Symbol.iterator] != "function") throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        if (typeof d4 != "object" && typeof d4 != "function") throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        d4 === null && (d4 = {});
        const g4 = new TextEncoder();
        for (const R4 of l3) {
          let w5;
          ArrayBuffer.isView(R4) ? w5 = new Uint8Array(R4.buffer.slice(R4.byteOffset, R4.byteOffset + R4.byteLength)) : R4 instanceof ArrayBuffer ? w5 = new Uint8Array(R4.slice(0)) : R4 instanceof Oe2 ? w5 = R4 : w5 = g4.encode(`${R4}`), ne3(this, ot, D3(this, ot) + (ArrayBuffer.isView(w5) ? w5.byteLength : w5.size)), D3(this, Pe2).push(w5);
        }
        ne3(this, Zt, `${d4.endings === void 0 ? "transparent" : d4.endings}`);
        const b6 = d4.type === void 0 ? "" : String(d4.type);
        ne3(this, gt, /^[\x20-\x7E]*$/.test(b6) ? b6 : "");
      }
      get size() {
        return D3(this, ot);
      }
      get type() {
        return D3(this, gt);
      }
      async text() {
        const l3 = new TextDecoder();
        let d4 = "";
        for await (const g4 of toIterator(D3(this, Pe2), false)) d4 += l3.decode(g4, { stream: true });
        return d4 += l3.decode(), d4;
      }
      async arrayBuffer() {
        const l3 = new Uint8Array(this.size);
        let d4 = 0;
        for await (const g4 of toIterator(D3(this, Pe2), false)) l3.set(g4, d4), d4 += g4.length;
        return l3.buffer;
      }
      stream() {
        const l3 = toIterator(D3(this, Pe2), true);
        return new globalThis.ReadableStream({ type: "bytes", async pull(d4) {
          const g4 = await l3.next();
          g4.done ? d4.close() : d4.enqueue(g4.value);
        }, async cancel() {
          await l3.return();
        } });
      }
      slice(l3 = 0, d4 = this.size, g4 = "") {
        const { size: b6 } = this;
        let R4 = l3 < 0 ? Math.max(b6 + l3, 0) : Math.min(l3, b6), w5 = d4 < 0 ? Math.max(b6 + d4, 0) : Math.min(d4, b6);
        const A2 = Math.max(w5 - R4, 0), z4 = D3(this, Pe2), B3 = [];
        let I5 = 0;
        for (const T5 of z4) {
          if (I5 >= A2) break;
          const $6 = ArrayBuffer.isView(T5) ? T5.byteLength : T5.size;
          if (R4 && $6 <= R4) R4 -= $6, w5 -= $6;
          else {
            let v4;
            ArrayBuffer.isView(T5) ? (v4 = T5.subarray(R4, Math.min($6, w5)), I5 += v4.byteLength) : (v4 = T5.slice(R4, Math.min($6, w5)), I5 += v4.size), w5 -= $6, B3.push(v4), R4 = 0;
          }
        }
        const k4 = new Oe2([], { type: String(g4).toLowerCase() });
        return ne3(k4, ot, A2), ne3(k4, Pe2, B3), k4;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](l3) {
        return l3 && typeof l3 == "object" && typeof l3.constructor == "function" && (typeof l3.stream == "function" || typeof l3.arrayBuffer == "function") && /^(Blob|File)$/.test(l3[Symbol.toStringTag]);
      }
    }, Pe2 = /* @__PURE__ */ new WeakMap(), gt = /* @__PURE__ */ new WeakMap(), ot = /* @__PURE__ */ new WeakMap(), Zt = /* @__PURE__ */ new WeakMap(), u4(Oe2, "Blob"), Oe2);
    Object.defineProperties(_Blob.prototype, { size: { enumerable: true }, type: { enumerable: true }, slice: { enumerable: true } });
    var Blob2 = _Blob;
    var _File = (it = class extends Blob2 {
      constructor(d4, g4, b6 = {}) {
        if (arguments.length < 2) throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        super(d4, b6);
        ye2(this, _t, 0);
        ye2(this, St2, "");
        b6 === null && (b6 = {});
        const R4 = b6.lastModified === void 0 ? Date.now() : Number(b6.lastModified);
        Number.isNaN(R4) || ne3(this, _t, R4), ne3(this, St2, String(g4));
      }
      get name() {
        return D3(this, St2);
      }
      get lastModified() {
        return D3(this, _t);
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
      static [Symbol.hasInstance](d4) {
        return !!d4 && d4 instanceof Blob2 && /^(File)$/.test(d4[Symbol.toStringTag]);
      }
    }, _t = /* @__PURE__ */ new WeakMap(), St2 = /* @__PURE__ */ new WeakMap(), u4(it, "File"), it);
    var File = _File;
    var { toStringTag: t$1, iterator: i2, hasInstance: h8 } = Symbol;
    var r6 = Math.random;
    var m4 = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    var f3 = u4((c2, l3, d4) => (c2 += "", /^(Blob|File)$/.test(l3 && l3[t$1]) ? [(d4 = d4 !== void 0 ? d4 + "" : l3[t$1] == "File" ? l3.name : "blob", c2), l3.name !== d4 || l3[t$1] == "blob" ? new File([l3], d4, l3) : l3] : [c2, l3 + ""]), "f");
    var e$1 = u4((c2, l3) => (l3 ? c2 : c2.replace(/\r?\n|\r/g, `\r
`)).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "e$1");
    var x5 = u4((c2, l3, d4) => {
      if (l3.length < d4) throw new TypeError(`Failed to execute '${c2}' on 'FormData': ${d4} arguments required, but only ${l3.length} present.`);
    }, "x");
    var FormData = (st = class {
      constructor(...l3) {
        ye2(this, oe3, []);
        if (l3.length) throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.");
      }
      get [t$1]() {
        return "FormData";
      }
      [i2]() {
        return this.entries();
      }
      static [h8](l3) {
        return l3 && typeof l3 == "object" && l3[t$1] === "FormData" && !m4.some((d4) => typeof l3[d4] != "function");
      }
      append(...l3) {
        x5("append", arguments, 2), D3(this, oe3).push(f3(...l3));
      }
      delete(l3) {
        x5("delete", arguments, 1), l3 += "", ne3(this, oe3, D3(this, oe3).filter(([d4]) => d4 !== l3));
      }
      get(l3) {
        x5("get", arguments, 1), l3 += "";
        for (var d4 = D3(this, oe3), g4 = d4.length, b6 = 0; b6 < g4; b6++) if (d4[b6][0] === l3) return d4[b6][1];
        return null;
      }
      getAll(l3, d4) {
        return x5("getAll", arguments, 1), d4 = [], l3 += "", D3(this, oe3).forEach((g4) => g4[0] === l3 && d4.push(g4[1])), d4;
      }
      has(l3) {
        return x5("has", arguments, 1), l3 += "", D3(this, oe3).some((d4) => d4[0] === l3);
      }
      forEach(l3, d4) {
        x5("forEach", arguments, 1);
        for (var [g4, b6] of this) l3.call(d4, b6, g4, this);
      }
      set(...l3) {
        x5("set", arguments, 2);
        var d4 = [], g4 = true;
        l3 = f3(...l3), D3(this, oe3).forEach((b6) => {
          b6[0] === l3[0] ? g4 && (g4 = !d4.push(l3)) : d4.push(b6);
        }), g4 && d4.push(l3), ne3(this, oe3, d4);
      }
      *entries() {
        yield* D3(this, oe3);
      }
      *keys() {
        for (var [l3] of this) yield l3;
      }
      *values() {
        for (var [, l3] of this) yield l3;
      }
    }, oe3 = /* @__PURE__ */ new WeakMap(), u4(st, "FormData"), st);
    function formDataToBlob(c2, l3 = Blob2) {
      var d4 = `${r6()}${r6()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), g4 = [], b6 = `--${d4}\r
Content-Disposition: form-data; name="`;
      return c2.forEach((R4, w5) => typeof R4 == "string" ? g4.push(b6 + e$1(w5) + `"\r
\r
${R4.replace(/\r(?!\n)|(?<!\r)\n/g, `\r
`)}\r
`) : g4.push(b6 + e$1(w5) + `"; filename="${e$1(R4.name, 1)}"\r
Content-Type: ${R4.type || "application/octet-stream"}\r
\r
`, R4, `\r
`)), g4.push(`--${d4}--`), new l3(g4, { type: "multipart/form-data; boundary=" + d4 });
    }
    u4(formDataToBlob, "formDataToBlob");
    var rn2 = class rn extends Error {
      constructor(l3, d4) {
        super(l3), Error.captureStackTrace(this, this.constructor), this.type = d4;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    u4(rn2, "FetchBaseError");
    var FetchBaseError = rn2;
    var nn2 = class nn extends FetchBaseError {
      constructor(l3, d4, g4) {
        super(l3, d4), g4 && (this.code = this.errno = g4.code, this.erroredSysCall = g4.syscall);
      }
    };
    u4(nn2, "FetchError");
    var FetchError = nn2;
    var NAME = Symbol.toStringTag;
    var isURLSearchParameters = u4((c2) => typeof c2 == "object" && typeof c2.append == "function" && typeof c2.delete == "function" && typeof c2.get == "function" && typeof c2.getAll == "function" && typeof c2.has == "function" && typeof c2.set == "function" && typeof c2.sort == "function" && c2[NAME] === "URLSearchParams", "isURLSearchParameters");
    var isBlob = u4((c2) => c2 && typeof c2 == "object" && typeof c2.arrayBuffer == "function" && typeof c2.type == "string" && typeof c2.stream == "function" && typeof c2.constructor == "function" && /^(Blob|File)$/.test(c2[NAME]), "isBlob");
    var isAbortSignal = u4((c2) => typeof c2 == "object" && (c2[NAME] === "AbortSignal" || c2[NAME] === "EventTarget"), "isAbortSignal");
    var isDomainOrSubdomain = u4((c2, l3) => {
      const d4 = new URL(l3).hostname, g4 = new URL(c2).hostname;
      return d4 === g4 || d4.endsWith(`.${g4}`);
    }, "isDomainOrSubdomain");
    var isSameProtocol = u4((c2, l3) => {
      const d4 = new URL(l3).protocol, g4 = new URL(c2).protocol;
      return d4 === g4;
    }, "isSameProtocol");
    var pipeline2 = require$$0$1.promisify(Stream__default.pipeline);
    var INTERNALS$2 = Symbol("Body internals");
    var on2 = class on {
      constructor(l3, { size: d4 = 0 } = {}) {
        let g4 = null;
        l3 === null ? l3 = null : isURLSearchParameters(l3) ? l3 = require$$0.Buffer.from(l3.toString()) : isBlob(l3) || require$$0.Buffer.isBuffer(l3) || (require$$0$1.types.isAnyArrayBuffer(l3) ? l3 = require$$0.Buffer.from(l3) : ArrayBuffer.isView(l3) ? l3 = require$$0.Buffer.from(l3.buffer, l3.byteOffset, l3.byteLength) : l3 instanceof Stream__default || (l3 instanceof FormData ? (l3 = formDataToBlob(l3), g4 = l3.type.split("=")[1]) : l3 = require$$0.Buffer.from(String(l3))));
        let b6 = l3;
        require$$0.Buffer.isBuffer(l3) ? b6 = Stream__default.Readable.from(l3) : isBlob(l3) && (b6 = Stream__default.Readable.from(l3.stream())), this[INTERNALS$2] = { body: l3, stream: b6, boundary: g4, disturbed: false, error: null }, this.size = d4, l3 instanceof Stream__default && l3.on("error", (R4) => {
          const w5 = R4 instanceof FetchBaseError ? R4 : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${R4.message}`, "system", R4);
          this[INTERNALS$2].error = w5;
        });
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer: l3, byteOffset: d4, byteLength: g4 } = await consumeBody(this);
        return l3.slice(d4, d4 + g4);
      }
      async formData() {
        const l3 = this.headers.get("content-type");
        if (l3.startsWith("application/x-www-form-urlencoded")) {
          const g4 = new FormData(), b6 = new URLSearchParams(await this.text());
          for (const [R4, w5] of b6) g4.append(R4, w5);
          return g4;
        }
        const { toFormData: d4 } = await Promise.resolve().then(() => __toESM(require_multipart_parser()));
        return d4(this.body, l3);
      }
      async blob() {
        const l3 = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "", d4 = await this.arrayBuffer();
        return new Blob2([d4], { type: l3 });
      }
      async json() {
        const l3 = await this.text();
        return JSON.parse(l3);
      }
      async text() {
        const l3 = await consumeBody(this);
        return new TextDecoder().decode(l3);
      }
      buffer() {
        return consumeBody(this);
      }
    };
    u4(on2, "Body");
    var Body = on2;
    Body.prototype.buffer = require$$0$1.deprecate(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer"), Object.defineProperties(Body.prototype, { body: { enumerable: true }, bodyUsed: { enumerable: true }, arrayBuffer: { enumerable: true }, blob: { enumerable: true }, json: { enumerable: true }, text: { enumerable: true }, data: { get: require$$0$1.deprecate(() => {
    }, "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)") } });
    async function consumeBody(c2) {
      if (c2[INTERNALS$2].disturbed) throw new TypeError(`body used already for: ${c2.url}`);
      if (c2[INTERNALS$2].disturbed = true, c2[INTERNALS$2].error) throw c2[INTERNALS$2].error;
      const { body: l3 } = c2;
      if (l3 === null || !(l3 instanceof Stream__default)) return require$$0.Buffer.alloc(0);
      const d4 = [];
      let g4 = 0;
      try {
        for await (const b6 of l3) {
          if (c2.size > 0 && g4 + b6.length > c2.size) {
            const R4 = new FetchError(`content size at ${c2.url} over limit: ${c2.size}`, "max-size");
            throw l3.destroy(R4), R4;
          }
          g4 += b6.length, d4.push(b6);
        }
      } catch (b6) {
        throw b6 instanceof FetchBaseError ? b6 : new FetchError(`Invalid response body while trying to fetch ${c2.url}: ${b6.message}`, "system", b6);
      }
      if (l3.readableEnded === true || l3._readableState.ended === true) try {
        return d4.every((b6) => typeof b6 == "string") ? require$$0.Buffer.from(d4.join("")) : require$$0.Buffer.concat(d4, g4);
      } catch (b6) {
        throw new FetchError(`Could not create Buffer from response body for ${c2.url}: ${b6.message}`, "system", b6);
      }
      else throw new FetchError(`Premature close of server response while trying to fetch ${c2.url}`);
    }
    u4(consumeBody, "consumeBody");
    var clone = u4((c2, l3) => {
      let d4, g4, { body: b6 } = c2[INTERNALS$2];
      if (c2.bodyUsed) throw new Error("cannot clone body after it is used");
      return b6 instanceof Stream__default && typeof b6.getBoundary != "function" && (d4 = new Stream.PassThrough({ highWaterMark: l3 }), g4 = new Stream.PassThrough({ highWaterMark: l3 }), b6.pipe(d4), b6.pipe(g4), c2[INTERNALS$2].stream = d4, b6 = g4), b6;
    }, "clone");
    var getNonSpecFormDataBoundary = require$$0$1.deprecate((c2) => c2.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    var extractContentType = u4((c2, l3) => c2 === null ? null : typeof c2 == "string" ? "text/plain;charset=UTF-8" : isURLSearchParameters(c2) ? "application/x-www-form-urlencoded;charset=UTF-8" : isBlob(c2) ? c2.type || null : require$$0.Buffer.isBuffer(c2) || require$$0$1.types.isAnyArrayBuffer(c2) || ArrayBuffer.isView(c2) ? null : c2 instanceof FormData ? `multipart/form-data; boundary=${l3[INTERNALS$2].boundary}` : c2 && typeof c2.getBoundary == "function" ? `multipart/form-data;boundary=${getNonSpecFormDataBoundary(c2)}` : c2 instanceof Stream__default ? null : "text/plain;charset=UTF-8", "extractContentType");
    var getTotalBytes = u4((c2) => {
      const { body: l3 } = c2[INTERNALS$2];
      return l3 === null ? 0 : isBlob(l3) ? l3.size : require$$0.Buffer.isBuffer(l3) ? l3.length : l3 && typeof l3.getLengthSync == "function" && l3.hasKnownLength && l3.hasKnownLength() ? l3.getLengthSync() : null;
    }, "getTotalBytes");
    var writeToStream = u4(async (c2, { body: l3 }) => {
      l3 === null ? c2.end() : await pipeline2(l3, c2);
    }, "writeToStream");
    var validateHeaderName = typeof http__default.validateHeaderName == "function" ? http__default.validateHeaderName : (c2) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(c2)) {
        const l3 = new TypeError(`Header name must be a valid HTTP token [${c2}]`);
        throw Object.defineProperty(l3, "code", { value: "ERR_INVALID_HTTP_TOKEN" }), l3;
      }
    };
    var validateHeaderValue = typeof http__default.validateHeaderValue == "function" ? http__default.validateHeaderValue : (c2, l3) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(l3)) {
        const d4 = new TypeError(`Invalid character in header content ["${c2}"]`);
        throw Object.defineProperty(d4, "code", { value: "ERR_INVALID_CHAR" }), d4;
      }
    };
    var Kt = class Kt2 extends URLSearchParams {
      constructor(l3) {
        let d4 = [];
        if (l3 instanceof Kt2) {
          const g4 = l3.raw();
          for (const [b6, R4] of Object.entries(g4)) d4.push(...R4.map((w5) => [b6, w5]));
        } else if (l3 != null) if (typeof l3 == "object" && !require$$0$1.types.isBoxedPrimitive(l3)) {
          const g4 = l3[Symbol.iterator];
          if (g4 == null) d4.push(...Object.entries(l3));
          else {
            if (typeof g4 != "function") throw new TypeError("Header pairs must be iterable");
            d4 = [...l3].map((b6) => {
              if (typeof b6 != "object" || require$$0$1.types.isBoxedPrimitive(b6)) throw new TypeError("Each header pair must be an iterable object");
              return [...b6];
            }).map((b6) => {
              if (b6.length !== 2) throw new TypeError("Each header pair must be a name/value tuple");
              return [...b6];
            });
          }
        } else throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        return d4 = d4.length > 0 ? d4.map(([g4, b6]) => (validateHeaderName(g4), validateHeaderValue(g4, String(b6)), [String(g4).toLowerCase(), String(b6)])) : void 0, super(d4), new Proxy(this, { get(g4, b6, R4) {
          switch (b6) {
            case "append":
            case "set":
              return (w5, A2) => (validateHeaderName(w5), validateHeaderValue(w5, String(A2)), URLSearchParams.prototype[b6].call(g4, String(w5).toLowerCase(), String(A2)));
            case "delete":
            case "has":
            case "getAll":
              return (w5) => (validateHeaderName(w5), URLSearchParams.prototype[b6].call(g4, String(w5).toLowerCase()));
            case "keys":
              return () => (g4.sort(), new Set(URLSearchParams.prototype.keys.call(g4)).keys());
            default:
              return Reflect.get(g4, b6, R4);
          }
        } });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(l3) {
        const d4 = this.getAll(l3);
        if (d4.length === 0) return null;
        let g4 = d4.join(", ");
        return /^content-encoding$/i.test(l3) && (g4 = g4.toLowerCase()), g4;
      }
      forEach(l3, d4 = void 0) {
        for (const g4 of this.keys()) Reflect.apply(l3, d4, [this.get(g4), g4, this]);
      }
      *values() {
        for (const l3 of this.keys()) yield this.get(l3);
      }
      *entries() {
        for (const l3 of this.keys()) yield [l3, this.get(l3)];
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((l3, d4) => (l3[d4] = this.getAll(d4), l3), {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((l3, d4) => {
          const g4 = this.getAll(d4);
          return d4 === "host" ? l3[d4] = g4[0] : l3[d4] = g4.length > 1 ? g4 : g4[0], l3;
        }, {});
      }
    };
    u4(Kt, "Headers");
    var Headers2 = Kt;
    Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((c2, l3) => (c2[l3] = { enumerable: true }, c2), {}));
    function fromRawHeaders(c2 = []) {
      return new Headers2(c2.reduce((l3, d4, g4, b6) => (g4 % 2 === 0 && l3.push(b6.slice(g4, g4 + 2)), l3), []).filter(([l3, d4]) => {
        try {
          return validateHeaderName(l3), validateHeaderValue(l3, String(d4)), true;
        } catch {
          return false;
        }
      }));
    }
    u4(fromRawHeaders, "fromRawHeaders");
    var redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    var isRedirect = u4((c2) => redirectStatus.has(c2), "isRedirect");
    var INTERNALS$1 = Symbol("Response internals");
    var Me2 = class Me3 extends Body {
      constructor(l3 = null, d4 = {}) {
        super(l3, d4);
        const g4 = d4.status != null ? d4.status : 200, b6 = new Headers2(d4.headers);
        if (l3 !== null && !b6.has("Content-Type")) {
          const R4 = extractContentType(l3, this);
          R4 && b6.append("Content-Type", R4);
        }
        this[INTERNALS$1] = { type: "default", url: d4.url, status: g4, statusText: d4.statusText || "", headers: b6, counter: d4.counter, highWaterMark: d4.highWaterMark };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Me3(clone(this, this.highWaterMark), { type: this.type, url: this.url, status: this.status, statusText: this.statusText, headers: this.headers, ok: this.ok, redirected: this.redirected, size: this.size, highWaterMark: this.highWaterMark });
      }
      static redirect(l3, d4 = 302) {
        if (!isRedirect(d4)) throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        return new Me3(null, { headers: { location: new URL(l3).toString() }, status: d4 });
      }
      static error() {
        const l3 = new Me3(null, { status: 0, statusText: "" });
        return l3[INTERNALS$1].type = "error", l3;
      }
      static json(l3 = void 0, d4 = {}) {
        const g4 = JSON.stringify(l3);
        if (g4 === void 0) throw new TypeError("data is not JSON serializable");
        const b6 = new Headers2(d4 && d4.headers);
        return b6.has("content-type") || b6.set("content-type", "application/json"), new Me3(g4, { ...d4, headers: b6 });
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    u4(Me2, "Response");
    var Response2 = Me2;
    Object.defineProperties(Response2.prototype, { type: { enumerable: true }, url: { enumerable: true }, status: { enumerable: true }, ok: { enumerable: true }, redirected: { enumerable: true }, statusText: { enumerable: true }, headers: { enumerable: true }, clone: { enumerable: true } });
    var getSearch = u4((c2) => {
      if (c2.search) return c2.search;
      const l3 = c2.href.length - 1, d4 = c2.hash || (c2.href[l3] === "#" ? "#" : "");
      return c2.href[l3 - d4.length] === "?" ? "?" : "";
    }, "getSearch");
    function stripURLForUseAsAReferrer(c2, l3 = false) {
      return c2 == null || (c2 = new URL(c2), /^(about|blob|data):$/.test(c2.protocol)) ? "no-referrer" : (c2.username = "", c2.password = "", c2.hash = "", l3 && (c2.pathname = "", c2.search = ""), c2);
    }
    u4(stripURLForUseAsAReferrer, "stripURLForUseAsAReferrer");
    var ReferrerPolicy = /* @__PURE__ */ new Set(["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"]);
    var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    function validateReferrerPolicy(c2) {
      if (!ReferrerPolicy.has(c2)) throw new TypeError(`Invalid referrerPolicy: ${c2}`);
      return c2;
    }
    u4(validateReferrerPolicy, "validateReferrerPolicy");
    function isOriginPotentiallyTrustworthy(c2) {
      if (/^(http|ws)s:$/.test(c2.protocol)) return true;
      const l3 = c2.host.replace(/(^\[)|(]$)/g, ""), d4 = require$$0$2.isIP(l3);
      return d4 === 4 && /^127\./.test(l3) || d4 === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(l3) ? true : c2.host === "localhost" || c2.host.endsWith(".localhost") ? false : c2.protocol === "file:";
    }
    u4(isOriginPotentiallyTrustworthy, "isOriginPotentiallyTrustworthy");
    function isUrlPotentiallyTrustworthy(c2) {
      return /^about:(blank|srcdoc)$/.test(c2) || c2.protocol === "data:" || /^(blob|filesystem):$/.test(c2.protocol) ? true : isOriginPotentiallyTrustworthy(c2);
    }
    u4(isUrlPotentiallyTrustworthy, "isUrlPotentiallyTrustworthy");
    function determineRequestsReferrer(c2, { referrerURLCallback: l3, referrerOriginCallback: d4 } = {}) {
      if (c2.referrer === "no-referrer" || c2.referrerPolicy === "") return null;
      const g4 = c2.referrerPolicy;
      if (c2.referrer === "about:client") return "no-referrer";
      const b6 = c2.referrer;
      let R4 = stripURLForUseAsAReferrer(b6), w5 = stripURLForUseAsAReferrer(b6, true);
      R4.toString().length > 4096 && (R4 = w5), l3 && (R4 = l3(R4)), d4 && (w5 = d4(w5));
      const A2 = new URL(c2.url);
      switch (g4) {
        case "no-referrer":
          return "no-referrer";
        case "origin":
          return w5;
        case "unsafe-url":
          return R4;
        case "strict-origin":
          return isUrlPotentiallyTrustworthy(R4) && !isUrlPotentiallyTrustworthy(A2) ? "no-referrer" : w5.toString();
        case "strict-origin-when-cross-origin":
          return R4.origin === A2.origin ? R4 : isUrlPotentiallyTrustworthy(R4) && !isUrlPotentiallyTrustworthy(A2) ? "no-referrer" : w5;
        case "same-origin":
          return R4.origin === A2.origin ? R4 : "no-referrer";
        case "origin-when-cross-origin":
          return R4.origin === A2.origin ? R4 : w5;
        case "no-referrer-when-downgrade":
          return isUrlPotentiallyTrustworthy(R4) && !isUrlPotentiallyTrustworthy(A2) ? "no-referrer" : R4;
        default:
          throw new TypeError(`Invalid referrerPolicy: ${g4}`);
      }
    }
    u4(determineRequestsReferrer, "determineRequestsReferrer");
    function parseReferrerPolicyFromHeader(c2) {
      const l3 = (c2.get("referrer-policy") || "").split(/[,\s]+/);
      let d4 = "";
      for (const g4 of l3) g4 && ReferrerPolicy.has(g4) && (d4 = g4);
      return d4;
    }
    u4(parseReferrerPolicyFromHeader, "parseReferrerPolicyFromHeader");
    var INTERNALS = Symbol("Request internals");
    var isRequest = u4((c2) => typeof c2 == "object" && typeof c2[INTERNALS] == "object", "isRequest");
    var doBadDataWarn = require$$0$1.deprecate(() => {
    }, ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");
    var Jt = class Jt2 extends Body {
      constructor(l3, d4 = {}) {
        let g4;
        if (isRequest(l3) ? g4 = new URL(l3.url) : (g4 = new URL(l3), l3 = {}), g4.username !== "" || g4.password !== "") throw new TypeError(`${g4} is an url with embedded credentials.`);
        let b6 = d4.method || l3.method || "GET";
        if (/^(delete|get|head|options|post|put)$/i.test(b6) && (b6 = b6.toUpperCase()), !isRequest(d4) && "data" in d4 && doBadDataWarn(), (d4.body != null || isRequest(l3) && l3.body !== null) && (b6 === "GET" || b6 === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body");
        const R4 = d4.body ? d4.body : isRequest(l3) && l3.body !== null ? clone(l3) : null;
        super(R4, { size: d4.size || l3.size || 0 });
        const w5 = new Headers2(d4.headers || l3.headers || {});
        if (R4 !== null && !w5.has("Content-Type")) {
          const B3 = extractContentType(R4, this);
          B3 && w5.set("Content-Type", B3);
        }
        let A2 = isRequest(l3) ? l3.signal : null;
        if ("signal" in d4 && (A2 = d4.signal), A2 != null && !isAbortSignal(A2)) throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        let z4 = d4.referrer == null ? l3.referrer : d4.referrer;
        if (z4 === "") z4 = "no-referrer";
        else if (z4) {
          const B3 = new URL(z4);
          z4 = /^about:(\/\/)?client$/.test(B3) ? "client" : B3;
        } else z4 = void 0;
        this[INTERNALS] = { method: b6, redirect: d4.redirect || l3.redirect || "follow", headers: w5, parsedURL: g4, signal: A2, referrer: z4 }, this.follow = d4.follow === void 0 ? l3.follow === void 0 ? 20 : l3.follow : d4.follow, this.compress = d4.compress === void 0 ? l3.compress === void 0 ? true : l3.compress : d4.compress, this.counter = d4.counter || l3.counter || 0, this.agent = d4.agent || l3.agent, this.highWaterMark = d4.highWaterMark || l3.highWaterMark || 16384, this.insecureHTTPParser = d4.insecureHTTPParser || l3.insecureHTTPParser || false, this.referrerPolicy = d4.referrerPolicy || l3.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return require$$1.format(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") return "";
        if (this[INTERNALS].referrer === "client") return "about:client";
        if (this[INTERNALS].referrer) return this[INTERNALS].referrer.toString();
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(l3) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(l3);
      }
      clone() {
        return new Jt2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    u4(Jt, "Request");
    var Request = Jt;
    Object.defineProperties(Request.prototype, { method: { enumerable: true }, url: { enumerable: true }, headers: { enumerable: true }, redirect: { enumerable: true }, clone: { enumerable: true }, signal: { enumerable: true }, referrer: { enumerable: true }, referrerPolicy: { enumerable: true } });
    var getNodeRequestOptions = u4((c2) => {
      const { parsedURL: l3 } = c2[INTERNALS], d4 = new Headers2(c2[INTERNALS].headers);
      d4.has("Accept") || d4.set("Accept", "*/*");
      let g4 = null;
      if (c2.body === null && /^(post|put)$/i.test(c2.method) && (g4 = "0"), c2.body !== null) {
        const A2 = getTotalBytes(c2);
        typeof A2 == "number" && !Number.isNaN(A2) && (g4 = String(A2));
      }
      g4 && d4.set("Content-Length", g4), c2.referrerPolicy === "" && (c2.referrerPolicy = DEFAULT_REFERRER_POLICY), c2.referrer && c2.referrer !== "no-referrer" ? c2[INTERNALS].referrer = determineRequestsReferrer(c2) : c2[INTERNALS].referrer = "no-referrer", c2[INTERNALS].referrer instanceof URL && d4.set("Referer", c2.referrer), d4.has("User-Agent") || d4.set("User-Agent", "node-fetch"), c2.compress && !d4.has("Accept-Encoding") && d4.set("Accept-Encoding", "gzip, deflate, br");
      let { agent: b6 } = c2;
      typeof b6 == "function" && (b6 = b6(l3));
      const R4 = getSearch(l3), w5 = { path: l3.pathname + R4, method: c2.method, headers: d4[Symbol.for("nodejs.util.inspect.custom")](), insecureHTTPParser: c2.insecureHTTPParser, agent: b6 };
      return { parsedURL: l3, options: w5 };
    }, "getNodeRequestOptions");
    var sn2 = class sn extends FetchBaseError {
      constructor(l3, d4 = "aborted") {
        super(l3, d4);
      }
    };
    u4(sn2, "AbortError");
    var AbortError = sn2;
    var nodeDomexception;
    var hasRequiredNodeDomexception;
    function requireNodeDomexception() {
      if (hasRequiredNodeDomexception) return nodeDomexception;
      if (hasRequiredNodeDomexception = 1, !globalThis.DOMException) try {
        const { MessageChannel: c2 } = require("worker_threads"), l3 = new c2().port1, d4 = new ArrayBuffer();
        l3.postMessage(d4, [d4, d4]);
      } catch (c2) {
        c2.constructor.name === "DOMException" && (globalThis.DOMException = c2.constructor);
      }
      return nodeDomexception = globalThis.DOMException, nodeDomexception;
    }
    u4(requireNodeDomexception, "requireNodeDomexception");
    var nodeDomexceptionExports = requireNodeDomexception();
    var DOMException2 = _commonjsHelpers.getDefaultExportFromCjs(nodeDomexceptionExports);
    var { stat } = node_fs.promises;
    var blobFromSync = u4((c2, l3) => fromBlob(node_fs.statSync(c2), c2, l3), "blobFromSync");
    var blobFrom = u4((c2, l3) => stat(c2).then((d4) => fromBlob(d4, c2, l3)), "blobFrom");
    var fileFrom = u4((c2, l3) => stat(c2).then((d4) => fromFile(d4, c2, l3)), "fileFrom");
    var fileFromSync = u4((c2, l3) => fromFile(node_fs.statSync(c2), c2, l3), "fileFromSync");
    var fromBlob = u4((c2, l3, d4 = "") => new Blob2([new BlobDataItem({ path: l3, size: c2.size, lastModified: c2.mtimeMs, start: 0 })], { type: d4 }), "fromBlob");
    var fromFile = u4((c2, l3, d4 = "") => new File([new BlobDataItem({ path: l3, size: c2.size, lastModified: c2.mtimeMs, start: 0 })], node_path.basename(l3), { type: d4, lastModified: c2.mtimeMs }), "fromFile");
    var Xt = class Xt2 {
      constructor(l3) {
        ye2(this, xe3);
        ye2(this, Ue2);
        ne3(this, xe3, l3.path), ne3(this, Ue2, l3.start), this.size = l3.size, this.lastModified = l3.lastModified;
      }
      slice(l3, d4) {
        return new Xt2({ path: D3(this, xe3), lastModified: this.lastModified, size: d4 - l3, start: D3(this, Ue2) + l3 });
      }
      async *stream() {
        const { mtimeMs: l3 } = await stat(D3(this, xe3));
        if (l3 > this.lastModified) throw new DOMException2("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
        yield* node_fs.createReadStream(D3(this, xe3), { start: D3(this, Ue2), end: D3(this, Ue2) + this.size - 1 });
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
    };
    xe3 = /* @__PURE__ */ new WeakMap(), Ue2 = /* @__PURE__ */ new WeakMap(), u4(Xt, "BlobDataItem");
    var BlobDataItem = Xt;
    var supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
    async function fetch$1(c2, l3) {
      return new Promise((d4, g4) => {
        const b6 = new Request(c2, l3), { parsedURL: R4, options: w5 } = getNodeRequestOptions(b6);
        if (!supportedSchemas.has(R4.protocol)) throw new TypeError(`node-fetch cannot load ${c2}. URL scheme "${R4.protocol.replace(/:$/, "")}" is not supported.`);
        if (R4.protocol === "data:") {
          const v4 = dataUriToBuffer(b6.url), K4 = new Response2(v4, { headers: { "Content-Type": v4.typeFull } });
          d4(K4);
          return;
        }
        const A2 = (R4.protocol === "https:" ? https__default : http__default).request, { signal: z4 } = b6;
        let B3 = null;
        const I5 = u4(() => {
          const v4 = new AbortError("The operation was aborted.");
          g4(v4), b6.body && b6.body instanceof Stream__default.Readable && b6.body.destroy(v4), !(!B3 || !B3.body) && B3.body.emit("error", v4);
        }, "abort");
        if (z4 && z4.aborted) {
          I5();
          return;
        }
        const k4 = u4(() => {
          I5(), $6();
        }, "abortAndFinalize"), T5 = A2(R4.toString(), w5);
        z4 && z4.addEventListener("abort", k4);
        const $6 = u4(() => {
          T5.abort(), z4 && z4.removeEventListener("abort", k4);
        }, "finalize");
        T5.on("error", (v4) => {
          g4(new FetchError(`request to ${b6.url} failed, reason: ${v4.message}`, "system", v4)), $6();
        }), fixResponseChunkedTransferBadEnding(T5, (v4) => {
          B3 && B3.body && B3.body.destroy(v4);
        }), process.version < "v14" && T5.on("socket", (v4) => {
          let K4;
          v4.prependListener("end", () => {
            K4 = v4._eventsCount;
          }), v4.prependListener("close", (U6) => {
            if (B3 && K4 < v4._eventsCount && !U6) {
              const N6 = new Error("Premature close");
              N6.code = "ERR_STREAM_PREMATURE_CLOSE", B3.body.emit("error", N6);
            }
          });
        }), T5.on("response", (v4) => {
          T5.setTimeout(0);
          const K4 = fromRawHeaders(v4.rawHeaders);
          if (isRedirect(v4.statusCode)) {
            const M4 = K4.get("Location");
            let H5 = null;
            try {
              H5 = M4 === null ? null : new URL(M4, b6.url);
            } catch {
              if (b6.redirect !== "manual") {
                g4(new FetchError(`uri requested responds with an invalid redirect URL: ${M4}`, "invalid-redirect")), $6();
                return;
              }
            }
            switch (b6.redirect) {
              case "error":
                g4(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${b6.url}`, "no-redirect")), $6();
                return;
              case "manual":
                break;
              case "follow": {
                if (H5 === null) break;
                if (b6.counter >= b6.follow) {
                  g4(new FetchError(`maximum redirect reached at: ${b6.url}`, "max-redirect")), $6();
                  return;
                }
                const Y4 = { headers: new Headers2(b6.headers), follow: b6.follow, counter: b6.counter + 1, agent: b6.agent, compress: b6.compress, method: b6.method, body: clone(b6), signal: b6.signal, size: b6.size, referrer: b6.referrer, referrerPolicy: b6.referrerPolicy };
                if (!isDomainOrSubdomain(b6.url, H5) || !isSameProtocol(b6.url, H5)) for (const wt2 of ["authorization", "www-authenticate", "cookie", "cookie2"]) Y4.headers.delete(wt2);
                if (v4.statusCode !== 303 && b6.body && l3.body instanceof Stream__default.Readable) {
                  g4(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), $6();
                  return;
                }
                (v4.statusCode === 303 || (v4.statusCode === 301 || v4.statusCode === 302) && b6.method === "POST") && (Y4.method = "GET", Y4.body = void 0, Y4.headers.delete("content-length"));
                const Q5 = parseReferrerPolicyFromHeader(K4);
                Q5 && (Y4.referrerPolicy = Q5), d4(fetch$1(new Request(H5, Y4))), $6();
                return;
              }
              default:
                return g4(new TypeError(`Redirect option '${b6.redirect}' is not a valid value of RequestRedirect`));
            }
          }
          z4 && v4.once("end", () => {
            z4.removeEventListener("abort", k4);
          });
          let U6 = Stream.pipeline(v4, new Stream.PassThrough(), (M4) => {
            M4 && g4(M4);
          });
          process.version < "v12.10" && v4.on("aborted", k4);
          const N6 = { url: b6.url, status: v4.statusCode, statusText: v4.statusMessage, headers: K4, size: b6.size, counter: b6.counter, highWaterMark: b6.highWaterMark }, J5 = K4.get("Content-Encoding");
          if (!b6.compress || b6.method === "HEAD" || J5 === null || v4.statusCode === 204 || v4.statusCode === 304) {
            B3 = new Response2(U6, N6), d4(B3);
            return;
          }
          const ge3 = { flush: zlib__default.Z_SYNC_FLUSH, finishFlush: zlib__default.Z_SYNC_FLUSH };
          if (J5 === "gzip" || J5 === "x-gzip") {
            U6 = Stream.pipeline(U6, zlib__default.createGunzip(ge3), (M4) => {
              M4 && g4(M4);
            }), B3 = new Response2(U6, N6), d4(B3);
            return;
          }
          if (J5 === "deflate" || J5 === "x-deflate") {
            const M4 = Stream.pipeline(v4, new Stream.PassThrough(), (H5) => {
              H5 && g4(H5);
            });
            M4.once("data", (H5) => {
              (H5[0] & 15) === 8 ? U6 = Stream.pipeline(U6, zlib__default.createInflate(), (Y4) => {
                Y4 && g4(Y4);
              }) : U6 = Stream.pipeline(U6, zlib__default.createInflateRaw(), (Y4) => {
                Y4 && g4(Y4);
              }), B3 = new Response2(U6, N6), d4(B3);
            }), M4.once("end", () => {
              B3 || (B3 = new Response2(U6, N6), d4(B3));
            });
            return;
          }
          if (J5 === "br") {
            U6 = Stream.pipeline(U6, zlib__default.createBrotliDecompress(), (M4) => {
              M4 && g4(M4);
            }), B3 = new Response2(U6, N6), d4(B3);
            return;
          }
          B3 = new Response2(U6, N6), d4(B3);
        }), writeToStream(T5, b6).catch(g4);
      });
    }
    u4(fetch$1, "fetch$1");
    function fixResponseChunkedTransferBadEnding(c2, l3) {
      const d4 = require$$0.Buffer.from(`0\r
\r
`);
      let g4 = false, b6 = false, R4;
      c2.on("response", (w5) => {
        const { headers: A2 } = w5;
        g4 = A2["transfer-encoding"] === "chunked" && !A2["content-length"];
      }), c2.on("socket", (w5) => {
        const A2 = u4(() => {
          if (g4 && !b6) {
            const B3 = new Error("Premature close");
            B3.code = "ERR_STREAM_PREMATURE_CLOSE", l3(B3);
          }
        }, "onSocketClose"), z4 = u4((B3) => {
          b6 = require$$0.Buffer.compare(B3.slice(-5), d4) === 0, !b6 && R4 && (b6 = require$$0.Buffer.compare(R4.slice(-3), d4.slice(0, 3)) === 0 && require$$0.Buffer.compare(B3.slice(-2), d4.slice(3)) === 0), R4 = B3;
        }, "onData");
        w5.prependListener("close", A2), w5.on("data", z4), c2.on("close", () => {
          w5.removeListener("close", A2), w5.removeListener("data", z4);
        });
      });
    }
    u4(fixResponseChunkedTransferBadEnding, "fixResponseChunkedTransferBadEnding");
    var privateData = /* @__PURE__ */ new WeakMap();
    var wrappers = /* @__PURE__ */ new WeakMap();
    function pd(c2) {
      const l3 = privateData.get(c2);
      return console.assert(l3 != null, "'this' is expected an Event object, but got", c2), l3;
    }
    u4(pd, "pd");
    function setCancelFlag(c2) {
      if (c2.passiveListener != null) {
        typeof console < "u" && typeof console.error == "function" && console.error("Unable to preventDefault inside passive event listener invocation.", c2.passiveListener);
        return;
      }
      c2.event.cancelable && (c2.canceled = true, typeof c2.event.preventDefault == "function" && c2.event.preventDefault());
    }
    u4(setCancelFlag, "setCancelFlag");
    function Event2(c2, l3) {
      privateData.set(this, { eventTarget: c2, event: l3, eventPhase: 2, currentTarget: c2, canceled: false, stopped: false, immediateStopped: false, passiveListener: null, timeStamp: l3.timeStamp || Date.now() }), Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
      const d4 = Object.keys(l3);
      for (let g4 = 0; g4 < d4.length; ++g4) {
        const b6 = d4[g4];
        b6 in this || Object.defineProperty(this, b6, defineRedirectDescriptor(b6));
      }
    }
    u4(Event2, "Event"), Event2.prototype = { get type() {
      return pd(this).event.type;
    }, get target() {
      return pd(this).eventTarget;
    }, get currentTarget() {
      return pd(this).currentTarget;
    }, composedPath() {
      const c2 = pd(this).currentTarget;
      return c2 == null ? [] : [c2];
    }, get NONE() {
      return 0;
    }, get CAPTURING_PHASE() {
      return 1;
    }, get AT_TARGET() {
      return 2;
    }, get BUBBLING_PHASE() {
      return 3;
    }, get eventPhase() {
      return pd(this).eventPhase;
    }, stopPropagation() {
      const c2 = pd(this);
      c2.stopped = true, typeof c2.event.stopPropagation == "function" && c2.event.stopPropagation();
    }, stopImmediatePropagation() {
      const c2 = pd(this);
      c2.stopped = true, c2.immediateStopped = true, typeof c2.event.stopImmediatePropagation == "function" && c2.event.stopImmediatePropagation();
    }, get bubbles() {
      return !!pd(this).event.bubbles;
    }, get cancelable() {
      return !!pd(this).event.cancelable;
    }, preventDefault() {
      setCancelFlag(pd(this));
    }, get defaultPrevented() {
      return pd(this).canceled;
    }, get composed() {
      return !!pd(this).event.composed;
    }, get timeStamp() {
      return pd(this).timeStamp;
    }, get srcElement() {
      return pd(this).eventTarget;
    }, get cancelBubble() {
      return pd(this).stopped;
    }, set cancelBubble(c2) {
      if (!c2) return;
      const l3 = pd(this);
      l3.stopped = true, typeof l3.event.cancelBubble == "boolean" && (l3.event.cancelBubble = true);
    }, get returnValue() {
      return !pd(this).canceled;
    }, set returnValue(c2) {
      c2 || setCancelFlag(pd(this));
    }, initEvent() {
    } }, Object.defineProperty(Event2.prototype, "constructor", { value: Event2, configurable: true, writable: true }), typeof window < "u" && typeof window.Event < "u" && (Object.setPrototypeOf(Event2.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event2));
    function defineRedirectDescriptor(c2) {
      return { get() {
        return pd(this).event[c2];
      }, set(l3) {
        pd(this).event[c2] = l3;
      }, configurable: true, enumerable: true };
    }
    u4(defineRedirectDescriptor, "defineRedirectDescriptor");
    function defineCallDescriptor(c2) {
      return { value() {
        const l3 = pd(this).event;
        return l3[c2].apply(l3, arguments);
      }, configurable: true, enumerable: true };
    }
    u4(defineCallDescriptor, "defineCallDescriptor");
    function defineWrapper(c2, l3) {
      const d4 = Object.keys(l3);
      if (d4.length === 0) return c2;
      function g4(b6, R4) {
        c2.call(this, b6, R4);
      }
      u4(g4, "CustomEvent"), g4.prototype = Object.create(c2.prototype, { constructor: { value: g4, configurable: true, writable: true } });
      for (let b6 = 0; b6 < d4.length; ++b6) {
        const R4 = d4[b6];
        if (!(R4 in c2.prototype)) {
          const A2 = typeof Object.getOwnPropertyDescriptor(l3, R4).value == "function";
          Object.defineProperty(g4.prototype, R4, A2 ? defineCallDescriptor(R4) : defineRedirectDescriptor(R4));
        }
      }
      return g4;
    }
    u4(defineWrapper, "defineWrapper");
    function getWrapper(c2) {
      if (c2 == null || c2 === Object.prototype) return Event2;
      let l3 = wrappers.get(c2);
      return l3 == null && (l3 = defineWrapper(getWrapper(Object.getPrototypeOf(c2)), c2), wrappers.set(c2, l3)), l3;
    }
    u4(getWrapper, "getWrapper");
    function wrapEvent(c2, l3) {
      const d4 = getWrapper(Object.getPrototypeOf(l3));
      return new d4(c2, l3);
    }
    u4(wrapEvent, "wrapEvent");
    function isStopped(c2) {
      return pd(c2).immediateStopped;
    }
    u4(isStopped, "isStopped");
    function setEventPhase(c2, l3) {
      pd(c2).eventPhase = l3;
    }
    u4(setEventPhase, "setEventPhase");
    function setCurrentTarget(c2, l3) {
      pd(c2).currentTarget = l3;
    }
    u4(setCurrentTarget, "setCurrentTarget");
    function setPassiveListener(c2, l3) {
      pd(c2).passiveListener = l3;
    }
    u4(setPassiveListener, "setPassiveListener");
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var CAPTURE = 1;
    var BUBBLE = 2;
    var ATTRIBUTE = 3;
    function isObject(c2) {
      return c2 !== null && typeof c2 == "object";
    }
    u4(isObject, "isObject");
    function getListeners(c2) {
      const l3 = listenersMap.get(c2);
      if (l3 == null) throw new TypeError("'this' is expected an EventTarget object, but got another value.");
      return l3;
    }
    u4(getListeners, "getListeners");
    function defineEventAttributeDescriptor(c2) {
      return { get() {
        let d4 = getListeners(this).get(c2);
        for (; d4 != null; ) {
          if (d4.listenerType === ATTRIBUTE) return d4.listener;
          d4 = d4.next;
        }
        return null;
      }, set(l3) {
        typeof l3 != "function" && !isObject(l3) && (l3 = null);
        const d4 = getListeners(this);
        let g4 = null, b6 = d4.get(c2);
        for (; b6 != null; ) b6.listenerType === ATTRIBUTE ? g4 !== null ? g4.next = b6.next : b6.next !== null ? d4.set(c2, b6.next) : d4.delete(c2) : g4 = b6, b6 = b6.next;
        if (l3 !== null) {
          const R4 = { listener: l3, listenerType: ATTRIBUTE, passive: false, once: false, next: null };
          g4 === null ? d4.set(c2, R4) : g4.next = R4;
        }
      }, configurable: true, enumerable: true };
    }
    u4(defineEventAttributeDescriptor, "defineEventAttributeDescriptor");
    function defineEventAttribute(c2, l3) {
      Object.defineProperty(c2, `on${l3}`, defineEventAttributeDescriptor(l3));
    }
    u4(defineEventAttribute, "defineEventAttribute");
    function defineCustomEventTarget(c2) {
      function l3() {
        EventTarget2.call(this);
      }
      u4(l3, "CustomEventTarget"), l3.prototype = Object.create(EventTarget2.prototype, { constructor: { value: l3, configurable: true, writable: true } });
      for (let d4 = 0; d4 < c2.length; ++d4) defineEventAttribute(l3.prototype, c2[d4]);
      return l3;
    }
    u4(defineCustomEventTarget, "defineCustomEventTarget");
    function EventTarget2() {
      if (this instanceof EventTarget2) {
        listenersMap.set(this, /* @__PURE__ */ new Map());
        return;
      }
      if (arguments.length === 1 && Array.isArray(arguments[0])) return defineCustomEventTarget(arguments[0]);
      if (arguments.length > 0) {
        const c2 = new Array(arguments.length);
        for (let l3 = 0; l3 < arguments.length; ++l3) c2[l3] = arguments[l3];
        return defineCustomEventTarget(c2);
      }
      throw new TypeError("Cannot call a class as a function");
    }
    u4(EventTarget2, "EventTarget"), EventTarget2.prototype = { addEventListener(c2, l3, d4) {
      if (l3 == null) return;
      if (typeof l3 != "function" && !isObject(l3)) throw new TypeError("'listener' should be a function or an object.");
      const g4 = getListeners(this), b6 = isObject(d4), w5 = (b6 ? !!d4.capture : !!d4) ? CAPTURE : BUBBLE, A2 = { listener: l3, listenerType: w5, passive: b6 && !!d4.passive, once: b6 && !!d4.once, next: null };
      let z4 = g4.get(c2);
      if (z4 === void 0) {
        g4.set(c2, A2);
        return;
      }
      let B3 = null;
      for (; z4 != null; ) {
        if (z4.listener === l3 && z4.listenerType === w5) return;
        B3 = z4, z4 = z4.next;
      }
      B3.next = A2;
    }, removeEventListener(c2, l3, d4) {
      if (l3 == null) return;
      const g4 = getListeners(this), R4 = (isObject(d4) ? !!d4.capture : !!d4) ? CAPTURE : BUBBLE;
      let w5 = null, A2 = g4.get(c2);
      for (; A2 != null; ) {
        if (A2.listener === l3 && A2.listenerType === R4) {
          w5 !== null ? w5.next = A2.next : A2.next !== null ? g4.set(c2, A2.next) : g4.delete(c2);
          return;
        }
        w5 = A2, A2 = A2.next;
      }
    }, dispatchEvent(c2) {
      if (c2 == null || typeof c2.type != "string") throw new TypeError('"event.type" should be a string.');
      const l3 = getListeners(this), d4 = c2.type;
      let g4 = l3.get(d4);
      if (g4 == null) return true;
      const b6 = wrapEvent(this, c2);
      let R4 = null;
      for (; g4 != null; ) {
        if (g4.once ? R4 !== null ? R4.next = g4.next : g4.next !== null ? l3.set(d4, g4.next) : l3.delete(d4) : R4 = g4, setPassiveListener(b6, g4.passive ? g4.listener : null), typeof g4.listener == "function") try {
          g4.listener.call(this, b6);
        } catch (w5) {
          typeof console < "u" && typeof console.error == "function" && console.error(w5);
        }
        else g4.listenerType !== ATTRIBUTE && typeof g4.listener.handleEvent == "function" && g4.listener.handleEvent(b6);
        if (isStopped(b6)) break;
        g4 = g4.next;
      }
      return setPassiveListener(b6, null), setEventPhase(b6, 0), setCurrentTarget(b6, null), !b6.defaultPrevented;
    } }, Object.defineProperty(EventTarget2.prototype, "constructor", { value: EventTarget2, configurable: true, writable: true }), typeof window < "u" && typeof window.EventTarget < "u" && Object.setPrototypeOf(EventTarget2.prototype, window.EventTarget.prototype);
    var an2 = class an extends EventTarget2 {
      constructor() {
        throw super(), new TypeError("AbortSignal cannot be constructed directly");
      }
      get aborted() {
        const l3 = abortedFlags.get(this);
        if (typeof l3 != "boolean") throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        return l3;
      }
    };
    u4(an2, "AbortSignal");
    var AbortSignal2 = an2;
    defineEventAttribute(AbortSignal2.prototype, "abort");
    function createAbortSignal() {
      const c2 = Object.create(AbortSignal2.prototype);
      return EventTarget2.call(c2), abortedFlags.set(c2, false), c2;
    }
    u4(createAbortSignal, "createAbortSignal");
    function abortSignal(c2) {
      abortedFlags.get(c2) === false && (abortedFlags.set(c2, true), c2.dispatchEvent({ type: "abort" }));
    }
    u4(abortSignal, "abortSignal");
    var abortedFlags = /* @__PURE__ */ new WeakMap();
    Object.defineProperties(AbortSignal2.prototype, { aborted: { enumerable: true } }), typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, { configurable: true, value: "AbortSignal" });
    var AbortController$1 = (at2 = class {
      constructor() {
        signals.set(this, createAbortSignal());
      }
      get signal() {
        return getSignal(this);
      }
      abort() {
        abortSignal(getSignal(this));
      }
    }, u4(at2, "AbortController"), at2);
    var signals = /* @__PURE__ */ new WeakMap();
    function getSignal(c2) {
      const l3 = signals.get(c2);
      if (l3 == null) throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${c2 === null ? "null" : typeof c2}`);
      return l3;
    }
    u4(getSignal, "getSignal"), Object.defineProperties(AbortController$1.prototype, { signal: { enumerable: true }, abort: { enumerable: true } }), typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol" && Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, { configurable: true, value: "AbortController" });
    var t2 = Object.defineProperty;
    var e3 = u4((c2, l3) => t2(c2, "name", { value: l3, configurable: true }), "e");
    var fetch3 = fetch$1;
    s4();
    function s4() {
      !globalThis.process?.versions?.node && !globalThis.process?.env?.DISABLE_NODE_FETCH_NATIVE_WARN && console.warn("[node-fetch-native] Node.js compatible build of `node-fetch-native` is being used in a non-Node.js environment. Please make sure you are using proper export conditions or report this issue to https://github.com/unjs/node-fetch-native. You can set `process.env.DISABLE_NODE_FETCH_NATIVE_WARN` to disable this warning.");
    }
    u4(s4, "s"), e3(s4, "checkNodeEnvironment"), exports2.AbortController = AbortController$1, exports2.AbortError = AbortError, exports2.Blob = Blob2, exports2.FetchError = FetchError, exports2.File = File, exports2.FormData = FormData, exports2.Headers = Headers2, exports2.Request = Request, exports2.Response = Response2, exports2.blobFrom = blobFrom, exports2.blobFromSync = blobFromSync, exports2.default = fetch3, exports2.fetch = fetch3, exports2.fileFrom = fileFrom, exports2.fileFromSync = fileFromSync, exports2.isRedirect = isRedirect;
  }
});

// ../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/index.cjs
var require_dist = __commonJS({
  "../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/index.cjs"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var node = require_node();
    require("http"), require("https"), require("zlib"), require("stream"), require("buffer"), require("util"), require_node_fetch_native_DhEqb06g(), require("url"), require("net"), require("fs"), require("path");
    var o = !!globalThis.process?.env?.FORCE_NODE_FETCH;
    var fetch3 = !o && globalThis.fetch || node.fetch;
    var Blob2 = !o && globalThis.Blob || node.Blob;
    var File = !o && globalThis.File || node.File;
    var FormData = !o && globalThis.FormData || node.FormData;
    var Headers2 = !o && globalThis.Headers || node.Headers;
    var Request = !o && globalThis.Request || node.Request;
    var Response2 = !o && globalThis.Response || node.Response;
    var AbortController2 = !o && globalThis.AbortController || node.AbortController;
    exports2.AbortError = node.AbortError, exports2.FetchError = node.FetchError, exports2.blobFrom = node.blobFrom, exports2.blobFromSync = node.blobFromSync, exports2.fileFrom = node.fileFrom, exports2.fileFromSync = node.fileFromSync, exports2.isRedirect = node.isRedirect, exports2.AbortController = AbortController2, exports2.Blob = Blob2, exports2.File = File, exports2.FormData = FormData, exports2.Headers = Headers2, exports2.Request = Request, exports2.Response = Response2, exports2.default = fetch3, exports2.fetch = fetch3;
  }
});

// ../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/lib/index.cjs
var require_lib = __commonJS({
  "../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/lib/index.cjs"(exports2, module2) {
    "use strict";
    var nodeFetch = require_dist();
    function fetch3(input, options) {
      return nodeFetch.fetch(input, options);
    }
    for (const key in nodeFetch) {
      fetch3[key] = nodeFetch[key];
    }
    module2.exports = fetch3;
  }
});

// ../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/proxy.cjs
var require_proxy = __commonJS({
  "../../node_modules/.pnpm/node-fetch-native@1.6.7/node_modules/node-fetch-native/dist/proxy.cjs"(exports2) {
    "use strict";
    var Ye2 = Object.defineProperty;
    var Re2 = (A2) => {
      throw TypeError(A2);
    };
    var ze2 = (A2, k4, c2) => k4 in A2 ? Ye2(A2, k4, { enumerable: true, configurable: true, writable: true, value: c2 }) : A2[k4] = c2;
    var e3 = (A2, k4) => Ye2(A2, "name", { value: k4, configurable: true });
    var $A = (A2, k4, c2) => ze2(A2, typeof k4 != "symbol" ? k4 + "" : k4, c2);
    var ke2 = (A2, k4, c2) => k4.has(A2) || Re2("Cannot " + c2);
    var Ge = (A2, k4) => Object(k4) !== k4 ? Re2('Cannot use the "in" operator on this value') : A2.has(k4);
    var Z4 = (A2, k4, c2) => (ke2(A2, k4, "read from private field"), c2 ? c2.call(A2) : k4.get(A2));
    var SA = (A2, k4, c2) => k4.has(A2) ? Re2("Cannot add the same private member more than once") : k4 instanceof WeakSet ? k4.add(A2) : k4.set(A2, c2);
    var mA = (A2, k4, c2, B3) => (ke2(A2, k4, "write to private field"), B3 ? B3.call(A2, c2) : k4.set(A2, c2), c2);
    var ee3 = (A2, k4, c2) => (ke2(A2, k4, "access private method"), c2);
    var fe4;
    var de3;
    var http2 = require("http");
    var https = require("https");
    var require$$1$1 = require("url");
    var require$$0$1 = require("assert");
    var require$$0$2 = require("net");
    var Stream = require("stream");
    var require$$0 = require("buffer");
    var require$$0$3 = require("util");
    var require$$7 = require("querystring");
    var require$$8 = require("events");
    var require$$0$4 = require("diagnostics_channel");
    var _commonjsHelpers = require_node_fetch_native_DhEqb06g();
    var require$$5 = require("tls");
    var zlib = require("zlib");
    var require$$5$1 = require("perf_hooks");
    var require$$8$1 = require("util/types");
    var require$$1 = require("worker_threads");
    var require$$5$2 = require("async_hooks");
    var require$$1$2 = require("console");
    var require$$1$3 = require("dns");
    var require$$5$3 = require("string_decoder");
    var require$$0$6 = require("net");
    var require$$0$5 = require("http");
    var require$$1$4 = require("https");
    var require$$1$7 = require("tls");
    var require$$1$5 = require("tty");
    var require$$1$6 = require("util");
    var require$$0$7 = require("os");
    var require$$3 = require("events");
    var require$$5$4 = require("url");
    var require$$2 = require("assert");
    var nodeFetchNative = require_lib();
    function _interopDefaultCompat(A2) {
      return A2 && typeof A2 == "object" && "default" in A2 ? A2.default : A2;
    }
    e3(_interopDefaultCompat, "_interopDefaultCompat");
    function _interopNamespaceCompat(A2) {
      if (A2 && typeof A2 == "object" && "default" in A2) return A2;
      const k4 = /* @__PURE__ */ Object.create(null);
      if (A2) for (const c2 in A2) k4[c2] = A2[c2];
      return k4.default = A2, k4;
    }
    e3(_interopNamespaceCompat, "_interopNamespaceCompat");
    var http__default = _interopDefaultCompat(http2);
    var http__namespace = _interopNamespaceCompat(http2);
    var https__namespace = _interopNamespaceCompat(https);
    var require$$1__default$1 = _interopDefaultCompat(require$$1$1);
    var require$$0__default$1 = _interopDefaultCompat(require$$0$1);
    var require$$0__default$2 = _interopDefaultCompat(require$$0$2);
    var Stream__default = _interopDefaultCompat(Stream);
    var require$$0__default = _interopDefaultCompat(require$$0);
    var require$$0__default$3 = _interopDefaultCompat(require$$0$3);
    var require$$7__default = _interopDefaultCompat(require$$7);
    var require$$8__default = _interopDefaultCompat(require$$8);
    var require$$0__default$4 = _interopDefaultCompat(require$$0$4);
    var require$$5__default = _interopDefaultCompat(require$$5);
    var zlib__default = _interopDefaultCompat(zlib);
    var require$$5__default$1 = _interopDefaultCompat(require$$5$1);
    var require$$8__default$1 = _interopDefaultCompat(require$$8$1);
    var require$$1__default = _interopDefaultCompat(require$$1);
    var require$$5__default$2 = _interopDefaultCompat(require$$5$2);
    var require$$1__default$2 = _interopDefaultCompat(require$$1$2);
    var require$$1__default$3 = _interopDefaultCompat(require$$1$3);
    var require$$5__default$3 = _interopDefaultCompat(require$$5$3);
    var require$$0__default$6 = _interopDefaultCompat(require$$0$6);
    var require$$0__default$5 = _interopDefaultCompat(require$$0$5);
    var require$$1__default$4 = _interopDefaultCompat(require$$1$4);
    var require$$1__default$7 = _interopDefaultCompat(require$$1$7);
    var require$$1__default$5 = _interopDefaultCompat(require$$1$5);
    var require$$1__default$6 = _interopDefaultCompat(require$$1$6);
    var require$$0__default$7 = _interopDefaultCompat(require$$0$7);
    var require$$3__default = _interopDefaultCompat(require$$3);
    var require$$5__default$4 = _interopDefaultCompat(require$$5$4);
    var require$$2__default = _interopDefaultCompat(require$$2);
    var undici = {};
    var symbols$4;
    var hasRequiredSymbols$4;
    function requireSymbols$4() {
      return hasRequiredSymbols$4 || (hasRequiredSymbols$4 = 1, symbols$4 = { kClose: Symbol("close"), kDestroy: Symbol("destroy"), kDispatch: Symbol("dispatch"), kUrl: Symbol("url"), kWriting: Symbol("writing"), kResuming: Symbol("resuming"), kQueue: Symbol("queue"), kConnect: Symbol("connect"), kConnecting: Symbol("connecting"), kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"), kKeepAliveMaxTimeout: Symbol("max keep alive timeout"), kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"), kKeepAliveTimeoutValue: Symbol("keep alive timeout"), kKeepAlive: Symbol("keep alive"), kHeadersTimeout: Symbol("headers timeout"), kBodyTimeout: Symbol("body timeout"), kServerName: Symbol("server name"), kLocalAddress: Symbol("local address"), kHost: Symbol("host"), kNoRef: Symbol("no ref"), kBodyUsed: Symbol("used"), kBody: Symbol("abstracted request body"), kRunning: Symbol("running"), kBlocking: Symbol("blocking"), kPending: Symbol("pending"), kSize: Symbol("size"), kBusy: Symbol("busy"), kQueued: Symbol("queued"), kFree: Symbol("free"), kConnected: Symbol("connected"), kClosed: Symbol("closed"), kNeedDrain: Symbol("need drain"), kReset: Symbol("reset"), kDestroyed: Symbol.for("nodejs.stream.destroyed"), kResume: Symbol("resume"), kOnError: Symbol("on error"), kMaxHeadersSize: Symbol("max headers size"), kRunningIdx: Symbol("running index"), kPendingIdx: Symbol("pending index"), kError: Symbol("error"), kClients: Symbol("clients"), kClient: Symbol("client"), kParser: Symbol("parser"), kOnDestroyed: Symbol("destroy callbacks"), kPipelining: Symbol("pipelining"), kSocket: Symbol("socket"), kHostHeader: Symbol("host header"), kConnector: Symbol("connector"), kStrictContentLength: Symbol("strict content length"), kMaxRedirections: Symbol("maxRedirections"), kMaxRequests: Symbol("maxRequestsPerClient"), kProxy: Symbol("proxy agent options"), kCounter: Symbol("socket request counter"), kInterceptors: Symbol("dispatch interceptors"), kMaxResponseSize: Symbol("max response size"), kHTTP2Session: Symbol("http2Session"), kHTTP2SessionState: Symbol("http2Session state"), kRetryHandlerDefaultRetry: Symbol("retry agent default retry"), kConstruct: Symbol("constructable"), kListeners: Symbol("listeners"), kHTTPContext: Symbol("http context"), kMaxConcurrentStreams: Symbol("max concurrent streams"), kNoProxyAgent: Symbol("no proxy agent"), kHttpProxyAgent: Symbol("http proxy agent"), kHttpsProxyAgent: Symbol("https proxy agent") }), symbols$4;
    }
    e3(requireSymbols$4, "requireSymbols$4");
    var errors;
    var hasRequiredErrors;
    function requireErrors() {
      if (hasRequiredErrors) return errors;
      hasRequiredErrors = 1;
      const M4 = class M extends Error {
        constructor(oA) {
          super(oA), this.name = "UndiciError", this.code = "UND_ERR";
        }
      };
      e3(M4, "UndiciError");
      let A2 = M4;
      const Y4 = class Y extends A2 {
        constructor(oA) {
          super(oA), this.name = "ConnectTimeoutError", this.message = oA || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
        }
      };
      e3(Y4, "ConnectTimeoutError");
      let k4 = Y4;
      const m4 = class m extends A2 {
        constructor(oA) {
          super(oA), this.name = "HeadersTimeoutError", this.message = oA || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
        }
      };
      e3(m4, "HeadersTimeoutError");
      let c2 = m4;
      const f3 = class f extends A2 {
        constructor(oA) {
          super(oA), this.name = "HeadersOverflowError", this.message = oA || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
        }
      };
      e3(f3, "HeadersOverflowError");
      let B3 = f3;
      const n = class n extends A2 {
        constructor(oA) {
          super(oA), this.name = "BodyTimeoutError", this.message = oA || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
        }
      };
      e3(n, "BodyTimeoutError");
      let t2 = n;
      const C5 = class C extends A2 {
        constructor(oA, aA, EA, sA) {
          super(oA), this.name = "ResponseStatusCodeError", this.message = oA || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = sA, this.status = aA, this.statusCode = aA, this.headers = EA;
        }
      };
      e3(C5, "ResponseStatusCodeError");
      let y3 = C5;
      const w5 = class w extends A2 {
        constructor(oA) {
          super(oA), this.name = "InvalidArgumentError", this.message = oA || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
        }
      };
      e3(w5, "InvalidArgumentError");
      let R4 = w5;
      const S6 = class S extends A2 {
        constructor(oA) {
          super(oA), this.name = "InvalidReturnValueError", this.message = oA || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
        }
      };
      e3(S6, "InvalidReturnValueError");
      let F2 = S6;
      const x5 = class x extends A2 {
        constructor(oA) {
          super(oA), this.name = "AbortError", this.message = oA || "The operation was aborted";
        }
      };
      e3(x5, "AbortError");
      let Q5 = x5;
      const z4 = class z extends Q5 {
        constructor(oA) {
          super(oA), this.name = "AbortError", this.message = oA || "Request aborted", this.code = "UND_ERR_ABORTED";
        }
      };
      e3(z4, "RequestAbortedError");
      let D3 = z4;
      const $6 = class $ extends A2 {
        constructor(oA) {
          super(oA), this.name = "InformationalError", this.message = oA || "Request information", this.code = "UND_ERR_INFO";
        }
      };
      e3($6, "InformationalError");
      let U6 = $6;
      const K4 = class K extends A2 {
        constructor(oA) {
          super(oA), this.name = "RequestContentLengthMismatchError", this.message = oA || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
        }
      };
      e3(K4, "RequestContentLengthMismatchError");
      let r6 = K4;
      const nA = class nA extends A2 {
        constructor(oA) {
          super(oA), this.name = "ResponseContentLengthMismatchError", this.message = oA || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
        }
      };
      e3(nA, "ResponseContentLengthMismatchError");
      let o = nA;
      const iA = class iA extends A2 {
        constructor(oA) {
          super(oA), this.name = "ClientDestroyedError", this.message = oA || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
        }
      };
      e3(iA, "ClientDestroyedError");
      let N6 = iA;
      const uA = class uA extends A2 {
        constructor(oA) {
          super(oA), this.name = "ClientClosedError", this.message = oA || "The client is closed", this.code = "UND_ERR_CLOSED";
        }
      };
      e3(uA, "ClientClosedError");
      let l3 = uA;
      const RA = class RA extends A2 {
        constructor(oA, aA) {
          super(oA), this.name = "SocketError", this.message = oA || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = aA;
        }
      };
      e3(RA, "SocketError");
      let I5 = RA;
      const IA = class IA extends A2 {
        constructor(oA) {
          super(oA), this.name = "NotSupportedError", this.message = oA || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
        }
      };
      e3(IA, "NotSupportedError");
      let p3 = IA;
      const CA = class CA extends A2 {
        constructor(oA) {
          super(oA), this.name = "MissingUpstreamError", this.message = oA || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
        }
      };
      e3(CA, "BalancedPoolMissingUpstreamError");
      let b6 = CA;
      const pA = class pA extends Error {
        constructor(oA, aA, EA) {
          super(oA), this.name = "HTTPParserError", this.code = aA ? `HPE_${aA}` : void 0, this.data = EA ? EA.toString() : void 0;
        }
      };
      e3(pA, "HTTPParserError");
      let G3 = pA;
      const fA = class fA extends A2 {
        constructor(oA) {
          super(oA), this.name = "ResponseExceededMaxSizeError", this.message = oA || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
        }
      };
      e3(fA, "ResponseExceededMaxSizeError");
      let J5 = fA;
      const kA = class kA extends A2 {
        constructor(oA, aA, { headers: EA, data: sA }) {
          super(oA), this.name = "RequestRetryError", this.message = oA || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = aA, this.data = sA, this.headers = EA;
        }
      };
      e3(kA, "RequestRetryError");
      let V4 = kA;
      const bA = class bA extends A2 {
        constructor(oA, aA, { headers: EA, data: sA }) {
          super(oA), this.name = "ResponseError", this.message = oA || "Response error", this.code = "UND_ERR_RESPONSE", this.statusCode = aA, this.data = sA, this.headers = EA;
        }
      };
      e3(bA, "ResponseError");
      let _5 = bA;
      const gA = class gA extends A2 {
        constructor(oA, aA, EA) {
          super(aA, { cause: oA, ...EA ?? {} }), this.name = "SecureProxyConnectionError", this.message = aA || "Secure Proxy Connection failed", this.code = "UND_ERR_PRX_TLS", this.cause = oA;
        }
      };
      e3(gA, "SecureProxyConnectionError");
      let q6 = gA;
      return errors = { AbortError: Q5, HTTPParserError: G3, UndiciError: A2, HeadersTimeoutError: c2, HeadersOverflowError: B3, BodyTimeoutError: t2, RequestContentLengthMismatchError: r6, ConnectTimeoutError: k4, ResponseStatusCodeError: y3, InvalidArgumentError: R4, InvalidReturnValueError: F2, RequestAbortedError: D3, ClientDestroyedError: N6, ClientClosedError: l3, InformationalError: U6, SocketError: I5, NotSupportedError: p3, ResponseContentLengthMismatchError: o, BalancedPoolMissingUpstreamError: b6, ResponseExceededMaxSizeError: J5, RequestRetryError: V4, ResponseError: _5, SecureProxyConnectionError: q6 }, errors;
    }
    e3(requireErrors, "requireErrors");
    var constants$4;
    var hasRequiredConstants$4;
    function requireConstants$4() {
      if (hasRequiredConstants$4) return constants$4;
      hasRequiredConstants$4 = 1;
      const A2 = {}, k4 = ["Accept", "Accept-Encoding", "Accept-Language", "Accept-Ranges", "Access-Control-Allow-Credentials", "Access-Control-Allow-Headers", "Access-Control-Allow-Methods", "Access-Control-Allow-Origin", "Access-Control-Expose-Headers", "Access-Control-Max-Age", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Age", "Allow", "Alt-Svc", "Alt-Used", "Authorization", "Cache-Control", "Clear-Site-Data", "Connection", "Content-Disposition", "Content-Encoding", "Content-Language", "Content-Length", "Content-Location", "Content-Range", "Content-Security-Policy", "Content-Security-Policy-Report-Only", "Content-Type", "Cookie", "Cross-Origin-Embedder-Policy", "Cross-Origin-Opener-Policy", "Cross-Origin-Resource-Policy", "Date", "Device-Memory", "Downlink", "ECT", "ETag", "Expect", "Expect-CT", "Expires", "Forwarded", "From", "Host", "If-Match", "If-Modified-Since", "If-None-Match", "If-Range", "If-Unmodified-Since", "Keep-Alive", "Last-Modified", "Link", "Location", "Max-Forwards", "Origin", "Permissions-Policy", "Pragma", "Proxy-Authenticate", "Proxy-Authorization", "RTT", "Range", "Referer", "Referrer-Policy", "Refresh", "Retry-After", "Sec-WebSocket-Accept", "Sec-WebSocket-Extensions", "Sec-WebSocket-Key", "Sec-WebSocket-Protocol", "Sec-WebSocket-Version", "Server", "Server-Timing", "Service-Worker-Allowed", "Service-Worker-Navigation-Preload", "Set-Cookie", "SourceMap", "Strict-Transport-Security", "Supports-Loading-Mode", "TE", "Timing-Allow-Origin", "Trailer", "Transfer-Encoding", "Upgrade", "Upgrade-Insecure-Requests", "User-Agent", "Vary", "Via", "WWW-Authenticate", "X-Content-Type-Options", "X-DNS-Prefetch-Control", "X-Frame-Options", "X-Permitted-Cross-Domain-Policies", "X-Powered-By", "X-Requested-With", "X-XSS-Protection"];
      for (let c2 = 0; c2 < k4.length; ++c2) {
        const B3 = k4[c2], t2 = B3.toLowerCase();
        A2[B3] = A2[t2] = t2;
      }
      return Object.setPrototypeOf(A2, null), constants$4 = { wellknownHeaderNames: k4, headerNameLowerCasedRecord: A2 }, constants$4;
    }
    e3(requireConstants$4, "requireConstants$4");
    var tree_1;
    var hasRequiredTree;
    function requireTree() {
      if (hasRequiredTree) return tree_1;
      hasRequiredTree = 1;
      const { wellknownHeaderNames: A2, headerNameLowerCasedRecord: k4 } = requireConstants$4(), y3 = class y4 {
        constructor(Q5, D3, U6) {
          $A(this, "value", null);
          $A(this, "left", null);
          $A(this, "middle", null);
          $A(this, "right", null);
          $A(this, "code");
          if (U6 === void 0 || U6 >= Q5.length) throw new TypeError("Unreachable");
          if ((this.code = Q5.charCodeAt(U6)) > 127) throw new TypeError("key must be ascii string");
          Q5.length !== ++U6 ? this.middle = new y4(Q5, D3, U6) : this.value = D3;
        }
        add(Q5, D3) {
          const U6 = Q5.length;
          if (U6 === 0) throw new TypeError("Unreachable");
          let r6 = 0, o = this;
          for (; ; ) {
            const N6 = Q5.charCodeAt(r6);
            if (N6 > 127) throw new TypeError("key must be ascii string");
            if (o.code === N6) if (U6 === ++r6) {
              o.value = D3;
              break;
            } else if (o.middle !== null) o = o.middle;
            else {
              o.middle = new y4(Q5, D3, r6);
              break;
            }
            else if (o.code < N6) if (o.left !== null) o = o.left;
            else {
              o.left = new y4(Q5, D3, r6);
              break;
            }
            else if (o.right !== null) o = o.right;
            else {
              o.right = new y4(Q5, D3, r6);
              break;
            }
          }
        }
        search(Q5) {
          const D3 = Q5.length;
          let U6 = 0, r6 = this;
          for (; r6 !== null && U6 < D3; ) {
            let o = Q5[U6];
            for (o <= 90 && o >= 65 && (o |= 32); r6 !== null; ) {
              if (o === r6.code) {
                if (D3 === ++U6) return r6;
                r6 = r6.middle;
                break;
              }
              r6 = r6.code < o ? r6.left : r6.right;
            }
          }
          return null;
        }
      };
      e3(y3, "TstNode");
      let c2 = y3;
      const R4 = class R {
        constructor() {
          $A(this, "node", null);
        }
        insert(Q5, D3) {
          this.node === null ? this.node = new c2(Q5, D3, 0) : this.node.add(Q5, D3);
        }
        lookup(Q5) {
          return this.node?.search(Q5)?.value ?? null;
        }
      };
      e3(R4, "TernarySearchTree");
      let B3 = R4;
      const t2 = new B3();
      for (let F2 = 0; F2 < A2.length; ++F2) {
        const Q5 = k4[A2[F2]];
        t2.insert(Q5, Q5);
      }
      return tree_1 = { TernarySearchTree: B3, tree: t2 }, tree_1;
    }
    e3(requireTree, "requireTree");
    var util$7;
    var hasRequiredUtil$7;
    function requireUtil$7() {
      if (hasRequiredUtil$7) return util$7;
      hasRequiredUtil$7 = 1;
      const A2 = require$$0__default$1, { kDestroyed: k4, kBodyUsed: c2, kListeners: B3, kBody: t2 } = requireSymbols$4(), { IncomingMessage: y3 } = http__default, R4 = Stream__default, F2 = require$$0__default$2, { Blob: Q5 } = require$$0__default, D3 = require$$0__default$3, { stringify: U6 } = require$$7__default, { EventEmitter: r6 } = require$$8__default, { InvalidArgumentError: o } = requireErrors(), { headerNameLowerCasedRecord: N6 } = requireConstants$4(), { tree: l3 } = requireTree(), [I5, p3] = process.versions.node.split(".").map((W6) => Number(W6)), QA = class QA {
        constructor(cA) {
          this[t2] = cA, this[c2] = false;
        }
        async *[Symbol.asyncIterator]() {
          A2(!this[c2], "disturbed"), this[c2] = true, yield* this[t2];
        }
      };
      e3(QA, "BodyAsyncIterable");
      let b6 = QA;
      function G3(W6) {
        return V4(W6) ? (z4(W6) === 0 && W6.on("data", function() {
          A2(false);
        }), typeof W6.readableDidRead != "boolean" && (W6[c2] = false, r6.prototype.on.call(W6, "data", function() {
          this[c2] = true;
        })), W6) : W6 && typeof W6.pipeTo == "function" ? new b6(W6) : W6 && typeof W6 != "string" && !ArrayBuffer.isView(W6) && x5(W6) ? new b6(W6) : W6;
      }
      e3(G3, "wrapRequestBody");
      function J5() {
      }
      e3(J5, "nop");
      function V4(W6) {
        return W6 && typeof W6 == "object" && typeof W6.pipe == "function" && typeof W6.on == "function";
      }
      e3(V4, "isStream");
      function _5(W6) {
        if (W6 === null) return false;
        if (W6 instanceof Q5) return true;
        if (typeof W6 != "object") return false;
        {
          const cA = W6[Symbol.toStringTag];
          return (cA === "Blob" || cA === "File") && ("stream" in W6 && typeof W6.stream == "function" || "arrayBuffer" in W6 && typeof W6.arrayBuffer == "function");
        }
      }
      e3(_5, "isBlobLike");
      function q6(W6, cA) {
        if (W6.includes("?") || W6.includes("#")) throw new Error('Query params cannot be passed when url already contains "?" or "#".');
        const yA = U6(cA);
        return yA && (W6 += "?" + yA), W6;
      }
      e3(q6, "buildURL");
      function M4(W6) {
        const cA = parseInt(W6, 10);
        return cA === Number(W6) && cA >= 0 && cA <= 65535;
      }
      e3(M4, "isValidPort");
      function Y4(W6) {
        return W6 != null && W6[0] === "h" && W6[1] === "t" && W6[2] === "t" && W6[3] === "p" && (W6[4] === ":" || W6[4] === "s" && W6[5] === ":");
      }
      e3(Y4, "isHttpOrHttpsPrefixed");
      function m4(W6) {
        if (typeof W6 == "string") {
          if (W6 = new URL(W6), !Y4(W6.origin || W6.protocol)) throw new o("Invalid URL protocol: the URL must start with `http:` or `https:`.");
          return W6;
        }
        if (!W6 || typeof W6 != "object") throw new o("Invalid URL: The URL argument must be a non-null object.");
        if (!(W6 instanceof URL)) {
          if (W6.port != null && W6.port !== "" && M4(W6.port) === false) throw new o("Invalid URL: port must be a valid integer or a string representation of an integer.");
          if (W6.path != null && typeof W6.path != "string") throw new o("Invalid URL path: the path must be a string or null/undefined.");
          if (W6.pathname != null && typeof W6.pathname != "string") throw new o("Invalid URL pathname: the pathname must be a string or null/undefined.");
          if (W6.hostname != null && typeof W6.hostname != "string") throw new o("Invalid URL hostname: the hostname must be a string or null/undefined.");
          if (W6.origin != null && typeof W6.origin != "string") throw new o("Invalid URL origin: the origin must be a string or null/undefined.");
          if (!Y4(W6.origin || W6.protocol)) throw new o("Invalid URL protocol: the URL must start with `http:` or `https:`.");
          const cA = W6.port != null ? W6.port : W6.protocol === "https:" ? 443 : 80;
          let yA = W6.origin != null ? W6.origin : `${W6.protocol || ""}//${W6.hostname || ""}:${cA}`, LA = W6.path != null ? W6.path : `${W6.pathname || ""}${W6.search || ""}`;
          return yA[yA.length - 1] === "/" && (yA = yA.slice(0, yA.length - 1)), LA && LA[0] !== "/" && (LA = `/${LA}`), new URL(`${yA}${LA}`);
        }
        if (!Y4(W6.origin || W6.protocol)) throw new o("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        return W6;
      }
      e3(m4, "parseURL");
      function f3(W6) {
        if (W6 = m4(W6), W6.pathname !== "/" || W6.search || W6.hash) throw new o("invalid url");
        return W6;
      }
      e3(f3, "parseOrigin");
      function n(W6) {
        if (W6[0] === "[") {
          const yA = W6.indexOf("]");
          return A2(yA !== -1), W6.substring(1, yA);
        }
        const cA = W6.indexOf(":");
        return cA === -1 ? W6 : W6.substring(0, cA);
      }
      e3(n, "getHostname");
      function C5(W6) {
        if (!W6) return null;
        A2(typeof W6 == "string");
        const cA = n(W6);
        return F2.isIP(cA) ? "" : cA;
      }
      e3(C5, "getServerName");
      function w5(W6) {
        return JSON.parse(JSON.stringify(W6));
      }
      e3(w5, "deepClone");
      function S6(W6) {
        return W6 != null && typeof W6[Symbol.asyncIterator] == "function";
      }
      e3(S6, "isAsyncIterable");
      function x5(W6) {
        return W6 != null && (typeof W6[Symbol.iterator] == "function" || typeof W6[Symbol.asyncIterator] == "function");
      }
      e3(x5, "isIterable");
      function z4(W6) {
        if (W6 == null) return 0;
        if (V4(W6)) {
          const cA = W6._readableState;
          return cA && cA.objectMode === false && cA.ended === true && Number.isFinite(cA.length) ? cA.length : null;
        } else {
          if (_5(W6)) return W6.size != null ? W6.size : null;
          if (pA(W6)) return W6.byteLength;
        }
        return null;
      }
      e3(z4, "bodyLength");
      function $6(W6) {
        return W6 && !!(W6.destroyed || W6[k4] || R4.isDestroyed?.(W6));
      }
      e3($6, "isDestroyed");
      function K4(W6, cA) {
        W6 == null || !V4(W6) || $6(W6) || (typeof W6.destroy == "function" ? (Object.getPrototypeOf(W6).constructor === y3 && (W6.socket = null), W6.destroy(cA)) : cA && queueMicrotask(() => {
          W6.emit("error", cA);
        }), W6.destroyed !== true && (W6[k4] = true));
      }
      e3(K4, "destroy");
      const nA = /timeout=(\d+)/;
      function iA(W6) {
        const cA = W6.toString().match(nA);
        return cA ? parseInt(cA[1], 10) * 1e3 : null;
      }
      e3(iA, "parseKeepAliveTimeout");
      function uA(W6) {
        return typeof W6 == "string" ? N6[W6] ?? W6.toLowerCase() : l3.lookup(W6) ?? W6.toString("latin1").toLowerCase();
      }
      e3(uA, "headerNameToString");
      function RA(W6) {
        return l3.lookup(W6) ?? W6.toString("latin1").toLowerCase();
      }
      e3(RA, "bufferToLowerCasedHeaderName");
      function IA(W6, cA) {
        cA === void 0 && (cA = {});
        for (let yA = 0; yA < W6.length; yA += 2) {
          const LA = uA(W6[yA]);
          let JA = cA[LA];
          if (JA) typeof JA == "string" && (JA = [JA], cA[LA] = JA), JA.push(W6[yA + 1].toString("utf8"));
          else {
            const WA = W6[yA + 1];
            typeof WA == "string" ? cA[LA] = WA : cA[LA] = Array.isArray(WA) ? WA.map((te3) => te3.toString("utf8")) : WA.toString("utf8");
          }
        }
        return "content-length" in cA && "content-disposition" in cA && (cA["content-disposition"] = Buffer.from(cA["content-disposition"]).toString("latin1")), cA;
      }
      e3(IA, "parseHeaders");
      function CA(W6) {
        const cA = W6.length, yA = new Array(cA);
        let LA = false, JA = -1, WA, te3, ie3 = 0;
        for (let oe3 = 0; oe3 < W6.length; oe3 += 2) WA = W6[oe3], te3 = W6[oe3 + 1], typeof WA != "string" && (WA = WA.toString()), typeof te3 != "string" && (te3 = te3.toString("utf8")), ie3 = WA.length, ie3 === 14 && WA[7] === "-" && (WA === "content-length" || WA.toLowerCase() === "content-length") ? LA = true : ie3 === 19 && WA[7] === "-" && (WA === "content-disposition" || WA.toLowerCase() === "content-disposition") && (JA = oe3 + 1), yA[oe3] = WA, yA[oe3 + 1] = te3;
        return LA && JA !== -1 && (yA[JA] = Buffer.from(yA[JA]).toString("latin1")), yA;
      }
      e3(CA, "parseRawHeaders");
      function pA(W6) {
        return W6 instanceof Uint8Array || Buffer.isBuffer(W6);
      }
      e3(pA, "isBuffer");
      function fA(W6, cA, yA) {
        if (!W6 || typeof W6 != "object") throw new o("handler must be an object");
        if (typeof W6.onConnect != "function") throw new o("invalid onConnect method");
        if (typeof W6.onError != "function") throw new o("invalid onError method");
        if (typeof W6.onBodySent != "function" && W6.onBodySent !== void 0) throw new o("invalid onBodySent method");
        if (yA || cA === "CONNECT") {
          if (typeof W6.onUpgrade != "function") throw new o("invalid onUpgrade method");
        } else {
          if (typeof W6.onHeaders != "function") throw new o("invalid onHeaders method");
          if (typeof W6.onData != "function") throw new o("invalid onData method");
          if (typeof W6.onComplete != "function") throw new o("invalid onComplete method");
        }
      }
      e3(fA, "validateHandler");
      function kA(W6) {
        return !!(W6 && (R4.isDisturbed(W6) || W6[c2]));
      }
      e3(kA, "isDisturbed");
      function bA(W6) {
        return !!(W6 && R4.isErrored(W6));
      }
      e3(bA, "isErrored");
      function gA(W6) {
        return !!(W6 && R4.isReadable(W6));
      }
      e3(gA, "isReadable");
      function DA(W6) {
        return { localAddress: W6.localAddress, localPort: W6.localPort, remoteAddress: W6.remoteAddress, remotePort: W6.remotePort, remoteFamily: W6.remoteFamily, timeout: W6.timeout, bytesWritten: W6.bytesWritten, bytesRead: W6.bytesRead };
      }
      e3(DA, "getSocketInfo");
      function oA(W6) {
        let cA;
        return new ReadableStream({ async start() {
          cA = W6[Symbol.asyncIterator]();
        }, async pull(yA) {
          const { done: LA, value: JA } = await cA.next();
          if (LA) queueMicrotask(() => {
            yA.close(), yA.byobRequest?.respond(0);
          });
          else {
            const WA = Buffer.isBuffer(JA) ? JA : Buffer.from(JA);
            WA.byteLength && yA.enqueue(new Uint8Array(WA));
          }
          return yA.desiredSize > 0;
        }, async cancel(yA) {
          await cA.return();
        }, type: "bytes" });
      }
      e3(oA, "ReadableStreamFrom");
      function aA(W6) {
        return W6 && typeof W6 == "object" && typeof W6.append == "function" && typeof W6.delete == "function" && typeof W6.get == "function" && typeof W6.getAll == "function" && typeof W6.has == "function" && typeof W6.set == "function" && W6[Symbol.toStringTag] === "FormData";
      }
      e3(aA, "isFormDataLike");
      function EA(W6, cA) {
        return "addEventListener" in W6 ? (W6.addEventListener("abort", cA, { once: true }), () => W6.removeEventListener("abort", cA)) : (W6.addListener("abort", cA), () => W6.removeListener("abort", cA));
      }
      e3(EA, "addAbortListener");
      const sA = typeof String.prototype.toWellFormed == "function", NA = typeof String.prototype.isWellFormed == "function";
      function wA(W6) {
        return sA ? `${W6}`.toWellFormed() : D3.toUSVString(W6);
      }
      e3(wA, "toUSVString");
      function vA(W6) {
        return NA ? `${W6}`.isWellFormed() : wA(W6) === `${W6}`;
      }
      e3(vA, "isUSVString");
      function dA(W6) {
        switch (W6) {
          case 34:
          case 40:
          case 41:
          case 44:
          case 47:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 91:
          case 92:
          case 93:
          case 123:
          case 125:
            return false;
          default:
            return W6 >= 33 && W6 <= 126;
        }
      }
      e3(dA, "isTokenCharCode");
      function XA(W6) {
        if (W6.length === 0) return false;
        for (let cA = 0; cA < W6.length; ++cA) if (!dA(W6.charCodeAt(cA))) return false;
        return true;
      }
      e3(XA, "isValidHTTPToken");
      const KA = /[^\t\x20-\x7e\x80-\xff]/;
      function OA(W6) {
        return !KA.test(W6);
      }
      e3(OA, "isValidHeaderValue");
      function PA(W6) {
        if (W6 == null || W6 === "") return { start: 0, end: null, size: null };
        const cA = W6 ? W6.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
        return cA ? { start: parseInt(cA[1]), end: cA[2] ? parseInt(cA[2]) : null, size: cA[3] ? parseInt(cA[3]) : null } : null;
      }
      e3(PA, "parseRangeHeader");
      function ZA(W6, cA, yA) {
        return (W6[B3] ?? (W6[B3] = [])).push([cA, yA]), W6.on(cA, yA), W6;
      }
      e3(ZA, "addListener");
      function HA(W6) {
        for (const [cA, yA] of W6[B3] ?? []) W6.removeListener(cA, yA);
        W6[B3] = null;
      }
      e3(HA, "removeAllListeners");
      function se2(W6, cA, yA) {
        try {
          cA.onError(yA), A2(cA.aborted);
        } catch (LA) {
          W6.emit("error", LA);
        }
      }
      e3(se2, "errorRequest");
      const ne3 = /* @__PURE__ */ Object.create(null);
      ne3.enumerable = true;
      const jA = { delete: "DELETE", DELETE: "DELETE", get: "GET", GET: "GET", head: "HEAD", HEAD: "HEAD", options: "OPTIONS", OPTIONS: "OPTIONS", post: "POST", POST: "POST", put: "PUT", PUT: "PUT" }, Ae = { ...jA, patch: "patch", PATCH: "PATCH" };
      return Object.setPrototypeOf(jA, null), Object.setPrototypeOf(Ae, null), util$7 = { kEnumerableProperty: ne3, nop: J5, isDisturbed: kA, isErrored: bA, isReadable: gA, toUSVString: wA, isUSVString: vA, isBlobLike: _5, parseOrigin: f3, parseURL: m4, getServerName: C5, isStream: V4, isIterable: x5, isAsyncIterable: S6, isDestroyed: $6, headerNameToString: uA, bufferToLowerCasedHeaderName: RA, addListener: ZA, removeAllListeners: HA, errorRequest: se2, parseRawHeaders: CA, parseHeaders: IA, parseKeepAliveTimeout: iA, destroy: K4, bodyLength: z4, deepClone: w5, ReadableStreamFrom: oA, isBuffer: pA, validateHandler: fA, getSocketInfo: DA, isFormDataLike: aA, buildURL: q6, addAbortListener: EA, isValidHTTPToken: XA, isValidHeaderValue: OA, isTokenCharCode: dA, parseRangeHeader: PA, normalizedMethodRecordsBase: jA, normalizedMethodRecords: Ae, isValidPort: M4, isHttpOrHttpsPrefixed: Y4, nodeMajor: I5, nodeMinor: p3, safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"], wrapRequestBody: G3 }, util$7;
    }
    e3(requireUtil$7, "requireUtil$7");
    var diagnostics;
    var hasRequiredDiagnostics;
    function requireDiagnostics() {
      if (hasRequiredDiagnostics) return diagnostics;
      hasRequiredDiagnostics = 1;
      const A2 = require$$0__default$4, k4 = require$$0__default$3, c2 = k4.debuglog("undici"), B3 = k4.debuglog("fetch"), t2 = k4.debuglog("websocket");
      let y3 = false;
      const R4 = { beforeConnect: A2.channel("undici:client:beforeConnect"), connected: A2.channel("undici:client:connected"), connectError: A2.channel("undici:client:connectError"), sendHeaders: A2.channel("undici:client:sendHeaders"), create: A2.channel("undici:request:create"), bodySent: A2.channel("undici:request:bodySent"), headers: A2.channel("undici:request:headers"), trailers: A2.channel("undici:request:trailers"), error: A2.channel("undici:request:error"), open: A2.channel("undici:websocket:open"), close: A2.channel("undici:websocket:close"), socketError: A2.channel("undici:websocket:socket_error"), ping: A2.channel("undici:websocket:ping"), pong: A2.channel("undici:websocket:pong") };
      if (c2.enabled || B3.enabled) {
        const F2 = B3.enabled ? B3 : c2;
        A2.channel("undici:client:beforeConnect").subscribe((Q5) => {
          const { connectParams: { version: D3, protocol: U6, port: r6, host: o } } = Q5;
          F2("connecting to %s using %s%s", `${o}${r6 ? `:${r6}` : ""}`, U6, D3);
        }), A2.channel("undici:client:connected").subscribe((Q5) => {
          const { connectParams: { version: D3, protocol: U6, port: r6, host: o } } = Q5;
          F2("connected to %s using %s%s", `${o}${r6 ? `:${r6}` : ""}`, U6, D3);
        }), A2.channel("undici:client:connectError").subscribe((Q5) => {
          const { connectParams: { version: D3, protocol: U6, port: r6, host: o }, error: N6 } = Q5;
          F2("connection to %s using %s%s errored - %s", `${o}${r6 ? `:${r6}` : ""}`, U6, D3, N6.message);
        }), A2.channel("undici:client:sendHeaders").subscribe((Q5) => {
          const { request: { method: D3, path: U6, origin: r6 } } = Q5;
          F2("sending request to %s %s/%s", D3, r6, U6);
        }), A2.channel("undici:request:headers").subscribe((Q5) => {
          const { request: { method: D3, path: U6, origin: r6 }, response: { statusCode: o } } = Q5;
          F2("received response to %s %s/%s - HTTP %d", D3, r6, U6, o);
        }), A2.channel("undici:request:trailers").subscribe((Q5) => {
          const { request: { method: D3, path: U6, origin: r6 } } = Q5;
          F2("trailers received from %s %s/%s", D3, r6, U6);
        }), A2.channel("undici:request:error").subscribe((Q5) => {
          const { request: { method: D3, path: U6, origin: r6 }, error: o } = Q5;
          F2("request to %s %s/%s errored - %s", D3, r6, U6, o.message);
        }), y3 = true;
      }
      if (t2.enabled) {
        if (!y3) {
          const F2 = c2.enabled ? c2 : t2;
          A2.channel("undici:client:beforeConnect").subscribe((Q5) => {
            const { connectParams: { version: D3, protocol: U6, port: r6, host: o } } = Q5;
            F2("connecting to %s%s using %s%s", o, r6 ? `:${r6}` : "", U6, D3);
          }), A2.channel("undici:client:connected").subscribe((Q5) => {
            const { connectParams: { version: D3, protocol: U6, port: r6, host: o } } = Q5;
            F2("connected to %s%s using %s%s", o, r6 ? `:${r6}` : "", U6, D3);
          }), A2.channel("undici:client:connectError").subscribe((Q5) => {
            const { connectParams: { version: D3, protocol: U6, port: r6, host: o }, error: N6 } = Q5;
            F2("connection to %s%s using %s%s errored - %s", o, r6 ? `:${r6}` : "", U6, D3, N6.message);
          }), A2.channel("undici:client:sendHeaders").subscribe((Q5) => {
            const { request: { method: D3, path: U6, origin: r6 } } = Q5;
            F2("sending request to %s %s/%s", D3, r6, U6);
          });
        }
        A2.channel("undici:websocket:open").subscribe((F2) => {
          const { address: { address: Q5, port: D3 } } = F2;
          t2("connection opened %s%s", Q5, D3 ? `:${D3}` : "");
        }), A2.channel("undici:websocket:close").subscribe((F2) => {
          const { websocket: Q5, code: D3, reason: U6 } = F2;
          t2("closed connection to %s - %s %s", Q5.url, D3, U6);
        }), A2.channel("undici:websocket:socket_error").subscribe((F2) => {
          t2("connection errored - %s", F2.message);
        }), A2.channel("undici:websocket:ping").subscribe((F2) => {
          t2("ping received");
        }), A2.channel("undici:websocket:pong").subscribe((F2) => {
          t2("pong received");
        });
      }
      return diagnostics = { channels: R4 }, diagnostics;
    }
    e3(requireDiagnostics, "requireDiagnostics");
    var request$1;
    var hasRequiredRequest$1;
    function requireRequest$1() {
      if (hasRequiredRequest$1) return request$1;
      hasRequiredRequest$1 = 1;
      const { InvalidArgumentError: A2, NotSupportedError: k4 } = requireErrors(), c2 = require$$0__default$1, { isValidHTTPToken: B3, isValidHeaderValue: t2, isStream: y3, destroy: R4, isBuffer: F2, isFormDataLike: Q5, isIterable: D3, isBlobLike: U6, buildURL: r6, validateHandler: o, getServerName: N6, normalizedMethodRecords: l3 } = requireUtil$7(), { channels: I5 } = requireDiagnostics(), { headerNameLowerCasedRecord: p3 } = requireConstants$4(), b6 = /[^\u0021-\u00ff]/, G3 = Symbol("handler"), _5 = class _ {
        constructor(M4, { path: Y4, method: m4, body: f3, headers: n, query: C5, idempotent: w5, blocking: S6, upgrade: x5, headersTimeout: z4, bodyTimeout: $6, reset: K4, throwOnError: nA, expectContinue: iA, servername: uA }, RA) {
          if (typeof Y4 != "string") throw new A2("path must be a string");
          if (Y4[0] !== "/" && !(Y4.startsWith("http://") || Y4.startsWith("https://")) && m4 !== "CONNECT") throw new A2("path must be an absolute URL or start with a slash");
          if (b6.test(Y4)) throw new A2("invalid request path");
          if (typeof m4 != "string") throw new A2("method must be a string");
          if (l3[m4] === void 0 && !B3(m4)) throw new A2("invalid request method");
          if (x5 && typeof x5 != "string") throw new A2("upgrade must be a string");
          if (z4 != null && (!Number.isFinite(z4) || z4 < 0)) throw new A2("invalid headersTimeout");
          if ($6 != null && (!Number.isFinite($6) || $6 < 0)) throw new A2("invalid bodyTimeout");
          if (K4 != null && typeof K4 != "boolean") throw new A2("invalid reset");
          if (iA != null && typeof iA != "boolean") throw new A2("invalid expectContinue");
          if (this.headersTimeout = z4, this.bodyTimeout = $6, this.throwOnError = nA === true, this.method = m4, this.abort = null, f3 == null) this.body = null;
          else if (y3(f3)) {
            this.body = f3;
            const IA = this.body._readableState;
            (!IA || !IA.autoDestroy) && (this.endHandler = e3(function() {
              R4(this);
            }, "autoDestroy"), this.body.on("end", this.endHandler)), this.errorHandler = (CA) => {
              this.abort ? this.abort(CA) : this.error = CA;
            }, this.body.on("error", this.errorHandler);
          } else if (F2(f3)) this.body = f3.byteLength ? f3 : null;
          else if (ArrayBuffer.isView(f3)) this.body = f3.buffer.byteLength ? Buffer.from(f3.buffer, f3.byteOffset, f3.byteLength) : null;
          else if (f3 instanceof ArrayBuffer) this.body = f3.byteLength ? Buffer.from(f3) : null;
          else if (typeof f3 == "string") this.body = f3.length ? Buffer.from(f3) : null;
          else if (Q5(f3) || D3(f3) || U6(f3)) this.body = f3;
          else throw new A2("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
          if (this.completed = false, this.aborted = false, this.upgrade = x5 || null, this.path = C5 ? r6(Y4, C5) : Y4, this.origin = M4, this.idempotent = w5 ?? (m4 === "HEAD" || m4 === "GET"), this.blocking = S6 ?? false, this.reset = K4 ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = [], this.expectContinue = iA ?? false, Array.isArray(n)) {
            if (n.length % 2 !== 0) throw new A2("headers array must be even");
            for (let IA = 0; IA < n.length; IA += 2) V4(this, n[IA], n[IA + 1]);
          } else if (n && typeof n == "object") if (n[Symbol.iterator]) for (const IA of n) {
            if (!Array.isArray(IA) || IA.length !== 2) throw new A2("headers must be in key-value pair format");
            V4(this, IA[0], IA[1]);
          }
          else {
            const IA = Object.keys(n);
            for (let CA = 0; CA < IA.length; ++CA) V4(this, IA[CA], n[IA[CA]]);
          }
          else if (n != null) throw new A2("headers must be an object or an array");
          o(RA, m4, x5), this.servername = uA || N6(this.host), this[G3] = RA, I5.create.hasSubscribers && I5.create.publish({ request: this });
        }
        onBodySent(M4) {
          if (this[G3].onBodySent) try {
            return this[G3].onBodySent(M4);
          } catch (Y4) {
            this.abort(Y4);
          }
        }
        onRequestSent() {
          if (I5.bodySent.hasSubscribers && I5.bodySent.publish({ request: this }), this[G3].onRequestSent) try {
            return this[G3].onRequestSent();
          } catch (M4) {
            this.abort(M4);
          }
        }
        onConnect(M4) {
          if (c2(!this.aborted), c2(!this.completed), this.error) M4(this.error);
          else return this.abort = M4, this[G3].onConnect(M4);
        }
        onResponseStarted() {
          return this[G3].onResponseStarted?.();
        }
        onHeaders(M4, Y4, m4, f3) {
          c2(!this.aborted), c2(!this.completed), I5.headers.hasSubscribers && I5.headers.publish({ request: this, response: { statusCode: M4, headers: Y4, statusText: f3 } });
          try {
            return this[G3].onHeaders(M4, Y4, m4, f3);
          } catch (n) {
            this.abort(n);
          }
        }
        onData(M4) {
          c2(!this.aborted), c2(!this.completed);
          try {
            return this[G3].onData(M4);
          } catch (Y4) {
            return this.abort(Y4), false;
          }
        }
        onUpgrade(M4, Y4, m4) {
          return c2(!this.aborted), c2(!this.completed), this[G3].onUpgrade(M4, Y4, m4);
        }
        onComplete(M4) {
          this.onFinally(), c2(!this.aborted), this.completed = true, I5.trailers.hasSubscribers && I5.trailers.publish({ request: this, trailers: M4 });
          try {
            return this[G3].onComplete(M4);
          } catch (Y4) {
            this.onError(Y4);
          }
        }
        onError(M4) {
          if (this.onFinally(), I5.error.hasSubscribers && I5.error.publish({ request: this, error: M4 }), !this.aborted) return this.aborted = true, this[G3].onError(M4);
        }
        onFinally() {
          this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
        }
        addHeader(M4, Y4) {
          return V4(this, M4, Y4), this;
        }
      };
      e3(_5, "Request");
      let J5 = _5;
      function V4(q6, M4, Y4) {
        if (Y4 && typeof Y4 == "object" && !Array.isArray(Y4)) throw new A2(`invalid ${M4} header`);
        if (Y4 === void 0) return;
        let m4 = p3[M4];
        if (m4 === void 0 && (m4 = M4.toLowerCase(), p3[m4] === void 0 && !B3(m4))) throw new A2("invalid header key");
        if (Array.isArray(Y4)) {
          const f3 = [];
          for (let n = 0; n < Y4.length; n++) if (typeof Y4[n] == "string") {
            if (!t2(Y4[n])) throw new A2(`invalid ${M4} header`);
            f3.push(Y4[n]);
          } else if (Y4[n] === null) f3.push("");
          else {
            if (typeof Y4[n] == "object") throw new A2(`invalid ${M4} header`);
            f3.push(`${Y4[n]}`);
          }
          Y4 = f3;
        } else if (typeof Y4 == "string") {
          if (!t2(Y4)) throw new A2(`invalid ${M4} header`);
        } else Y4 === null ? Y4 = "" : Y4 = `${Y4}`;
        if (q6.host === null && m4 === "host") {
          if (typeof Y4 != "string") throw new A2("invalid host header");
          q6.host = Y4;
        } else if (q6.contentLength === null && m4 === "content-length") {
          if (q6.contentLength = parseInt(Y4, 10), !Number.isFinite(q6.contentLength)) throw new A2("invalid content-length header");
        } else if (q6.contentType === null && m4 === "content-type") q6.contentType = Y4, q6.headers.push(M4, Y4);
        else {
          if (m4 === "transfer-encoding" || m4 === "keep-alive" || m4 === "upgrade") throw new A2(`invalid ${m4} header`);
          if (m4 === "connection") {
            const f3 = typeof Y4 == "string" ? Y4.toLowerCase() : null;
            if (f3 !== "close" && f3 !== "keep-alive") throw new A2("invalid connection header");
            f3 === "close" && (q6.reset = true);
          } else {
            if (m4 === "expect") throw new k4("expect header not supported");
            q6.headers.push(M4, Y4);
          }
        }
      }
      return e3(V4, "processHeader"), request$1 = J5, request$1;
    }
    e3(requireRequest$1, "requireRequest$1");
    var dispatcher;
    var hasRequiredDispatcher;
    function requireDispatcher() {
      var t2, y3;
      if (hasRequiredDispatcher) return dispatcher;
      hasRequiredDispatcher = 1;
      const A2 = require$$8__default, B3 = class B extends A2 {
        dispatch() {
          throw new Error("not implemented");
        }
        close() {
          throw new Error("not implemented");
        }
        destroy() {
          throw new Error("not implemented");
        }
        compose(...Q5) {
          const D3 = Array.isArray(Q5[0]) ? Q5[0] : Q5;
          let U6 = this.dispatch.bind(this);
          for (const r6 of D3) if (r6 != null) {
            if (typeof r6 != "function") throw new TypeError(`invalid interceptor, expected function received ${typeof r6}`);
            if (U6 = r6(U6), U6 == null || typeof U6 != "function" || U6.length !== 2) throw new TypeError("invalid interceptor");
          }
          return new c2(this, U6);
        }
      };
      e3(B3, "Dispatcher");
      let k4 = B3;
      const R4 = class R extends k4 {
        constructor(D3, U6) {
          super();
          SA(this, t2, null);
          SA(this, y3, null);
          mA(this, t2, D3), mA(this, y3, U6);
        }
        dispatch(...D3) {
          Z4(this, y3).call(this, ...D3);
        }
        close(...D3) {
          return Z4(this, t2).close(...D3);
        }
        destroy(...D3) {
          return Z4(this, t2).destroy(...D3);
        }
      };
      t2 = /* @__PURE__ */ new WeakMap(), y3 = /* @__PURE__ */ new WeakMap(), e3(R4, "ComposedDispatcher");
      let c2 = R4;
      return dispatcher = k4, dispatcher;
    }
    e3(requireDispatcher, "requireDispatcher");
    var dispatcherBase;
    var hasRequiredDispatcherBase;
    function requireDispatcherBase() {
      if (hasRequiredDispatcherBase) return dispatcherBase;
      hasRequiredDispatcherBase = 1;
      const A2 = requireDispatcher(), { ClientDestroyedError: k4, ClientClosedError: c2, InvalidArgumentError: B3 } = requireErrors(), { kDestroy: t2, kClose: y3, kClosed: R4, kDestroyed: F2, kDispatch: Q5, kInterceptors: D3 } = requireSymbols$4(), U6 = Symbol("onDestroyed"), r6 = Symbol("onClosed"), o = Symbol("Intercepted Dispatch"), l3 = class l extends A2 {
        constructor() {
          super(), this[F2] = false, this[U6] = null, this[R4] = false, this[r6] = [];
        }
        get destroyed() {
          return this[F2];
        }
        get closed() {
          return this[R4];
        }
        get interceptors() {
          return this[D3];
        }
        set interceptors(p3) {
          if (p3) {
            for (let b6 = p3.length - 1; b6 >= 0; b6--) if (typeof this[D3][b6] != "function") throw new B3("interceptor must be an function");
          }
          this[D3] = p3;
        }
        close(p3) {
          if (p3 === void 0) return new Promise((G3, J5) => {
            this.close((V4, _5) => V4 ? J5(V4) : G3(_5));
          });
          if (typeof p3 != "function") throw new B3("invalid callback");
          if (this[F2]) {
            queueMicrotask(() => p3(new k4(), null));
            return;
          }
          if (this[R4]) {
            this[r6] ? this[r6].push(p3) : queueMicrotask(() => p3(null, null));
            return;
          }
          this[R4] = true, this[r6].push(p3);
          const b6 = e3(() => {
            const G3 = this[r6];
            this[r6] = null;
            for (let J5 = 0; J5 < G3.length; J5++) G3[J5](null, null);
          }, "onClosed");
          this[y3]().then(() => this.destroy()).then(() => {
            queueMicrotask(b6);
          });
        }
        destroy(p3, b6) {
          if (typeof p3 == "function" && (b6 = p3, p3 = null), b6 === void 0) return new Promise((J5, V4) => {
            this.destroy(p3, (_5, q6) => _5 ? V4(_5) : J5(q6));
          });
          if (typeof b6 != "function") throw new B3("invalid callback");
          if (this[F2]) {
            this[U6] ? this[U6].push(b6) : queueMicrotask(() => b6(null, null));
            return;
          }
          p3 || (p3 = new k4()), this[F2] = true, this[U6] = this[U6] || [], this[U6].push(b6);
          const G3 = e3(() => {
            const J5 = this[U6];
            this[U6] = null;
            for (let V4 = 0; V4 < J5.length; V4++) J5[V4](null, null);
          }, "onDestroyed");
          this[t2](p3).then(() => {
            queueMicrotask(G3);
          });
        }
        [o](p3, b6) {
          if (!this[D3] || this[D3].length === 0) return this[o] = this[Q5], this[Q5](p3, b6);
          let G3 = this[Q5].bind(this);
          for (let J5 = this[D3].length - 1; J5 >= 0; J5--) G3 = this[D3][J5](G3);
          return this[o] = G3, G3(p3, b6);
        }
        dispatch(p3, b6) {
          if (!b6 || typeof b6 != "object") throw new B3("handler must be an object");
          try {
            if (!p3 || typeof p3 != "object") throw new B3("opts must be an object.");
            if (this[F2] || this[U6]) throw new k4();
            if (this[R4]) throw new c2();
            return this[o](p3, b6);
          } catch (G3) {
            if (typeof b6.onError != "function") throw new B3("invalid onError method");
            return b6.onError(G3), false;
          }
        }
      };
      e3(l3, "DispatcherBase");
      let N6 = l3;
      return dispatcherBase = N6, dispatcherBase;
    }
    e3(requireDispatcherBase, "requireDispatcherBase");
    var timers;
    var hasRequiredTimers;
    function requireTimers() {
      var N6;
      if (hasRequiredTimers) return timers;
      hasRequiredTimers = 1;
      let A2 = 0;
      const k4 = 1e3, c2 = (k4 >> 1) - 1;
      let B3;
      const t2 = Symbol("kFastTimer"), y3 = [], R4 = -2, F2 = -1, Q5 = 0, D3 = 1;
      function U6() {
        A2 += c2;
        let I5 = 0, p3 = y3.length;
        for (; I5 < p3; ) {
          const b6 = y3[I5];
          b6._state === Q5 ? (b6._idleStart = A2 - c2, b6._state = D3) : b6._state === D3 && A2 >= b6._idleStart + b6._idleTimeout && (b6._state = F2, b6._idleStart = -1, b6._onTimeout(b6._timerArg)), b6._state === F2 ? (b6._state = R4, --p3 !== 0 && (y3[I5] = y3[p3])) : ++I5;
        }
        y3.length = p3, y3.length !== 0 && r6();
      }
      e3(U6, "onTick");
      function r6() {
        B3 ? B3.refresh() : (clearTimeout(B3), B3 = setTimeout(U6, c2), B3.unref && B3.unref());
      }
      e3(r6, "refreshTimeout"), N6 = t2;
      const l3 = class l {
        constructor(p3, b6, G3) {
          $A(this, N6, true);
          $A(this, "_state", R4);
          $A(this, "_idleTimeout", -1);
          $A(this, "_idleStart", -1);
          $A(this, "_onTimeout");
          $A(this, "_timerArg");
          this._onTimeout = p3, this._idleTimeout = b6, this._timerArg = G3, this.refresh();
        }
        refresh() {
          this._state === R4 && y3.push(this), (!B3 || y3.length === 1) && r6(), this._state = Q5;
        }
        clear() {
          this._state = F2, this._idleStart = -1;
        }
      };
      e3(l3, "FastTimer");
      let o = l3;
      return timers = { setTimeout(I5, p3, b6) {
        return p3 <= k4 ? setTimeout(I5, p3, b6) : new o(I5, p3, b6);
      }, clearTimeout(I5) {
        I5[t2] ? I5.clear() : clearTimeout(I5);
      }, setFastTimeout(I5, p3, b6) {
        return new o(I5, p3, b6);
      }, clearFastTimeout(I5) {
        I5.clear();
      }, now() {
        return A2;
      }, tick(I5 = 0) {
        A2 += I5 - k4 + 1, U6(), U6();
      }, reset() {
        A2 = 0, y3.length = 0, clearTimeout(B3), B3 = null;
      }, kFastTimer: t2 }, timers;
    }
    e3(requireTimers, "requireTimers");
    var connect;
    var hasRequiredConnect;
    function requireConnect() {
      var o, N6;
      if (hasRequiredConnect) return connect;
      hasRequiredConnect = 1;
      const A2 = require$$0__default$2, k4 = require$$0__default$1, c2 = requireUtil$7(), { InvalidArgumentError: B3, ConnectTimeoutError: t2 } = requireErrors(), y3 = requireTimers();
      function R4() {
      }
      e3(R4, "noop");
      let F2, Q5;
      _commonjsHelpers.commonjsGlobal.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG) ? Q5 = (o = class {
        constructor(I5) {
          this._maxCachedSessions = I5, this._sessionCache = /* @__PURE__ */ new Map(), this._sessionRegistry = new _commonjsHelpers.commonjsGlobal.FinalizationRegistry((p3) => {
            if (this._sessionCache.size < this._maxCachedSessions) return;
            const b6 = this._sessionCache.get(p3);
            b6 !== void 0 && b6.deref() === void 0 && this._sessionCache.delete(p3);
          });
        }
        get(I5) {
          const p3 = this._sessionCache.get(I5);
          return p3 ? p3.deref() : null;
        }
        set(I5, p3) {
          this._maxCachedSessions !== 0 && (this._sessionCache.set(I5, new WeakRef(p3)), this._sessionRegistry.register(p3, I5));
        }
      }, e3(o, "WeakSessionCache"), o) : Q5 = (N6 = class {
        constructor(I5) {
          this._maxCachedSessions = I5, this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(I5) {
          return this._sessionCache.get(I5);
        }
        set(I5, p3) {
          if (this._maxCachedSessions !== 0) {
            if (this._sessionCache.size >= this._maxCachedSessions) {
              const { value: b6 } = this._sessionCache.keys().next();
              this._sessionCache.delete(b6);
            }
            this._sessionCache.set(I5, p3);
          }
        }
      }, e3(N6, "SimpleSessionCache"), N6);
      function D3({ allowH2: l3, maxCachedSessions: I5, socketPath: p3, timeout: b6, session: G3, ...J5 }) {
        if (I5 != null && (!Number.isInteger(I5) || I5 < 0)) throw new B3("maxCachedSessions must be a positive integer or zero");
        const V4 = { path: p3, ...J5 }, _5 = new Q5(I5 ?? 100);
        return b6 = b6 ?? 1e4, l3 = l3 ?? false, e3(function({ hostname: M4, host: Y4, protocol: m4, port: f3, servername: n, localAddress: C5, httpSocket: w5 }, S6) {
          let x5;
          if (m4 === "https:") {
            F2 || (F2 = require$$5__default), n = n || V4.servername || c2.getServerName(Y4) || null;
            const $6 = n || M4;
            k4($6);
            const K4 = G3 || _5.get($6) || null;
            f3 = f3 || 443, x5 = F2.connect({ highWaterMark: 16384, ...V4, servername: n, session: K4, localAddress: C5, ALPNProtocols: l3 ? ["http/1.1", "h2"] : ["http/1.1"], socket: w5, port: f3, host: M4 }), x5.on("session", function(nA) {
              _5.set($6, nA);
            });
          } else k4(!w5, "httpSocket can only be sent on TLS update"), f3 = f3 || 80, x5 = A2.connect({ highWaterMark: 64 * 1024, ...V4, localAddress: C5, port: f3, host: M4 });
          if (V4.keepAlive == null || V4.keepAlive) {
            const $6 = V4.keepAliveInitialDelay === void 0 ? 6e4 : V4.keepAliveInitialDelay;
            x5.setKeepAlive(true, $6);
          }
          const z4 = U6(new WeakRef(x5), { timeout: b6, hostname: M4, port: f3 });
          return x5.setNoDelay(true).once(m4 === "https:" ? "secureConnect" : "connect", function() {
            if (queueMicrotask(z4), S6) {
              const $6 = S6;
              S6 = null, $6(null, this);
            }
          }).on("error", function($6) {
            if (queueMicrotask(z4), S6) {
              const K4 = S6;
              S6 = null, K4($6);
            }
          }), x5;
        }, "connect");
      }
      e3(D3, "buildConnector");
      const U6 = process.platform === "win32" ? (l3, I5) => {
        if (!I5.timeout) return R4;
        let p3 = null, b6 = null;
        const G3 = y3.setFastTimeout(() => {
          p3 = setImmediate(() => {
            b6 = setImmediate(() => r6(l3.deref(), I5));
          });
        }, I5.timeout);
        return () => {
          y3.clearFastTimeout(G3), clearImmediate(p3), clearImmediate(b6);
        };
      } : (l3, I5) => {
        if (!I5.timeout) return R4;
        let p3 = null;
        const b6 = y3.setFastTimeout(() => {
          p3 = setImmediate(() => {
            r6(l3.deref(), I5);
          });
        }, I5.timeout);
        return () => {
          y3.clearFastTimeout(b6), clearImmediate(p3);
        };
      };
      function r6(l3, I5) {
        if (l3 == null) return;
        let p3 = "Connect Timeout Error";
        Array.isArray(l3.autoSelectFamilyAttemptedAddresses) ? p3 += ` (attempted addresses: ${l3.autoSelectFamilyAttemptedAddresses.join(", ")},` : p3 += ` (attempted address: ${I5.hostname}:${I5.port},`, p3 += ` timeout: ${I5.timeout}ms)`, c2.destroy(l3, new t2(p3));
      }
      return e3(r6, "onConnectTimeout"), connect = D3, connect;
    }
    e3(requireConnect, "requireConnect");
    var constants$3 = {};
    var utils = {};
    var hasRequiredUtils;
    function requireUtils() {
      if (hasRequiredUtils) return utils;
      hasRequiredUtils = 1, Object.defineProperty(utils, "__esModule", { value: true }), utils.enumToMap = void 0;
      function A2(k4) {
        const c2 = {};
        return Object.keys(k4).forEach((B3) => {
          const t2 = k4[B3];
          typeof t2 == "number" && (c2[B3] = t2);
        }), c2;
      }
      return e3(A2, "enumToMap"), utils.enumToMap = A2, utils;
    }
    e3(requireUtils, "requireUtils");
    var hasRequiredConstants$3;
    function requireConstants$3() {
      return hasRequiredConstants$3 || (hasRequiredConstants$3 = 1, (function(A2) {
        Object.defineProperty(A2, "__esModule", { value: true }), A2.SPECIAL_HEADERS = A2.HEADER_STATE = A2.MINOR = A2.MAJOR = A2.CONNECTION_TOKEN_CHARS = A2.HEADER_CHARS = A2.TOKEN = A2.STRICT_TOKEN = A2.HEX = A2.URL_CHAR = A2.STRICT_URL_CHAR = A2.USERINFO_CHARS = A2.MARK = A2.ALPHANUM = A2.NUM = A2.HEX_MAP = A2.NUM_MAP = A2.ALPHA = A2.FINISH = A2.H_METHOD_MAP = A2.METHOD_MAP = A2.METHODS_RTSP = A2.METHODS_ICE = A2.METHODS_HTTP = A2.METHODS = A2.LENIENT_FLAGS = A2.FLAGS = A2.TYPE = A2.ERROR = void 0;
        const k4 = requireUtils();
        (function(t2) {
          t2[t2.OK = 0] = "OK", t2[t2.INTERNAL = 1] = "INTERNAL", t2[t2.STRICT = 2] = "STRICT", t2[t2.LF_EXPECTED = 3] = "LF_EXPECTED", t2[t2.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", t2[t2.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", t2[t2.INVALID_METHOD = 6] = "INVALID_METHOD", t2[t2.INVALID_URL = 7] = "INVALID_URL", t2[t2.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", t2[t2.INVALID_VERSION = 9] = "INVALID_VERSION", t2[t2.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", t2[t2.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", t2[t2.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", t2[t2.INVALID_STATUS = 13] = "INVALID_STATUS", t2[t2.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", t2[t2.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", t2[t2.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", t2[t2.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", t2[t2.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", t2[t2.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", t2[t2.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", t2[t2.PAUSED = 21] = "PAUSED", t2[t2.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", t2[t2.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", t2[t2.USER = 24] = "USER";
        })(A2.ERROR || (A2.ERROR = {})), (function(t2) {
          t2[t2.BOTH = 0] = "BOTH", t2[t2.REQUEST = 1] = "REQUEST", t2[t2.RESPONSE = 2] = "RESPONSE";
        })(A2.TYPE || (A2.TYPE = {})), (function(t2) {
          t2[t2.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", t2[t2.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", t2[t2.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", t2[t2.CHUNKED = 8] = "CHUNKED", t2[t2.UPGRADE = 16] = "UPGRADE", t2[t2.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", t2[t2.SKIPBODY = 64] = "SKIPBODY", t2[t2.TRAILING = 128] = "TRAILING", t2[t2.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
        })(A2.FLAGS || (A2.FLAGS = {})), (function(t2) {
          t2[t2.HEADERS = 1] = "HEADERS", t2[t2.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", t2[t2.KEEP_ALIVE = 4] = "KEEP_ALIVE";
        })(A2.LENIENT_FLAGS || (A2.LENIENT_FLAGS = {}));
        var c2;
        (function(t2) {
          t2[t2.DELETE = 0] = "DELETE", t2[t2.GET = 1] = "GET", t2[t2.HEAD = 2] = "HEAD", t2[t2.POST = 3] = "POST", t2[t2.PUT = 4] = "PUT", t2[t2.CONNECT = 5] = "CONNECT", t2[t2.OPTIONS = 6] = "OPTIONS", t2[t2.TRACE = 7] = "TRACE", t2[t2.COPY = 8] = "COPY", t2[t2.LOCK = 9] = "LOCK", t2[t2.MKCOL = 10] = "MKCOL", t2[t2.MOVE = 11] = "MOVE", t2[t2.PROPFIND = 12] = "PROPFIND", t2[t2.PROPPATCH = 13] = "PROPPATCH", t2[t2.SEARCH = 14] = "SEARCH", t2[t2.UNLOCK = 15] = "UNLOCK", t2[t2.BIND = 16] = "BIND", t2[t2.REBIND = 17] = "REBIND", t2[t2.UNBIND = 18] = "UNBIND", t2[t2.ACL = 19] = "ACL", t2[t2.REPORT = 20] = "REPORT", t2[t2.MKACTIVITY = 21] = "MKACTIVITY", t2[t2.CHECKOUT = 22] = "CHECKOUT", t2[t2.MERGE = 23] = "MERGE", t2[t2["M-SEARCH"] = 24] = "M-SEARCH", t2[t2.NOTIFY = 25] = "NOTIFY", t2[t2.SUBSCRIBE = 26] = "SUBSCRIBE", t2[t2.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", t2[t2.PATCH = 28] = "PATCH", t2[t2.PURGE = 29] = "PURGE", t2[t2.MKCALENDAR = 30] = "MKCALENDAR", t2[t2.LINK = 31] = "LINK", t2[t2.UNLINK = 32] = "UNLINK", t2[t2.SOURCE = 33] = "SOURCE", t2[t2.PRI = 34] = "PRI", t2[t2.DESCRIBE = 35] = "DESCRIBE", t2[t2.ANNOUNCE = 36] = "ANNOUNCE", t2[t2.SETUP = 37] = "SETUP", t2[t2.PLAY = 38] = "PLAY", t2[t2.PAUSE = 39] = "PAUSE", t2[t2.TEARDOWN = 40] = "TEARDOWN", t2[t2.GET_PARAMETER = 41] = "GET_PARAMETER", t2[t2.SET_PARAMETER = 42] = "SET_PARAMETER", t2[t2.REDIRECT = 43] = "REDIRECT", t2[t2.RECORD = 44] = "RECORD", t2[t2.FLUSH = 45] = "FLUSH";
        })(c2 = A2.METHODS || (A2.METHODS = {})), A2.METHODS_HTTP = [c2.DELETE, c2.GET, c2.HEAD, c2.POST, c2.PUT, c2.CONNECT, c2.OPTIONS, c2.TRACE, c2.COPY, c2.LOCK, c2.MKCOL, c2.MOVE, c2.PROPFIND, c2.PROPPATCH, c2.SEARCH, c2.UNLOCK, c2.BIND, c2.REBIND, c2.UNBIND, c2.ACL, c2.REPORT, c2.MKACTIVITY, c2.CHECKOUT, c2.MERGE, c2["M-SEARCH"], c2.NOTIFY, c2.SUBSCRIBE, c2.UNSUBSCRIBE, c2.PATCH, c2.PURGE, c2.MKCALENDAR, c2.LINK, c2.UNLINK, c2.PRI, c2.SOURCE], A2.METHODS_ICE = [c2.SOURCE], A2.METHODS_RTSP = [c2.OPTIONS, c2.DESCRIBE, c2.ANNOUNCE, c2.SETUP, c2.PLAY, c2.PAUSE, c2.TEARDOWN, c2.GET_PARAMETER, c2.SET_PARAMETER, c2.REDIRECT, c2.RECORD, c2.FLUSH, c2.GET, c2.POST], A2.METHOD_MAP = k4.enumToMap(c2), A2.H_METHOD_MAP = {}, Object.keys(A2.METHOD_MAP).forEach((t2) => {
          /^H/.test(t2) && (A2.H_METHOD_MAP[t2] = A2.METHOD_MAP[t2]);
        }), (function(t2) {
          t2[t2.SAFE = 0] = "SAFE", t2[t2.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", t2[t2.UNSAFE = 2] = "UNSAFE";
        })(A2.FINISH || (A2.FINISH = {})), A2.ALPHA = [];
        for (let t2 = 65; t2 <= 90; t2++) A2.ALPHA.push(String.fromCharCode(t2)), A2.ALPHA.push(String.fromCharCode(t2 + 32));
        A2.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 }, A2.HEX_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, A2.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], A2.ALPHANUM = A2.ALPHA.concat(A2.NUM), A2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"], A2.USERINFO_CHARS = A2.ALPHANUM.concat(A2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]), A2.STRICT_URL_CHAR = ["!", '"', "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~"].concat(A2.ALPHANUM), A2.URL_CHAR = A2.STRICT_URL_CHAR.concat(["	", "\f"]);
        for (let t2 = 128; t2 <= 255; t2++) A2.URL_CHAR.push(t2);
        A2.HEX = A2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]), A2.STRICT_TOKEN = ["!", "#", "$", "%", "&", "'", "*", "+", "-", ".", "^", "_", "`", "|", "~"].concat(A2.ALPHANUM), A2.TOKEN = A2.STRICT_TOKEN.concat([" "]), A2.HEADER_CHARS = ["	"];
        for (let t2 = 32; t2 <= 255; t2++) t2 !== 127 && A2.HEADER_CHARS.push(t2);
        A2.CONNECTION_TOKEN_CHARS = A2.HEADER_CHARS.filter((t2) => t2 !== 44), A2.MAJOR = A2.NUM_MAP, A2.MINOR = A2.MAJOR;
        var B3;
        (function(t2) {
          t2[t2.GENERAL = 0] = "GENERAL", t2[t2.CONNECTION = 1] = "CONNECTION", t2[t2.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", t2[t2.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", t2[t2.UPGRADE = 4] = "UPGRADE", t2[t2.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", t2[t2.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", t2[t2.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", t2[t2.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
        })(B3 = A2.HEADER_STATE || (A2.HEADER_STATE = {})), A2.SPECIAL_HEADERS = { connection: B3.CONNECTION, "content-length": B3.CONTENT_LENGTH, "proxy-connection": B3.CONNECTION, "transfer-encoding": B3.TRANSFER_ENCODING, upgrade: B3.UPGRADE };
      })(constants$3)), constants$3;
    }
    e3(requireConstants$3, "requireConstants$3");
    var llhttpWasm;
    var hasRequiredLlhttpWasm;
    function requireLlhttpWasm() {
      if (hasRequiredLlhttpWasm) return llhttpWasm;
      hasRequiredLlhttpWasm = 1;
      const { Buffer: A2 } = require$$0__default;
      return llhttpWasm = A2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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CABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv", "base64"), llhttpWasm;
    }
    e3(requireLlhttpWasm, "requireLlhttpWasm");
    var llhttp_simdWasm;
    var hasRequiredLlhttp_simdWasm;
    function requireLlhttp_simdWasm() {
      if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm;
      hasRequiredLlhttp_simdWasm = 1;
      const { Buffer: A2 } = require$$0__default;
      return llhttp_simdWasm = A2.from("AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==", "base64"), llhttp_simdWasm;
    }
    e3(requireLlhttp_simdWasm, "requireLlhttp_simdWasm");
    var constants$2;
    var hasRequiredConstants$2;
    function requireConstants$2() {
      if (hasRequiredConstants$2) return constants$2;
      hasRequiredConstants$2 = 1;
      const A2 = ["GET", "HEAD", "POST"], k4 = new Set(A2), c2 = [101, 204, 205, 304], B3 = [301, 302, 303, 307, 308], t2 = new Set(B3), y3 = ["1", "7", "9", "11", "13", "15", "17", "19", "20", "21", "22", "23", "25", "37", "42", "43", "53", "69", "77", "79", "87", "95", "101", "102", "103", "104", "109", "110", "111", "113", "115", "117", "119", "123", "135", "137", "139", "143", "161", "179", "389", "427", "465", "512", "513", "514", "515", "526", "530", "531", "532", "540", "548", "554", "556", "563", "587", "601", "636", "989", "990", "993", "995", "1719", "1720", "1723", "2049", "3659", "4045", "4190", "5060", "5061", "6000", "6566", "6665", "6666", "6667", "6668", "6669", "6679", "6697", "10080"], R4 = new Set(y3), F2 = ["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"], Q5 = new Set(F2), D3 = ["follow", "manual", "error"], U6 = ["GET", "HEAD", "OPTIONS", "TRACE"], r6 = new Set(U6), o = ["navigate", "same-origin", "no-cors", "cors"], N6 = ["omit", "same-origin", "include"], l3 = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"], I5 = ["content-encoding", "content-language", "content-location", "content-type", "content-length"], p3 = ["half"], b6 = ["CONNECT", "TRACE", "TRACK"], G3 = new Set(b6), J5 = ["audio", "audioworklet", "font", "image", "manifest", "paintworklet", "script", "style", "track", "video", "xslt", ""], V4 = new Set(J5);
      return constants$2 = { subresource: J5, forbiddenMethods: b6, requestBodyHeader: I5, referrerPolicy: F2, requestRedirect: D3, requestMode: o, requestCredentials: N6, requestCache: l3, redirectStatus: B3, corsSafeListedMethods: A2, nullBodyStatus: c2, safeMethods: U6, badPorts: y3, requestDuplex: p3, subresourceSet: V4, badPortsSet: R4, redirectStatusSet: t2, corsSafeListedMethodsSet: k4, safeMethodsSet: r6, forbiddenMethodsSet: G3, referrerPolicySet: Q5 }, constants$2;
    }
    e3(requireConstants$2, "requireConstants$2");
    var global$1;
    var hasRequiredGlobal$1;
    function requireGlobal$1() {
      if (hasRequiredGlobal$1) return global$1;
      hasRequiredGlobal$1 = 1;
      const A2 = Symbol.for("undici.globalOrigin.1");
      function k4() {
        return globalThis[A2];
      }
      e3(k4, "getGlobalOrigin");
      function c2(B3) {
        if (B3 === void 0) {
          Object.defineProperty(globalThis, A2, { value: void 0, writable: true, enumerable: false, configurable: false });
          return;
        }
        const t2 = new URL(B3);
        if (t2.protocol !== "http:" && t2.protocol !== "https:") throw new TypeError(`Only http & https urls are allowed, received ${t2.protocol}`);
        Object.defineProperty(globalThis, A2, { value: t2, writable: true, enumerable: false, configurable: false });
      }
      return e3(c2, "setGlobalOrigin"), global$1 = { getGlobalOrigin: k4, setGlobalOrigin: c2 }, global$1;
    }
    e3(requireGlobal$1, "requireGlobal$1");
    var dataUrl;
    var hasRequiredDataUrl;
    function requireDataUrl() {
      if (hasRequiredDataUrl) return dataUrl;
      hasRequiredDataUrl = 1;
      const A2 = require$$0__default$1, k4 = new TextEncoder(), c2 = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/, B3 = /[\u000A\u000D\u0009\u0020]/, t2 = /[\u0009\u000A\u000C\u000D\u0020]/g, y3 = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
      function R4(m4) {
        A2(m4.protocol === "data:");
        let f3 = F2(m4, true);
        f3 = f3.slice(5);
        const n = { position: 0 };
        let C5 = D3(",", f3, n);
        const w5 = C5.length;
        if (C5 = _5(C5, true, true), n.position >= f3.length) return "failure";
        n.position++;
        const S6 = f3.slice(w5 + 1);
        let x5 = U6(S6);
        if (/;(\u0020){0,}base64$/i.test(C5)) {
          const $6 = M4(x5);
          if (x5 = I5($6), x5 === "failure") return "failure";
          C5 = C5.slice(0, -6), C5 = C5.replace(/(\u0020)+$/, ""), C5 = C5.slice(0, -1);
        }
        C5.startsWith(";") && (C5 = "text/plain" + C5);
        let z4 = l3(C5);
        return z4 === "failure" && (z4 = l3("text/plain;charset=US-ASCII")), { mimeType: z4, body: x5 };
      }
      e3(R4, "dataURLProcessor");
      function F2(m4, f3 = false) {
        if (!f3) return m4.href;
        const n = m4.href, C5 = m4.hash.length, w5 = C5 === 0 ? n : n.substring(0, n.length - C5);
        return !C5 && n.endsWith("#") ? w5.slice(0, -1) : w5;
      }
      e3(F2, "URLSerializer");
      function Q5(m4, f3, n) {
        let C5 = "";
        for (; n.position < f3.length && m4(f3[n.position]); ) C5 += f3[n.position], n.position++;
        return C5;
      }
      e3(Q5, "collectASequenceOfCodePoints");
      function D3(m4, f3, n) {
        const C5 = f3.indexOf(m4, n.position), w5 = n.position;
        return C5 === -1 ? (n.position = f3.length, f3.slice(w5)) : (n.position = C5, f3.slice(w5, n.position));
      }
      e3(D3, "collectASequenceOfCodePointsFast");
      function U6(m4) {
        const f3 = k4.encode(m4);
        return N6(f3);
      }
      e3(U6, "stringPercentDecode");
      function r6(m4) {
        return m4 >= 48 && m4 <= 57 || m4 >= 65 && m4 <= 70 || m4 >= 97 && m4 <= 102;
      }
      e3(r6, "isHexCharByte");
      function o(m4) {
        return m4 >= 48 && m4 <= 57 ? m4 - 48 : (m4 & 223) - 55;
      }
      e3(o, "hexByteToNumber");
      function N6(m4) {
        const f3 = m4.length, n = new Uint8Array(f3);
        let C5 = 0;
        for (let w5 = 0; w5 < f3; ++w5) {
          const S6 = m4[w5];
          S6 !== 37 ? n[C5++] = S6 : S6 === 37 && !(r6(m4[w5 + 1]) && r6(m4[w5 + 2])) ? n[C5++] = 37 : (n[C5++] = o(m4[w5 + 1]) << 4 | o(m4[w5 + 2]), w5 += 2);
        }
        return f3 === C5 ? n : n.subarray(0, C5);
      }
      e3(N6, "percentDecode");
      function l3(m4) {
        m4 = J5(m4, true, true);
        const f3 = { position: 0 }, n = D3("/", m4, f3);
        if (n.length === 0 || !c2.test(n) || f3.position > m4.length) return "failure";
        f3.position++;
        let C5 = D3(";", m4, f3);
        if (C5 = J5(C5, false, true), C5.length === 0 || !c2.test(C5)) return "failure";
        const w5 = n.toLowerCase(), S6 = C5.toLowerCase(), x5 = { type: w5, subtype: S6, parameters: /* @__PURE__ */ new Map(), essence: `${w5}/${S6}` };
        for (; f3.position < m4.length; ) {
          f3.position++, Q5((K4) => B3.test(K4), m4, f3);
          let z4 = Q5((K4) => K4 !== ";" && K4 !== "=", m4, f3);
          if (z4 = z4.toLowerCase(), f3.position < m4.length) {
            if (m4[f3.position] === ";") continue;
            f3.position++;
          }
          if (f3.position > m4.length) break;
          let $6 = null;
          if (m4[f3.position] === '"') $6 = p3(m4, f3, true), D3(";", m4, f3);
          else if ($6 = D3(";", m4, f3), $6 = J5($6, false, true), $6.length === 0) continue;
          z4.length !== 0 && c2.test(z4) && ($6.length === 0 || y3.test($6)) && !x5.parameters.has(z4) && x5.parameters.set(z4, $6);
        }
        return x5;
      }
      e3(l3, "parseMIMEType");
      function I5(m4) {
        m4 = m4.replace(t2, "");
        let f3 = m4.length;
        if (f3 % 4 === 0 && m4.charCodeAt(f3 - 1) === 61 && (--f3, m4.charCodeAt(f3 - 1) === 61 && --f3), f3 % 4 === 1 || /[^+/0-9A-Za-z]/.test(m4.length === f3 ? m4 : m4.substring(0, f3))) return "failure";
        const n = Buffer.from(m4, "base64");
        return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
      }
      e3(I5, "forgivingBase64");
      function p3(m4, f3, n) {
        const C5 = f3.position;
        let w5 = "";
        for (A2(m4[f3.position] === '"'), f3.position++; w5 += Q5((x5) => x5 !== '"' && x5 !== "\\", m4, f3), !(f3.position >= m4.length); ) {
          const S6 = m4[f3.position];
          if (f3.position++, S6 === "\\") {
            if (f3.position >= m4.length) {
              w5 += "\\";
              break;
            }
            w5 += m4[f3.position], f3.position++;
          } else {
            A2(S6 === '"');
            break;
          }
        }
        return n ? w5 : m4.slice(C5, f3.position);
      }
      e3(p3, "collectAnHTTPQuotedString");
      function b6(m4) {
        A2(m4 !== "failure");
        const { parameters: f3, essence: n } = m4;
        let C5 = n;
        for (let [w5, S6] of f3.entries()) C5 += ";", C5 += w5, C5 += "=", c2.test(S6) || (S6 = S6.replace(/(\\|")/g, "\\$1"), S6 = '"' + S6, S6 += '"'), C5 += S6;
        return C5;
      }
      e3(b6, "serializeAMimeType");
      function G3(m4) {
        return m4 === 13 || m4 === 10 || m4 === 9 || m4 === 32;
      }
      e3(G3, "isHTTPWhiteSpace");
      function J5(m4, f3 = true, n = true) {
        return q6(m4, f3, n, G3);
      }
      e3(J5, "removeHTTPWhitespace");
      function V4(m4) {
        return m4 === 13 || m4 === 10 || m4 === 9 || m4 === 12 || m4 === 32;
      }
      e3(V4, "isASCIIWhitespace");
      function _5(m4, f3 = true, n = true) {
        return q6(m4, f3, n, V4);
      }
      e3(_5, "removeASCIIWhitespace");
      function q6(m4, f3, n, C5) {
        let w5 = 0, S6 = m4.length - 1;
        if (f3) for (; w5 < m4.length && C5(m4.charCodeAt(w5)); ) w5++;
        if (n) for (; S6 > 0 && C5(m4.charCodeAt(S6)); ) S6--;
        return w5 === 0 && S6 === m4.length - 1 ? m4 : m4.slice(w5, S6 + 1);
      }
      e3(q6, "removeChars");
      function M4(m4) {
        const f3 = m4.length;
        if (65535 > f3) return String.fromCharCode.apply(null, m4);
        let n = "", C5 = 0, w5 = 65535;
        for (; C5 < f3; ) C5 + w5 > f3 && (w5 = f3 - C5), n += String.fromCharCode.apply(null, m4.subarray(C5, C5 += w5));
        return n;
      }
      e3(M4, "isomorphicDecode");
      function Y4(m4) {
        switch (m4.essence) {
          case "application/ecmascript":
          case "application/javascript":
          case "application/x-ecmascript":
          case "application/x-javascript":
          case "text/ecmascript":
          case "text/javascript":
          case "text/javascript1.0":
          case "text/javascript1.1":
          case "text/javascript1.2":
          case "text/javascript1.3":
          case "text/javascript1.4":
          case "text/javascript1.5":
          case "text/jscript":
          case "text/livescript":
          case "text/x-ecmascript":
          case "text/x-javascript":
            return "text/javascript";
          case "application/json":
          case "text/json":
            return "application/json";
          case "image/svg+xml":
            return "image/svg+xml";
          case "text/xml":
          case "application/xml":
            return "application/xml";
        }
        return m4.subtype.endsWith("+json") ? "application/json" : m4.subtype.endsWith("+xml") ? "application/xml" : "";
      }
      return e3(Y4, "minimizeSupportedMimeType"), dataUrl = { dataURLProcessor: R4, URLSerializer: F2, collectASequenceOfCodePoints: Q5, collectASequenceOfCodePointsFast: D3, stringPercentDecode: U6, parseMIMEType: l3, collectAnHTTPQuotedString: p3, serializeAMimeType: b6, removeChars: q6, removeHTTPWhitespace: J5, minimizeSupportedMimeType: Y4, HTTP_TOKEN_CODEPOINTS: c2, isomorphicDecode: M4 }, dataUrl;
    }
    e3(requireDataUrl, "requireDataUrl");
    var webidl_1;
    var hasRequiredWebidl;
    function requireWebidl() {
      if (hasRequiredWebidl) return webidl_1;
      hasRequiredWebidl = 1;
      const { types: A2, inspect: k4 } = require$$0__default$3, { markAsUncloneable: c2 } = require$$1__default, { toUSVString: B3 } = requireUtil$7(), t2 = {};
      return t2.converters = {}, t2.util = {}, t2.errors = {}, t2.errors.exception = function(y3) {
        return new TypeError(`${y3.header}: ${y3.message}`);
      }, t2.errors.conversionFailed = function(y3) {
        const R4 = y3.types.length === 1 ? "" : " one of", F2 = `${y3.argument} could not be converted to${R4}: ${y3.types.join(", ")}.`;
        return t2.errors.exception({ header: y3.prefix, message: F2 });
      }, t2.errors.invalidArgument = function(y3) {
        return t2.errors.exception({ header: y3.prefix, message: `"${y3.value}" is an invalid ${y3.type}.` });
      }, t2.brandCheck = function(y3, R4, F2) {
        if (F2?.strict !== false) {
          if (!(y3 instanceof R4)) {
            const Q5 = new TypeError("Illegal invocation");
            throw Q5.code = "ERR_INVALID_THIS", Q5;
          }
        } else if (y3?.[Symbol.toStringTag] !== R4.prototype[Symbol.toStringTag]) {
          const Q5 = new TypeError("Illegal invocation");
          throw Q5.code = "ERR_INVALID_THIS", Q5;
        }
      }, t2.argumentLengthCheck = function({ length: y3 }, R4, F2) {
        if (y3 < R4) throw t2.errors.exception({ message: `${R4} argument${R4 !== 1 ? "s" : ""} required, but${y3 ? " only" : ""} ${y3} found.`, header: F2 });
      }, t2.illegalConstructor = function() {
        throw t2.errors.exception({ header: "TypeError", message: "Illegal constructor" });
      }, t2.util.Type = function(y3) {
        switch (typeof y3) {
          case "undefined":
            return "Undefined";
          case "boolean":
            return "Boolean";
          case "string":
            return "String";
          case "symbol":
            return "Symbol";
          case "number":
            return "Number";
          case "bigint":
            return "BigInt";
          case "function":
          case "object":
            return y3 === null ? "Null" : "Object";
        }
      }, t2.util.markAsUncloneable = c2 || (() => {
      }), t2.util.ConvertToInt = function(y3, R4, F2, Q5) {
        let D3, U6;
        R4 === 64 ? (D3 = Math.pow(2, 53) - 1, F2 === "unsigned" ? U6 = 0 : U6 = Math.pow(-2, 53) + 1) : F2 === "unsigned" ? (U6 = 0, D3 = Math.pow(2, R4) - 1) : (U6 = Math.pow(-2, R4) - 1, D3 = Math.pow(2, R4 - 1) - 1);
        let r6 = Number(y3);
        if (r6 === 0 && (r6 = 0), Q5?.enforceRange === true) {
          if (Number.isNaN(r6) || r6 === Number.POSITIVE_INFINITY || r6 === Number.NEGATIVE_INFINITY) throw t2.errors.exception({ header: "Integer conversion", message: `Could not convert ${t2.util.Stringify(y3)} to an integer.` });
          if (r6 = t2.util.IntegerPart(r6), r6 < U6 || r6 > D3) throw t2.errors.exception({ header: "Integer conversion", message: `Value must be between ${U6}-${D3}, got ${r6}.` });
          return r6;
        }
        return !Number.isNaN(r6) && Q5?.clamp === true ? (r6 = Math.min(Math.max(r6, U6), D3), Math.floor(r6) % 2 === 0 ? r6 = Math.floor(r6) : r6 = Math.ceil(r6), r6) : Number.isNaN(r6) || r6 === 0 && Object.is(0, r6) || r6 === Number.POSITIVE_INFINITY || r6 === Number.NEGATIVE_INFINITY ? 0 : (r6 = t2.util.IntegerPart(r6), r6 = r6 % Math.pow(2, R4), F2 === "signed" && r6 >= Math.pow(2, R4) - 1 ? r6 - Math.pow(2, R4) : r6);
      }, t2.util.IntegerPart = function(y3) {
        const R4 = Math.floor(Math.abs(y3));
        return y3 < 0 ? -1 * R4 : R4;
      }, t2.util.Stringify = function(y3) {
        switch (t2.util.Type(y3)) {
          case "Symbol":
            return `Symbol(${y3.description})`;
          case "Object":
            return k4(y3);
          case "String":
            return `"${y3}"`;
          default:
            return `${y3}`;
        }
      }, t2.sequenceConverter = function(y3) {
        return (R4, F2, Q5, D3) => {
          if (t2.util.Type(R4) !== "Object") throw t2.errors.exception({ header: F2, message: `${Q5} (${t2.util.Stringify(R4)}) is not iterable.` });
          const U6 = typeof D3 == "function" ? D3() : R4?.[Symbol.iterator]?.(), r6 = [];
          let o = 0;
          if (U6 === void 0 || typeof U6.next != "function") throw t2.errors.exception({ header: F2, message: `${Q5} is not iterable.` });
          for (; ; ) {
            const { done: N6, value: l3 } = U6.next();
            if (N6) break;
            r6.push(y3(l3, F2, `${Q5}[${o++}]`));
          }
          return r6;
        };
      }, t2.recordConverter = function(y3, R4) {
        return (F2, Q5, D3) => {
          if (t2.util.Type(F2) !== "Object") throw t2.errors.exception({ header: Q5, message: `${D3} ("${t2.util.Type(F2)}") is not an Object.` });
          const U6 = {};
          if (!A2.isProxy(F2)) {
            const o = [...Object.getOwnPropertyNames(F2), ...Object.getOwnPropertySymbols(F2)];
            for (const N6 of o) {
              const l3 = y3(N6, Q5, D3), I5 = R4(F2[N6], Q5, D3);
              U6[l3] = I5;
            }
            return U6;
          }
          const r6 = Reflect.ownKeys(F2);
          for (const o of r6) if (Reflect.getOwnPropertyDescriptor(F2, o)?.enumerable) {
            const l3 = y3(o, Q5, D3), I5 = R4(F2[o], Q5, D3);
            U6[l3] = I5;
          }
          return U6;
        };
      }, t2.interfaceConverter = function(y3) {
        return (R4, F2, Q5, D3) => {
          if (D3?.strict !== false && !(R4 instanceof y3)) throw t2.errors.exception({ header: F2, message: `Expected ${Q5} ("${t2.util.Stringify(R4)}") to be an instance of ${y3.name}.` });
          return R4;
        };
      }, t2.dictionaryConverter = function(y3) {
        return (R4, F2, Q5) => {
          const D3 = t2.util.Type(R4), U6 = {};
          if (D3 === "Null" || D3 === "Undefined") return U6;
          if (D3 !== "Object") throw t2.errors.exception({ header: F2, message: `Expected ${R4} to be one of: Null, Undefined, Object.` });
          for (const r6 of y3) {
            const { key: o, defaultValue: N6, required: l3, converter: I5 } = r6;
            if (l3 === true && !Object.hasOwn(R4, o)) throw t2.errors.exception({ header: F2, message: `Missing required key "${o}".` });
            let p3 = R4[o];
            const b6 = Object.hasOwn(r6, "defaultValue");
            if (b6 && p3 !== null && (p3 ?? (p3 = N6())), l3 || b6 || p3 !== void 0) {
              if (p3 = I5(p3, F2, `${Q5}.${o}`), r6.allowedValues && !r6.allowedValues.includes(p3)) throw t2.errors.exception({ header: F2, message: `${p3} is not an accepted type. Expected one of ${r6.allowedValues.join(", ")}.` });
              U6[o] = p3;
            }
          }
          return U6;
        };
      }, t2.nullableConverter = function(y3) {
        return (R4, F2, Q5) => R4 === null ? R4 : y3(R4, F2, Q5);
      }, t2.converters.DOMString = function(y3, R4, F2, Q5) {
        if (y3 === null && Q5?.legacyNullToEmptyString) return "";
        if (typeof y3 == "symbol") throw t2.errors.exception({ header: R4, message: `${F2} is a symbol, which cannot be converted to a DOMString.` });
        return String(y3);
      }, t2.converters.ByteString = function(y3, R4, F2) {
        const Q5 = t2.converters.DOMString(y3, R4, F2);
        for (let D3 = 0; D3 < Q5.length; D3++) if (Q5.charCodeAt(D3) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${D3} has a value of ${Q5.charCodeAt(D3)} which is greater than 255.`);
        return Q5;
      }, t2.converters.USVString = B3, t2.converters.boolean = function(y3) {
        return !!y3;
      }, t2.converters.any = function(y3) {
        return y3;
      }, t2.converters["long long"] = function(y3, R4, F2) {
        return t2.util.ConvertToInt(y3, 64, "signed", void 0, R4, F2);
      }, t2.converters["unsigned long long"] = function(y3, R4, F2) {
        return t2.util.ConvertToInt(y3, 64, "unsigned", void 0, R4, F2);
      }, t2.converters["unsigned long"] = function(y3, R4, F2) {
        return t2.util.ConvertToInt(y3, 32, "unsigned", void 0, R4, F2);
      }, t2.converters["unsigned short"] = function(y3, R4, F2, Q5) {
        return t2.util.ConvertToInt(y3, 16, "unsigned", Q5, R4, F2);
      }, t2.converters.ArrayBuffer = function(y3, R4, F2, Q5) {
        if (t2.util.Type(y3) !== "Object" || !A2.isAnyArrayBuffer(y3)) throw t2.errors.conversionFailed({ prefix: R4, argument: `${F2} ("${t2.util.Stringify(y3)}")`, types: ["ArrayBuffer"] });
        if (Q5?.allowShared === false && A2.isSharedArrayBuffer(y3)) throw t2.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (y3.resizable || y3.growable) throw t2.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return y3;
      }, t2.converters.TypedArray = function(y3, R4, F2, Q5, D3) {
        if (t2.util.Type(y3) !== "Object" || !A2.isTypedArray(y3) || y3.constructor.name !== R4.name) throw t2.errors.conversionFailed({ prefix: F2, argument: `${Q5} ("${t2.util.Stringify(y3)}")`, types: [R4.name] });
        if (D3?.allowShared === false && A2.isSharedArrayBuffer(y3.buffer)) throw t2.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (y3.buffer.resizable || y3.buffer.growable) throw t2.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return y3;
      }, t2.converters.DataView = function(y3, R4, F2, Q5) {
        if (t2.util.Type(y3) !== "Object" || !A2.isDataView(y3)) throw t2.errors.exception({ header: R4, message: `${F2} is not a DataView.` });
        if (Q5?.allowShared === false && A2.isSharedArrayBuffer(y3.buffer)) throw t2.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
        if (y3.buffer.resizable || y3.buffer.growable) throw t2.errors.exception({ header: "ArrayBuffer", message: "Received a resizable ArrayBuffer." });
        return y3;
      }, t2.converters.BufferSource = function(y3, R4, F2, Q5) {
        if (A2.isAnyArrayBuffer(y3)) return t2.converters.ArrayBuffer(y3, R4, F2, { ...Q5, allowShared: false });
        if (A2.isTypedArray(y3)) return t2.converters.TypedArray(y3, y3.constructor, R4, F2, { ...Q5, allowShared: false });
        if (A2.isDataView(y3)) return t2.converters.DataView(y3, R4, F2, { ...Q5, allowShared: false });
        throw t2.errors.conversionFailed({ prefix: R4, argument: `${F2} ("${t2.util.Stringify(y3)}")`, types: ["BufferSource"] });
      }, t2.converters["sequence<ByteString>"] = t2.sequenceConverter(t2.converters.ByteString), t2.converters["sequence<sequence<ByteString>>"] = t2.sequenceConverter(t2.converters["sequence<ByteString>"]), t2.converters["record<ByteString, ByteString>"] = t2.recordConverter(t2.converters.ByteString, t2.converters.ByteString), webidl_1 = { webidl: t2 }, webidl_1;
    }
    e3(requireWebidl, "requireWebidl");
    var util$6;
    var hasRequiredUtil$6;
    function requireUtil$6() {
      var xA;
      if (hasRequiredUtil$6) return util$6;
      hasRequiredUtil$6 = 1;
      const { Transform: A2 } = Stream__default, k4 = zlib__default, { redirectStatusSet: c2, referrerPolicySet: B3, badPortsSet: t2 } = requireConstants$2(), { getGlobalOrigin: y3 } = requireGlobal$1(), { collectASequenceOfCodePoints: R4, collectAnHTTPQuotedString: F2, removeChars: Q5, parseMIMEType: D3 } = requireDataUrl(), { performance: U6 } = require$$5__default$1, { isBlobLike: r6, ReadableStreamFrom: o, isValidHTTPToken: N6, normalizedMethodRecordsBase: l3 } = requireUtil$7(), I5 = require$$0__default$1, { isUint8Array: p3 } = require$$8__default$1, { webidl: b6 } = requireWebidl();
      let G3 = [], J5;
      try {
        J5 = require("crypto");
        const v4 = ["sha256", "sha384", "sha512"];
        G3 = J5.getHashes().filter((X5) => v4.includes(X5));
      } catch {
      }
      function V4(v4) {
        const X5 = v4.urlList, j3 = X5.length;
        return j3 === 0 ? null : X5[j3 - 1].toString();
      }
      e3(V4, "responseURL");
      function _5(v4, X5) {
        if (!c2.has(v4.status)) return null;
        let j3 = v4.headersList.get("location", true);
        return j3 !== null && w5(j3) && (q6(j3) || (j3 = M4(j3)), j3 = new URL(j3, V4(v4))), j3 && !j3.hash && (j3.hash = X5), j3;
      }
      e3(_5, "responseLocationURL");
      function q6(v4) {
        for (let X5 = 0; X5 < v4.length; ++X5) {
          const j3 = v4.charCodeAt(X5);
          if (j3 > 126 || j3 < 32) return false;
        }
        return true;
      }
      e3(q6, "isValidEncodedURL");
      function M4(v4) {
        return Buffer.from(v4, "binary").toString("utf8");
      }
      e3(M4, "normalizeBinaryStringToUtf8");
      function Y4(v4) {
        return v4.urlList[v4.urlList.length - 1];
      }
      e3(Y4, "requestCurrentURL");
      function m4(v4) {
        const X5 = Y4(v4);
        return LA(X5) && t2.has(X5.port) ? "blocked" : "allowed";
      }
      e3(m4, "requestBadPort");
      function f3(v4) {
        return v4 instanceof Error || v4?.constructor?.name === "Error" || v4?.constructor?.name === "DOMException";
      }
      e3(f3, "isErrorLike");
      function n(v4) {
        for (let X5 = 0; X5 < v4.length; ++X5) {
          const j3 = v4.charCodeAt(X5);
          if (!(j3 === 9 || j3 >= 32 && j3 <= 126 || j3 >= 128 && j3 <= 255)) return false;
        }
        return true;
      }
      e3(n, "isValidReasonPhrase");
      const C5 = N6;
      function w5(v4) {
        return (v4[0] === "	" || v4[0] === " " || v4[v4.length - 1] === "	" || v4[v4.length - 1] === " " || v4.includes(`
`) || v4.includes("\r") || v4.includes("\0")) === false;
      }
      e3(w5, "isValidHeaderValue");
      function S6(v4, X5) {
        const { headersList: j3 } = X5, tA = (j3.get("referrer-policy", true) ?? "").split(",");
        let rA = "";
        if (tA.length > 0) for (let FA = tA.length; FA !== 0; FA--) {
          const TA = tA[FA - 1].trim();
          if (B3.has(TA)) {
            rA = TA;
            break;
          }
        }
        rA !== "" && (v4.referrerPolicy = rA);
      }
      e3(S6, "setRequestReferrerPolicyOnRedirect");
      function x5() {
        return "allowed";
      }
      e3(x5, "crossOriginResourcePolicyCheck");
      function z4() {
        return "success";
      }
      e3(z4, "corsCheck");
      function $6() {
        return "success";
      }
      e3($6, "TAOCheck");
      function K4(v4) {
        let X5 = null;
        X5 = v4.mode, v4.headersList.set("sec-fetch-mode", X5, true);
      }
      e3(K4, "appendFetchMetadata");
      function nA(v4) {
        let X5 = v4.origin;
        if (!(X5 === "client" || X5 === void 0)) {
          if (v4.responseTainting === "cors" || v4.mode === "websocket") v4.headersList.append("origin", X5, true);
          else if (v4.method !== "GET" && v4.method !== "HEAD") {
            switch (v4.referrerPolicy) {
              case "no-referrer":
                X5 = null;
                break;
              case "no-referrer-when-downgrade":
              case "strict-origin":
              case "strict-origin-when-cross-origin":
                v4.origin && yA(v4.origin) && !yA(Y4(v4)) && (X5 = null);
                break;
              case "same-origin":
                wA(v4, Y4(v4)) || (X5 = null);
                break;
            }
            v4.headersList.append("origin", X5, true);
          }
        }
      }
      e3(nA, "appendRequestOriginHeader");
      function iA(v4, X5) {
        return v4;
      }
      e3(iA, "coarsenTime");
      function uA(v4, X5, j3) {
        return !v4?.startTime || v4.startTime < X5 ? { domainLookupStartTime: X5, domainLookupEndTime: X5, connectionStartTime: X5, connectionEndTime: X5, secureConnectionStartTime: X5, ALPNNegotiatedProtocol: v4?.ALPNNegotiatedProtocol } : { domainLookupStartTime: iA(v4.domainLookupStartTime), domainLookupEndTime: iA(v4.domainLookupEndTime), connectionStartTime: iA(v4.connectionStartTime), connectionEndTime: iA(v4.connectionEndTime), secureConnectionStartTime: iA(v4.secureConnectionStartTime), ALPNNegotiatedProtocol: v4.ALPNNegotiatedProtocol };
      }
      e3(uA, "clampAndCoarsenConnectionTimingInfo");
      function RA(v4) {
        return iA(U6.now());
      }
      e3(RA, "coarsenedSharedCurrentTime");
      function IA(v4) {
        return { startTime: v4.startTime ?? 0, redirectStartTime: 0, redirectEndTime: 0, postRedirectStartTime: v4.startTime ?? 0, finalServiceWorkerStartTime: 0, finalNetworkResponseStartTime: 0, finalNetworkRequestStartTime: 0, endTime: 0, encodedBodySize: 0, decodedBodySize: 0, finalConnectionTimingInfo: null };
      }
      e3(IA, "createOpaqueTimingInfo");
      function CA() {
        return { referrerPolicy: "strict-origin-when-cross-origin" };
      }
      e3(CA, "makePolicyContainer");
      function pA(v4) {
        return { referrerPolicy: v4.referrerPolicy };
      }
      e3(pA, "clonePolicyContainer");
      function fA(v4) {
        const X5 = v4.referrerPolicy;
        I5(X5);
        let j3 = null;
        if (v4.referrer === "client") {
          const VA = y3();
          if (!VA || VA.origin === "null") return "no-referrer";
          j3 = new URL(VA);
        } else v4.referrer instanceof URL && (j3 = v4.referrer);
        let tA = kA(j3);
        const rA = kA(j3, true);
        tA.toString().length > 4096 && (tA = rA);
        const FA = wA(v4, tA), TA = bA(tA) && !bA(v4.url);
        switch (X5) {
          case "origin":
            return rA ?? kA(j3, true);
          case "unsafe-url":
            return tA;
          case "same-origin":
            return FA ? rA : "no-referrer";
          case "origin-when-cross-origin":
            return FA ? tA : rA;
          case "strict-origin-when-cross-origin": {
            const VA = Y4(v4);
            return wA(tA, VA) ? tA : bA(tA) && !bA(VA) ? "no-referrer" : rA;
          }
          case "strict-origin":
          case "no-referrer-when-downgrade":
          default:
            return TA ? "no-referrer" : rA;
        }
      }
      e3(fA, "determineRequestsReferrer");
      function kA(v4, X5) {
        return I5(v4 instanceof URL), v4 = new URL(v4), v4.protocol === "file:" || v4.protocol === "about:" || v4.protocol === "blank:" ? "no-referrer" : (v4.username = "", v4.password = "", v4.hash = "", X5 && (v4.pathname = "", v4.search = ""), v4);
      }
      e3(kA, "stripURLForReferrer");
      function bA(v4) {
        if (!(v4 instanceof URL)) return false;
        if (v4.href === "about:blank" || v4.href === "about:srcdoc" || v4.protocol === "data:" || v4.protocol === "file:") return true;
        return X5(v4.origin);
        function X5(j3) {
          if (j3 == null || j3 === "null") return false;
          const tA = new URL(j3);
          return !!(tA.protocol === "https:" || tA.protocol === "wss:" || /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(tA.hostname) || tA.hostname === "localhost" || tA.hostname.includes("localhost.") || tA.hostname.endsWith(".localhost"));
        }
      }
      e3(bA, "isURLPotentiallyTrustworthy");
      function gA(v4, X5) {
        if (J5 === void 0) return true;
        const j3 = oA(X5);
        if (j3 === "no metadata" || j3.length === 0) return true;
        const tA = aA(j3), rA = EA(j3, tA);
        for (const FA of rA) {
          const TA = FA.algo, VA = FA.hash;
          let YA = J5.createHash(TA).update(v4).digest("base64");
          if (YA[YA.length - 1] === "=" && (YA[YA.length - 2] === "=" ? YA = YA.slice(0, -2) : YA = YA.slice(0, -1)), sA(YA, VA)) return true;
        }
        return false;
      }
      e3(gA, "bytesMatch");
      const DA = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
      function oA(v4) {
        const X5 = [];
        let j3 = true;
        for (const tA of v4.split(" ")) {
          j3 = false;
          const rA = DA.exec(tA);
          if (rA === null || rA.groups === void 0 || rA.groups.algo === void 0) continue;
          const FA = rA.groups.algo.toLowerCase();
          G3.includes(FA) && X5.push(rA.groups);
        }
        return j3 === true ? "no metadata" : X5;
      }
      e3(oA, "parseMetadata");
      function aA(v4) {
        let X5 = v4[0].algo;
        if (X5[3] === "5") return X5;
        for (let j3 = 1; j3 < v4.length; ++j3) {
          const tA = v4[j3];
          if (tA.algo[3] === "5") {
            X5 = "sha512";
            break;
          } else {
            if (X5[3] === "3") continue;
            tA.algo[3] === "3" && (X5 = "sha384");
          }
        }
        return X5;
      }
      e3(aA, "getStrongestMetadata");
      function EA(v4, X5) {
        if (v4.length === 1) return v4;
        let j3 = 0;
        for (let tA = 0; tA < v4.length; ++tA) v4[tA].algo === X5 && (v4[j3++] = v4[tA]);
        return v4.length = j3, v4;
      }
      e3(EA, "filterMetadataListByAlgorithm");
      function sA(v4, X5) {
        if (v4.length !== X5.length) return false;
        for (let j3 = 0; j3 < v4.length; ++j3) if (v4[j3] !== X5[j3]) {
          if (v4[j3] === "+" && X5[j3] === "-" || v4[j3] === "/" && X5[j3] === "_") continue;
          return false;
        }
        return true;
      }
      e3(sA, "compareBase64Mixed");
      function NA(v4) {
      }
      e3(NA, "tryUpgradeRequestToAPotentiallyTrustworthyURL");
      function wA(v4, X5) {
        return v4.origin === X5.origin && v4.origin === "null" || v4.protocol === X5.protocol && v4.hostname === X5.hostname && v4.port === X5.port;
      }
      e3(wA, "sameOrigin");
      function vA() {
        let v4, X5;
        return { promise: new Promise((tA, rA) => {
          v4 = tA, X5 = rA;
        }), resolve: v4, reject: X5 };
      }
      e3(vA, "createDeferredPromise");
      function dA(v4) {
        return v4.controller.state === "aborted";
      }
      e3(dA, "isAborted");
      function XA(v4) {
        return v4.controller.state === "aborted" || v4.controller.state === "terminated";
      }
      e3(XA, "isCancelled");
      function KA(v4) {
        return l3[v4.toLowerCase()] ?? v4;
      }
      e3(KA, "normalizeMethod");
      function OA(v4) {
        const X5 = JSON.stringify(v4);
        if (X5 === void 0) throw new TypeError("Value is not JSON serializable");
        return I5(typeof X5 == "string"), X5;
      }
      e3(OA, "serializeJavascriptValueToJSONString");
      const PA = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
      function ZA(v4, X5, j3 = 0, tA = 1) {
        var FA, TA, VA;
        const YA = class YA {
          constructor(Qe2, qA) {
            SA(this, FA);
            SA(this, TA);
            SA(this, VA);
            mA(this, FA, Qe2), mA(this, TA, qA), mA(this, VA, 0);
          }
          next() {
            if (typeof this != "object" || this === null || !Ge(FA, this)) throw new TypeError(`'next' called on an object that does not implement interface ${v4} Iterator.`);
            const Qe2 = Z4(this, VA), qA = Z4(this, FA)[X5], ae3 = qA.length;
            if (Qe2 >= ae3) return { value: void 0, done: true };
            const { [j3]: ce2, [tA]: re3 } = qA[Qe2];
            mA(this, VA, Qe2 + 1);
            let Be2;
            switch (Z4(this, TA)) {
              case "key":
                Be2 = ce2;
                break;
              case "value":
                Be2 = re3;
                break;
              case "key+value":
                Be2 = [ce2, re3];
                break;
            }
            return { value: Be2, done: false };
          }
        };
        FA = /* @__PURE__ */ new WeakMap(), TA = /* @__PURE__ */ new WeakMap(), VA = /* @__PURE__ */ new WeakMap(), e3(YA, "FastIterableIterator");
        let rA = YA;
        return delete rA.prototype.constructor, Object.setPrototypeOf(rA.prototype, PA), Object.defineProperties(rA.prototype, { [Symbol.toStringTag]: { writable: false, enumerable: false, configurable: true, value: `${v4} Iterator` }, next: { writable: true, enumerable: true, configurable: true } }), function(_A, Qe2) {
          return new rA(_A, Qe2);
        };
      }
      e3(ZA, "createIterator");
      function HA(v4, X5, j3, tA = 0, rA = 1) {
        const FA = ZA(v4, j3, tA, rA), TA = { keys: { writable: true, enumerable: true, configurable: true, value: e3(function() {
          return b6.brandCheck(this, X5), FA(this, "key");
        }, "keys") }, values: { writable: true, enumerable: true, configurable: true, value: e3(function() {
          return b6.brandCheck(this, X5), FA(this, "value");
        }, "values") }, entries: { writable: true, enumerable: true, configurable: true, value: e3(function() {
          return b6.brandCheck(this, X5), FA(this, "key+value");
        }, "entries") }, forEach: { writable: true, enumerable: true, configurable: true, value: e3(function(YA, _A = globalThis) {
          if (b6.brandCheck(this, X5), b6.argumentLengthCheck(arguments, 1, `${v4}.forEach`), typeof YA != "function") throw new TypeError(`Failed to execute 'forEach' on '${v4}': parameter 1 is not of type 'Function'.`);
          for (const { 0: Qe2, 1: qA } of FA(this, "key+value")) YA.call(_A, qA, Qe2, this);
        }, "forEach") } };
        return Object.defineProperties(X5.prototype, { ...TA, [Symbol.iterator]: { writable: true, enumerable: false, configurable: true, value: TA.entries.value } });
      }
      e3(HA, "iteratorMixin");
      async function se2(v4, X5, j3) {
        const tA = X5, rA = j3;
        let FA;
        try {
          FA = v4.stream.getReader();
        } catch (TA) {
          rA(TA);
          return;
        }
        try {
          tA(await W6(FA));
        } catch (TA) {
          rA(TA);
        }
      }
      e3(se2, "fullyReadBody");
      function ne3(v4) {
        return v4 instanceof ReadableStream || v4[Symbol.toStringTag] === "ReadableStream" && typeof v4.tee == "function";
      }
      e3(ne3, "isReadableStreamLike");
      function jA(v4) {
        try {
          v4.close(), v4.byobRequest?.respond(0);
        } catch (X5) {
          if (!X5.message.includes("Controller is already closed") && !X5.message.includes("ReadableStream is already closed")) throw X5;
        }
      }
      e3(jA, "readableStreamClose");
      const Ae = /[^\x00-\xFF]/;
      function QA(v4) {
        return I5(!Ae.test(v4)), v4;
      }
      e3(QA, "isomorphicEncode");
      async function W6(v4) {
        const X5 = [];
        let j3 = 0;
        for (; ; ) {
          const { done: tA, value: rA } = await v4.read();
          if (tA) return Buffer.concat(X5, j3);
          if (!p3(rA)) throw new TypeError("Received non-Uint8Array chunk");
          X5.push(rA), j3 += rA.length;
        }
      }
      e3(W6, "readAllBytes");
      function cA(v4) {
        I5("protocol" in v4);
        const X5 = v4.protocol;
        return X5 === "about:" || X5 === "blob:" || X5 === "data:";
      }
      e3(cA, "urlIsLocal");
      function yA(v4) {
        return typeof v4 == "string" && v4[5] === ":" && v4[0] === "h" && v4[1] === "t" && v4[2] === "t" && v4[3] === "p" && v4[4] === "s" || v4.protocol === "https:";
      }
      e3(yA, "urlHasHttpsScheme");
      function LA(v4) {
        I5("protocol" in v4);
        const X5 = v4.protocol;
        return X5 === "http:" || X5 === "https:";
      }
      e3(LA, "urlIsHttpHttpsScheme");
      function JA(v4, X5) {
        const j3 = v4;
        if (!j3.startsWith("bytes")) return "failure";
        const tA = { position: 5 };
        if (X5 && R4((YA) => YA === "	" || YA === " ", j3, tA), j3.charCodeAt(tA.position) !== 61) return "failure";
        tA.position++, X5 && R4((YA) => YA === "	" || YA === " ", j3, tA);
        const rA = R4((YA) => {
          const _A = YA.charCodeAt(0);
          return _A >= 48 && _A <= 57;
        }, j3, tA), FA = rA.length ? Number(rA) : null;
        if (X5 && R4((YA) => YA === "	" || YA === " ", j3, tA), j3.charCodeAt(tA.position) !== 45) return "failure";
        tA.position++, X5 && R4((YA) => YA === "	" || YA === " ", j3, tA);
        const TA = R4((YA) => {
          const _A = YA.charCodeAt(0);
          return _A >= 48 && _A <= 57;
        }, j3, tA), VA = TA.length ? Number(TA) : null;
        return tA.position < j3.length || VA === null && FA === null || FA > VA ? "failure" : { rangeStartValue: FA, rangeEndValue: VA };
      }
      e3(JA, "simpleRangeHeaderValue");
      function WA(v4, X5, j3) {
        let tA = "bytes ";
        return tA += QA(`${v4}`), tA += "-", tA += QA(`${X5}`), tA += "/", tA += QA(`${j3}`), tA;
      }
      e3(WA, "buildContentRange");
      const zA = class zA extends A2 {
        constructor(j3) {
          super();
          SA(this, xA);
          mA(this, xA, j3);
        }
        _transform(j3, tA, rA) {
          if (!this._inflateStream) {
            if (j3.length === 0) {
              rA();
              return;
            }
            this._inflateStream = (j3[0] & 15) === 8 ? k4.createInflate(Z4(this, xA)) : k4.createInflateRaw(Z4(this, xA)), this._inflateStream.on("data", this.push.bind(this)), this._inflateStream.on("end", () => this.push(null)), this._inflateStream.on("error", (FA) => this.destroy(FA));
          }
          this._inflateStream.write(j3, tA, rA);
        }
        _final(j3) {
          this._inflateStream && (this._inflateStream.end(), this._inflateStream = null), j3();
        }
      };
      xA = /* @__PURE__ */ new WeakMap(), e3(zA, "InflateStream");
      let te3 = zA;
      function ie3(v4) {
        return new te3(v4);
      }
      e3(ie3, "createInflate");
      function oe3(v4) {
        let X5 = null, j3 = null, tA = null;
        const rA = GA("content-type", v4);
        if (rA === null) return "failure";
        for (const FA of rA) {
          const TA = D3(FA);
          TA === "failure" || TA.essence === "*/*" || (tA = TA, tA.essence !== j3 ? (X5 = null, tA.parameters.has("charset") && (X5 = tA.parameters.get("charset")), j3 = tA.essence) : !tA.parameters.has("charset") && X5 !== null && tA.parameters.set("charset", X5));
        }
        return tA ?? "failure";
      }
      e3(oe3, "extractMimeType");
      function Ie2(v4) {
        const X5 = v4, j3 = { position: 0 }, tA = [];
        let rA = "";
        for (; j3.position < X5.length; ) {
          if (rA += R4((FA) => FA !== '"' && FA !== ",", X5, j3), j3.position < X5.length) if (X5.charCodeAt(j3.position) === 34) {
            if (rA += F2(X5, j3), j3.position < X5.length) continue;
          } else I5(X5.charCodeAt(j3.position) === 44), j3.position++;
          rA = Q5(rA, true, true, (FA) => FA === 9 || FA === 32), tA.push(rA), rA = "";
        }
        return tA;
      }
      e3(Ie2, "gettingDecodingSplitting");
      function GA(v4, X5) {
        const j3 = X5.get(v4, true);
        return j3 === null ? null : Ie2(j3);
      }
      e3(GA, "getDecodeSplit");
      const eA = new TextDecoder();
      function lA(v4) {
        return v4.length === 0 ? "" : (v4[0] === 239 && v4[1] === 187 && v4[2] === 191 && (v4 = v4.subarray(3)), eA.decode(v4));
      }
      e3(lA, "utf8DecodeBytes");
      const UA = class UA {
        constructor() {
          $A(this, "policyContainer", CA());
        }
        get baseUrl() {
          return y3();
        }
        get origin() {
          return this.baseUrl?.origin;
        }
      };
      e3(UA, "EnvironmentSettingsObjectBase");
      let BA = UA;
      const AA = class AA {
        constructor() {
          $A(this, "settingsObject", new BA());
        }
      };
      e3(AA, "EnvironmentSettingsObject");
      let hA = AA;
      const MA = new hA();
      return util$6 = { isAborted: dA, isCancelled: XA, isValidEncodedURL: q6, createDeferredPromise: vA, ReadableStreamFrom: o, tryUpgradeRequestToAPotentiallyTrustworthyURL: NA, clampAndCoarsenConnectionTimingInfo: uA, coarsenedSharedCurrentTime: RA, determineRequestsReferrer: fA, makePolicyContainer: CA, clonePolicyContainer: pA, appendFetchMetadata: K4, appendRequestOriginHeader: nA, TAOCheck: $6, corsCheck: z4, crossOriginResourcePolicyCheck: x5, createOpaqueTimingInfo: IA, setRequestReferrerPolicyOnRedirect: S6, isValidHTTPToken: N6, requestBadPort: m4, requestCurrentURL: Y4, responseURL: V4, responseLocationURL: _5, isBlobLike: r6, isURLPotentiallyTrustworthy: bA, isValidReasonPhrase: n, sameOrigin: wA, normalizeMethod: KA, serializeJavascriptValueToJSONString: OA, iteratorMixin: HA, createIterator: ZA, isValidHeaderName: C5, isValidHeaderValue: w5, isErrorLike: f3, fullyReadBody: se2, bytesMatch: gA, isReadableStreamLike: ne3, readableStreamClose: jA, isomorphicEncode: QA, urlIsLocal: cA, urlHasHttpsScheme: yA, urlIsHttpHttpsScheme: LA, readAllBytes: W6, simpleRangeHeaderValue: JA, buildContentRange: WA, parseMetadata: oA, createInflate: ie3, extractMimeType: oe3, getDecodeSplit: GA, utf8DecodeBytes: lA, environmentSettingsObject: MA }, util$6;
    }
    e3(requireUtil$6, "requireUtil$6");
    var symbols$3;
    var hasRequiredSymbols$3;
    function requireSymbols$3() {
      return hasRequiredSymbols$3 || (hasRequiredSymbols$3 = 1, symbols$3 = { kUrl: Symbol("url"), kHeaders: Symbol("headers"), kSignal: Symbol("signal"), kState: Symbol("state"), kDispatcher: Symbol("dispatcher") }), symbols$3;
    }
    e3(requireSymbols$3, "requireSymbols$3");
    var file;
    var hasRequiredFile;
    function requireFile() {
      if (hasRequiredFile) return file;
      hasRequiredFile = 1;
      const { Blob: A2, File: k4 } = require$$0__default, { kState: c2 } = requireSymbols$3(), { webidl: B3 } = requireWebidl(), R4 = class R5 {
        constructor(Q5, D3, U6 = {}) {
          const r6 = D3, o = U6.type, N6 = U6.lastModified ?? Date.now();
          this[c2] = { blobLike: Q5, name: r6, type: o, lastModified: N6 };
        }
        stream(...Q5) {
          return B3.brandCheck(this, R5), this[c2].blobLike.stream(...Q5);
        }
        arrayBuffer(...Q5) {
          return B3.brandCheck(this, R5), this[c2].blobLike.arrayBuffer(...Q5);
        }
        slice(...Q5) {
          return B3.brandCheck(this, R5), this[c2].blobLike.slice(...Q5);
        }
        text(...Q5) {
          return B3.brandCheck(this, R5), this[c2].blobLike.text(...Q5);
        }
        get size() {
          return B3.brandCheck(this, R5), this[c2].blobLike.size;
        }
        get type() {
          return B3.brandCheck(this, R5), this[c2].blobLike.type;
        }
        get name() {
          return B3.brandCheck(this, R5), this[c2].name;
        }
        get lastModified() {
          return B3.brandCheck(this, R5), this[c2].lastModified;
        }
        get [Symbol.toStringTag]() {
          return "File";
        }
      };
      e3(R4, "FileLike");
      let t2 = R4;
      B3.converters.Blob = B3.interfaceConverter(A2);
      function y3(F2) {
        return F2 instanceof k4 || F2 && (typeof F2.stream == "function" || typeof F2.arrayBuffer == "function") && F2[Symbol.toStringTag] === "File";
      }
      return e3(y3, "isFileLike"), file = { FileLike: t2, isFileLike: y3 }, file;
    }
    e3(requireFile, "requireFile");
    var formdata;
    var hasRequiredFormdata;
    function requireFormdata() {
      if (hasRequiredFormdata) return formdata;
      hasRequiredFormdata = 1;
      const { isBlobLike: A2, iteratorMixin: k4 } = requireUtil$6(), { kState: c2 } = requireSymbols$3(), { kEnumerableProperty: B3 } = requireUtil$7(), { FileLike: t2, isFileLike: y3 } = requireFile(), { webidl: R4 } = requireWebidl(), { File: F2 } = require$$0__default, Q5 = require$$0__default$3, D3 = globalThis.File ?? F2, o = class o2 {
        constructor(l3) {
          if (R4.util.markAsUncloneable(this), l3 !== void 0) throw R4.errors.conversionFailed({ prefix: "FormData constructor", argument: "Argument 1", types: ["undefined"] });
          this[c2] = [];
        }
        append(l3, I5, p3 = void 0) {
          R4.brandCheck(this, o2);
          const b6 = "FormData.append";
          if (R4.argumentLengthCheck(arguments, 2, b6), arguments.length === 3 && !A2(I5)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
          l3 = R4.converters.USVString(l3, b6, "name"), I5 = A2(I5) ? R4.converters.Blob(I5, b6, "value", { strict: false }) : R4.converters.USVString(I5, b6, "value"), p3 = arguments.length === 3 ? R4.converters.USVString(p3, b6, "filename") : void 0;
          const G3 = r6(l3, I5, p3);
          this[c2].push(G3);
        }
        delete(l3) {
          R4.brandCheck(this, o2);
          const I5 = "FormData.delete";
          R4.argumentLengthCheck(arguments, 1, I5), l3 = R4.converters.USVString(l3, I5, "name"), this[c2] = this[c2].filter((p3) => p3.name !== l3);
        }
        get(l3) {
          R4.brandCheck(this, o2);
          const I5 = "FormData.get";
          R4.argumentLengthCheck(arguments, 1, I5), l3 = R4.converters.USVString(l3, I5, "name");
          const p3 = this[c2].findIndex((b6) => b6.name === l3);
          return p3 === -1 ? null : this[c2][p3].value;
        }
        getAll(l3) {
          R4.brandCheck(this, o2);
          const I5 = "FormData.getAll";
          return R4.argumentLengthCheck(arguments, 1, I5), l3 = R4.converters.USVString(l3, I5, "name"), this[c2].filter((p3) => p3.name === l3).map((p3) => p3.value);
        }
        has(l3) {
          R4.brandCheck(this, o2);
          const I5 = "FormData.has";
          return R4.argumentLengthCheck(arguments, 1, I5), l3 = R4.converters.USVString(l3, I5, "name"), this[c2].findIndex((p3) => p3.name === l3) !== -1;
        }
        set(l3, I5, p3 = void 0) {
          R4.brandCheck(this, o2);
          const b6 = "FormData.set";
          if (R4.argumentLengthCheck(arguments, 2, b6), arguments.length === 3 && !A2(I5)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
          l3 = R4.converters.USVString(l3, b6, "name"), I5 = A2(I5) ? R4.converters.Blob(I5, b6, "name", { strict: false }) : R4.converters.USVString(I5, b6, "name"), p3 = arguments.length === 3 ? R4.converters.USVString(p3, b6, "name") : void 0;
          const G3 = r6(l3, I5, p3), J5 = this[c2].findIndex((V4) => V4.name === l3);
          J5 !== -1 ? this[c2] = [...this[c2].slice(0, J5), G3, ...this[c2].slice(J5 + 1).filter((V4) => V4.name !== l3)] : this[c2].push(G3);
        }
        [Q5.inspect.custom](l3, I5) {
          const p3 = this[c2].reduce((G3, J5) => (G3[J5.name] ? Array.isArray(G3[J5.name]) ? G3[J5.name].push(J5.value) : G3[J5.name] = [G3[J5.name], J5.value] : G3[J5.name] = J5.value, G3), { __proto__: null });
          I5.depth ?? (I5.depth = l3), I5.colors ?? (I5.colors = true);
          const b6 = Q5.formatWithOptions(I5, p3);
          return `FormData ${b6.slice(b6.indexOf("]") + 2)}`;
        }
      };
      e3(o, "FormData");
      let U6 = o;
      k4("FormData", U6, c2, "name", "value"), Object.defineProperties(U6.prototype, { append: B3, delete: B3, get: B3, getAll: B3, has: B3, set: B3, [Symbol.toStringTag]: { value: "FormData", configurable: true } });
      function r6(N6, l3, I5) {
        if (typeof l3 != "string") {
          if (y3(l3) || (l3 = l3 instanceof Blob ? new D3([l3], "blob", { type: l3.type }) : new t2(l3, "blob", { type: l3.type })), I5 !== void 0) {
            const p3 = { type: l3.type, lastModified: l3.lastModified };
            l3 = l3 instanceof F2 ? new D3([l3], I5, p3) : new t2(l3, I5, p3);
          }
        }
        return { name: N6, value: l3 };
      }
      return e3(r6, "makeEntry"), formdata = { FormData: U6, makeEntry: r6 }, formdata;
    }
    e3(requireFormdata, "requireFormdata");
    var formdataParser;
    var hasRequiredFormdataParser;
    function requireFormdataParser() {
      if (hasRequiredFormdataParser) return formdataParser;
      hasRequiredFormdataParser = 1;
      const { isUSVString: A2, bufferToLowerCasedHeaderName: k4 } = requireUtil$7(), { utf8DecodeBytes: c2 } = requireUtil$6(), { HTTP_TOKEN_CODEPOINTS: B3, isomorphicDecode: t2 } = requireDataUrl(), { isFileLike: y3 } = requireFile(), { makeEntry: R4 } = requireFormdata(), F2 = require$$0__default$1, { File: Q5 } = require$$0__default, D3 = globalThis.File ?? Q5, U6 = Buffer.from('form-data; name="'), r6 = Buffer.from("; filename"), o = Buffer.from("--"), N6 = Buffer.from(`--\r
`);
      function l3(q6) {
        for (let M4 = 0; M4 < q6.length; ++M4) if ((q6.charCodeAt(M4) & -128) !== 0) return false;
        return true;
      }
      e3(l3, "isAsciiString");
      function I5(q6) {
        const M4 = q6.length;
        if (M4 < 27 || M4 > 70) return false;
        for (let Y4 = 0; Y4 < M4; ++Y4) {
          const m4 = q6.charCodeAt(Y4);
          if (!(m4 >= 48 && m4 <= 57 || m4 >= 65 && m4 <= 90 || m4 >= 97 && m4 <= 122 || m4 === 39 || m4 === 45 || m4 === 95)) return false;
        }
        return true;
      }
      e3(I5, "validateBoundary");
      function p3(q6, M4) {
        F2(M4 !== "failure" && M4.essence === "multipart/form-data");
        const Y4 = M4.parameters.get("boundary");
        if (Y4 === void 0) return "failure";
        const m4 = Buffer.from(`--${Y4}`, "utf8"), f3 = [], n = { position: 0 };
        for (; q6[n.position] === 13 && q6[n.position + 1] === 10; ) n.position += 2;
        let C5 = q6.length;
        for (; q6[C5 - 1] === 10 && q6[C5 - 2] === 13; ) C5 -= 2;
        for (C5 !== q6.length && (q6 = q6.subarray(0, C5)); ; ) {
          if (q6.subarray(n.position, n.position + m4.length).equals(m4)) n.position += m4.length;
          else return "failure";
          if (n.position === q6.length - 2 && _5(q6, o, n) || n.position === q6.length - 4 && _5(q6, N6, n)) return f3;
          if (q6[n.position] !== 13 || q6[n.position + 1] !== 10) return "failure";
          n.position += 2;
          const w5 = b6(q6, n);
          if (w5 === "failure") return "failure";
          let { name: S6, filename: x5, contentType: z4, encoding: $6 } = w5;
          n.position += 2;
          let K4;
          {
            const iA = q6.indexOf(m4.subarray(2), n.position);
            if (iA === -1) return "failure";
            K4 = q6.subarray(n.position, iA - 4), n.position += K4.length, $6 === "base64" && (K4 = Buffer.from(K4.toString(), "base64"));
          }
          if (q6[n.position] !== 13 || q6[n.position + 1] !== 10) return "failure";
          n.position += 2;
          let nA;
          x5 !== null ? (z4 ?? (z4 = "text/plain"), l3(z4) || (z4 = ""), nA = new D3([K4], x5, { type: z4 })) : nA = c2(Buffer.from(K4)), F2(A2(S6)), F2(typeof nA == "string" && A2(nA) || y3(nA)), f3.push(R4(S6, nA, x5));
        }
      }
      e3(p3, "multipartFormDataParser");
      function b6(q6, M4) {
        let Y4 = null, m4 = null, f3 = null, n = null;
        for (; ; ) {
          if (q6[M4.position] === 13 && q6[M4.position + 1] === 10) return Y4 === null ? "failure" : { name: Y4, filename: m4, contentType: f3, encoding: n };
          let C5 = J5((w5) => w5 !== 10 && w5 !== 13 && w5 !== 58, q6, M4);
          if (C5 = V4(C5, true, true, (w5) => w5 === 9 || w5 === 32), !B3.test(C5.toString()) || q6[M4.position] !== 58) return "failure";
          switch (M4.position++, J5((w5) => w5 === 32 || w5 === 9, q6, M4), k4(C5)) {
            case "content-disposition": {
              if (Y4 = m4 = null, !_5(q6, U6, M4) || (M4.position += 17, Y4 = G3(q6, M4), Y4 === null)) return "failure";
              if (_5(q6, r6, M4)) {
                let w5 = M4.position + r6.length;
                if (q6[w5] === 42 && (M4.position += 1, w5 += 1), q6[w5] !== 61 || q6[w5 + 1] !== 34 || (M4.position += 12, m4 = G3(q6, M4), m4 === null)) return "failure";
              }
              break;
            }
            case "content-type": {
              let w5 = J5((S6) => S6 !== 10 && S6 !== 13, q6, M4);
              w5 = V4(w5, false, true, (S6) => S6 === 9 || S6 === 32), f3 = t2(w5);
              break;
            }
            case "content-transfer-encoding": {
              let w5 = J5((S6) => S6 !== 10 && S6 !== 13, q6, M4);
              w5 = V4(w5, false, true, (S6) => S6 === 9 || S6 === 32), n = t2(w5);
              break;
            }
            default:
              J5((w5) => w5 !== 10 && w5 !== 13, q6, M4);
          }
          if (q6[M4.position] !== 13 && q6[M4.position + 1] !== 10) return "failure";
          M4.position += 2;
        }
      }
      e3(b6, "parseMultipartFormDataHeaders");
      function G3(q6, M4) {
        F2(q6[M4.position - 1] === 34);
        let Y4 = J5((m4) => m4 !== 10 && m4 !== 13 && m4 !== 34, q6, M4);
        return q6[M4.position] !== 34 ? null : (M4.position++, Y4 = new TextDecoder().decode(Y4).replace(/%0A/ig, `
`).replace(/%0D/ig, "\r").replace(/%22/g, '"'), Y4);
      }
      e3(G3, "parseMultipartFormDataName");
      function J5(q6, M4, Y4) {
        let m4 = Y4.position;
        for (; m4 < M4.length && q6(M4[m4]); ) ++m4;
        return M4.subarray(Y4.position, Y4.position = m4);
      }
      e3(J5, "collectASequenceOfBytes");
      function V4(q6, M4, Y4, m4) {
        let f3 = 0, n = q6.length - 1;
        if (M4) for (; f3 < q6.length && m4(q6[f3]); ) f3++;
        for (; n > 0 && m4(q6[n]); ) n--;
        return f3 === 0 && n === q6.length - 1 ? q6 : q6.subarray(f3, n + 1);
      }
      e3(V4, "removeChars");
      function _5(q6, M4, Y4) {
        if (q6.length < M4.length) return false;
        for (let m4 = 0; m4 < M4.length; m4++) if (M4[m4] !== q6[Y4.position + m4]) return false;
        return true;
      }
      return e3(_5, "bufferStartsWith"), formdataParser = { multipartFormDataParser: p3, validateBoundary: I5 }, formdataParser;
    }
    e3(requireFormdataParser, "requireFormdataParser");
    var body;
    var hasRequiredBody;
    function requireBody() {
      if (hasRequiredBody) return body;
      hasRequiredBody = 1;
      const A2 = requireUtil$7(), { ReadableStreamFrom: k4, isBlobLike: c2, isReadableStreamLike: B3, readableStreamClose: t2, createDeferredPromise: y3, fullyReadBody: R4, extractMimeType: F2, utf8DecodeBytes: Q5 } = requireUtil$6(), { FormData: D3 } = requireFormdata(), { kState: U6 } = requireSymbols$3(), { webidl: r6 } = requireWebidl(), { Blob: o } = require$$0__default, N6 = require$$0__default$1, { isErrored: l3, isDisturbed: I5 } = Stream__default, { isArrayBuffer: p3 } = require$$8__default$1, { serializeAMimeType: b6 } = requireDataUrl(), { multipartFormDataParser: G3 } = requireFormdataParser();
      let J5;
      try {
        const K4 = require("crypto");
        J5 = e3((nA) => K4.randomInt(0, nA), "random");
      } catch {
        J5 = e3((K4) => Math.floor(Math.random(K4)), "random");
      }
      const V4 = new TextEncoder();
      function _5() {
      }
      e3(_5, "noop");
      const q6 = globalThis.FinalizationRegistry && process.version.indexOf("v18") !== 0;
      let M4;
      q6 && (M4 = new FinalizationRegistry((K4) => {
        const nA = K4.deref();
        nA && !nA.locked && !I5(nA) && !l3(nA) && nA.cancel("Response object has been garbage collected").catch(_5);
      }));
      function Y4(K4, nA = false) {
        let iA = null;
        K4 instanceof ReadableStream ? iA = K4 : c2(K4) ? iA = K4.stream() : iA = new ReadableStream({ async pull(fA) {
          const kA = typeof RA == "string" ? V4.encode(RA) : RA;
          kA.byteLength && fA.enqueue(kA), queueMicrotask(() => t2(fA));
        }, start() {
        }, type: "bytes" }), N6(B3(iA));
        let uA = null, RA = null, IA = null, CA = null;
        if (typeof K4 == "string") RA = K4, CA = "text/plain;charset=UTF-8";
        else if (K4 instanceof URLSearchParams) RA = K4.toString(), CA = "application/x-www-form-urlencoded;charset=UTF-8";
        else if (p3(K4)) RA = new Uint8Array(K4.slice());
        else if (ArrayBuffer.isView(K4)) RA = new Uint8Array(K4.buffer.slice(K4.byteOffset, K4.byteOffset + K4.byteLength));
        else if (A2.isFormDataLike(K4)) {
          const fA = `----formdata-undici-0${`${J5(1e11)}`.padStart(11, "0")}`, kA = `--${fA}\r
Content-Disposition: form-data`;
          const bA = e3((sA) => sA.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), "escape"), gA = e3((sA) => sA.replace(/\r?\n|\r/g, `\r
`), "normalizeLinefeeds"), DA = [], oA = new Uint8Array([13, 10]);
          IA = 0;
          let aA = false;
          for (const [sA, NA] of K4) if (typeof NA == "string") {
            const wA = V4.encode(kA + `; name="${bA(gA(sA))}"\r
\r
${gA(NA)}\r
`);
            DA.push(wA), IA += wA.byteLength;
          } else {
            const wA = V4.encode(`${kA}; name="${bA(gA(sA))}"` + (NA.name ? `; filename="${bA(NA.name)}"` : "") + `\r
Content-Type: ${NA.type || "application/octet-stream"}\r
\r
`);
            DA.push(wA, NA, oA), typeof NA.size == "number" ? IA += wA.byteLength + NA.size + oA.byteLength : aA = true;
          }
          const EA = V4.encode(`--${fA}--\r
`);
          DA.push(EA), IA += EA.byteLength, aA && (IA = null), RA = K4, uA = e3(async function* () {
            for (const sA of DA) sA.stream ? yield* sA.stream() : yield sA;
          }, "action"), CA = `multipart/form-data; boundary=${fA}`;
        } else if (c2(K4)) RA = K4, IA = K4.size, K4.type && (CA = K4.type);
        else if (typeof K4[Symbol.asyncIterator] == "function") {
          if (nA) throw new TypeError("keepalive");
          if (A2.isDisturbed(K4) || K4.locked) throw new TypeError("Response body object should not be disturbed or locked");
          iA = K4 instanceof ReadableStream ? K4 : k4(K4);
        }
        if ((typeof RA == "string" || A2.isBuffer(RA)) && (IA = Buffer.byteLength(RA)), uA != null) {
          let fA;
          iA = new ReadableStream({ async start() {
            fA = uA(K4)[Symbol.asyncIterator]();
          }, async pull(kA) {
            const { value: bA, done: gA } = await fA.next();
            if (gA) queueMicrotask(() => {
              kA.close(), kA.byobRequest?.respond(0);
            });
            else if (!l3(iA)) {
              const DA = new Uint8Array(bA);
              DA.byteLength && kA.enqueue(DA);
            }
            return kA.desiredSize > 0;
          }, async cancel(kA) {
            await fA.return();
          }, type: "bytes" });
        }
        return [{ stream: iA, source: RA, length: IA }, CA];
      }
      e3(Y4, "extractBody");
      function m4(K4, nA = false) {
        return K4 instanceof ReadableStream && (N6(!A2.isDisturbed(K4), "The body has already been consumed."), N6(!K4.locked, "The stream is locked.")), Y4(K4, nA);
      }
      e3(m4, "safelyExtractBody");
      function f3(K4, nA) {
        const [iA, uA] = nA.stream.tee();
        return q6 && M4.register(K4, new WeakRef(iA)), nA.stream = iA, { stream: uA, length: nA.length, source: nA.source };
      }
      e3(f3, "cloneBody");
      function n(K4) {
        if (K4.aborted) throw new DOMException("The operation was aborted.", "AbortError");
      }
      e3(n, "throwIfAborted");
      function C5(K4) {
        return { blob() {
          return S6(this, (iA) => {
            let uA = $6(this);
            return uA === null ? uA = "" : uA && (uA = b6(uA)), new o([iA], { type: uA });
          }, K4);
        }, arrayBuffer() {
          return S6(this, (iA) => new Uint8Array(iA).buffer, K4);
        }, text() {
          return S6(this, Q5, K4);
        }, json() {
          return S6(this, z4, K4);
        }, formData() {
          return S6(this, (iA) => {
            const uA = $6(this);
            if (uA !== null) switch (uA.essence) {
              case "multipart/form-data": {
                const RA = G3(iA, uA);
                if (RA === "failure") throw new TypeError("Failed to parse body as FormData.");
                const IA = new D3();
                return IA[U6] = RA, IA;
              }
              case "application/x-www-form-urlencoded": {
                const RA = new URLSearchParams(iA.toString()), IA = new D3();
                for (const [CA, pA] of RA) IA.append(CA, pA);
                return IA;
              }
            }
            throw new TypeError('Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".');
          }, K4);
        }, bytes() {
          return S6(this, (iA) => new Uint8Array(iA), K4);
        } };
      }
      e3(C5, "bodyMixinMethods");
      function w5(K4) {
        Object.assign(K4.prototype, C5(K4));
      }
      e3(w5, "mixinBody");
      async function S6(K4, nA, iA) {
        if (r6.brandCheck(K4, iA), x5(K4)) throw new TypeError("Body is unusable: Body has already been read");
        n(K4[U6]);
        const uA = y3(), RA = e3((CA) => uA.reject(CA), "errorSteps"), IA = e3((CA) => {
          try {
            uA.resolve(nA(CA));
          } catch (pA) {
            RA(pA);
          }
        }, "successSteps");
        return K4[U6].body == null ? (IA(Buffer.allocUnsafe(0)), uA.promise) : (await R4(K4[U6].body, IA, RA), uA.promise);
      }
      e3(S6, "consumeBody");
      function x5(K4) {
        const nA = K4[U6].body;
        return nA != null && (nA.stream.locked || A2.isDisturbed(nA.stream));
      }
      e3(x5, "bodyUnusable");
      function z4(K4) {
        return JSON.parse(Q5(K4));
      }
      e3(z4, "parseJSONFromBytes");
      function $6(K4) {
        const nA = K4[U6].headersList, iA = F2(nA);
        return iA === "failure" ? null : iA;
      }
      return e3($6, "bodyMimeType"), body = { extractBody: Y4, safelyExtractBody: m4, cloneBody: f3, mixinBody: w5, streamRegistry: M4, hasFinalizationRegistry: q6, bodyUnusable: x5 }, body;
    }
    e3(requireBody, "requireBody");
    var clientH1;
    var hasRequiredClientH1;
    function requireClientH1() {
      if (hasRequiredClientH1) return clientH1;
      hasRequiredClientH1 = 1;
      const A2 = require$$0__default$1, k4 = requireUtil$7(), { channels: c2 } = requireDiagnostics(), B3 = requireTimers(), { RequestContentLengthMismatchError: t2, ResponseContentLengthMismatchError: y3, RequestAbortedError: R4, HeadersTimeoutError: F2, HeadersOverflowError: Q5, SocketError: D3, InformationalError: U6, BodyTimeoutError: r6, HTTPParserError: o, ResponseExceededMaxSizeError: N6 } = requireErrors(), { kUrl: l3, kReset: I5, kClient: p3, kParser: b6, kBlocking: G3, kRunning: J5, kPending: V4, kSize: _5, kWriting: q6, kQueue: M4, kNoRef: Y4, kKeepAliveDefaultTimeout: m4, kHostHeader: f3, kPendingIdx: n, kRunningIdx: C5, kError: w5, kPipelining: S6, kSocket: x5, kKeepAliveTimeoutValue: z4, kMaxHeadersSize: $6, kKeepAliveMaxTimeout: K4, kKeepAliveTimeoutThreshold: nA, kHeadersTimeout: iA, kBodyTimeout: uA, kStrictContentLength: RA, kMaxRequests: IA, kCounter: CA, kMaxResponseSize: pA, kOnError: fA, kResume: kA, kHTTPContext: bA } = requireSymbols$4(), gA = requireConstants$3(), DA = Buffer.alloc(0), oA = Buffer[Symbol.species], aA = k4.addListener, EA = k4.removeAllListeners;
      let sA;
      async function NA() {
        const GA = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : void 0;
        let eA;
        try {
          eA = await WebAssembly.compile(requireLlhttp_simdWasm());
        } catch {
          eA = await WebAssembly.compile(GA || requireLlhttpWasm());
        }
        return await WebAssembly.instantiate(eA, { env: { wasm_on_url: e3((lA, BA, hA) => 0, "wasm_on_url"), wasm_on_status: e3((lA, BA, hA) => {
          A2(dA.ptr === lA);
          const MA = BA - OA + XA.byteOffset;
          return dA.onStatus(new oA(XA.buffer, MA, hA)) || 0;
        }, "wasm_on_status"), wasm_on_message_begin: e3((lA) => (A2(dA.ptr === lA), dA.onMessageBegin() || 0), "wasm_on_message_begin"), wasm_on_header_field: e3((lA, BA, hA) => {
          A2(dA.ptr === lA);
          const MA = BA - OA + XA.byteOffset;
          return dA.onHeaderField(new oA(XA.buffer, MA, hA)) || 0;
        }, "wasm_on_header_field"), wasm_on_header_value: e3((lA, BA, hA) => {
          A2(dA.ptr === lA);
          const MA = BA - OA + XA.byteOffset;
          return dA.onHeaderValue(new oA(XA.buffer, MA, hA)) || 0;
        }, "wasm_on_header_value"), wasm_on_headers_complete: e3((lA, BA, hA, MA) => (A2(dA.ptr === lA), dA.onHeadersComplete(BA, !!hA, !!MA) || 0), "wasm_on_headers_complete"), wasm_on_body: e3((lA, BA, hA) => {
          A2(dA.ptr === lA);
          const MA = BA - OA + XA.byteOffset;
          return dA.onBody(new oA(XA.buffer, MA, hA)) || 0;
        }, "wasm_on_body"), wasm_on_message_complete: e3((lA) => (A2(dA.ptr === lA), dA.onMessageComplete() || 0), "wasm_on_message_complete") } });
      }
      e3(NA, "lazyllhttp");
      let wA = null, vA = NA();
      vA.catch();
      let dA = null, XA = null, KA = 0, OA = null;
      const PA = 0, ZA = 1, HA = 2 | ZA, se2 = 4 | ZA, ne3 = 8 | PA, oe3 = class oe {
        constructor(eA, lA, { exports: BA }) {
          A2(Number.isFinite(eA[$6]) && eA[$6] > 0), this.llhttp = BA, this.ptr = this.llhttp.llhttp_alloc(gA.TYPE.RESPONSE), this.client = eA, this.socket = lA, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = false, this.headers = [], this.headersSize = 0, this.headersMaxSize = eA[$6], this.shouldKeepAlive = false, this.paused = false, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = eA[pA];
        }
        setTimeout(eA, lA) {
          eA !== this.timeoutValue || lA & ZA ^ this.timeoutType & ZA ? (this.timeout && (B3.clearTimeout(this.timeout), this.timeout = null), eA && (lA & ZA ? this.timeout = B3.setFastTimeout(Ae, eA, new WeakRef(this)) : (this.timeout = setTimeout(Ae, eA, new WeakRef(this)), this.timeout.unref())), this.timeoutValue = eA) : this.timeout && this.timeout.refresh && this.timeout.refresh(), this.timeoutType = lA;
        }
        resume() {
          this.socket.destroyed || !this.paused || (A2(this.ptr != null), A2(dA == null), this.llhttp.llhttp_resume(this.ptr), A2(this.timeoutType === se2), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = false, this.execute(this.socket.read() || DA), this.readMore());
        }
        readMore() {
          for (; !this.paused && this.ptr; ) {
            const eA = this.socket.read();
            if (eA === null) break;
            this.execute(eA);
          }
        }
        execute(eA) {
          A2(this.ptr != null), A2(dA == null), A2(!this.paused);
          const { socket: lA, llhttp: BA } = this;
          eA.length > KA && (OA && BA.free(OA), KA = Math.ceil(eA.length / 4096) * 4096, OA = BA.malloc(KA)), new Uint8Array(BA.memory.buffer, OA, KA).set(eA);
          try {
            let hA;
            try {
              XA = eA, dA = this, hA = BA.llhttp_execute(this.ptr, OA, eA.length);
            } catch (xA) {
              throw xA;
            } finally {
              dA = null, XA = null;
            }
            const MA = BA.llhttp_get_error_pos(this.ptr) - OA;
            if (hA === gA.ERROR.PAUSED_UPGRADE) this.onUpgrade(eA.slice(MA));
            else if (hA === gA.ERROR.PAUSED) this.paused = true, lA.unshift(eA.slice(MA));
            else if (hA !== gA.ERROR.OK) {
              const xA = BA.llhttp_get_error_reason(this.ptr);
              let zA = "";
              if (xA) {
                const UA = new Uint8Array(BA.memory.buffer, xA).indexOf(0);
                zA = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(BA.memory.buffer, xA, UA).toString() + ")";
              }
              throw new o(zA, gA.ERROR[hA], eA.slice(MA));
            }
          } catch (hA) {
            k4.destroy(lA, hA);
          }
        }
        destroy() {
          A2(this.ptr != null), A2(dA == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, this.timeout && B3.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = false;
        }
        onStatus(eA) {
          this.statusText = eA.toString();
        }
        onMessageBegin() {
          const { socket: eA, client: lA } = this;
          if (eA.destroyed) return -1;
          const BA = lA[M4][lA[C5]];
          if (!BA) return -1;
          BA.onResponseStarted();
        }
        onHeaderField(eA) {
          const lA = this.headers.length;
          (lA & 1) === 0 ? this.headers.push(eA) : this.headers[lA - 1] = Buffer.concat([this.headers[lA - 1], eA]), this.trackHeader(eA.length);
        }
        onHeaderValue(eA) {
          let lA = this.headers.length;
          (lA & 1) === 1 ? (this.headers.push(eA), lA += 1) : this.headers[lA - 1] = Buffer.concat([this.headers[lA - 1], eA]);
          const BA = this.headers[lA - 2];
          if (BA.length === 10) {
            const hA = k4.bufferToLowerCasedHeaderName(BA);
            hA === "keep-alive" ? this.keepAlive += eA.toString() : hA === "connection" && (this.connection += eA.toString());
          } else BA.length === 14 && k4.bufferToLowerCasedHeaderName(BA) === "content-length" && (this.contentLength += eA.toString());
          this.trackHeader(eA.length);
        }
        trackHeader(eA) {
          this.headersSize += eA, this.headersSize >= this.headersMaxSize && k4.destroy(this.socket, new Q5());
        }
        onUpgrade(eA) {
          const { upgrade: lA, client: BA, socket: hA, headers: MA, statusCode: xA } = this;
          A2(lA), A2(BA[x5] === hA), A2(!hA.destroyed), A2(!this.paused), A2((MA.length & 1) === 0);
          const zA = BA[M4][BA[C5]];
          A2(zA), A2(zA.upgrade || zA.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, this.headers = [], this.headersSize = 0, hA.unshift(eA), hA[b6].destroy(), hA[b6] = null, hA[p3] = null, hA[w5] = null, EA(hA), BA[x5] = null, BA[bA] = null, BA[M4][BA[C5]++] = null, BA.emit("disconnect", BA[l3], [BA], new U6("upgrade"));
          try {
            zA.onUpgrade(xA, MA, hA);
          } catch (UA) {
            k4.destroy(hA, UA);
          }
          BA[kA]();
        }
        onHeadersComplete(eA, lA, BA) {
          const { client: hA, socket: MA, headers: xA, statusText: zA } = this;
          if (MA.destroyed) return -1;
          const UA = hA[M4][hA[C5]];
          if (!UA) return -1;
          if (A2(!this.upgrade), A2(this.statusCode < 200), eA === 100) return k4.destroy(MA, new D3("bad response", k4.getSocketInfo(MA))), -1;
          if (lA && !UA.upgrade) return k4.destroy(MA, new D3("bad upgrade", k4.getSocketInfo(MA))), -1;
          if (A2(this.timeoutType === HA), this.statusCode = eA, this.shouldKeepAlive = BA || UA.method === "HEAD" && !MA[I5] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
            const v4 = UA.bodyTimeout != null ? UA.bodyTimeout : hA[uA];
            this.setTimeout(v4, se2);
          } else this.timeout && this.timeout.refresh && this.timeout.refresh();
          if (UA.method === "CONNECT") return A2(hA[J5] === 1), this.upgrade = true, 2;
          if (lA) return A2(hA[J5] === 1), this.upgrade = true, 2;
          if (A2((this.headers.length & 1) === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && hA[S6]) {
            const v4 = this.keepAlive ? k4.parseKeepAliveTimeout(this.keepAlive) : null;
            if (v4 != null) {
              const X5 = Math.min(v4 - hA[nA], hA[K4]);
              X5 <= 0 ? MA[I5] = true : hA[z4] = X5;
            } else hA[z4] = hA[m4];
          } else MA[I5] = true;
          const AA = UA.onHeaders(eA, xA, this.resume, zA) === false;
          return UA.aborted ? -1 : UA.method === "HEAD" || eA < 200 ? 1 : (MA[G3] && (MA[G3] = false, hA[kA]()), AA ? gA.ERROR.PAUSED : 0);
        }
        onBody(eA) {
          const { client: lA, socket: BA, statusCode: hA, maxResponseSize: MA } = this;
          if (BA.destroyed) return -1;
          const xA = lA[M4][lA[C5]];
          if (A2(xA), A2(this.timeoutType === se2), this.timeout && this.timeout.refresh && this.timeout.refresh(), A2(hA >= 200), MA > -1 && this.bytesRead + eA.length > MA) return k4.destroy(BA, new N6()), -1;
          if (this.bytesRead += eA.length, xA.onData(eA) === false) return gA.ERROR.PAUSED;
        }
        onMessageComplete() {
          const { client: eA, socket: lA, statusCode: BA, upgrade: hA, headers: MA, contentLength: xA, bytesRead: zA, shouldKeepAlive: UA } = this;
          if (lA.destroyed && (!BA || UA)) return -1;
          if (hA) return;
          A2(BA >= 100), A2((this.headers.length & 1) === 0);
          const AA = eA[M4][eA[C5]];
          if (A2(AA), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", this.headers = [], this.headersSize = 0, !(BA < 200)) {
            if (AA.method !== "HEAD" && xA && zA !== parseInt(xA, 10)) return k4.destroy(lA, new y3()), -1;
            if (AA.onComplete(MA), eA[M4][eA[C5]++] = null, lA[q6]) return A2(eA[J5] === 0), k4.destroy(lA, new U6("reset")), gA.ERROR.PAUSED;
            if (UA) {
              if (lA[I5] && eA[J5] === 0) return k4.destroy(lA, new U6("reset")), gA.ERROR.PAUSED;
              eA[S6] == null || eA[S6] === 1 ? setImmediate(() => eA[kA]()) : eA[kA]();
            } else return k4.destroy(lA, new U6("reset")), gA.ERROR.PAUSED;
          }
        }
      };
      e3(oe3, "Parser");
      let jA = oe3;
      function Ae(GA) {
        const { socket: eA, timeoutType: lA, client: BA, paused: hA } = GA.deref();
        lA === HA ? (!eA[q6] || eA.writableNeedDrain || BA[J5] > 1) && (A2(!hA, "cannot be paused while waiting for headers"), k4.destroy(eA, new F2())) : lA === se2 ? hA || k4.destroy(eA, new r6()) : lA === ne3 && (A2(BA[J5] === 0 && BA[z4]), k4.destroy(eA, new U6("socket idle timeout")));
      }
      e3(Ae, "onParserTimeout");
      async function QA(GA, eA) {
        GA[x5] = eA, wA || (wA = await vA, vA = null), eA[Y4] = false, eA[q6] = false, eA[I5] = false, eA[G3] = false, eA[b6] = new jA(GA, eA, wA), aA(eA, "error", function(BA) {
          A2(BA.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
          const hA = this[b6];
          if (BA.code === "ECONNRESET" && hA.statusCode && !hA.shouldKeepAlive) {
            hA.onMessageComplete();
            return;
          }
          this[w5] = BA, this[p3][fA](BA);
        }), aA(eA, "readable", function() {
          const BA = this[b6];
          BA && BA.readMore();
        }), aA(eA, "end", function() {
          const BA = this[b6];
          if (BA.statusCode && !BA.shouldKeepAlive) {
            BA.onMessageComplete();
            return;
          }
          k4.destroy(this, new D3("other side closed", k4.getSocketInfo(this)));
        }), aA(eA, "close", function() {
          const BA = this[p3], hA = this[b6];
          hA && (!this[w5] && hA.statusCode && !hA.shouldKeepAlive && hA.onMessageComplete(), this[b6].destroy(), this[b6] = null);
          const MA = this[w5] || new D3("closed", k4.getSocketInfo(this));
          if (BA[x5] = null, BA[bA] = null, BA.destroyed) {
            A2(BA[V4] === 0);
            const xA = BA[M4].splice(BA[C5]);
            for (let zA = 0; zA < xA.length; zA++) {
              const UA = xA[zA];
              k4.errorRequest(BA, UA, MA);
            }
          } else if (BA[J5] > 0 && MA.code !== "UND_ERR_INFO") {
            const xA = BA[M4][BA[C5]];
            BA[M4][BA[C5]++] = null, k4.errorRequest(BA, xA, MA);
          }
          BA[n] = BA[C5], A2(BA[J5] === 0), BA.emit("disconnect", BA[l3], [BA], MA), BA[kA]();
        });
        let lA = false;
        return eA.on("close", () => {
          lA = true;
        }), { version: "h1", defaultPipelining: 1, write(...BA) {
          return yA(GA, ...BA);
        }, resume() {
          W6(GA);
        }, destroy(BA, hA) {
          lA ? queueMicrotask(hA) : eA.destroy(BA).on("close", hA);
        }, get destroyed() {
          return eA.destroyed;
        }, busy(BA) {
          return !!(eA[q6] || eA[I5] || eA[G3] || BA && (GA[J5] > 0 && !BA.idempotent || GA[J5] > 0 && (BA.upgrade || BA.method === "CONNECT") || GA[J5] > 0 && k4.bodyLength(BA.body) !== 0 && (k4.isStream(BA.body) || k4.isAsyncIterable(BA.body) || k4.isFormDataLike(BA.body))));
        } };
      }
      e3(QA, "connectH1");
      function W6(GA) {
        const eA = GA[x5];
        if (eA && !eA.destroyed) {
          if (GA[_5] === 0 ? !eA[Y4] && eA.unref && (eA.unref(), eA[Y4] = true) : eA[Y4] && eA.ref && (eA.ref(), eA[Y4] = false), GA[_5] === 0) eA[b6].timeoutType !== ne3 && eA[b6].setTimeout(GA[z4], ne3);
          else if (GA[J5] > 0 && eA[b6].statusCode < 200 && eA[b6].timeoutType !== HA) {
            const lA = GA[M4][GA[C5]], BA = lA.headersTimeout != null ? lA.headersTimeout : GA[iA];
            eA[b6].setTimeout(BA, HA);
          }
        }
      }
      e3(W6, "resumeH1");
      function cA(GA) {
        return GA !== "GET" && GA !== "HEAD" && GA !== "OPTIONS" && GA !== "TRACE" && GA !== "CONNECT";
      }
      e3(cA, "shouldSendContentLength");
      function yA(GA, eA) {
        const { method: lA, path: BA, host: hA, upgrade: MA, blocking: xA, reset: zA } = eA;
        let { body: UA, headers: AA, contentLength: v4 } = eA;
        const X5 = lA === "PUT" || lA === "POST" || lA === "PATCH" || lA === "QUERY" || lA === "PROPFIND" || lA === "PROPPATCH";
        if (k4.isFormDataLike(UA)) {
          sA || (sA = requireBody().extractBody);
          const [TA, VA] = sA(UA);
          eA.contentType == null && AA.push("content-type", VA), UA = TA.stream, v4 = TA.length;
        } else k4.isBlobLike(UA) && eA.contentType == null && UA.type && AA.push("content-type", UA.type);
        UA && typeof UA.read == "function" && UA.read(0);
        const j3 = k4.bodyLength(UA);
        if (v4 = j3 ?? v4, v4 === null && (v4 = eA.contentLength), v4 === 0 && !X5 && (v4 = null), cA(lA) && v4 > 0 && eA.contentLength !== null && eA.contentLength !== v4) {
          if (GA[RA]) return k4.errorRequest(GA, eA, new t2()), false;
          process.emitWarning(new t2());
        }
        const tA = GA[x5], rA = e3((TA) => {
          eA.aborted || eA.completed || (k4.errorRequest(GA, eA, TA || new R4()), k4.destroy(UA), k4.destroy(tA, new U6("aborted")));
        }, "abort");
        try {
          eA.onConnect(rA);
        } catch (TA) {
          k4.errorRequest(GA, eA, TA);
        }
        if (eA.aborted) return false;
        lA === "HEAD" && (tA[I5] = true), (MA || lA === "CONNECT") && (tA[I5] = true), zA != null && (tA[I5] = zA), GA[IA] && tA[CA]++ >= GA[IA] && (tA[I5] = true), xA && (tA[G3] = true);
        let FA = `${lA} ${BA} HTTP/1.1\r
`;
        if (typeof hA == "string" ? FA += `host: ${hA}\r
` : FA += GA[f3], MA ? FA += `connection: upgrade\r
upgrade: ${MA}\r
` : GA[S6] && !tA[I5] ? FA += `connection: keep-alive\r
` : FA += `connection: close\r
`, Array.isArray(AA)) for (let TA = 0; TA < AA.length; TA += 2) {
          const VA = AA[TA + 0], YA = AA[TA + 1];
          if (Array.isArray(YA)) for (let _A = 0; _A < YA.length; _A++) FA += `${VA}: ${YA[_A]}\r
`;
          else FA += `${VA}: ${YA}\r
`;
        }
        return c2.sendHeaders.hasSubscribers && c2.sendHeaders.publish({ request: eA, headers: FA, socket: tA }), !UA || j3 === 0 ? JA(rA, null, GA, eA, tA, v4, FA, X5) : k4.isBuffer(UA) ? JA(rA, UA, GA, eA, tA, v4, FA, X5) : k4.isBlobLike(UA) ? typeof UA.stream == "function" ? te3(rA, UA.stream(), GA, eA, tA, v4, FA, X5) : WA(rA, UA, GA, eA, tA, v4, FA, X5) : k4.isStream(UA) ? LA(rA, UA, GA, eA, tA, v4, FA, X5) : k4.isIterable(UA) ? te3(rA, UA, GA, eA, tA, v4, FA, X5) : A2(false), true;
      }
      e3(yA, "writeH1");
      function LA(GA, eA, lA, BA, hA, MA, xA, zA) {
        A2(MA !== 0 || lA[J5] === 0, "stream body cannot be pipelined");
        let UA = false;
        const AA = new ie3({ abort: GA, socket: hA, request: BA, contentLength: MA, client: lA, expectsPayload: zA, header: xA }), v4 = e3(function(rA) {
          if (!UA) try {
            !AA.write(rA) && this.pause && this.pause();
          } catch (FA) {
            k4.destroy(this, FA);
          }
        }, "onData"), X5 = e3(function() {
          UA || eA.resume && eA.resume();
        }, "onDrain"), j3 = e3(function() {
          if (queueMicrotask(() => {
            eA.removeListener("error", tA);
          }), !UA) {
            const rA = new R4();
            queueMicrotask(() => tA(rA));
          }
        }, "onClose"), tA = e3(function(rA) {
          if (!UA) {
            if (UA = true, A2(hA.destroyed || hA[q6] && lA[J5] <= 1), hA.off("drain", X5).off("error", tA), eA.removeListener("data", v4).removeListener("end", tA).removeListener("close", j3), !rA) try {
              AA.end();
            } catch (FA) {
              rA = FA;
            }
            AA.destroy(rA), rA && (rA.code !== "UND_ERR_INFO" || rA.message !== "reset") ? k4.destroy(eA, rA) : k4.destroy(eA);
          }
        }, "onFinished");
        eA.on("data", v4).on("end", tA).on("error", tA).on("close", j3), eA.resume && eA.resume(), hA.on("drain", X5).on("error", tA), eA.errorEmitted ?? eA.errored ? setImmediate(() => tA(eA.errored)) : (eA.endEmitted ?? eA.readableEnded) && setImmediate(() => tA(null)), (eA.closeEmitted ?? eA.closed) && setImmediate(j3);
      }
      e3(LA, "writeStream");
      function JA(GA, eA, lA, BA, hA, MA, xA, zA) {
        try {
          eA ? k4.isBuffer(eA) && (A2(MA === eA.byteLength, "buffer body must have content length"), hA.cork(), hA.write(`${xA}content-length: ${MA}\r
\r
`, "latin1"), hA.write(eA), hA.uncork(), BA.onBodySent(eA), !zA && BA.reset !== false && (hA[I5] = true)) : MA === 0 ? hA.write(`${xA}content-length: 0\r
\r
`, "latin1") : (A2(MA === null, "no body must not have content length"), hA.write(`${xA}\r
`, "latin1")), BA.onRequestSent(), lA[kA]();
        } catch (UA) {
          GA(UA);
        }
      }
      e3(JA, "writeBuffer");
      async function WA(GA, eA, lA, BA, hA, MA, xA, zA) {
        A2(MA === eA.size, "blob body must have content length");
        try {
          if (MA != null && MA !== eA.size) throw new t2();
          const UA = Buffer.from(await eA.arrayBuffer());
          hA.cork(), hA.write(`${xA}content-length: ${MA}\r
\r
`, "latin1"), hA.write(UA), hA.uncork(), BA.onBodySent(UA), BA.onRequestSent(), !zA && BA.reset !== false && (hA[I5] = true), lA[kA]();
        } catch (UA) {
          GA(UA);
        }
      }
      e3(WA, "writeBlob");
      async function te3(GA, eA, lA, BA, hA, MA, xA, zA) {
        A2(MA !== 0 || lA[J5] === 0, "iterator body cannot be pipelined");
        let UA = null;
        function AA() {
          if (UA) {
            const j3 = UA;
            UA = null, j3();
          }
        }
        e3(AA, "onDrain");
        const v4 = e3(() => new Promise((j3, tA) => {
          A2(UA === null), hA[w5] ? tA(hA[w5]) : UA = j3;
        }), "waitForDrain");
        hA.on("close", AA).on("drain", AA);
        const X5 = new ie3({ abort: GA, socket: hA, request: BA, contentLength: MA, client: lA, expectsPayload: zA, header: xA });
        try {
          for await (const j3 of eA) {
            if (hA[w5]) throw hA[w5];
            X5.write(j3) || await v4();
          }
          X5.end();
        } catch (j3) {
          X5.destroy(j3);
        } finally {
          hA.off("close", AA).off("drain", AA);
        }
      }
      e3(te3, "writeIterable");
      const Ie2 = class Ie {
        constructor({ abort: eA, socket: lA, request: BA, contentLength: hA, client: MA, expectsPayload: xA, header: zA }) {
          this.socket = lA, this.request = BA, this.contentLength = hA, this.client = MA, this.bytesWritten = 0, this.expectsPayload = xA, this.header = zA, this.abort = eA, lA[q6] = true;
        }
        write(eA) {
          const { socket: lA, request: BA, contentLength: hA, client: MA, bytesWritten: xA, expectsPayload: zA, header: UA } = this;
          if (lA[w5]) throw lA[w5];
          if (lA.destroyed) return false;
          const AA = Buffer.byteLength(eA);
          if (!AA) return true;
          if (hA !== null && xA + AA > hA) {
            if (MA[RA]) throw new t2();
            process.emitWarning(new t2());
          }
          lA.cork(), xA === 0 && (!zA && BA.reset !== false && (lA[I5] = true), hA === null ? lA.write(`${UA}transfer-encoding: chunked\r
`, "latin1") : lA.write(`${UA}content-length: ${hA}\r
\r
`, "latin1")), hA === null && lA.write(`\r
${AA.toString(16)}\r
`, "latin1"), this.bytesWritten += AA;
          const v4 = lA.write(eA);
          return lA.uncork(), BA.onBodySent(eA), v4 || lA[b6].timeout && lA[b6].timeoutType === HA && lA[b6].timeout.refresh && lA[b6].timeout.refresh(), v4;
        }
        end() {
          const { socket: eA, contentLength: lA, client: BA, bytesWritten: hA, expectsPayload: MA, header: xA, request: zA } = this;
          if (zA.onRequestSent(), eA[q6] = false, eA[w5]) throw eA[w5];
          if (!eA.destroyed) {
            if (hA === 0 ? MA ? eA.write(`${xA}content-length: 0\r
\r
`, "latin1") : eA.write(`${xA}\r
`, "latin1") : lA === null && eA.write(`\r
0\r
\r
`, "latin1"), lA !== null && hA !== lA) {
              if (BA[RA]) throw new t2();
              process.emitWarning(new t2());
            }
            eA[b6].timeout && eA[b6].timeoutType === HA && eA[b6].timeout.refresh && eA[b6].timeout.refresh(), BA[kA]();
          }
        }
        destroy(eA) {
          const { socket: lA, client: BA, abort: hA } = this;
          lA[q6] = false, eA && (A2(BA[J5] <= 1, "pipeline should only contain this request"), hA(eA));
        }
      };
      e3(Ie2, "AsyncWriter");
      let ie3 = Ie2;
      return clientH1 = QA, clientH1;
    }
    e3(requireClientH1, "requireClientH1");
    var clientH2;
    var hasRequiredClientH2;
    function requireClientH2() {
      if (hasRequiredClientH2) return clientH2;
      hasRequiredClientH2 = 1;
      const A2 = require$$0__default$1, { pipeline: k4 } = Stream__default, c2 = requireUtil$7(), { RequestContentLengthMismatchError: B3, RequestAbortedError: t2, SocketError: y3, InformationalError: R4 } = requireErrors(), { kUrl: F2, kReset: Q5, kClient: D3, kRunning: U6, kPending: r6, kQueue: o, kPendingIdx: N6, kRunningIdx: l3, kError: I5, kSocket: p3, kStrictContentLength: b6, kOnError: G3, kMaxConcurrentStreams: J5, kHTTP2Session: V4, kResume: _5, kSize: q6, kHTTPContext: M4 } = requireSymbols$4(), Y4 = Symbol("open streams");
      let m4, f3 = false, n;
      try {
        n = require("http2");
      } catch {
        n = { constants: {} };
      }
      const { constants: { HTTP2_HEADER_AUTHORITY: C5, HTTP2_HEADER_METHOD: w5, HTTP2_HEADER_PATH: S6, HTTP2_HEADER_SCHEME: x5, HTTP2_HEADER_CONTENT_LENGTH: z4, HTTP2_HEADER_EXPECT: $6, HTTP2_HEADER_STATUS: K4 } } = n;
      function nA(aA) {
        const EA = [];
        for (const [sA, NA] of Object.entries(aA)) if (Array.isArray(NA)) for (const wA of NA) EA.push(Buffer.from(sA), Buffer.from(wA));
        else EA.push(Buffer.from(sA), Buffer.from(NA));
        return EA;
      }
      e3(nA, "parseH2Headers");
      async function iA(aA, EA) {
        aA[p3] = EA, f3 || (f3 = true, process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" }));
        const sA = n.connect(aA[F2], { createConnection: e3(() => EA, "createConnection"), peerMaxConcurrentStreams: aA[J5] });
        sA[Y4] = 0, sA[D3] = aA, sA[p3] = EA, c2.addListener(sA, "error", RA), c2.addListener(sA, "frameError", IA), c2.addListener(sA, "end", CA), c2.addListener(sA, "goaway", pA), c2.addListener(sA, "close", function() {
          const { [D3]: wA } = this, { [p3]: vA } = wA, dA = this[p3][I5] || this[I5] || new y3("closed", c2.getSocketInfo(vA));
          if (wA[V4] = null, wA.destroyed) {
            A2(wA[r6] === 0);
            const XA = wA[o].splice(wA[l3]);
            for (let KA = 0; KA < XA.length; KA++) {
              const OA = XA[KA];
              c2.errorRequest(wA, OA, dA);
            }
          }
        }), sA.unref(), aA[V4] = sA, EA[V4] = sA, c2.addListener(EA, "error", function(wA) {
          A2(wA.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[I5] = wA, this[D3][G3](wA);
        }), c2.addListener(EA, "end", function() {
          c2.destroy(this, new y3("other side closed", c2.getSocketInfo(this)));
        }), c2.addListener(EA, "close", function() {
          const wA = this[I5] || new y3("closed", c2.getSocketInfo(this));
          aA[p3] = null, this[V4] != null && this[V4].destroy(wA), aA[N6] = aA[l3], A2(aA[U6] === 0), aA.emit("disconnect", aA[F2], [aA], wA), aA[_5]();
        });
        let NA = false;
        return EA.on("close", () => {
          NA = true;
        }), { version: "h2", defaultPipelining: 1 / 0, write(...wA) {
          return kA(aA, ...wA);
        }, resume() {
          uA(aA);
        }, destroy(wA, vA) {
          NA ? queueMicrotask(vA) : EA.destroy(wA).on("close", vA);
        }, get destroyed() {
          return EA.destroyed;
        }, busy() {
          return false;
        } };
      }
      e3(iA, "connectH2");
      function uA(aA) {
        const EA = aA[p3];
        EA?.destroyed === false && (aA[q6] === 0 && aA[J5] === 0 ? (EA.unref(), aA[V4].unref()) : (EA.ref(), aA[V4].ref()));
      }
      e3(uA, "resumeH2");
      function RA(aA) {
        A2(aA.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[p3][I5] = aA, this[D3][G3](aA);
      }
      e3(RA, "onHttp2SessionError");
      function IA(aA, EA, sA) {
        if (sA === 0) {
          const NA = new R4(`HTTP/2: "frameError" received - type ${aA}, code ${EA}`);
          this[p3][I5] = NA, this[D3][G3](NA);
        }
      }
      e3(IA, "onHttp2FrameError");
      function CA() {
        const aA = new y3("other side closed", c2.getSocketInfo(this[p3]));
        this.destroy(aA), c2.destroy(this[p3], aA);
      }
      e3(CA, "onHttp2SessionEnd");
      function pA(aA) {
        const EA = this[I5] || new y3(`HTTP/2: "GOAWAY" frame received with code ${aA}`, c2.getSocketInfo(this)), sA = this[D3];
        if (sA[p3] = null, sA[M4] = null, this[V4] != null && (this[V4].destroy(EA), this[V4] = null), c2.destroy(this[p3], EA), sA[l3] < sA[o].length) {
          const NA = sA[o][sA[l3]];
          sA[o][sA[l3]++] = null, c2.errorRequest(sA, NA, EA), sA[N6] = sA[l3];
        }
        A2(sA[U6] === 0), sA.emit("disconnect", sA[F2], [sA], EA), sA[_5]();
      }
      e3(pA, "onHTTP2GoAway");
      function fA(aA) {
        return aA !== "GET" && aA !== "HEAD" && aA !== "OPTIONS" && aA !== "TRACE" && aA !== "CONNECT";
      }
      e3(fA, "shouldSendContentLength");
      function kA(aA, EA) {
        const sA = aA[V4], { method: NA, path: wA, host: vA, upgrade: dA, expectContinue: XA, signal: KA, headers: OA } = EA;
        let { body: PA } = EA;
        if (dA) return c2.errorRequest(aA, EA, new Error("Upgrade not supported for H2")), false;
        const ZA = {};
        for (let yA = 0; yA < OA.length; yA += 2) {
          const LA = OA[yA + 0], JA = OA[yA + 1];
          if (Array.isArray(JA)) for (let WA = 0; WA < JA.length; WA++) ZA[LA] ? ZA[LA] += `,${JA[WA]}` : ZA[LA] = JA[WA];
          else ZA[LA] = JA;
        }
        let HA;
        const { hostname: se2, port: ne3 } = aA[F2];
        ZA[C5] = vA || `${se2}${ne3 ? `:${ne3}` : ""}`, ZA[w5] = NA;
        const jA = e3((yA) => {
          EA.aborted || EA.completed || (yA = yA || new t2(), c2.errorRequest(aA, EA, yA), HA != null && c2.destroy(HA, yA), c2.destroy(PA, yA), aA[o][aA[l3]++] = null, aA[_5]());
        }, "abort");
        try {
          EA.onConnect(jA);
        } catch (yA) {
          c2.errorRequest(aA, EA, yA);
        }
        if (EA.aborted) return false;
        if (NA === "CONNECT") return sA.ref(), HA = sA.request(ZA, { endStream: false, signal: KA }), HA.id && !HA.pending ? (EA.onUpgrade(null, null, HA), ++sA[Y4], aA[o][aA[l3]++] = null) : HA.once("ready", () => {
          EA.onUpgrade(null, null, HA), ++sA[Y4], aA[o][aA[l3]++] = null;
        }), HA.once("close", () => {
          sA[Y4] -= 1, sA[Y4] === 0 && sA.unref();
        }), true;
        ZA[S6] = wA, ZA[x5] = "https";
        const Ae = NA === "PUT" || NA === "POST" || NA === "PATCH";
        PA && typeof PA.read == "function" && PA.read(0);
        let QA = c2.bodyLength(PA);
        if (c2.isFormDataLike(PA)) {
          m4 ?? (m4 = requireBody().extractBody);
          const [yA, LA] = m4(PA);
          ZA["content-type"] = LA, PA = yA.stream, QA = yA.length;
        }
        if (QA == null && (QA = EA.contentLength), (QA === 0 || !Ae) && (QA = null), fA(NA) && QA > 0 && EA.contentLength != null && EA.contentLength !== QA) {
          if (aA[b6]) return c2.errorRequest(aA, EA, new B3()), false;
          process.emitWarning(new B3());
        }
        QA != null && (A2(PA, "no body must not have content length"), ZA[z4] = `${QA}`), sA.ref();
        const W6 = NA === "GET" || NA === "HEAD" || PA === null;
        return XA ? (ZA[$6] = "100-continue", HA = sA.request(ZA, { endStream: W6, signal: KA }), HA.once("continue", cA)) : (HA = sA.request(ZA, { endStream: W6, signal: KA }), cA()), ++sA[Y4], HA.once("response", (yA) => {
          const { [K4]: LA, ...JA } = yA;
          if (EA.onResponseStarted(), EA.aborted) {
            const WA = new t2();
            c2.errorRequest(aA, EA, WA), c2.destroy(HA, WA);
            return;
          }
          EA.onHeaders(Number(LA), nA(JA), HA.resume.bind(HA), "") === false && HA.pause(), HA.on("data", (WA) => {
            EA.onData(WA) === false && HA.pause();
          });
        }), HA.once("end", () => {
          (HA.state?.state == null || HA.state.state < 6) && EA.onComplete([]), sA[Y4] === 0 && sA.unref(), jA(new R4("HTTP/2: stream half-closed (remote)")), aA[o][aA[l3]++] = null, aA[N6] = aA[l3], aA[_5]();
        }), HA.once("close", () => {
          sA[Y4] -= 1, sA[Y4] === 0 && sA.unref();
        }), HA.once("error", function(yA) {
          jA(yA);
        }), HA.once("frameError", (yA, LA) => {
          jA(new R4(`HTTP/2: "frameError" received - type ${yA}, code ${LA}`));
        }), true;
        function cA() {
          !PA || QA === 0 ? bA(jA, HA, null, aA, EA, aA[p3], QA, Ae) : c2.isBuffer(PA) ? bA(jA, HA, PA, aA, EA, aA[p3], QA, Ae) : c2.isBlobLike(PA) ? typeof PA.stream == "function" ? oA(jA, HA, PA.stream(), aA, EA, aA[p3], QA, Ae) : DA(jA, HA, PA, aA, EA, aA[p3], QA, Ae) : c2.isStream(PA) ? gA(jA, aA[p3], Ae, HA, PA, aA, EA, QA) : c2.isIterable(PA) ? oA(jA, HA, PA, aA, EA, aA[p3], QA, Ae) : A2(false);
        }
        e3(cA, "writeBodyH2");
      }
      e3(kA, "writeH2");
      function bA(aA, EA, sA, NA, wA, vA, dA, XA) {
        try {
          sA != null && c2.isBuffer(sA) && (A2(dA === sA.byteLength, "buffer body must have content length"), EA.cork(), EA.write(sA), EA.uncork(), EA.end(), wA.onBodySent(sA)), XA || (vA[Q5] = true), wA.onRequestSent(), NA[_5]();
        } catch (KA) {
          aA(KA);
        }
      }
      e3(bA, "writeBuffer");
      function gA(aA, EA, sA, NA, wA, vA, dA, XA) {
        A2(XA !== 0 || vA[U6] === 0, "stream body cannot be pipelined");
        const KA = k4(wA, NA, (PA) => {
          PA ? (c2.destroy(KA, PA), aA(PA)) : (c2.removeAllListeners(KA), dA.onRequestSent(), sA || (EA[Q5] = true), vA[_5]());
        });
        c2.addListener(KA, "data", OA);
        function OA(PA) {
          dA.onBodySent(PA);
        }
        e3(OA, "onPipeData");
      }
      e3(gA, "writeStream");
      async function DA(aA, EA, sA, NA, wA, vA, dA, XA) {
        A2(dA === sA.size, "blob body must have content length");
        try {
          if (dA != null && dA !== sA.size) throw new B3();
          const KA = Buffer.from(await sA.arrayBuffer());
          EA.cork(), EA.write(KA), EA.uncork(), EA.end(), wA.onBodySent(KA), wA.onRequestSent(), XA || (vA[Q5] = true), NA[_5]();
        } catch (KA) {
          aA(KA);
        }
      }
      e3(DA, "writeBlob");
      async function oA(aA, EA, sA, NA, wA, vA, dA, XA) {
        A2(dA !== 0 || NA[U6] === 0, "iterator body cannot be pipelined");
        let KA = null;
        function OA() {
          if (KA) {
            const ZA = KA;
            KA = null, ZA();
          }
        }
        e3(OA, "onDrain");
        const PA = e3(() => new Promise((ZA, HA) => {
          A2(KA === null), vA[I5] ? HA(vA[I5]) : KA = ZA;
        }), "waitForDrain");
        EA.on("close", OA).on("drain", OA);
        try {
          for await (const ZA of sA) {
            if (vA[I5]) throw vA[I5];
            const HA = EA.write(ZA);
            wA.onBodySent(ZA), HA || await PA();
          }
          EA.end(), wA.onRequestSent(), XA || (vA[Q5] = true), NA[_5]();
        } catch (ZA) {
          aA(ZA);
        } finally {
          EA.off("close", OA).off("drain", OA);
        }
      }
      return e3(oA, "writeIterable"), clientH2 = iA, clientH2;
    }
    e3(requireClientH2, "requireClientH2");
    var redirectHandler;
    var hasRequiredRedirectHandler;
    function requireRedirectHandler() {
      if (hasRequiredRedirectHandler) return redirectHandler;
      hasRequiredRedirectHandler = 1;
      const A2 = requireUtil$7(), { kBodyUsed: k4 } = requireSymbols$4(), c2 = require$$0__default$1, { InvalidArgumentError: B3 } = requireErrors(), t2 = require$$8__default, y3 = [300, 301, 302, 303, 307, 308], R4 = Symbol("body"), o = class o {
        constructor(I5) {
          this[R4] = I5, this[k4] = false;
        }
        async *[Symbol.asyncIterator]() {
          c2(!this[k4], "disturbed"), this[k4] = true, yield* this[R4];
        }
      };
      e3(o, "BodyAsyncIterable");
      let F2 = o;
      const N6 = class N {
        constructor(I5, p3, b6, G3) {
          if (p3 != null && (!Number.isInteger(p3) || p3 < 0)) throw new B3("maxRedirections must be a positive number");
          A2.validateHandler(G3, b6.method, b6.upgrade), this.dispatch = I5, this.location = null, this.abort = null, this.opts = { ...b6, maxRedirections: 0 }, this.maxRedirections = p3, this.handler = G3, this.history = [], this.redirectionLimitReached = false, A2.isStream(this.opts.body) ? (A2.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
            c2(false);
          }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[k4] = false, t2.prototype.on.call(this.opts.body, "data", function() {
            this[k4] = true;
          }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new F2(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && A2.isIterable(this.opts.body) && (this.opts.body = new F2(this.opts.body));
        }
        onConnect(I5) {
          this.abort = I5, this.handler.onConnect(I5, { history: this.history });
        }
        onUpgrade(I5, p3, b6) {
          this.handler.onUpgrade(I5, p3, b6);
        }
        onError(I5) {
          this.handler.onError(I5);
        }
        onHeaders(I5, p3, b6, G3) {
          if (this.location = this.history.length >= this.maxRedirections || A2.isDisturbed(this.opts.body) ? null : D3(I5, p3), this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
            this.request && this.request.abort(new Error("max redirects")), this.redirectionLimitReached = true, this.abort(new Error("max redirects"));
            return;
          }
          if (this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location) return this.handler.onHeaders(I5, p3, b6, G3);
          const { origin: J5, pathname: V4, search: _5 } = A2.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), q6 = _5 ? `${V4}${_5}` : V4;
          this.opts.headers = r6(this.opts.headers, I5 === 303, this.opts.origin !== J5), this.opts.path = q6, this.opts.origin = J5, this.opts.maxRedirections = 0, this.opts.query = null, I5 === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", this.opts.body = null);
        }
        onData(I5) {
          if (!this.location) return this.handler.onData(I5);
        }
        onComplete(I5) {
          this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(I5);
        }
        onBodySent(I5) {
          this.handler.onBodySent && this.handler.onBodySent(I5);
        }
      };
      e3(N6, "RedirectHandler");
      let Q5 = N6;
      function D3(l3, I5) {
        if (y3.indexOf(l3) === -1) return null;
        for (let p3 = 0; p3 < I5.length; p3 += 2) if (I5[p3].length === 8 && A2.headerNameToString(I5[p3]) === "location") return I5[p3 + 1];
      }
      e3(D3, "parseLocation");
      function U6(l3, I5, p3) {
        if (l3.length === 4) return A2.headerNameToString(l3) === "host";
        if (I5 && A2.headerNameToString(l3).startsWith("content-")) return true;
        if (p3 && (l3.length === 13 || l3.length === 6 || l3.length === 19)) {
          const b6 = A2.headerNameToString(l3);
          return b6 === "authorization" || b6 === "cookie" || b6 === "proxy-authorization";
        }
        return false;
      }
      e3(U6, "shouldRemoveHeader");
      function r6(l3, I5, p3) {
        const b6 = [];
        if (Array.isArray(l3)) for (let G3 = 0; G3 < l3.length; G3 += 2) U6(l3[G3], I5, p3) || b6.push(l3[G3], l3[G3 + 1]);
        else if (l3 && typeof l3 == "object") for (const G3 of Object.keys(l3)) U6(G3, I5, p3) || b6.push(G3, l3[G3]);
        else c2(l3 == null, "headers must be an object or an array");
        return b6;
      }
      return e3(r6, "cleanRequestHeaders"), redirectHandler = Q5, redirectHandler;
    }
    e3(requireRedirectHandler, "requireRedirectHandler");
    var redirectInterceptor;
    var hasRequiredRedirectInterceptor;
    function requireRedirectInterceptor() {
      if (hasRequiredRedirectInterceptor) return redirectInterceptor;
      hasRequiredRedirectInterceptor = 1;
      const A2 = requireRedirectHandler();
      function k4({ maxRedirections: c2 }) {
        return (B3) => e3(function(y3, R4) {
          const { maxRedirections: F2 = c2 } = y3;
          if (!F2) return B3(y3, R4);
          const Q5 = new A2(B3, F2, y3, R4);
          return y3 = { ...y3, maxRedirections: 0 }, B3(y3, Q5);
        }, "Intercept");
      }
      return e3(k4, "createRedirectInterceptor"), redirectInterceptor = k4, redirectInterceptor;
    }
    e3(requireRedirectInterceptor, "requireRedirectInterceptor");
    var client;
    var hasRequiredClient;
    function requireClient() {
      if (hasRequiredClient) return client;
      hasRequiredClient = 1;
      const A2 = require$$0__default$1, k4 = require$$0__default$2, c2 = http__default, B3 = requireUtil$7(), { channels: t2 } = requireDiagnostics(), y3 = requireRequest$1(), R4 = requireDispatcherBase(), { InvalidArgumentError: F2, InformationalError: Q5, ClientDestroyedError: D3 } = requireErrors(), U6 = requireConnect(), { kUrl: r6, kServerName: o, kClient: N6, kBusy: l3, kConnect: I5, kResuming: p3, kRunning: b6, kPending: G3, kSize: J5, kQueue: V4, kConnected: _5, kConnecting: q6, kNeedDrain: M4, kKeepAliveDefaultTimeout: Y4, kHostHeader: m4, kPendingIdx: f3, kRunningIdx: n, kError: C5, kPipelining: w5, kKeepAliveTimeoutValue: S6, kMaxHeadersSize: x5, kKeepAliveMaxTimeout: z4, kKeepAliveTimeoutThreshold: $6, kHeadersTimeout: K4, kBodyTimeout: nA, kStrictContentLength: iA, kConnector: uA, kMaxRedirections: RA, kMaxRequests: IA, kCounter: CA, kClose: pA, kDestroy: fA, kDispatch: kA, kInterceptors: bA, kLocalAddress: gA, kMaxResponseSize: DA, kOnError: oA, kHTTPContext: aA, kMaxConcurrentStreams: EA, kResume: sA } = requireSymbols$4(), NA = requireClientH1(), wA = requireClientH2();
      let vA = false;
      const dA = Symbol("kClosedResolve"), XA = e3(() => {
      }, "noop");
      function KA(QA) {
        return QA[w5] ?? QA[aA]?.defaultPipelining ?? 1;
      }
      e3(KA, "getPipelining");
      const Ae = class Ae extends R4 {
        constructor(W6, { interceptors: cA, maxHeaderSize: yA, headersTimeout: LA, socketTimeout: JA, requestTimeout: WA, connectTimeout: te3, bodyTimeout: ie3, idleTimeout: oe3, keepAlive: Ie2, keepAliveTimeout: GA, maxKeepAliveTimeout: eA, keepAliveMaxTimeout: lA, keepAliveTimeoutThreshold: BA, socketPath: hA, pipelining: MA, tls: xA, strictContentLength: zA, maxCachedSessions: UA, maxRedirections: AA, connect: v4, maxRequestsPerClient: X5, localAddress: j3, maxResponseSize: tA, autoSelectFamily: rA, autoSelectFamilyAttemptTimeout: FA, maxConcurrentStreams: TA, allowH2: VA } = {}) {
          if (super(), Ie2 !== void 0) throw new F2("unsupported keepAlive, use pipelining=0 instead");
          if (JA !== void 0) throw new F2("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
          if (WA !== void 0) throw new F2("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
          if (oe3 !== void 0) throw new F2("unsupported idleTimeout, use keepAliveTimeout instead");
          if (eA !== void 0) throw new F2("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
          if (yA != null && !Number.isFinite(yA)) throw new F2("invalid maxHeaderSize");
          if (hA != null && typeof hA != "string") throw new F2("invalid socketPath");
          if (te3 != null && (!Number.isFinite(te3) || te3 < 0)) throw new F2("invalid connectTimeout");
          if (GA != null && (!Number.isFinite(GA) || GA <= 0)) throw new F2("invalid keepAliveTimeout");
          if (lA != null && (!Number.isFinite(lA) || lA <= 0)) throw new F2("invalid keepAliveMaxTimeout");
          if (BA != null && !Number.isFinite(BA)) throw new F2("invalid keepAliveTimeoutThreshold");
          if (LA != null && (!Number.isInteger(LA) || LA < 0)) throw new F2("headersTimeout must be a positive integer or zero");
          if (ie3 != null && (!Number.isInteger(ie3) || ie3 < 0)) throw new F2("bodyTimeout must be a positive integer or zero");
          if (v4 != null && typeof v4 != "function" && typeof v4 != "object") throw new F2("connect must be a function or an object");
          if (AA != null && (!Number.isInteger(AA) || AA < 0)) throw new F2("maxRedirections must be a positive number");
          if (X5 != null && (!Number.isInteger(X5) || X5 < 0)) throw new F2("maxRequestsPerClient must be a positive number");
          if (j3 != null && (typeof j3 != "string" || k4.isIP(j3) === 0)) throw new F2("localAddress must be valid string IP address");
          if (tA != null && (!Number.isInteger(tA) || tA < -1)) throw new F2("maxResponseSize must be a positive number");
          if (FA != null && (!Number.isInteger(FA) || FA < -1)) throw new F2("autoSelectFamilyAttemptTimeout must be a positive number");
          if (VA != null && typeof VA != "boolean") throw new F2("allowH2 must be a valid boolean value");
          if (TA != null && (typeof TA != "number" || TA < 1)) throw new F2("maxConcurrentStreams must be a positive integer, greater than 0");
          typeof v4 != "function" && (v4 = U6({ ...xA, maxCachedSessions: UA, allowH2: VA, socketPath: hA, timeout: te3, ...rA ? { autoSelectFamily: rA, autoSelectFamilyAttemptTimeout: FA } : void 0, ...v4 })), cA?.Client && Array.isArray(cA.Client) ? (this[bA] = cA.Client, vA || (vA = true, process.emitWarning("Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.", { code: "UNDICI-CLIENT-INTERCEPTOR-DEPRECATED" }))) : this[bA] = [PA({ maxRedirections: AA })], this[r6] = B3.parseOrigin(W6), this[uA] = v4, this[w5] = MA ?? 1, this[x5] = yA || c2.maxHeaderSize, this[Y4] = GA ?? 4e3, this[z4] = lA ?? 6e5, this[$6] = BA ?? 2e3, this[S6] = this[Y4], this[o] = null, this[gA] = j3 ?? null, this[p3] = 0, this[M4] = 0, this[m4] = `host: ${this[r6].hostname}${this[r6].port ? `:${this[r6].port}` : ""}\r
`, this[nA] = ie3 ?? 3e5, this[K4] = LA ?? 3e5, this[iA] = zA ?? true, this[RA] = AA, this[IA] = X5, this[dA] = null, this[DA] = tA > -1 ? tA : -1, this[EA] = TA ?? 100, this[aA] = null, this[V4] = [], this[n] = 0, this[f3] = 0, this[sA] = (YA) => ne3(this, YA), this[oA] = (YA) => ZA(this, YA);
        }
        get pipelining() {
          return this[w5];
        }
        set pipelining(W6) {
          this[w5] = W6, this[sA](true);
        }
        get [G3]() {
          return this[V4].length - this[f3];
        }
        get [b6]() {
          return this[f3] - this[n];
        }
        get [J5]() {
          return this[V4].length - this[n];
        }
        get [_5]() {
          return !!this[aA] && !this[q6] && !this[aA].destroyed;
        }
        get [l3]() {
          return !!(this[aA]?.busy(null) || this[J5] >= (KA(this) || 1) || this[G3] > 0);
        }
        [I5](W6) {
          HA(this), this.once("connect", W6);
        }
        [kA](W6, cA) {
          const yA = W6.origin || this[r6].origin, LA = new y3(yA, W6, cA);
          return this[V4].push(LA), this[p3] || (B3.bodyLength(LA.body) == null && B3.isIterable(LA.body) ? (this[p3] = 1, queueMicrotask(() => ne3(this))) : this[sA](true)), this[p3] && this[M4] !== 2 && this[l3] && (this[M4] = 2), this[M4] < 2;
        }
        async [pA]() {
          return new Promise((W6) => {
            this[J5] ? this[dA] = W6 : W6(null);
          });
        }
        async [fA](W6) {
          return new Promise((cA) => {
            const yA = this[V4].splice(this[f3]);
            for (let JA = 0; JA < yA.length; JA++) {
              const WA = yA[JA];
              B3.errorRequest(this, WA, W6);
            }
            const LA = e3(() => {
              this[dA] && (this[dA](), this[dA] = null), cA(null);
            }, "callback");
            this[aA] ? (this[aA].destroy(W6, LA), this[aA] = null) : queueMicrotask(LA), this[sA]();
          });
        }
      };
      e3(Ae, "Client");
      let OA = Ae;
      const PA = requireRedirectInterceptor();
      function ZA(QA, W6) {
        if (QA[b6] === 0 && W6.code !== "UND_ERR_INFO" && W6.code !== "UND_ERR_SOCKET") {
          A2(QA[f3] === QA[n]);
          const cA = QA[V4].splice(QA[n]);
          for (let yA = 0; yA < cA.length; yA++) {
            const LA = cA[yA];
            B3.errorRequest(QA, LA, W6);
          }
          A2(QA[J5] === 0);
        }
      }
      e3(ZA, "onError");
      async function HA(QA) {
        A2(!QA[q6]), A2(!QA[aA]);
        let { host: W6, hostname: cA, protocol: yA, port: LA } = QA[r6];
        if (cA[0] === "[") {
          const JA = cA.indexOf("]");
          A2(JA !== -1);
          const WA = cA.substring(1, JA);
          A2(k4.isIP(WA)), cA = WA;
        }
        QA[q6] = true, t2.beforeConnect.hasSubscribers && t2.beforeConnect.publish({ connectParams: { host: W6, hostname: cA, protocol: yA, port: LA, version: QA[aA]?.version, servername: QA[o], localAddress: QA[gA] }, connector: QA[uA] });
        try {
          const JA = await new Promise((WA, te3) => {
            QA[uA]({ host: W6, hostname: cA, protocol: yA, port: LA, servername: QA[o], localAddress: QA[gA] }, (ie3, oe3) => {
              ie3 ? te3(ie3) : WA(oe3);
            });
          });
          if (QA.destroyed) {
            B3.destroy(JA.on("error", XA), new D3());
            return;
          }
          A2(JA);
          try {
            QA[aA] = JA.alpnProtocol === "h2" ? await wA(QA, JA) : await NA(QA, JA);
          } catch (WA) {
            throw JA.destroy().on("error", XA), WA;
          }
          QA[q6] = false, JA[CA] = 0, JA[IA] = QA[IA], JA[N6] = QA, JA[C5] = null, t2.connected.hasSubscribers && t2.connected.publish({ connectParams: { host: W6, hostname: cA, protocol: yA, port: LA, version: QA[aA]?.version, servername: QA[o], localAddress: QA[gA] }, connector: QA[uA], socket: JA }), QA.emit("connect", QA[r6], [QA]);
        } catch (JA) {
          if (QA.destroyed) return;
          if (QA[q6] = false, t2.connectError.hasSubscribers && t2.connectError.publish({ connectParams: { host: W6, hostname: cA, protocol: yA, port: LA, version: QA[aA]?.version, servername: QA[o], localAddress: QA[gA] }, connector: QA[uA], error: JA }), JA.code === "ERR_TLS_CERT_ALTNAME_INVALID") for (A2(QA[b6] === 0); QA[G3] > 0 && QA[V4][QA[f3]].servername === QA[o]; ) {
            const WA = QA[V4][QA[f3]++];
            B3.errorRequest(QA, WA, JA);
          }
          else ZA(QA, JA);
          QA.emit("connectionError", QA[r6], [QA], JA);
        }
        QA[sA]();
      }
      e3(HA, "connect");
      function se2(QA) {
        QA[M4] = 0, QA.emit("drain", QA[r6], [QA]);
      }
      e3(se2, "emitDrain");
      function ne3(QA, W6) {
        QA[p3] !== 2 && (QA[p3] = 2, jA(QA, W6), QA[p3] = 0, QA[n] > 256 && (QA[V4].splice(0, QA[n]), QA[f3] -= QA[n], QA[n] = 0));
      }
      e3(ne3, "resume");
      function jA(QA, W6) {
        for (; ; ) {
          if (QA.destroyed) {
            A2(QA[G3] === 0);
            return;
          }
          if (QA[dA] && !QA[J5]) {
            QA[dA](), QA[dA] = null;
            return;
          }
          if (QA[aA] && QA[aA].resume(), QA[l3]) QA[M4] = 2;
          else if (QA[M4] === 2) {
            W6 ? (QA[M4] = 1, queueMicrotask(() => se2(QA))) : se2(QA);
            continue;
          }
          if (QA[G3] === 0 || QA[b6] >= (KA(QA) || 1)) return;
          const cA = QA[V4][QA[f3]];
          if (QA[r6].protocol === "https:" && QA[o] !== cA.servername) {
            if (QA[b6] > 0) return;
            QA[o] = cA.servername, QA[aA]?.destroy(new Q5("servername changed"), () => {
              QA[aA] = null, ne3(QA);
            });
          }
          if (QA[q6]) return;
          if (!QA[aA]) {
            HA(QA);
            return;
          }
          if (QA[aA].destroyed || QA[aA].busy(cA)) return;
          !cA.aborted && QA[aA].write(cA) ? QA[f3]++ : QA[V4].splice(QA[f3], 1);
        }
      }
      return e3(jA, "_resume"), client = OA, client;
    }
    e3(requireClient, "requireClient");
    var fixedQueue;
    var hasRequiredFixedQueue;
    function requireFixedQueue() {
      var t2;
      if (hasRequiredFixedQueue) return fixedQueue;
      hasRequiredFixedQueue = 1;
      const A2 = 2048, k4 = A2 - 1, B3 = class B {
        constructor() {
          this.bottom = 0, this.top = 0, this.list = new Array(A2), this.next = null;
        }
        isEmpty() {
          return this.top === this.bottom;
        }
        isFull() {
          return (this.top + 1 & k4) === this.bottom;
        }
        push(R4) {
          this.list[this.top] = R4, this.top = this.top + 1 & k4;
        }
        shift() {
          const R4 = this.list[this.bottom];
          return R4 === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & k4, R4);
        }
      };
      e3(B3, "FixedCircularBuffer");
      let c2 = B3;
      return fixedQueue = (t2 = class {
        constructor() {
          this.head = this.tail = new c2();
        }
        isEmpty() {
          return this.head.isEmpty();
        }
        push(R4) {
          this.head.isFull() && (this.head = this.head.next = new c2()), this.head.push(R4);
        }
        shift() {
          const R4 = this.tail, F2 = R4.shift();
          return R4.isEmpty() && R4.next !== null && (this.tail = R4.next), F2;
        }
      }, e3(t2, "FixedQueue"), t2), fixedQueue;
    }
    e3(requireFixedQueue, "requireFixedQueue");
    var poolStats;
    var hasRequiredPoolStats;
    function requirePoolStats() {
      if (hasRequiredPoolStats) return poolStats;
      hasRequiredPoolStats = 1;
      const { kFree: A2, kConnected: k4, kPending: c2, kQueued: B3, kRunning: t2, kSize: y3 } = requireSymbols$4(), R4 = Symbol("pool"), Q5 = class Q {
        constructor(U6) {
          this[R4] = U6;
        }
        get connected() {
          return this[R4][k4];
        }
        get free() {
          return this[R4][A2];
        }
        get pending() {
          return this[R4][c2];
        }
        get queued() {
          return this[R4][B3];
        }
        get running() {
          return this[R4][t2];
        }
        get size() {
          return this[R4][y3];
        }
      };
      e3(Q5, "PoolStats");
      let F2 = Q5;
      return poolStats = F2, poolStats;
    }
    e3(requirePoolStats, "requirePoolStats");
    var poolBase;
    var hasRequiredPoolBase;
    function requirePoolBase() {
      if (hasRequiredPoolBase) return poolBase;
      hasRequiredPoolBase = 1;
      const A2 = requireDispatcherBase(), k4 = requireFixedQueue(), { kConnected: c2, kSize: B3, kRunning: t2, kPending: y3, kQueued: R4, kBusy: F2, kFree: Q5, kUrl: D3, kClose: U6, kDestroy: r6, kDispatch: o } = requireSymbols$4(), N6 = requirePoolStats(), l3 = Symbol("clients"), I5 = Symbol("needDrain"), p3 = Symbol("queue"), b6 = Symbol("closed resolve"), G3 = Symbol("onDrain"), J5 = Symbol("onConnect"), V4 = Symbol("onDisconnect"), _5 = Symbol("onConnectionError"), q6 = Symbol("get dispatcher"), M4 = Symbol("add client"), Y4 = Symbol("remove client"), m4 = Symbol("stats"), n = class n extends A2 {
        constructor() {
          super(), this[p3] = new k4(), this[l3] = [], this[R4] = 0;
          const w5 = this;
          this[G3] = e3(function(x5, z4) {
            const $6 = w5[p3];
            let K4 = false;
            for (; !K4; ) {
              const nA = $6.shift();
              if (!nA) break;
              w5[R4]--, K4 = !this.dispatch(nA.opts, nA.handler);
            }
            this[I5] = K4, !this[I5] && w5[I5] && (w5[I5] = false, w5.emit("drain", x5, [w5, ...z4])), w5[b6] && $6.isEmpty() && Promise.all(w5[l3].map((nA) => nA.close())).then(w5[b6]);
          }, "onDrain"), this[J5] = (S6, x5) => {
            w5.emit("connect", S6, [w5, ...x5]);
          }, this[V4] = (S6, x5, z4) => {
            w5.emit("disconnect", S6, [w5, ...x5], z4);
          }, this[_5] = (S6, x5, z4) => {
            w5.emit("connectionError", S6, [w5, ...x5], z4);
          }, this[m4] = new N6(this);
        }
        get [F2]() {
          return this[I5];
        }
        get [c2]() {
          return this[l3].filter((w5) => w5[c2]).length;
        }
        get [Q5]() {
          return this[l3].filter((w5) => w5[c2] && !w5[I5]).length;
        }
        get [y3]() {
          let w5 = this[R4];
          for (const { [y3]: S6 } of this[l3]) w5 += S6;
          return w5;
        }
        get [t2]() {
          let w5 = 0;
          for (const { [t2]: S6 } of this[l3]) w5 += S6;
          return w5;
        }
        get [B3]() {
          let w5 = this[R4];
          for (const { [B3]: S6 } of this[l3]) w5 += S6;
          return w5;
        }
        get stats() {
          return this[m4];
        }
        async [U6]() {
          this[p3].isEmpty() ? await Promise.all(this[l3].map((w5) => w5.close())) : await new Promise((w5) => {
            this[b6] = w5;
          });
        }
        async [r6](w5) {
          for (; ; ) {
            const S6 = this[p3].shift();
            if (!S6) break;
            S6.handler.onError(w5);
          }
          await Promise.all(this[l3].map((S6) => S6.destroy(w5)));
        }
        [o](w5, S6) {
          const x5 = this[q6]();
          return x5 ? x5.dispatch(w5, S6) || (x5[I5] = true, this[I5] = !this[q6]()) : (this[I5] = true, this[p3].push({ opts: w5, handler: S6 }), this[R4]++), !this[I5];
        }
        [M4](w5) {
          return w5.on("drain", this[G3]).on("connect", this[J5]).on("disconnect", this[V4]).on("connectionError", this[_5]), this[l3].push(w5), this[I5] && queueMicrotask(() => {
            this[I5] && this[G3](w5[D3], [this, w5]);
          }), this;
        }
        [Y4](w5) {
          w5.close(() => {
            const S6 = this[l3].indexOf(w5);
            S6 !== -1 && this[l3].splice(S6, 1);
          }), this[I5] = this[l3].some((S6) => !S6[I5] && S6.closed !== true && S6.destroyed !== true);
        }
      };
      e3(n, "PoolBase");
      let f3 = n;
      return poolBase = { PoolBase: f3, kClients: l3, kNeedDrain: I5, kAddClient: M4, kRemoveClient: Y4, kGetDispatcher: q6 }, poolBase;
    }
    e3(requirePoolBase, "requirePoolBase");
    var pool;
    var hasRequiredPool;
    function requirePool() {
      if (hasRequiredPool) return pool;
      hasRequiredPool = 1;
      const { PoolBase: A2, kClients: k4, kNeedDrain: c2, kAddClient: B3, kGetDispatcher: t2 } = requirePoolBase(), y3 = requireClient(), { InvalidArgumentError: R4 } = requireErrors(), F2 = requireUtil$7(), { kUrl: Q5, kInterceptors: D3 } = requireSymbols$4(), U6 = requireConnect(), r6 = Symbol("options"), o = Symbol("connections"), N6 = Symbol("factory");
      function l3(b6, G3) {
        return new y3(b6, G3);
      }
      e3(l3, "defaultFactory");
      const p3 = class p extends A2 {
        constructor(G3, { connections: J5, factory: V4 = l3, connect: _5, connectTimeout: q6, tls: M4, maxCachedSessions: Y4, socketPath: m4, autoSelectFamily: f3, autoSelectFamilyAttemptTimeout: n, allowH2: C5, ...w5 } = {}) {
          if (super(), J5 != null && (!Number.isFinite(J5) || J5 < 0)) throw new R4("invalid connections");
          if (typeof V4 != "function") throw new R4("factory must be a function.");
          if (_5 != null && typeof _5 != "function" && typeof _5 != "object") throw new R4("connect must be a function or an object");
          typeof _5 != "function" && (_5 = U6({ ...M4, maxCachedSessions: Y4, allowH2: C5, socketPath: m4, timeout: q6, ...f3 ? { autoSelectFamily: f3, autoSelectFamilyAttemptTimeout: n } : void 0, ..._5 })), this[D3] = w5.interceptors?.Pool && Array.isArray(w5.interceptors.Pool) ? w5.interceptors.Pool : [], this[o] = J5 || null, this[Q5] = F2.parseOrigin(G3), this[r6] = { ...F2.deepClone(w5), connect: _5, allowH2: C5 }, this[r6].interceptors = w5.interceptors ? { ...w5.interceptors } : void 0, this[N6] = V4, this.on("connectionError", (S6, x5, z4) => {
            for (const $6 of x5) {
              const K4 = this[k4].indexOf($6);
              K4 !== -1 && this[k4].splice(K4, 1);
            }
          });
        }
        [t2]() {
          for (const G3 of this[k4]) if (!G3[c2]) return G3;
          if (!this[o] || this[k4].length < this[o]) {
            const G3 = this[N6](this[Q5], this[r6]);
            return this[B3](G3), G3;
          }
        }
      };
      e3(p3, "Pool");
      let I5 = p3;
      return pool = I5, pool;
    }
    e3(requirePool, "requirePool");
    var balancedPool;
    var hasRequiredBalancedPool;
    function requireBalancedPool() {
      if (hasRequiredBalancedPool) return balancedPool;
      hasRequiredBalancedPool = 1;
      const { BalancedPoolMissingUpstreamError: A2, InvalidArgumentError: k4 } = requireErrors(), { PoolBase: c2, kClients: B3, kNeedDrain: t2, kAddClient: y3, kRemoveClient: R4, kGetDispatcher: F2 } = requirePoolBase(), Q5 = requirePool(), { kUrl: D3, kInterceptors: U6 } = requireSymbols$4(), { parseOrigin: r6 } = requireUtil$7(), o = Symbol("factory"), N6 = Symbol("options"), l3 = Symbol("kGreatestCommonDivisor"), I5 = Symbol("kCurrentWeight"), p3 = Symbol("kIndex"), b6 = Symbol("kWeight"), G3 = Symbol("kMaxWeightPerServer"), J5 = Symbol("kErrorPenalty");
      function V4(Y4, m4) {
        if (Y4 === 0) return m4;
        for (; m4 !== 0; ) {
          const f3 = m4;
          m4 = Y4 % m4, Y4 = f3;
        }
        return Y4;
      }
      e3(V4, "getGreatestCommonDivisor");
      function _5(Y4, m4) {
        return new Q5(Y4, m4);
      }
      e3(_5, "defaultFactory");
      const M4 = class M extends c2 {
        constructor(m4 = [], { factory: f3 = _5, ...n } = {}) {
          if (super(), this[N6] = n, this[p3] = -1, this[I5] = 0, this[G3] = this[N6].maxWeightPerServer || 100, this[J5] = this[N6].errorPenalty || 15, Array.isArray(m4) || (m4 = [m4]), typeof f3 != "function") throw new k4("factory must be a function.");
          this[U6] = n.interceptors?.BalancedPool && Array.isArray(n.interceptors.BalancedPool) ? n.interceptors.BalancedPool : [], this[o] = f3;
          for (const C5 of m4) this.addUpstream(C5);
          this._updateBalancedPoolStats();
        }
        addUpstream(m4) {
          const f3 = r6(m4).origin;
          if (this[B3].find((C5) => C5[D3].origin === f3 && C5.closed !== true && C5.destroyed !== true)) return this;
          const n = this[o](f3, Object.assign({}, this[N6]));
          this[y3](n), n.on("connect", () => {
            n[b6] = Math.min(this[G3], n[b6] + this[J5]);
          }), n.on("connectionError", () => {
            n[b6] = Math.max(1, n[b6] - this[J5]), this._updateBalancedPoolStats();
          }), n.on("disconnect", (...C5) => {
            const w5 = C5[2];
            w5 && w5.code === "UND_ERR_SOCKET" && (n[b6] = Math.max(1, n[b6] - this[J5]), this._updateBalancedPoolStats());
          });
          for (const C5 of this[B3]) C5[b6] = this[G3];
          return this._updateBalancedPoolStats(), this;
        }
        _updateBalancedPoolStats() {
          let m4 = 0;
          for (let f3 = 0; f3 < this[B3].length; f3++) m4 = V4(this[B3][f3][b6], m4);
          this[l3] = m4;
        }
        removeUpstream(m4) {
          const f3 = r6(m4).origin, n = this[B3].find((C5) => C5[D3].origin === f3 && C5.closed !== true && C5.destroyed !== true);
          return n && this[R4](n), this;
        }
        get upstreams() {
          return this[B3].filter((m4) => m4.closed !== true && m4.destroyed !== true).map((m4) => m4[D3].origin);
        }
        [F2]() {
          if (this[B3].length === 0) throw new A2();
          if (!this[B3].find((w5) => !w5[t2] && w5.closed !== true && w5.destroyed !== true) || this[B3].map((w5) => w5[t2]).reduce((w5, S6) => w5 && S6, true)) return;
          let n = 0, C5 = this[B3].findIndex((w5) => !w5[t2]);
          for (; n++ < this[B3].length; ) {
            this[p3] = (this[p3] + 1) % this[B3].length;
            const w5 = this[B3][this[p3]];
            if (w5[b6] > this[B3][C5][b6] && !w5[t2] && (C5 = this[p3]), this[p3] === 0 && (this[I5] = this[I5] - this[l3], this[I5] <= 0 && (this[I5] = this[G3])), w5[b6] >= this[I5] && !w5[t2]) return w5;
          }
          return this[I5] = this[B3][C5][b6], this[p3] = C5, this[B3][C5];
        }
      };
      e3(M4, "BalancedPool");
      let q6 = M4;
      return balancedPool = q6, balancedPool;
    }
    e3(requireBalancedPool, "requireBalancedPool");
    var agent;
    var hasRequiredAgent;
    function requireAgent() {
      if (hasRequiredAgent) return agent;
      hasRequiredAgent = 1;
      const { InvalidArgumentError: A2 } = requireErrors(), { kClients: k4, kRunning: c2, kClose: B3, kDestroy: t2, kDispatch: y3, kInterceptors: R4 } = requireSymbols$4(), F2 = requireDispatcherBase(), Q5 = requirePool(), D3 = requireClient(), U6 = requireUtil$7(), r6 = requireRedirectInterceptor(), o = Symbol("onConnect"), N6 = Symbol("onDisconnect"), l3 = Symbol("onConnectionError"), I5 = Symbol("maxRedirections"), p3 = Symbol("onDrain"), b6 = Symbol("factory"), G3 = Symbol("options");
      function J5(q6, M4) {
        return M4 && M4.connections === 1 ? new D3(q6, M4) : new Q5(q6, M4);
      }
      e3(J5, "defaultFactory");
      const _5 = class _ extends F2 {
        constructor({ factory: M4 = J5, maxRedirections: Y4 = 0, connect: m4, ...f3 } = {}) {
          if (super(), typeof M4 != "function") throw new A2("factory must be a function.");
          if (m4 != null && typeof m4 != "function" && typeof m4 != "object") throw new A2("connect must be a function or an object");
          if (!Number.isInteger(Y4) || Y4 < 0) throw new A2("maxRedirections must be a positive number");
          m4 && typeof m4 != "function" && (m4 = { ...m4 }), this[R4] = f3.interceptors?.Agent && Array.isArray(f3.interceptors.Agent) ? f3.interceptors.Agent : [r6({ maxRedirections: Y4 })], this[G3] = { ...U6.deepClone(f3), connect: m4 }, this[G3].interceptors = f3.interceptors ? { ...f3.interceptors } : void 0, this[I5] = Y4, this[b6] = M4, this[k4] = /* @__PURE__ */ new Map(), this[p3] = (n, C5) => {
            this.emit("drain", n, [this, ...C5]);
          }, this[o] = (n, C5) => {
            this.emit("connect", n, [this, ...C5]);
          }, this[N6] = (n, C5, w5) => {
            this.emit("disconnect", n, [this, ...C5], w5);
          }, this[l3] = (n, C5, w5) => {
            this.emit("connectionError", n, [this, ...C5], w5);
          };
        }
        get [c2]() {
          let M4 = 0;
          for (const Y4 of this[k4].values()) M4 += Y4[c2];
          return M4;
        }
        [y3](M4, Y4) {
          let m4;
          if (M4.origin && (typeof M4.origin == "string" || M4.origin instanceof URL)) m4 = String(M4.origin);
          else throw new A2("opts.origin must be a non-empty string or URL.");
          let f3 = this[k4].get(m4);
          return f3 || (f3 = this[b6](M4.origin, this[G3]).on("drain", this[p3]).on("connect", this[o]).on("disconnect", this[N6]).on("connectionError", this[l3]), this[k4].set(m4, f3)), f3.dispatch(M4, Y4);
        }
        async [B3]() {
          const M4 = [];
          for (const Y4 of this[k4].values()) M4.push(Y4.close());
          this[k4].clear(), await Promise.all(M4);
        }
        async [t2](M4) {
          const Y4 = [];
          for (const m4 of this[k4].values()) Y4.push(m4.destroy(M4));
          this[k4].clear(), await Promise.all(Y4);
        }
      };
      e3(_5, "Agent");
      let V4 = _5;
      return agent = V4, agent;
    }
    e3(requireAgent, "requireAgent");
    var proxyAgent;
    var hasRequiredProxyAgent;
    function requireProxyAgent() {
      var Y4, Je2;
      if (hasRequiredProxyAgent) return proxyAgent;
      hasRequiredProxyAgent = 1;
      const { kProxy: A2, kClose: k4, kDestroy: c2, kInterceptors: B3 } = requireSymbols$4(), { URL: t2 } = require$$1__default$1, y3 = requireAgent(), R4 = requirePool(), F2 = requireDispatcherBase(), { InvalidArgumentError: Q5, RequestAbortedError: D3, SecureProxyConnectionError: U6 } = requireErrors(), r6 = requireConnect(), o = Symbol("proxy agent"), N6 = Symbol("proxy client"), l3 = Symbol("proxy headers"), I5 = Symbol("request tls settings"), p3 = Symbol("proxy tls settings"), b6 = Symbol("connect endpoint function");
      function G3(n) {
        return n === "https:" ? 443 : 80;
      }
      e3(G3, "defaultProtocolPort");
      function J5(n, C5) {
        return new R4(n, C5);
      }
      e3(J5, "defaultFactory");
      const V4 = e3(() => {
      }, "noop"), f3 = class f extends F2 {
        constructor(w5) {
          super();
          SA(this, Y4);
          if (!w5 || typeof w5 == "object" && !(w5 instanceof t2) && !w5.uri) throw new Q5("Proxy uri is mandatory");
          const { clientFactory: S6 = J5 } = w5;
          if (typeof S6 != "function") throw new Q5("Proxy opts.clientFactory must be a function.");
          const x5 = ee3(this, Y4, Je2).call(this, w5), { href: z4, origin: $6, port: K4, protocol: nA, username: iA, password: uA, hostname: RA } = x5;
          if (this[A2] = { uri: z4, protocol: nA }, this[B3] = w5.interceptors?.ProxyAgent && Array.isArray(w5.interceptors.ProxyAgent) ? w5.interceptors.ProxyAgent : [], this[I5] = w5.requestTls, this[p3] = w5.proxyTls, this[l3] = w5.headers || {}, w5.auth && w5.token) throw new Q5("opts.auth cannot be used in combination with opts.token");
          w5.auth ? this[l3]["proxy-authorization"] = `Basic ${w5.auth}` : w5.token ? this[l3]["proxy-authorization"] = w5.token : iA && uA && (this[l3]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(iA)}:${decodeURIComponent(uA)}`).toString("base64")}`);
          const IA = r6({ ...w5.proxyTls });
          this[b6] = r6({ ...w5.requestTls }), this[N6] = S6(x5, { connect: IA }), this[o] = new y3({ ...w5, connect: e3(async (CA, pA) => {
            let fA = CA.host;
            CA.port || (fA += `:${G3(CA.protocol)}`);
            try {
              const { socket: kA, statusCode: bA } = await this[N6].connect({ origin: $6, port: K4, path: fA, signal: CA.signal, headers: { ...this[l3], host: CA.host }, servername: this[p3]?.servername || RA });
              if (bA !== 200 && (kA.on("error", V4).destroy(), pA(new D3(`Proxy response (${bA}) !== 200 when HTTP Tunneling`))), CA.protocol !== "https:") {
                pA(null, kA);
                return;
              }
              let gA;
              this[I5] ? gA = this[I5].servername : gA = CA.servername, this[b6]({ ...CA, servername: gA, httpSocket: kA }, pA);
            } catch (kA) {
              kA.code === "ERR_TLS_CERT_ALTNAME_INVALID" ? pA(new U6(kA)) : pA(kA);
            }
          }, "connect") });
        }
        dispatch(w5, S6) {
          const x5 = q6(w5.headers);
          if (M4(x5), x5 && !("host" in x5) && !("Host" in x5)) {
            const { host: z4 } = new t2(w5.origin);
            x5.host = z4;
          }
          return this[o].dispatch({ ...w5, headers: x5 }, S6);
        }
        async [k4]() {
          await this[o].close(), await this[N6].close();
        }
        async [c2]() {
          await this[o].destroy(), await this[N6].destroy();
        }
      };
      Y4 = /* @__PURE__ */ new WeakSet(), Je2 = e3(function(w5) {
        return typeof w5 == "string" ? new t2(w5) : w5 instanceof t2 ? w5 : new t2(w5.uri);
      }, "#getUrl"), e3(f3, "ProxyAgent");
      let _5 = f3;
      function q6(n) {
        if (Array.isArray(n)) {
          const C5 = {};
          for (let w5 = 0; w5 < n.length; w5 += 2) C5[n[w5]] = n[w5 + 1];
          return C5;
        }
        return n;
      }
      e3(q6, "buildHeaders");
      function M4(n) {
        if (n && Object.keys(n).find((w5) => w5.toLowerCase() === "proxy-authorization")) throw new Q5("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
      return e3(M4, "throwIfProxyAuthIsSent"), proxyAgent = _5, proxyAgent;
    }
    e3(requireProxyAgent, "requireProxyAgent");
    var envHttpProxyAgent;
    var hasRequiredEnvHttpProxyAgent;
    function requireEnvHttpProxyAgent() {
      var l3, I5, p3, b6, ve2, He2, Ne2, Ve2, me3;
      if (hasRequiredEnvHttpProxyAgent) return envHttpProxyAgent;
      hasRequiredEnvHttpProxyAgent = 1;
      const A2 = requireDispatcherBase(), { kClose: k4, kDestroy: c2, kClosed: B3, kDestroyed: t2, kDispatch: y3, kNoProxyAgent: R4, kHttpProxyAgent: F2, kHttpsProxyAgent: Q5 } = requireSymbols$4(), D3 = requireProxyAgent(), U6 = requireAgent(), r6 = { "http:": 80, "https:": 443 };
      let o = false;
      const M4 = class M extends A2 {
        constructor(f3 = {}) {
          super();
          SA(this, b6);
          SA(this, l3, null);
          SA(this, I5, null);
          SA(this, p3, null);
          mA(this, p3, f3), o || (o = true, process.emitWarning("EnvHttpProxyAgent is experimental, expect them to change at any time.", { code: "UNDICI-EHPA" }));
          const { httpProxy: n, httpsProxy: C5, noProxy: w5, ...S6 } = f3;
          this[R4] = new U6(S6);
          const x5 = n ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
          x5 ? this[F2] = new D3({ ...S6, uri: x5 }) : this[F2] = this[R4];
          const z4 = C5 ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
          z4 ? this[Q5] = new D3({ ...S6, uri: z4 }) : this[Q5] = this[F2], ee3(this, b6, Ne2).call(this);
        }
        [y3](f3, n) {
          const C5 = new URL(f3.origin);
          return ee3(this, b6, ve2).call(this, C5).dispatch(f3, n);
        }
        async [k4]() {
          await this[R4].close(), this[F2][B3] || await this[F2].close(), this[Q5][B3] || await this[Q5].close();
        }
        async [c2](f3) {
          await this[R4].destroy(f3), this[F2][t2] || await this[F2].destroy(f3), this[Q5][t2] || await this[Q5].destroy(f3);
        }
      };
      l3 = /* @__PURE__ */ new WeakMap(), I5 = /* @__PURE__ */ new WeakMap(), p3 = /* @__PURE__ */ new WeakMap(), b6 = /* @__PURE__ */ new WeakSet(), ve2 = e3(function(f3) {
        let { protocol: n, host: C5, port: w5 } = f3;
        return C5 = C5.replace(/:\d*$/, "").toLowerCase(), w5 = Number.parseInt(w5, 10) || r6[n] || 0, ee3(this, b6, He2).call(this, C5, w5) ? n === "https:" ? this[Q5] : this[F2] : this[R4];
      }, "#getProxyAgentForUrl"), He2 = e3(function(f3, n) {
        if (Z4(this, b6, Ve2) && ee3(this, b6, Ne2).call(this), Z4(this, I5).length === 0) return true;
        if (Z4(this, l3) === "*") return false;
        for (let C5 = 0; C5 < Z4(this, I5).length; C5++) {
          const w5 = Z4(this, I5)[C5];
          if (!(w5.port && w5.port !== n)) {
            if (/^[.*]/.test(w5.hostname)) {
              if (f3.endsWith(w5.hostname.replace(/^\*/, ""))) return false;
            } else if (f3 === w5.hostname) return false;
          }
        }
        return true;
      }, "#shouldProxy"), Ne2 = e3(function() {
        const f3 = Z4(this, p3).noProxy ?? Z4(this, b6, me3), n = f3.split(/[,\s]/), C5 = [];
        for (let w5 = 0; w5 < n.length; w5++) {
          const S6 = n[w5];
          if (!S6) continue;
          const x5 = S6.match(/^(.+):(\d+)$/);
          C5.push({ hostname: (x5 ? x5[1] : S6).toLowerCase(), port: x5 ? Number.parseInt(x5[2], 10) : 0 });
        }
        mA(this, l3, f3), mA(this, I5, C5);
      }, "#parseNoProxy"), Ve2 = e3(function() {
        return Z4(this, p3).noProxy !== void 0 ? false : Z4(this, l3) !== Z4(this, b6, me3);
      }, "#noProxyChanged"), me3 = e3(function() {
        return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
      }, "#noProxyEnv"), e3(M4, "EnvHttpProxyAgent");
      let N6 = M4;
      return envHttpProxyAgent = N6, envHttpProxyAgent;
    }
    e3(requireEnvHttpProxyAgent, "requireEnvHttpProxyAgent");
    var retryHandler;
    var hasRequiredRetryHandler;
    function requireRetryHandler() {
      if (hasRequiredRetryHandler) return retryHandler;
      hasRequiredRetryHandler = 1;
      const A2 = require$$0__default$1, { kRetryHandlerDefaultRetry: k4 } = requireSymbols$4(), { RequestRetryError: c2 } = requireErrors(), { isDisturbed: B3, parseHeaders: t2, parseRangeHeader: y3, wrapRequestBody: R4 } = requireUtil$7();
      function F2(U6) {
        const r6 = Date.now();
        return new Date(U6).getTime() - r6;
      }
      e3(F2, "calculateRetryAfterHeader");
      const D3 = class D4 {
        constructor(r6, o) {
          const { retryOptions: N6, ...l3 } = r6, { retry: I5, maxRetries: p3, maxTimeout: b6, minTimeout: G3, timeoutFactor: J5, methods: V4, errorCodes: _5, retryAfter: q6, statusCodes: M4 } = N6 ?? {};
          this.dispatch = o.dispatch, this.handler = o.handler, this.opts = { ...l3, body: R4(r6.body) }, this.abort = null, this.aborted = false, this.retryOpts = { retry: I5 ?? D4[k4], retryAfter: q6 ?? true, maxTimeout: b6 ?? 30 * 1e3, minTimeout: G3 ?? 500, timeoutFactor: J5 ?? 2, maxRetries: p3 ?? 5, methods: V4 ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"], statusCodes: M4 ?? [500, 502, 503, 504, 429], errorCodes: _5 ?? ["ECONNRESET", "ECONNREFUSED", "ENOTFOUND", "ENETDOWN", "ENETUNREACH", "EHOSTDOWN", "EHOSTUNREACH", "EPIPE", "UND_ERR_SOCKET"] }, this.retryCount = 0, this.retryCountCheckpoint = 0, this.start = 0, this.end = null, this.etag = null, this.resume = null, this.handler.onConnect((Y4) => {
            this.aborted = true, this.abort ? this.abort(Y4) : this.reason = Y4;
          });
        }
        onRequestSent() {
          this.handler.onRequestSent && this.handler.onRequestSent();
        }
        onUpgrade(r6, o, N6) {
          this.handler.onUpgrade && this.handler.onUpgrade(r6, o, N6);
        }
        onConnect(r6) {
          this.aborted ? r6(this.reason) : this.abort = r6;
        }
        onBodySent(r6) {
          if (this.handler.onBodySent) return this.handler.onBodySent(r6);
        }
        static [k4](r6, { state: o, opts: N6 }, l3) {
          const { statusCode: I5, code: p3, headers: b6 } = r6, { method: G3, retryOptions: J5 } = N6, { maxRetries: V4, minTimeout: _5, maxTimeout: q6, timeoutFactor: M4, statusCodes: Y4, errorCodes: m4, methods: f3 } = J5, { counter: n } = o;
          if (p3 && p3 !== "UND_ERR_REQ_RETRY" && !m4.includes(p3)) {
            l3(r6);
            return;
          }
          if (Array.isArray(f3) && !f3.includes(G3)) {
            l3(r6);
            return;
          }
          if (I5 != null && Array.isArray(Y4) && !Y4.includes(I5)) {
            l3(r6);
            return;
          }
          if (n > V4) {
            l3(r6);
            return;
          }
          let C5 = b6?.["retry-after"];
          C5 && (C5 = Number(C5), C5 = Number.isNaN(C5) ? F2(C5) : C5 * 1e3);
          const w5 = C5 > 0 ? Math.min(C5, q6) : Math.min(_5 * M4 ** (n - 1), q6);
          setTimeout(() => l3(null), w5);
        }
        onHeaders(r6, o, N6, l3) {
          const I5 = t2(o);
          if (this.retryCount += 1, r6 >= 300) return this.retryOpts.statusCodes.includes(r6) === false ? this.handler.onHeaders(r6, o, N6, l3) : (this.abort(new c2("Request failed", r6, { headers: I5, data: { count: this.retryCount } })), false);
          if (this.resume != null) {
            if (this.resume = null, r6 !== 206 && (this.start > 0 || r6 !== 200)) return this.abort(new c2("server does not support the range header and the payload was partially consumed", r6, { headers: I5, data: { count: this.retryCount } })), false;
            const b6 = y3(I5["content-range"]);
            if (!b6) return this.abort(new c2("Content-Range mismatch", r6, { headers: I5, data: { count: this.retryCount } })), false;
            if (this.etag != null && this.etag !== I5.etag) return this.abort(new c2("ETag mismatch", r6, { headers: I5, data: { count: this.retryCount } })), false;
            const { start: G3, size: J5, end: V4 = J5 - 1 } = b6;
            return A2(this.start === G3, "content-range mismatch"), A2(this.end == null || this.end === V4, "content-range mismatch"), this.resume = N6, true;
          }
          if (this.end == null) {
            if (r6 === 206) {
              const b6 = y3(I5["content-range"]);
              if (b6 == null) return this.handler.onHeaders(r6, o, N6, l3);
              const { start: G3, size: J5, end: V4 = J5 - 1 } = b6;
              A2(G3 != null && Number.isFinite(G3), "content-range mismatch"), A2(V4 != null && Number.isFinite(V4), "invalid content-length"), this.start = G3, this.end = V4;
            }
            if (this.end == null) {
              const b6 = I5["content-length"];
              this.end = b6 != null ? Number(b6) - 1 : null;
            }
            return A2(Number.isFinite(this.start)), A2(this.end == null || Number.isFinite(this.end), "invalid content-length"), this.resume = N6, this.etag = I5.etag != null ? I5.etag : null, this.etag != null && this.etag.startsWith("W/") && (this.etag = null), this.handler.onHeaders(r6, o, N6, l3);
          }
          const p3 = new c2("Request failed", r6, { headers: I5, data: { count: this.retryCount } });
          return this.abort(p3), false;
        }
        onData(r6) {
          return this.start += r6.length, this.handler.onData(r6);
        }
        onComplete(r6) {
          return this.retryCount = 0, this.handler.onComplete(r6);
        }
        onError(r6) {
          if (this.aborted || B3(this.opts.body)) return this.handler.onError(r6);
          this.retryCount - this.retryCountCheckpoint > 0 ? this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint) : this.retryCount += 1, this.retryOpts.retry(r6, { state: { counter: this.retryCount }, opts: { retryOptions: this.retryOpts, ...this.opts } }, o.bind(this));
          function o(N6) {
            if (N6 != null || this.aborted || B3(this.opts.body)) return this.handler.onError(N6);
            if (this.start !== 0) {
              const l3 = { range: `bytes=${this.start}-${this.end ?? ""}` };
              this.etag != null && (l3["if-match"] = this.etag), this.opts = { ...this.opts, headers: { ...this.opts.headers, ...l3 } };
            }
            try {
              this.retryCountCheckpoint = this.retryCount, this.dispatch(this.opts, this);
            } catch (l3) {
              this.handler.onError(l3);
            }
          }
          e3(o, "onRetry");
        }
      };
      e3(D3, "RetryHandler");
      let Q5 = D3;
      return retryHandler = Q5, retryHandler;
    }
    e3(requireRetryHandler, "requireRetryHandler");
    var retryAgent;
    var hasRequiredRetryAgent;
    function requireRetryAgent() {
      var B3, t2;
      if (hasRequiredRetryAgent) return retryAgent;
      hasRequiredRetryAgent = 1;
      const A2 = requireDispatcher(), k4 = requireRetryHandler(), y3 = class y extends A2 {
        constructor(Q5, D3 = {}) {
          super(D3);
          SA(this, B3, null);
          SA(this, t2, null);
          mA(this, B3, Q5), mA(this, t2, D3);
        }
        dispatch(Q5, D3) {
          const U6 = new k4({ ...Q5, retryOptions: Z4(this, t2) }, { dispatch: Z4(this, B3).dispatch.bind(Z4(this, B3)), handler: D3 });
          return Z4(this, B3).dispatch(Q5, U6);
        }
        close() {
          return Z4(this, B3).close();
        }
        destroy() {
          return Z4(this, B3).destroy();
        }
      };
      B3 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap(), e3(y3, "RetryAgent");
      let c2 = y3;
      return retryAgent = c2, retryAgent;
    }
    e3(requireRetryAgent, "requireRetryAgent");
    var api = {};
    var apiRequest = { exports: {} };
    var readable;
    var hasRequiredReadable;
    function requireReadable() {
      if (hasRequiredReadable) return readable;
      hasRequiredReadable = 1;
      const A2 = require$$0__default$1, { Readable: k4 } = Stream__default, { RequestAbortedError: c2, NotSupportedError: B3, InvalidArgumentError: t2, AbortError: y3 } = requireErrors(), R4 = requireUtil$7(), { ReadableStreamFrom: F2 } = requireUtil$7(), Q5 = Symbol("kConsume"), D3 = Symbol("kReading"), U6 = Symbol("kBody"), r6 = Symbol("kAbort"), o = Symbol("kContentType"), N6 = Symbol("kContentLength"), l3 = e3(() => {
      }, "noop"), m4 = class m extends k4 {
        constructor({ resume: n, abort: C5, contentType: w5 = "", contentLength: S6, highWaterMark: x5 = 64 * 1024 }) {
          super({ autoDestroy: true, read: n, highWaterMark: x5 }), this._readableState.dataEmitted = false, this[r6] = C5, this[Q5] = null, this[U6] = null, this[o] = w5, this[N6] = S6, this[D3] = false;
        }
        destroy(n) {
          return !n && !this._readableState.endEmitted && (n = new c2()), n && this[r6](), super.destroy(n);
        }
        _destroy(n, C5) {
          this[D3] ? C5(n) : setImmediate(() => {
            C5(n);
          });
        }
        on(n, ...C5) {
          return (n === "data" || n === "readable") && (this[D3] = true), super.on(n, ...C5);
        }
        addListener(n, ...C5) {
          return this.on(n, ...C5);
        }
        off(n, ...C5) {
          const w5 = super.off(n, ...C5);
          return (n === "data" || n === "readable") && (this[D3] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), w5;
        }
        removeListener(n, ...C5) {
          return this.off(n, ...C5);
        }
        push(n) {
          return this[Q5] && n !== null ? (M4(this[Q5], n), this[D3] ? super.push(n) : true) : super.push(n);
        }
        async text() {
          return G3(this, "text");
        }
        async json() {
          return G3(this, "json");
        }
        async blob() {
          return G3(this, "blob");
        }
        async bytes() {
          return G3(this, "bytes");
        }
        async arrayBuffer() {
          return G3(this, "arrayBuffer");
        }
        async formData() {
          throw new B3();
        }
        get bodyUsed() {
          return R4.isDisturbed(this);
        }
        get body() {
          return this[U6] || (this[U6] = F2(this), this[Q5] && (this[U6].getReader(), A2(this[U6].locked))), this[U6];
        }
        async dump(n) {
          let C5 = Number.isFinite(n?.limit) ? n.limit : 131072;
          const w5 = n?.signal;
          if (w5 != null && (typeof w5 != "object" || !("aborted" in w5))) throw new t2("signal must be an AbortSignal");
          return w5?.throwIfAborted(), this._readableState.closeEmitted ? null : await new Promise((S6, x5) => {
            this[N6] > C5 && this.destroy(new y3());
            const z4 = e3(() => {
              this.destroy(w5.reason ?? new y3());
            }, "onAbort");
            w5?.addEventListener("abort", z4), this.on("close", function() {
              w5?.removeEventListener("abort", z4), w5?.aborted ? x5(w5.reason ?? new y3()) : S6(null);
            }).on("error", l3).on("data", function($6) {
              C5 -= $6.length, C5 <= 0 && this.destroy();
            }).resume();
          });
        }
      };
      e3(m4, "BodyReadable");
      let I5 = m4;
      function p3(f3) {
        return f3[U6] && f3[U6].locked === true || f3[Q5];
      }
      e3(p3, "isLocked");
      function b6(f3) {
        return R4.isDisturbed(f3) || p3(f3);
      }
      e3(b6, "isUnusable");
      async function G3(f3, n) {
        return A2(!f3[Q5]), new Promise((C5, w5) => {
          if (b6(f3)) {
            const S6 = f3._readableState;
            S6.destroyed && S6.closeEmitted === false ? f3.on("error", (x5) => {
              w5(x5);
            }).on("close", () => {
              w5(new TypeError("unusable"));
            }) : w5(S6.errored ?? new TypeError("unusable"));
          } else queueMicrotask(() => {
            f3[Q5] = { type: n, stream: f3, resolve: C5, reject: w5, length: 0, body: [] }, f3.on("error", function(S6) {
              Y4(this[Q5], S6);
            }).on("close", function() {
              this[Q5].body !== null && Y4(this[Q5], new c2());
            }), J5(f3[Q5]);
          });
        });
      }
      e3(G3, "consume");
      function J5(f3) {
        if (f3.body === null) return;
        const { _readableState: n } = f3.stream;
        if (n.bufferIndex) {
          const C5 = n.bufferIndex, w5 = n.buffer.length;
          for (let S6 = C5; S6 < w5; S6++) M4(f3, n.buffer[S6]);
        } else for (const C5 of n.buffer) M4(f3, C5);
        for (n.endEmitted ? q6(this[Q5]) : f3.stream.on("end", function() {
          q6(this[Q5]);
        }), f3.stream.resume(); f3.stream.read() != null; ) ;
      }
      e3(J5, "consumeStart");
      function V4(f3, n) {
        if (f3.length === 0 || n === 0) return "";
        const C5 = f3.length === 1 ? f3[0] : Buffer.concat(f3, n), w5 = C5.length, S6 = w5 > 2 && C5[0] === 239 && C5[1] === 187 && C5[2] === 191 ? 3 : 0;
        return C5.utf8Slice(S6, w5);
      }
      e3(V4, "chunksDecode");
      function _5(f3, n) {
        if (f3.length === 0 || n === 0) return new Uint8Array(0);
        if (f3.length === 1) return new Uint8Array(f3[0]);
        const C5 = new Uint8Array(Buffer.allocUnsafeSlow(n).buffer);
        let w5 = 0;
        for (let S6 = 0; S6 < f3.length; ++S6) {
          const x5 = f3[S6];
          C5.set(x5, w5), w5 += x5.length;
        }
        return C5;
      }
      e3(_5, "chunksConcat");
      function q6(f3) {
        const { type: n, body: C5, resolve: w5, stream: S6, length: x5 } = f3;
        try {
          n === "text" ? w5(V4(C5, x5)) : n === "json" ? w5(JSON.parse(V4(C5, x5))) : n === "arrayBuffer" ? w5(_5(C5, x5).buffer) : n === "blob" ? w5(new Blob(C5, { type: S6[o] })) : n === "bytes" && w5(_5(C5, x5)), Y4(f3);
        } catch (z4) {
          S6.destroy(z4);
        }
      }
      e3(q6, "consumeEnd");
      function M4(f3, n) {
        f3.length += n.length, f3.body.push(n);
      }
      e3(M4, "consumePush");
      function Y4(f3, n) {
        f3.body !== null && (n ? f3.reject(n) : f3.resolve(), f3.type = null, f3.stream = null, f3.resolve = null, f3.reject = null, f3.length = 0, f3.body = null);
      }
      return e3(Y4, "consumeFinish"), readable = { Readable: I5, chunksDecode: V4 }, readable;
    }
    e3(requireReadable, "requireReadable");
    var util$5;
    var hasRequiredUtil$5;
    function requireUtil$5() {
      if (hasRequiredUtil$5) return util$5;
      hasRequiredUtil$5 = 1;
      const A2 = require$$0__default$1, { ResponseStatusCodeError: k4 } = requireErrors(), { chunksDecode: c2 } = requireReadable(), B3 = 128 * 1024;
      async function t2({ callback: F2, body: Q5, contentType: D3, statusCode: U6, statusMessage: r6, headers: o }) {
        A2(Q5);
        let N6 = [], l3 = 0;
        try {
          for await (const G3 of Q5) if (N6.push(G3), l3 += G3.length, l3 > B3) {
            N6 = [], l3 = 0;
            break;
          }
        } catch {
          N6 = [], l3 = 0;
        }
        const I5 = `Response status code ${U6}${r6 ? `: ${r6}` : ""}`;
        if (U6 === 204 || !D3 || !l3) {
          queueMicrotask(() => F2(new k4(I5, U6, o)));
          return;
        }
        const p3 = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        let b6;
        try {
          y3(D3) ? b6 = JSON.parse(c2(N6, l3)) : R4(D3) && (b6 = c2(N6, l3));
        } catch {
        } finally {
          Error.stackTraceLimit = p3;
        }
        queueMicrotask(() => F2(new k4(I5, U6, o, b6)));
      }
      e3(t2, "getResolveErrorBodyCallback");
      const y3 = e3((F2) => F2.length > 15 && F2[11] === "/" && F2[0] === "a" && F2[1] === "p" && F2[2] === "p" && F2[3] === "l" && F2[4] === "i" && F2[5] === "c" && F2[6] === "a" && F2[7] === "t" && F2[8] === "i" && F2[9] === "o" && F2[10] === "n" && F2[12] === "j" && F2[13] === "s" && F2[14] === "o" && F2[15] === "n", "isContentTypeApplicationJson"), R4 = e3((F2) => F2.length > 4 && F2[4] === "/" && F2[0] === "t" && F2[1] === "e" && F2[2] === "x" && F2[3] === "t", "isContentTypeText");
      return util$5 = { getResolveErrorBodyCallback: t2, isContentTypeApplicationJson: y3, isContentTypeText: R4 }, util$5;
    }
    e3(requireUtil$5, "requireUtil$5");
    var hasRequiredApiRequest;
    function requireApiRequest() {
      if (hasRequiredApiRequest) return apiRequest.exports;
      hasRequiredApiRequest = 1;
      const A2 = require$$0__default$1, { Readable: k4 } = requireReadable(), { InvalidArgumentError: c2, RequestAbortedError: B3 } = requireErrors(), t2 = requireUtil$7(), { getResolveErrorBodyCallback: y3 } = requireUtil$5(), { AsyncResource: R4 } = require$$5__default$2, D3 = class D extends R4 {
        constructor(r6, o) {
          if (!r6 || typeof r6 != "object") throw new c2("invalid opts");
          const { signal: N6, method: l3, opaque: I5, body: p3, onInfo: b6, responseHeaders: G3, throwOnError: J5, highWaterMark: V4 } = r6;
          try {
            if (typeof o != "function") throw new c2("invalid callback");
            if (V4 && (typeof V4 != "number" || V4 < 0)) throw new c2("invalid highWaterMark");
            if (N6 && typeof N6.on != "function" && typeof N6.addEventListener != "function") throw new c2("signal must be an EventEmitter or EventTarget");
            if (l3 === "CONNECT") throw new c2("invalid method");
            if (b6 && typeof b6 != "function") throw new c2("invalid onInfo callback");
            super("UNDICI_REQUEST");
          } catch (_5) {
            throw t2.isStream(p3) && t2.destroy(p3.on("error", t2.nop), _5), _5;
          }
          this.method = l3, this.responseHeaders = G3 || null, this.opaque = I5 || null, this.callback = o, this.res = null, this.abort = null, this.body = p3, this.trailers = {}, this.context = null, this.onInfo = b6 || null, this.throwOnError = J5, this.highWaterMark = V4, this.signal = N6, this.reason = null, this.removeAbortListener = null, t2.isStream(p3) && p3.on("error", (_5) => {
            this.onError(_5);
          }), this.signal && (this.signal.aborted ? this.reason = this.signal.reason ?? new B3() : this.removeAbortListener = t2.addAbortListener(this.signal, () => {
            this.reason = this.signal.reason ?? new B3(), this.res ? t2.destroy(this.res.on("error", t2.nop), this.reason) : this.abort && this.abort(this.reason), this.removeAbortListener && (this.res?.off("close", this.removeAbortListener), this.removeAbortListener(), this.removeAbortListener = null);
          }));
        }
        onConnect(r6, o) {
          if (this.reason) {
            r6(this.reason);
            return;
          }
          A2(this.callback), this.abort = r6, this.context = o;
        }
        onHeaders(r6, o, N6, l3) {
          const { callback: I5, opaque: p3, abort: b6, context: G3, responseHeaders: J5, highWaterMark: V4 } = this, _5 = J5 === "raw" ? t2.parseRawHeaders(o) : t2.parseHeaders(o);
          if (r6 < 200) {
            this.onInfo && this.onInfo({ statusCode: r6, headers: _5 });
            return;
          }
          const q6 = J5 === "raw" ? t2.parseHeaders(o) : _5, M4 = q6["content-type"], Y4 = q6["content-length"], m4 = new k4({ resume: N6, abort: b6, contentType: M4, contentLength: this.method !== "HEAD" && Y4 ? Number(Y4) : null, highWaterMark: V4 });
          this.removeAbortListener && m4.on("close", this.removeAbortListener), this.callback = null, this.res = m4, I5 !== null && (this.throwOnError && r6 >= 400 ? this.runInAsyncScope(y3, null, { callback: I5, body: m4, contentType: M4, statusCode: r6, statusMessage: l3, headers: _5 }) : this.runInAsyncScope(I5, null, null, { statusCode: r6, headers: _5, trailers: this.trailers, opaque: p3, body: m4, context: G3 }));
        }
        onData(r6) {
          return this.res.push(r6);
        }
        onComplete(r6) {
          t2.parseHeaders(r6, this.trailers), this.res.push(null);
        }
        onError(r6) {
          const { res: o, callback: N6, body: l3, opaque: I5 } = this;
          N6 && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(N6, null, r6, { opaque: I5 });
          })), o && (this.res = null, queueMicrotask(() => {
            t2.destroy(o, r6);
          })), l3 && (this.body = null, t2.destroy(l3, r6)), this.removeAbortListener && (o?.off("close", this.removeAbortListener), this.removeAbortListener(), this.removeAbortListener = null);
        }
      };
      e3(D3, "RequestHandler");
      let F2 = D3;
      function Q5(U6, r6) {
        if (r6 === void 0) return new Promise((o, N6) => {
          Q5.call(this, U6, (l3, I5) => l3 ? N6(l3) : o(I5));
        });
        try {
          this.dispatch(U6, new F2(U6, r6));
        } catch (o) {
          if (typeof r6 != "function") throw o;
          const N6 = U6?.opaque;
          queueMicrotask(() => r6(o, { opaque: N6 }));
        }
      }
      return e3(Q5, "request"), apiRequest.exports = Q5, apiRequest.exports.RequestHandler = F2, apiRequest.exports;
    }
    e3(requireApiRequest, "requireApiRequest");
    var abortSignal;
    var hasRequiredAbortSignal;
    function requireAbortSignal() {
      if (hasRequiredAbortSignal) return abortSignal;
      hasRequiredAbortSignal = 1;
      const { addAbortListener: A2 } = requireUtil$7(), { RequestAbortedError: k4 } = requireErrors(), c2 = Symbol("kListener"), B3 = Symbol("kSignal");
      function t2(F2) {
        F2.abort ? F2.abort(F2[B3]?.reason) : F2.reason = F2[B3]?.reason ?? new k4(), R4(F2);
      }
      e3(t2, "abort");
      function y3(F2, Q5) {
        if (F2.reason = null, F2[B3] = null, F2[c2] = null, !!Q5) {
          if (Q5.aborted) {
            t2(F2);
            return;
          }
          F2[B3] = Q5, F2[c2] = () => {
            t2(F2);
          }, A2(F2[B3], F2[c2]);
        }
      }
      e3(y3, "addSignal");
      function R4(F2) {
        F2[B3] && ("removeEventListener" in F2[B3] ? F2[B3].removeEventListener("abort", F2[c2]) : F2[B3].removeListener("abort", F2[c2]), F2[B3] = null, F2[c2] = null);
      }
      return e3(R4, "removeSignal"), abortSignal = { addSignal: y3, removeSignal: R4 }, abortSignal;
    }
    e3(requireAbortSignal, "requireAbortSignal");
    var apiStream;
    var hasRequiredApiStream;
    function requireApiStream() {
      if (hasRequiredApiStream) return apiStream;
      hasRequiredApiStream = 1;
      const A2 = require$$0__default$1, { finished: k4, PassThrough: c2 } = Stream__default, { InvalidArgumentError: B3, InvalidReturnValueError: t2 } = requireErrors(), y3 = requireUtil$7(), { getResolveErrorBodyCallback: R4 } = requireUtil$5(), { AsyncResource: F2 } = require$$5__default$2, { addSignal: Q5, removeSignal: D3 } = requireAbortSignal(), o = class o extends F2 {
        constructor(l3, I5, p3) {
          if (!l3 || typeof l3 != "object") throw new B3("invalid opts");
          const { signal: b6, method: G3, opaque: J5, body: V4, onInfo: _5, responseHeaders: q6, throwOnError: M4 } = l3;
          try {
            if (typeof p3 != "function") throw new B3("invalid callback");
            if (typeof I5 != "function") throw new B3("invalid factory");
            if (b6 && typeof b6.on != "function" && typeof b6.addEventListener != "function") throw new B3("signal must be an EventEmitter or EventTarget");
            if (G3 === "CONNECT") throw new B3("invalid method");
            if (_5 && typeof _5 != "function") throw new B3("invalid onInfo callback");
            super("UNDICI_STREAM");
          } catch (Y4) {
            throw y3.isStream(V4) && y3.destroy(V4.on("error", y3.nop), Y4), Y4;
          }
          this.responseHeaders = q6 || null, this.opaque = J5 || null, this.factory = I5, this.callback = p3, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = V4, this.onInfo = _5 || null, this.throwOnError = M4 || false, y3.isStream(V4) && V4.on("error", (Y4) => {
            this.onError(Y4);
          }), Q5(this, b6);
        }
        onConnect(l3, I5) {
          if (this.reason) {
            l3(this.reason);
            return;
          }
          A2(this.callback), this.abort = l3, this.context = I5;
        }
        onHeaders(l3, I5, p3, b6) {
          const { factory: G3, opaque: J5, context: V4, callback: _5, responseHeaders: q6 } = this, M4 = q6 === "raw" ? y3.parseRawHeaders(I5) : y3.parseHeaders(I5);
          if (l3 < 200) {
            this.onInfo && this.onInfo({ statusCode: l3, headers: M4 });
            return;
          }
          this.factory = null;
          let Y4;
          if (this.throwOnError && l3 >= 400) {
            const n = (q6 === "raw" ? y3.parseHeaders(I5) : M4)["content-type"];
            Y4 = new c2(), this.callback = null, this.runInAsyncScope(R4, null, { callback: _5, body: Y4, contentType: n, statusCode: l3, statusMessage: b6, headers: M4 });
          } else {
            if (G3 === null) return;
            if (Y4 = this.runInAsyncScope(G3, null, { statusCode: l3, headers: M4, opaque: J5, context: V4 }), !Y4 || typeof Y4.write != "function" || typeof Y4.end != "function" || typeof Y4.on != "function") throw new t2("expected Writable");
            k4(Y4, { readable: false }, (f3) => {
              const { callback: n, res: C5, opaque: w5, trailers: S6, abort: x5 } = this;
              this.res = null, (f3 || !C5.readable) && y3.destroy(C5, f3), this.callback = null, this.runInAsyncScope(n, null, f3 || null, { opaque: w5, trailers: S6 }), f3 && x5();
            });
          }
          return Y4.on("drain", p3), this.res = Y4, (Y4.writableNeedDrain !== void 0 ? Y4.writableNeedDrain : Y4._writableState?.needDrain) !== true;
        }
        onData(l3) {
          const { res: I5 } = this;
          return I5 ? I5.write(l3) : true;
        }
        onComplete(l3) {
          const { res: I5 } = this;
          D3(this), I5 && (this.trailers = y3.parseHeaders(l3), I5.end());
        }
        onError(l3) {
          const { res: I5, callback: p3, opaque: b6, body: G3 } = this;
          D3(this), this.factory = null, I5 ? (this.res = null, y3.destroy(I5, l3)) : p3 && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(p3, null, l3, { opaque: b6 });
          })), G3 && (this.body = null, y3.destroy(G3, l3));
        }
      };
      e3(o, "StreamHandler");
      let U6 = o;
      function r6(N6, l3, I5) {
        if (I5 === void 0) return new Promise((p3, b6) => {
          r6.call(this, N6, l3, (G3, J5) => G3 ? b6(G3) : p3(J5));
        });
        try {
          this.dispatch(N6, new U6(N6, l3, I5));
        } catch (p3) {
          if (typeof I5 != "function") throw p3;
          const b6 = N6?.opaque;
          queueMicrotask(() => I5(p3, { opaque: b6 }));
        }
      }
      return e3(r6, "stream"), apiStream = r6, apiStream;
    }
    e3(requireApiStream, "requireApiStream");
    var apiPipeline;
    var hasRequiredApiPipeline;
    function requireApiPipeline() {
      if (hasRequiredApiPipeline) return apiPipeline;
      hasRequiredApiPipeline = 1;
      const { Readable: A2, Duplex: k4, PassThrough: c2 } = Stream__default, { InvalidArgumentError: B3, InvalidReturnValueError: t2, RequestAbortedError: y3 } = requireErrors(), R4 = requireUtil$7(), { AsyncResource: F2 } = require$$5__default$2, { addSignal: Q5, removeSignal: D3 } = requireAbortSignal(), U6 = require$$0__default$1, r6 = Symbol("resume"), p3 = class p extends A2 {
        constructor() {
          super({ autoDestroy: true }), this[r6] = null;
        }
        _read() {
          const { [r6]: V4 } = this;
          V4 && (this[r6] = null, V4());
        }
        _destroy(V4, _5) {
          this._read(), _5(V4);
        }
      };
      e3(p3, "PipelineRequest");
      let o = p3;
      const b6 = class b extends A2 {
        constructor(V4) {
          super({ autoDestroy: true }), this[r6] = V4;
        }
        _read() {
          this[r6]();
        }
        _destroy(V4, _5) {
          !V4 && !this._readableState.endEmitted && (V4 = new y3()), _5(V4);
        }
      };
      e3(b6, "PipelineResponse");
      let N6 = b6;
      const G3 = class G extends F2 {
        constructor(V4, _5) {
          if (!V4 || typeof V4 != "object") throw new B3("invalid opts");
          if (typeof _5 != "function") throw new B3("invalid handler");
          const { signal: q6, method: M4, opaque: Y4, onInfo: m4, responseHeaders: f3 } = V4;
          if (q6 && typeof q6.on != "function" && typeof q6.addEventListener != "function") throw new B3("signal must be an EventEmitter or EventTarget");
          if (M4 === "CONNECT") throw new B3("invalid method");
          if (m4 && typeof m4 != "function") throw new B3("invalid onInfo callback");
          super("UNDICI_PIPELINE"), this.opaque = Y4 || null, this.responseHeaders = f3 || null, this.handler = _5, this.abort = null, this.context = null, this.onInfo = m4 || null, this.req = new o().on("error", R4.nop), this.ret = new k4({ readableObjectMode: V4.objectMode, autoDestroy: true, read: e3(() => {
            const { body: n } = this;
            n?.resume && n.resume();
          }, "read"), write: e3((n, C5, w5) => {
            const { req: S6 } = this;
            S6.push(n, C5) || S6._readableState.destroyed ? w5() : S6[r6] = w5;
          }, "write"), destroy: e3((n, C5) => {
            const { body: w5, req: S6, res: x5, ret: z4, abort: $6 } = this;
            !n && !z4._readableState.endEmitted && (n = new y3()), $6 && n && $6(), R4.destroy(w5, n), R4.destroy(S6, n), R4.destroy(x5, n), D3(this), C5(n);
          }, "destroy") }).on("prefinish", () => {
            const { req: n } = this;
            n.push(null);
          }), this.res = null, Q5(this, q6);
        }
        onConnect(V4, _5) {
          const { ret: q6, res: M4 } = this;
          if (this.reason) {
            V4(this.reason);
            return;
          }
          U6(!M4, "pipeline cannot be retried"), U6(!q6.destroyed), this.abort = V4, this.context = _5;
        }
        onHeaders(V4, _5, q6) {
          const { opaque: M4, handler: Y4, context: m4 } = this;
          if (V4 < 200) {
            if (this.onInfo) {
              const n = this.responseHeaders === "raw" ? R4.parseRawHeaders(_5) : R4.parseHeaders(_5);
              this.onInfo({ statusCode: V4, headers: n });
            }
            return;
          }
          this.res = new N6(q6);
          let f3;
          try {
            this.handler = null;
            const n = this.responseHeaders === "raw" ? R4.parseRawHeaders(_5) : R4.parseHeaders(_5);
            f3 = this.runInAsyncScope(Y4, null, { statusCode: V4, headers: n, opaque: M4, body: this.res, context: m4 });
          } catch (n) {
            throw this.res.on("error", R4.nop), n;
          }
          if (!f3 || typeof f3.on != "function") throw new t2("expected Readable");
          f3.on("data", (n) => {
            const { ret: C5, body: w5 } = this;
            !C5.push(n) && w5.pause && w5.pause();
          }).on("error", (n) => {
            const { ret: C5 } = this;
            R4.destroy(C5, n);
          }).on("end", () => {
            const { ret: n } = this;
            n.push(null);
          }).on("close", () => {
            const { ret: n } = this;
            n._readableState.ended || R4.destroy(n, new y3());
          }), this.body = f3;
        }
        onData(V4) {
          const { res: _5 } = this;
          return _5.push(V4);
        }
        onComplete(V4) {
          const { res: _5 } = this;
          _5.push(null);
        }
        onError(V4) {
          const { ret: _5 } = this;
          this.handler = null, R4.destroy(_5, V4);
        }
      };
      e3(G3, "PipelineHandler");
      let l3 = G3;
      function I5(J5, V4) {
        try {
          const _5 = new l3(J5, V4);
          return this.dispatch({ ...J5, body: _5.req }, _5), _5.ret;
        } catch (_5) {
          return new c2().destroy(_5);
        }
      }
      return e3(I5, "pipeline"), apiPipeline = I5, apiPipeline;
    }
    e3(requireApiPipeline, "requireApiPipeline");
    var apiUpgrade;
    var hasRequiredApiUpgrade;
    function requireApiUpgrade() {
      if (hasRequiredApiUpgrade) return apiUpgrade;
      hasRequiredApiUpgrade = 1;
      const { InvalidArgumentError: A2, SocketError: k4 } = requireErrors(), { AsyncResource: c2 } = require$$5__default$2, B3 = requireUtil$7(), { addSignal: t2, removeSignal: y3 } = requireAbortSignal(), R4 = require$$0__default$1, D3 = class D extends c2 {
        constructor(r6, o) {
          if (!r6 || typeof r6 != "object") throw new A2("invalid opts");
          if (typeof o != "function") throw new A2("invalid callback");
          const { signal: N6, opaque: l3, responseHeaders: I5 } = r6;
          if (N6 && typeof N6.on != "function" && typeof N6.addEventListener != "function") throw new A2("signal must be an EventEmitter or EventTarget");
          super("UNDICI_UPGRADE"), this.responseHeaders = I5 || null, this.opaque = l3 || null, this.callback = o, this.abort = null, this.context = null, t2(this, N6);
        }
        onConnect(r6, o) {
          if (this.reason) {
            r6(this.reason);
            return;
          }
          R4(this.callback), this.abort = r6, this.context = null;
        }
        onHeaders() {
          throw new k4("bad upgrade", null);
        }
        onUpgrade(r6, o, N6) {
          R4(r6 === 101);
          const { callback: l3, opaque: I5, context: p3 } = this;
          y3(this), this.callback = null;
          const b6 = this.responseHeaders === "raw" ? B3.parseRawHeaders(o) : B3.parseHeaders(o);
          this.runInAsyncScope(l3, null, null, { headers: b6, socket: N6, opaque: I5, context: p3 });
        }
        onError(r6) {
          const { callback: o, opaque: N6 } = this;
          y3(this), o && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(o, null, r6, { opaque: N6 });
          }));
        }
      };
      e3(D3, "UpgradeHandler");
      let F2 = D3;
      function Q5(U6, r6) {
        if (r6 === void 0) return new Promise((o, N6) => {
          Q5.call(this, U6, (l3, I5) => l3 ? N6(l3) : o(I5));
        });
        try {
          const o = new F2(U6, r6);
          this.dispatch({ ...U6, method: U6.method || "GET", upgrade: U6.protocol || "Websocket" }, o);
        } catch (o) {
          if (typeof r6 != "function") throw o;
          const N6 = U6?.opaque;
          queueMicrotask(() => r6(o, { opaque: N6 }));
        }
      }
      return e3(Q5, "upgrade"), apiUpgrade = Q5, apiUpgrade;
    }
    e3(requireApiUpgrade, "requireApiUpgrade");
    var apiConnect;
    var hasRequiredApiConnect;
    function requireApiConnect() {
      if (hasRequiredApiConnect) return apiConnect;
      hasRequiredApiConnect = 1;
      const A2 = require$$0__default$1, { AsyncResource: k4 } = require$$5__default$2, { InvalidArgumentError: c2, SocketError: B3 } = requireErrors(), t2 = requireUtil$7(), { addSignal: y3, removeSignal: R4 } = requireAbortSignal(), D3 = class D extends k4 {
        constructor(r6, o) {
          if (!r6 || typeof r6 != "object") throw new c2("invalid opts");
          if (typeof o != "function") throw new c2("invalid callback");
          const { signal: N6, opaque: l3, responseHeaders: I5 } = r6;
          if (N6 && typeof N6.on != "function" && typeof N6.addEventListener != "function") throw new c2("signal must be an EventEmitter or EventTarget");
          super("UNDICI_CONNECT"), this.opaque = l3 || null, this.responseHeaders = I5 || null, this.callback = o, this.abort = null, y3(this, N6);
        }
        onConnect(r6, o) {
          if (this.reason) {
            r6(this.reason);
            return;
          }
          A2(this.callback), this.abort = r6, this.context = o;
        }
        onHeaders() {
          throw new B3("bad connect", null);
        }
        onUpgrade(r6, o, N6) {
          const { callback: l3, opaque: I5, context: p3 } = this;
          R4(this), this.callback = null;
          let b6 = o;
          b6 != null && (b6 = this.responseHeaders === "raw" ? t2.parseRawHeaders(o) : t2.parseHeaders(o)), this.runInAsyncScope(l3, null, null, { statusCode: r6, headers: b6, socket: N6, opaque: I5, context: p3 });
        }
        onError(r6) {
          const { callback: o, opaque: N6 } = this;
          R4(this), o && (this.callback = null, queueMicrotask(() => {
            this.runInAsyncScope(o, null, r6, { opaque: N6 });
          }));
        }
      };
      e3(D3, "ConnectHandler");
      let F2 = D3;
      function Q5(U6, r6) {
        if (r6 === void 0) return new Promise((o, N6) => {
          Q5.call(this, U6, (l3, I5) => l3 ? N6(l3) : o(I5));
        });
        try {
          const o = new F2(U6, r6);
          this.dispatch({ ...U6, method: "CONNECT" }, o);
        } catch (o) {
          if (typeof r6 != "function") throw o;
          const N6 = U6?.opaque;
          queueMicrotask(() => r6(o, { opaque: N6 }));
        }
      }
      return e3(Q5, "connect"), apiConnect = Q5, apiConnect;
    }
    e3(requireApiConnect, "requireApiConnect");
    var hasRequiredApi;
    function requireApi() {
      return hasRequiredApi || (hasRequiredApi = 1, api.request = requireApiRequest(), api.stream = requireApiStream(), api.pipeline = requireApiPipeline(), api.upgrade = requireApiUpgrade(), api.connect = requireApiConnect()), api;
    }
    e3(requireApi, "requireApi");
    var mockErrors;
    var hasRequiredMockErrors;
    function requireMockErrors() {
      if (hasRequiredMockErrors) return mockErrors;
      hasRequiredMockErrors = 1;
      const { UndiciError: A2 } = requireErrors(), c2 = class c3 extends A2 {
        constructor(t2) {
          super(t2), Error.captureStackTrace(this, c3), this.name = "MockNotMatchedError", this.message = t2 || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
        }
      };
      e3(c2, "MockNotMatchedError");
      let k4 = c2;
      return mockErrors = { MockNotMatchedError: k4 }, mockErrors;
    }
    e3(requireMockErrors, "requireMockErrors");
    var mockSymbols;
    var hasRequiredMockSymbols;
    function requireMockSymbols() {
      return hasRequiredMockSymbols || (hasRequiredMockSymbols = 1, mockSymbols = { kAgent: Symbol("agent"), kOptions: Symbol("options"), kFactory: Symbol("factory"), kDispatches: Symbol("dispatches"), kDispatchKey: Symbol("dispatch key"), kDefaultHeaders: Symbol("default headers"), kDefaultTrailers: Symbol("default trailers"), kContentLength: Symbol("content length"), kMockAgent: Symbol("mock agent"), kMockAgentSet: Symbol("mock agent set"), kMockAgentGet: Symbol("mock agent get"), kMockDispatch: Symbol("mock dispatch"), kClose: Symbol("close"), kOriginalClose: Symbol("original agent close"), kOrigin: Symbol("origin"), kIsMockActive: Symbol("is mock active"), kNetConnect: Symbol("net connect"), kGetNetConnect: Symbol("get net connect"), kConnected: Symbol("connected") }), mockSymbols;
    }
    e3(requireMockSymbols, "requireMockSymbols");
    var mockUtils;
    var hasRequiredMockUtils;
    function requireMockUtils() {
      if (hasRequiredMockUtils) return mockUtils;
      hasRequiredMockUtils = 1;
      const { MockNotMatchedError: A2 } = requireMockErrors(), { kDispatches: k4, kMockAgent: c2, kOriginalDispatch: B3, kOrigin: t2, kGetNetConnect: y3 } = requireMockSymbols(), { buildURL: R4 } = requireUtil$7(), { STATUS_CODES: F2 } = http__default, { types: { isPromise: Q5 } } = require$$0__default$3;
      function D3(C5, w5) {
        return typeof C5 == "string" ? C5 === w5 : C5 instanceof RegExp ? C5.test(w5) : typeof C5 == "function" ? C5(w5) === true : false;
      }
      e3(D3, "matchValue");
      function U6(C5) {
        return Object.fromEntries(Object.entries(C5).map(([w5, S6]) => [w5.toLocaleLowerCase(), S6]));
      }
      e3(U6, "lowerCaseEntries");
      function r6(C5, w5) {
        if (Array.isArray(C5)) {
          for (let S6 = 0; S6 < C5.length; S6 += 2) if (C5[S6].toLocaleLowerCase() === w5.toLocaleLowerCase()) return C5[S6 + 1];
          return;
        } else return typeof C5.get == "function" ? C5.get(w5) : U6(C5)[w5.toLocaleLowerCase()];
      }
      e3(r6, "getHeaderByName");
      function o(C5) {
        const w5 = C5.slice(), S6 = [];
        for (let x5 = 0; x5 < w5.length; x5 += 2) S6.push([w5[x5], w5[x5 + 1]]);
        return Object.fromEntries(S6);
      }
      e3(o, "buildHeadersFromArray");
      function N6(C5, w5) {
        if (typeof C5.headers == "function") return Array.isArray(w5) && (w5 = o(w5)), C5.headers(w5 ? U6(w5) : {});
        if (typeof C5.headers > "u") return true;
        if (typeof w5 != "object" || typeof C5.headers != "object") return false;
        for (const [S6, x5] of Object.entries(C5.headers)) {
          const z4 = r6(w5, S6);
          if (!D3(x5, z4)) return false;
        }
        return true;
      }
      e3(N6, "matchHeaders");
      function l3(C5) {
        if (typeof C5 != "string") return C5;
        const w5 = C5.split("?");
        if (w5.length !== 2) return C5;
        const S6 = new URLSearchParams(w5.pop());
        return S6.sort(), [...w5, S6.toString()].join("?");
      }
      e3(l3, "safeUrl");
      function I5(C5, { path: w5, method: S6, body: x5, headers: z4 }) {
        const $6 = D3(C5.path, w5), K4 = D3(C5.method, S6), nA = typeof C5.body < "u" ? D3(C5.body, x5) : true, iA = N6(C5, z4);
        return $6 && K4 && nA && iA;
      }
      e3(I5, "matchKey");
      function p3(C5) {
        return Buffer.isBuffer(C5) || C5 instanceof Uint8Array || C5 instanceof ArrayBuffer ? C5 : typeof C5 == "object" ? JSON.stringify(C5) : C5.toString();
      }
      e3(p3, "getResponseData");
      function b6(C5, w5) {
        const S6 = w5.query ? R4(w5.path, w5.query) : w5.path, x5 = typeof S6 == "string" ? l3(S6) : S6;
        let z4 = C5.filter(({ consumed: $6 }) => !$6).filter(({ path: $6 }) => D3(l3($6), x5));
        if (z4.length === 0) throw new A2(`Mock dispatch not matched for path '${x5}'`);
        if (z4 = z4.filter(({ method: $6 }) => D3($6, w5.method)), z4.length === 0) throw new A2(`Mock dispatch not matched for method '${w5.method}' on path '${x5}'`);
        if (z4 = z4.filter(({ body: $6 }) => typeof $6 < "u" ? D3($6, w5.body) : true), z4.length === 0) throw new A2(`Mock dispatch not matched for body '${w5.body}' on path '${x5}'`);
        if (z4 = z4.filter(($6) => N6($6, w5.headers)), z4.length === 0) {
          const $6 = typeof w5.headers == "object" ? JSON.stringify(w5.headers) : w5.headers;
          throw new A2(`Mock dispatch not matched for headers '${$6}' on path '${x5}'`);
        }
        return z4[0];
      }
      e3(b6, "getMockDispatch");
      function G3(C5, w5, S6) {
        const x5 = { timesInvoked: 0, times: 1, persist: false, consumed: false }, z4 = typeof S6 == "function" ? { callback: S6 } : { ...S6 }, $6 = { ...x5, ...w5, pending: true, data: { error: null, ...z4 } };
        return C5.push($6), $6;
      }
      e3(G3, "addMockDispatch");
      function J5(C5, w5) {
        const S6 = C5.findIndex((x5) => x5.consumed ? I5(x5, w5) : false);
        S6 !== -1 && C5.splice(S6, 1);
      }
      e3(J5, "deleteMockDispatch");
      function V4(C5) {
        const { path: w5, method: S6, body: x5, headers: z4, query: $6 } = C5;
        return { path: w5, method: S6, body: x5, headers: z4, query: $6 };
      }
      e3(V4, "buildKey");
      function _5(C5) {
        const w5 = Object.keys(C5), S6 = [];
        for (let x5 = 0; x5 < w5.length; ++x5) {
          const z4 = w5[x5], $6 = C5[z4], K4 = Buffer.from(`${z4}`);
          if (Array.isArray($6)) for (let nA = 0; nA < $6.length; ++nA) S6.push(K4, Buffer.from(`${$6[nA]}`));
          else S6.push(K4, Buffer.from(`${$6}`));
        }
        return S6;
      }
      e3(_5, "generateKeyValues");
      function q6(C5) {
        return F2[C5] || "unknown";
      }
      e3(q6, "getStatusText");
      async function M4(C5) {
        const w5 = [];
        for await (const S6 of C5) w5.push(S6);
        return Buffer.concat(w5).toString("utf8");
      }
      e3(M4, "getResponse");
      function Y4(C5, w5) {
        const S6 = V4(C5), x5 = b6(this[k4], S6);
        x5.timesInvoked++, x5.data.callback && (x5.data = { ...x5.data, ...x5.data.callback(C5) });
        const { data: { statusCode: z4, data: $6, headers: K4, trailers: nA, error: iA }, delay: uA, persist: RA } = x5, { timesInvoked: IA, times: CA } = x5;
        if (x5.consumed = !RA && IA >= CA, x5.pending = IA < CA, iA !== null) return J5(this[k4], S6), w5.onError(iA), true;
        typeof uA == "number" && uA > 0 ? setTimeout(() => {
          pA(this[k4]);
        }, uA) : pA(this[k4]);
        function pA(kA, bA = $6) {
          const gA = Array.isArray(C5.headers) ? o(C5.headers) : C5.headers, DA = typeof bA == "function" ? bA({ ...C5, headers: gA }) : bA;
          if (Q5(DA)) {
            DA.then((sA) => pA(kA, sA));
            return;
          }
          const oA = p3(DA), aA = _5(K4), EA = _5(nA);
          w5.onConnect?.((sA) => w5.onError(sA), null), w5.onHeaders?.(z4, aA, fA, q6(z4)), w5.onData?.(Buffer.from(oA)), w5.onComplete?.(EA), J5(kA, S6);
        }
        e3(pA, "handleReply");
        function fA() {
        }
        return e3(fA, "resume"), true;
      }
      e3(Y4, "mockDispatch");
      function m4() {
        const C5 = this[c2], w5 = this[t2], S6 = this[B3];
        return e3(function(z4, $6) {
          if (C5.isMockActive) try {
            Y4.call(this, z4, $6);
          } catch (K4) {
            if (K4 instanceof A2) {
              const nA = C5[y3]();
              if (nA === false) throw new A2(`${K4.message}: subsequent request to origin ${w5} was not allowed (net.connect disabled)`);
              if (f3(nA, w5)) S6.call(this, z4, $6);
              else throw new A2(`${K4.message}: subsequent request to origin ${w5} was not allowed (net.connect is not enabled for this origin)`);
            } else throw K4;
          }
          else S6.call(this, z4, $6);
        }, "dispatch");
      }
      e3(m4, "buildMockDispatch");
      function f3(C5, w5) {
        const S6 = new URL(w5);
        return C5 === true ? true : !!(Array.isArray(C5) && C5.some((x5) => D3(x5, S6.host)));
      }
      e3(f3, "checkNetConnect");
      function n(C5) {
        if (C5) {
          const { agent: w5, ...S6 } = C5;
          return S6;
        }
      }
      return e3(n, "buildMockOptions"), mockUtils = { getResponseData: p3, getMockDispatch: b6, addMockDispatch: G3, deleteMockDispatch: J5, buildKey: V4, generateKeyValues: _5, matchValue: D3, getResponse: M4, getStatusText: q6, mockDispatch: Y4, buildMockDispatch: m4, checkNetConnect: f3, buildMockOptions: n, getHeaderByName: r6, buildHeadersFromArray: o }, mockUtils;
    }
    e3(requireMockUtils, "requireMockUtils");
    var mockInterceptor = {};
    var hasRequiredMockInterceptor;
    function requireMockInterceptor() {
      if (hasRequiredMockInterceptor) return mockInterceptor;
      hasRequiredMockInterceptor = 1;
      const { getResponseData: A2, buildKey: k4, addMockDispatch: c2 } = requireMockUtils(), { kDispatches: B3, kDispatchKey: t2, kDefaultHeaders: y3, kDefaultTrailers: R4, kContentLength: F2, kMockDispatch: Q5 } = requireMockSymbols(), { InvalidArgumentError: D3 } = requireErrors(), { buildURL: U6 } = requireUtil$7(), N6 = class N {
        constructor(p3) {
          this[Q5] = p3;
        }
        delay(p3) {
          if (typeof p3 != "number" || !Number.isInteger(p3) || p3 <= 0) throw new D3("waitInMs must be a valid integer > 0");
          return this[Q5].delay = p3, this;
        }
        persist() {
          return this[Q5].persist = true, this;
        }
        times(p3) {
          if (typeof p3 != "number" || !Number.isInteger(p3) || p3 <= 0) throw new D3("repeatTimes must be a valid integer > 0");
          return this[Q5].times = p3, this;
        }
      };
      e3(N6, "MockScope");
      let r6 = N6;
      const l3 = class l {
        constructor(p3, b6) {
          if (typeof p3 != "object") throw new D3("opts must be an object");
          if (typeof p3.path > "u") throw new D3("opts.path must be defined");
          if (typeof p3.method > "u" && (p3.method = "GET"), typeof p3.path == "string") if (p3.query) p3.path = U6(p3.path, p3.query);
          else {
            const G3 = new URL(p3.path, "data://");
            p3.path = G3.pathname + G3.search;
          }
          typeof p3.method == "string" && (p3.method = p3.method.toUpperCase()), this[t2] = k4(p3), this[B3] = b6, this[y3] = {}, this[R4] = {}, this[F2] = false;
        }
        createMockScopeDispatchData({ statusCode: p3, data: b6, responseOptions: G3 }) {
          const J5 = A2(b6), V4 = this[F2] ? { "content-length": J5.length } : {}, _5 = { ...this[y3], ...V4, ...G3.headers }, q6 = { ...this[R4], ...G3.trailers };
          return { statusCode: p3, data: b6, headers: _5, trailers: q6 };
        }
        validateReplyParameters(p3) {
          if (typeof p3.statusCode > "u") throw new D3("statusCode must be defined");
          if (typeof p3.responseOptions != "object" || p3.responseOptions === null) throw new D3("responseOptions must be an object");
        }
        reply(p3) {
          if (typeof p3 == "function") {
            const V4 = e3((q6) => {
              const M4 = p3(q6);
              if (typeof M4 != "object" || M4 === null) throw new D3("reply options callback must return an object");
              const Y4 = { data: "", responseOptions: {}, ...M4 };
              return this.validateReplyParameters(Y4), { ...this.createMockScopeDispatchData(Y4) };
            }, "wrappedDefaultsCallback"), _5 = c2(this[B3], this[t2], V4);
            return new r6(_5);
          }
          const b6 = { statusCode: p3, data: arguments[1] === void 0 ? "" : arguments[1], responseOptions: arguments[2] === void 0 ? {} : arguments[2] };
          this.validateReplyParameters(b6);
          const G3 = this.createMockScopeDispatchData(b6), J5 = c2(this[B3], this[t2], G3);
          return new r6(J5);
        }
        replyWithError(p3) {
          if (typeof p3 > "u") throw new D3("error must be defined");
          const b6 = c2(this[B3], this[t2], { error: p3 });
          return new r6(b6);
        }
        defaultReplyHeaders(p3) {
          if (typeof p3 > "u") throw new D3("headers must be defined");
          return this[y3] = p3, this;
        }
        defaultReplyTrailers(p3) {
          if (typeof p3 > "u") throw new D3("trailers must be defined");
          return this[R4] = p3, this;
        }
        replyContentLength() {
          return this[F2] = true, this;
        }
      };
      e3(l3, "MockInterceptor");
      let o = l3;
      return mockInterceptor.MockInterceptor = o, mockInterceptor.MockScope = r6, mockInterceptor;
    }
    e3(requireMockInterceptor, "requireMockInterceptor");
    var mockClient;
    var hasRequiredMockClient;
    function requireMockClient() {
      if (hasRequiredMockClient) return mockClient;
      hasRequiredMockClient = 1;
      const { promisify: A2 } = require$$0__default$3, k4 = requireClient(), { buildMockDispatch: c2 } = requireMockUtils(), { kDispatches: B3, kMockAgent: t2, kClose: y3, kOriginalClose: R4, kOrigin: F2, kOriginalDispatch: Q5, kConnected: D3 } = requireMockSymbols(), { MockInterceptor: U6 } = requireMockInterceptor(), r6 = requireSymbols$4(), { InvalidArgumentError: o } = requireErrors(), l3 = class l extends k4 {
        constructor(p3, b6) {
          if (super(p3, b6), !b6 || !b6.agent || typeof b6.agent.dispatch != "function") throw new o("Argument opts.agent must implement Agent");
          this[t2] = b6.agent, this[F2] = p3, this[B3] = [], this[D3] = 1, this[Q5] = this.dispatch, this[R4] = this.close.bind(this), this.dispatch = c2.call(this), this.close = this[y3];
        }
        get [r6.kConnected]() {
          return this[D3];
        }
        intercept(p3) {
          return new U6(p3, this[B3]);
        }
        async [y3]() {
          await A2(this[R4])(), this[D3] = 0, this[t2][r6.kClients].delete(this[F2]);
        }
      };
      e3(l3, "MockClient");
      let N6 = l3;
      return mockClient = N6, mockClient;
    }
    e3(requireMockClient, "requireMockClient");
    var mockPool;
    var hasRequiredMockPool;
    function requireMockPool() {
      if (hasRequiredMockPool) return mockPool;
      hasRequiredMockPool = 1;
      const { promisify: A2 } = require$$0__default$3, k4 = requirePool(), { buildMockDispatch: c2 } = requireMockUtils(), { kDispatches: B3, kMockAgent: t2, kClose: y3, kOriginalClose: R4, kOrigin: F2, kOriginalDispatch: Q5, kConnected: D3 } = requireMockSymbols(), { MockInterceptor: U6 } = requireMockInterceptor(), r6 = requireSymbols$4(), { InvalidArgumentError: o } = requireErrors(), l3 = class l extends k4 {
        constructor(p3, b6) {
          if (super(p3, b6), !b6 || !b6.agent || typeof b6.agent.dispatch != "function") throw new o("Argument opts.agent must implement Agent");
          this[t2] = b6.agent, this[F2] = p3, this[B3] = [], this[D3] = 1, this[Q5] = this.dispatch, this[R4] = this.close.bind(this), this.dispatch = c2.call(this), this.close = this[y3];
        }
        get [r6.kConnected]() {
          return this[D3];
        }
        intercept(p3) {
          return new U6(p3, this[B3]);
        }
        async [y3]() {
          await A2(this[R4])(), this[D3] = 0, this[t2][r6.kClients].delete(this[F2]);
        }
      };
      e3(l3, "MockPool");
      let N6 = l3;
      return mockPool = N6, mockPool;
    }
    e3(requireMockPool, "requireMockPool");
    var pluralizer;
    var hasRequiredPluralizer;
    function requirePluralizer() {
      var c2;
      if (hasRequiredPluralizer) return pluralizer;
      hasRequiredPluralizer = 1;
      const A2 = { pronoun: "it", is: "is", was: "was", this: "this" }, k4 = { pronoun: "they", is: "are", was: "were", this: "these" };
      return pluralizer = (c2 = class {
        constructor(t2, y3) {
          this.singular = t2, this.plural = y3;
        }
        pluralize(t2) {
          const y3 = t2 === 1, R4 = y3 ? A2 : k4, F2 = y3 ? this.singular : this.plural;
          return { ...R4, count: t2, noun: F2 };
        }
      }, e3(c2, "Pluralizer"), c2), pluralizer;
    }
    e3(requirePluralizer, "requirePluralizer");
    var pendingInterceptorsFormatter;
    var hasRequiredPendingInterceptorsFormatter;
    function requirePendingInterceptorsFormatter() {
      var t2;
      if (hasRequiredPendingInterceptorsFormatter) return pendingInterceptorsFormatter;
      hasRequiredPendingInterceptorsFormatter = 1;
      const { Transform: A2 } = Stream__default, { Console: k4 } = require$$1__default$2, c2 = process.versions.icu ? "\u2705" : "Y ", B3 = process.versions.icu ? "\u274C" : "N ";
      return pendingInterceptorsFormatter = (t2 = class {
        constructor({ disableColors: R4 } = {}) {
          this.transform = new A2({ transform(F2, Q5, D3) {
            D3(null, F2);
          } }), this.logger = new k4({ stdout: this.transform, inspectOptions: { colors: !R4 && !process.env.CI } });
        }
        format(R4) {
          const F2 = R4.map(({ method: Q5, path: D3, data: { statusCode: U6 }, persist: r6, times: o, timesInvoked: N6, origin: l3 }) => ({ Method: Q5, Origin: l3, Path: D3, "Status code": U6, Persistent: r6 ? c2 : B3, Invocations: N6, Remaining: r6 ? 1 / 0 : o - N6 }));
          return this.logger.table(F2), this.transform.read().toString();
        }
      }, e3(t2, "PendingInterceptorsFormatter"), t2), pendingInterceptorsFormatter;
    }
    e3(requirePendingInterceptorsFormatter, "requirePendingInterceptorsFormatter");
    var mockAgent;
    var hasRequiredMockAgent;
    function requireMockAgent() {
      if (hasRequiredMockAgent) return mockAgent;
      hasRequiredMockAgent = 1;
      const { kClients: A2 } = requireSymbols$4(), k4 = requireAgent(), { kAgent: c2, kMockAgentSet: B3, kMockAgentGet: t2, kDispatches: y3, kIsMockActive: R4, kNetConnect: F2, kGetNetConnect: Q5, kOptions: D3, kFactory: U6 } = requireMockSymbols(), r6 = requireMockClient(), o = requireMockPool(), { matchValue: N6, buildMockOptions: l3 } = requireMockUtils(), { InvalidArgumentError: I5, UndiciError: p3 } = requireErrors(), b6 = requireDispatcher(), G3 = requirePluralizer(), J5 = requirePendingInterceptorsFormatter(), _5 = class _ extends b6 {
        constructor(M4) {
          if (super(M4), this[F2] = true, this[R4] = true, M4?.agent && typeof M4.agent.dispatch != "function") throw new I5("Argument opts.agent must implement Agent");
          const Y4 = M4?.agent ? M4.agent : new k4(M4);
          this[c2] = Y4, this[A2] = Y4[A2], this[D3] = l3(M4);
        }
        get(M4) {
          let Y4 = this[t2](M4);
          return Y4 || (Y4 = this[U6](M4), this[B3](M4, Y4)), Y4;
        }
        dispatch(M4, Y4) {
          return this.get(M4.origin), this[c2].dispatch(M4, Y4);
        }
        async close() {
          await this[c2].close(), this[A2].clear();
        }
        deactivate() {
          this[R4] = false;
        }
        activate() {
          this[R4] = true;
        }
        enableNetConnect(M4) {
          if (typeof M4 == "string" || typeof M4 == "function" || M4 instanceof RegExp) Array.isArray(this[F2]) ? this[F2].push(M4) : this[F2] = [M4];
          else if (typeof M4 > "u") this[F2] = true;
          else throw new I5("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
        disableNetConnect() {
          this[F2] = false;
        }
        get isMockActive() {
          return this[R4];
        }
        [B3](M4, Y4) {
          this[A2].set(M4, Y4);
        }
        [U6](M4) {
          const Y4 = Object.assign({ agent: this }, this[D3]);
          return this[D3] && this[D3].connections === 1 ? new r6(M4, Y4) : new o(M4, Y4);
        }
        [t2](M4) {
          const Y4 = this[A2].get(M4);
          if (Y4) return Y4;
          if (typeof M4 != "string") {
            const m4 = this[U6]("http://localhost:9999");
            return this[B3](M4, m4), m4;
          }
          for (const [m4, f3] of Array.from(this[A2])) if (f3 && typeof m4 != "string" && N6(m4, M4)) {
            const n = this[U6](M4);
            return this[B3](M4, n), n[y3] = f3[y3], n;
          }
        }
        [Q5]() {
          return this[F2];
        }
        pendingInterceptors() {
          const M4 = this[A2];
          return Array.from(M4.entries()).flatMap(([Y4, m4]) => m4[y3].map((f3) => ({ ...f3, origin: Y4 }))).filter(({ pending: Y4 }) => Y4);
        }
        assertNoPendingInterceptors({ pendingInterceptorsFormatter: M4 = new J5() } = {}) {
          const Y4 = this.pendingInterceptors();
          if (Y4.length === 0) return;
          const m4 = new G3("interceptor", "interceptors").pluralize(Y4.length);
          throw new p3(`
${m4.count} ${m4.noun} ${m4.is} pending:

${M4.format(Y4)}
`.trim());
        }
      };
      e3(_5, "MockAgent");
      let V4 = _5;
      return mockAgent = V4, mockAgent;
    }
    e3(requireMockAgent, "requireMockAgent");
    var global2;
    var hasRequiredGlobal;
    function requireGlobal() {
      if (hasRequiredGlobal) return global2;
      hasRequiredGlobal = 1;
      const A2 = Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError: k4 } = requireErrors(), c2 = requireAgent();
      t2() === void 0 && B3(new c2());
      function B3(y3) {
        if (!y3 || typeof y3.dispatch != "function") throw new k4("Argument agent must implement Agent");
        Object.defineProperty(globalThis, A2, { value: y3, writable: true, enumerable: false, configurable: false });
      }
      e3(B3, "setGlobalDispatcher");
      function t2() {
        return globalThis[A2];
      }
      return e3(t2, "getGlobalDispatcher"), global2 = { setGlobalDispatcher: B3, getGlobalDispatcher: t2 }, global2;
    }
    e3(requireGlobal, "requireGlobal");
    var decoratorHandler;
    var hasRequiredDecoratorHandler;
    function requireDecoratorHandler() {
      var A2, k4;
      return hasRequiredDecoratorHandler || (hasRequiredDecoratorHandler = 1, decoratorHandler = (k4 = class {
        constructor(B3) {
          SA(this, A2);
          if (typeof B3 != "object" || B3 === null) throw new TypeError("handler must be an object");
          mA(this, A2, B3);
        }
        onConnect(...B3) {
          return Z4(this, A2).onConnect?.(...B3);
        }
        onError(...B3) {
          return Z4(this, A2).onError?.(...B3);
        }
        onUpgrade(...B3) {
          return Z4(this, A2).onUpgrade?.(...B3);
        }
        onResponseStarted(...B3) {
          return Z4(this, A2).onResponseStarted?.(...B3);
        }
        onHeaders(...B3) {
          return Z4(this, A2).onHeaders?.(...B3);
        }
        onData(...B3) {
          return Z4(this, A2).onData?.(...B3);
        }
        onComplete(...B3) {
          return Z4(this, A2).onComplete?.(...B3);
        }
        onBodySent(...B3) {
          return Z4(this, A2).onBodySent?.(...B3);
        }
      }, A2 = /* @__PURE__ */ new WeakMap(), e3(k4, "DecoratorHandler"), k4)), decoratorHandler;
    }
    e3(requireDecoratorHandler, "requireDecoratorHandler");
    var redirect;
    var hasRequiredRedirect;
    function requireRedirect() {
      if (hasRequiredRedirect) return redirect;
      hasRequiredRedirect = 1;
      const A2 = requireRedirectHandler();
      return redirect = e3((k4) => {
        const c2 = k4?.maxRedirections;
        return (B3) => e3(function(y3, R4) {
          const { maxRedirections: F2 = c2, ...Q5 } = y3;
          if (!F2) return B3(y3, R4);
          const D3 = new A2(B3, F2, y3, R4);
          return B3(Q5, D3);
        }, "redirectInterceptor");
      }, "redirect"), redirect;
    }
    e3(requireRedirect, "requireRedirect");
    var retry;
    var hasRequiredRetry;
    function requireRetry() {
      if (hasRequiredRetry) return retry;
      hasRequiredRetry = 1;
      const A2 = requireRetryHandler();
      return retry = e3((k4) => (c2) => e3(function(t2, y3) {
        return c2(t2, new A2({ ...t2, retryOptions: { ...k4, ...t2.retryOptions } }, { handler: y3, dispatch: c2 }));
      }, "retryInterceptor"), "retry"), retry;
    }
    e3(requireRetry, "requireRetry");
    var dump;
    var hasRequiredDump;
    function requireDump() {
      var R4, F2, Q5, D3, U6, r6, o, N6, xe3;
      if (hasRequiredDump) return dump;
      hasRequiredDump = 1;
      const A2 = requireUtil$7(), { InvalidArgumentError: k4, RequestAbortedError: c2 } = requireErrors(), B3 = requireDecoratorHandler(), I5 = class I extends B3 {
        constructor({ maxSize: G3 }, J5) {
          super(J5);
          SA(this, N6);
          SA(this, R4, 1024 * 1024);
          SA(this, F2, null);
          SA(this, Q5, false);
          SA(this, D3, false);
          SA(this, U6, 0);
          SA(this, r6, null);
          SA(this, o, null);
          if (G3 != null && (!Number.isFinite(G3) || G3 < 1)) throw new k4("maxSize must be a number greater than 0");
          mA(this, R4, G3 ?? Z4(this, R4)), mA(this, o, J5);
        }
        onConnect(G3) {
          mA(this, F2, G3), Z4(this, o).onConnect(ee3(this, N6, xe3).bind(this));
        }
        onHeaders(G3, J5, V4, _5) {
          const M4 = A2.parseHeaders(J5)["content-length"];
          if (M4 != null && M4 > Z4(this, R4)) throw new c2(`Response size (${M4}) larger than maxSize (${Z4(this, R4)})`);
          return Z4(this, D3) ? true : Z4(this, o).onHeaders(G3, J5, V4, _5);
        }
        onError(G3) {
          Z4(this, Q5) || (G3 = Z4(this, r6) ?? G3, Z4(this, o).onError(G3));
        }
        onData(G3) {
          return mA(this, U6, Z4(this, U6) + G3.length), Z4(this, U6) >= Z4(this, R4) && (mA(this, Q5, true), Z4(this, D3) ? Z4(this, o).onError(Z4(this, r6)) : Z4(this, o).onComplete([])), true;
        }
        onComplete(G3) {
          if (!Z4(this, Q5)) {
            if (Z4(this, D3)) {
              Z4(this, o).onError(this.reason);
              return;
            }
            Z4(this, o).onComplete(G3);
          }
        }
      };
      R4 = /* @__PURE__ */ new WeakMap(), F2 = /* @__PURE__ */ new WeakMap(), Q5 = /* @__PURE__ */ new WeakMap(), D3 = /* @__PURE__ */ new WeakMap(), U6 = /* @__PURE__ */ new WeakMap(), r6 = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new WeakMap(), N6 = /* @__PURE__ */ new WeakSet(), xe3 = e3(function(G3) {
        mA(this, D3, true), mA(this, r6, G3);
      }, "#customAbort"), e3(I5, "DumpHandler");
      let t2 = I5;
      function y3({ maxSize: p3 } = { maxSize: 1024 * 1024 }) {
        return (b6) => e3(function(J5, V4) {
          const { dumpMaxSize: _5 = p3 } = J5, q6 = new t2({ maxSize: _5 }, V4);
          return b6(J5, q6);
        }, "Intercept");
      }
      return e3(y3, "createDumpInterceptor"), dump = y3, dump;
    }
    e3(requireDump, "requireDump");
    var dns;
    var hasRequiredDns;
    function requireDns() {
      var Q5, D3, U6, r6, We2, qe, I5, p3, b6, G3, J5;
      if (hasRequiredDns) return dns;
      hasRequiredDns = 1;
      const { isIP: A2 } = require$$0__default$2, { lookup: k4 } = require$$1__default$3, c2 = requireDecoratorHandler(), { InvalidArgumentError: B3, InformationalError: t2 } = requireErrors(), y3 = Math.pow(2, 31) - 1, l3 = class l {
        constructor(q6) {
          SA(this, r6);
          SA(this, Q5, 0);
          SA(this, D3, 0);
          SA(this, U6, /* @__PURE__ */ new Map());
          $A(this, "dualStack", true);
          $A(this, "affinity", null);
          $A(this, "lookup", null);
          $A(this, "pick", null);
          mA(this, Q5, q6.maxTTL), mA(this, D3, q6.maxItems), this.dualStack = q6.dualStack, this.affinity = q6.affinity, this.lookup = q6.lookup ?? ee3(this, r6, We2), this.pick = q6.pick ?? ee3(this, r6, qe);
        }
        get full() {
          return Z4(this, U6).size === Z4(this, D3);
        }
        runLookup(q6, M4, Y4) {
          const m4 = Z4(this, U6).get(q6.hostname);
          if (m4 == null && this.full) {
            Y4(null, q6.origin);
            return;
          }
          const f3 = { affinity: this.affinity, dualStack: this.dualStack, lookup: this.lookup, pick: this.pick, ...M4.dns, maxTTL: Z4(this, Q5), maxItems: Z4(this, D3) };
          if (m4 == null) this.lookup(q6, f3, (n, C5) => {
            if (n || C5 == null || C5.length === 0) {
              Y4(n ?? new t2("No DNS entries found"));
              return;
            }
            this.setRecords(q6, C5);
            const w5 = Z4(this, U6).get(q6.hostname), S6 = this.pick(q6, w5, f3.affinity);
            let x5;
            typeof S6.port == "number" ? x5 = `:${S6.port}` : q6.port !== "" ? x5 = `:${q6.port}` : x5 = "", Y4(null, `${q6.protocol}//${S6.family === 6 ? `[${S6.address}]` : S6.address}${x5}`);
          });
          else {
            const n = this.pick(q6, m4, f3.affinity);
            if (n == null) {
              Z4(this, U6).delete(q6.hostname), this.runLookup(q6, M4, Y4);
              return;
            }
            let C5;
            typeof n.port == "number" ? C5 = `:${n.port}` : q6.port !== "" ? C5 = `:${q6.port}` : C5 = "", Y4(null, `${q6.protocol}//${n.family === 6 ? `[${n.address}]` : n.address}${C5}`);
          }
        }
        setRecords(q6, M4) {
          const Y4 = Date.now(), m4 = { records: { 4: null, 6: null } };
          for (const f3 of M4) {
            f3.timestamp = Y4, typeof f3.ttl == "number" ? f3.ttl = Math.min(f3.ttl, Z4(this, Q5)) : f3.ttl = Z4(this, Q5);
            const n = m4.records[f3.family] ?? { ips: [] };
            n.ips.push(f3), m4.records[f3.family] = n;
          }
          Z4(this, U6).set(q6.hostname, m4);
        }
        getHandler(q6, M4) {
          return new F2(this, q6, M4);
        }
      };
      Q5 = /* @__PURE__ */ new WeakMap(), D3 = /* @__PURE__ */ new WeakMap(), U6 = /* @__PURE__ */ new WeakMap(), r6 = /* @__PURE__ */ new WeakSet(), We2 = e3(function(q6, M4, Y4) {
        k4(q6.hostname, { all: true, family: this.dualStack === false ? this.affinity : 0, order: "ipv4first" }, (m4, f3) => {
          if (m4) return Y4(m4);
          const n = /* @__PURE__ */ new Map();
          for (const C5 of f3) n.set(`${C5.address}:${C5.family}`, C5);
          Y4(null, n.values());
        });
      }, "#defaultLookup"), qe = e3(function(q6, M4, Y4) {
        let m4 = null;
        const { records: f3, offset: n } = M4;
        let C5;
        if (this.dualStack ? (Y4 == null && (n == null || n === y3 ? (M4.offset = 0, Y4 = 4) : (M4.offset++, Y4 = (M4.offset & 1) === 1 ? 6 : 4)), f3[Y4] != null && f3[Y4].ips.length > 0 ? C5 = f3[Y4] : C5 = f3[Y4 === 4 ? 6 : 4]) : C5 = f3[Y4], C5 == null || C5.ips.length === 0) return m4;
        C5.offset == null || C5.offset === y3 ? C5.offset = 0 : C5.offset++;
        const w5 = C5.offset % C5.ips.length;
        return m4 = C5.ips[w5] ?? null, m4 == null ? m4 : Date.now() - m4.timestamp > m4.ttl ? (C5.ips.splice(w5, 1), this.pick(q6, M4, Y4)) : m4;
      }, "#defaultPick"), e3(l3, "DNSInstance");
      let R4 = l3;
      const V4 = class V extends c2 {
        constructor(M4, { origin: Y4, handler: m4, dispatch: f3 }, n) {
          super(m4);
          SA(this, I5, null);
          SA(this, p3, null);
          SA(this, b6, null);
          SA(this, G3, null);
          SA(this, J5, null);
          mA(this, J5, Y4), mA(this, G3, m4), mA(this, p3, { ...n }), mA(this, I5, M4), mA(this, b6, f3);
        }
        onError(M4) {
          switch (M4.code) {
            case "ETIMEDOUT":
            case "ECONNREFUSED": {
              if (Z4(this, I5).dualStack) {
                Z4(this, I5).runLookup(Z4(this, J5), Z4(this, p3), (Y4, m4) => {
                  if (Y4) return Z4(this, G3).onError(Y4);
                  const f3 = { ...Z4(this, p3), origin: m4 };
                  Z4(this, b6).call(this, f3, this);
                });
                return;
              }
              Z4(this, G3).onError(M4);
              return;
            }
            case "ENOTFOUND":
              Z4(this, I5).deleteRecord(Z4(this, J5));
            default:
              Z4(this, G3).onError(M4);
              break;
          }
        }
      };
      I5 = /* @__PURE__ */ new WeakMap(), p3 = /* @__PURE__ */ new WeakMap(), b6 = /* @__PURE__ */ new WeakMap(), G3 = /* @__PURE__ */ new WeakMap(), J5 = /* @__PURE__ */ new WeakMap(), e3(V4, "DNSDispatchHandler");
      let F2 = V4;
      return dns = e3((_5) => {
        if (_5?.maxTTL != null && (typeof _5?.maxTTL != "number" || _5?.maxTTL < 0)) throw new B3("Invalid maxTTL. Must be a positive number");
        if (_5?.maxItems != null && (typeof _5?.maxItems != "number" || _5?.maxItems < 1)) throw new B3("Invalid maxItems. Must be a positive number and greater than zero");
        if (_5?.affinity != null && _5?.affinity !== 4 && _5?.affinity !== 6) throw new B3("Invalid affinity. Must be either 4 or 6");
        if (_5?.dualStack != null && typeof _5?.dualStack != "boolean") throw new B3("Invalid dualStack. Must be a boolean");
        if (_5?.lookup != null && typeof _5?.lookup != "function") throw new B3("Invalid lookup. Must be a function");
        if (_5?.pick != null && typeof _5?.pick != "function") throw new B3("Invalid pick. Must be a function");
        const q6 = _5?.dualStack ?? true;
        let M4;
        q6 ? M4 = _5?.affinity ?? null : M4 = _5?.affinity ?? 4;
        const Y4 = { maxTTL: _5?.maxTTL ?? 1e4, lookup: _5?.lookup ?? null, pick: _5?.pick ?? null, dualStack: q6, affinity: M4, maxItems: _5?.maxItems ?? 1 / 0 }, m4 = new R4(Y4);
        return (f3) => e3(function(C5, w5) {
          const S6 = C5.origin.constructor === URL ? C5.origin : new URL(C5.origin);
          return A2(S6.hostname) !== 0 ? f3(C5, w5) : (m4.runLookup(S6, C5, (x5, z4) => {
            if (x5) return w5.onError(x5);
            let $6 = null;
            $6 = { ...C5, servername: S6.hostname, origin: z4, headers: { host: S6.hostname, ...C5.headers } }, f3($6, m4.getHandler({ origin: S6, dispatch: f3, handler: w5 }, C5));
          }), true);
        }, "dnsInterceptor");
      }, "dns"), dns;
    }
    e3(requireDns, "requireDns");
    var headers;
    var hasRequiredHeaders;
    function requireHeaders() {
      var q6, M4;
      if (hasRequiredHeaders) return headers;
      hasRequiredHeaders = 1;
      const { kConstruct: A2 } = requireSymbols$4(), { kEnumerableProperty: k4 } = requireUtil$7(), { iteratorMixin: c2, isValidHeaderName: B3, isValidHeaderValue: t2 } = requireUtil$6(), { webidl: y3 } = requireWebidl(), R4 = require$$0__default$1, F2 = require$$0__default$3, Q5 = Symbol("headers map"), D3 = Symbol("headers map sorted");
      function U6(m4) {
        return m4 === 10 || m4 === 13 || m4 === 9 || m4 === 32;
      }
      e3(U6, "isHTTPWhiteSpaceCharCode");
      function r6(m4) {
        let f3 = 0, n = m4.length;
        for (; n > f3 && U6(m4.charCodeAt(n - 1)); ) --n;
        for (; n > f3 && U6(m4.charCodeAt(f3)); ) ++f3;
        return f3 === 0 && n === m4.length ? m4 : m4.substring(f3, n);
      }
      e3(r6, "headerValueNormalize");
      function o(m4, f3) {
        if (Array.isArray(f3)) for (let n = 0; n < f3.length; ++n) {
          const C5 = f3[n];
          if (C5.length !== 2) throw y3.errors.exception({ header: "Headers constructor", message: `expected name/value pair to be length 2, found ${C5.length}.` });
          N6(m4, C5[0], C5[1]);
        }
        else if (typeof f3 == "object" && f3 !== null) {
          const n = Object.keys(f3);
          for (let C5 = 0; C5 < n.length; ++C5) N6(m4, n[C5], f3[n[C5]]);
        } else throw y3.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
      }
      e3(o, "fill");
      function N6(m4, f3, n) {
        if (n = r6(n), B3(f3)) {
          if (!t2(n)) throw y3.errors.invalidArgument({ prefix: "Headers.append", value: n, type: "header value" });
        } else throw y3.errors.invalidArgument({ prefix: "Headers.append", value: f3, type: "header name" });
        if (b6(m4) === "immutable") throw new TypeError("immutable");
        return J5(m4).append(f3, n, false);
      }
      e3(N6, "appendHeader");
      function l3(m4, f3) {
        return m4[0] < f3[0] ? -1 : 1;
      }
      e3(l3, "compareHeaderName");
      const _5 = class _6 {
        constructor(f3) {
          $A(this, "cookies", null);
          f3 instanceof _6 ? (this[Q5] = new Map(f3[Q5]), this[D3] = f3[D3], this.cookies = f3.cookies === null ? null : [...f3.cookies]) : (this[Q5] = new Map(f3), this[D3] = null);
        }
        contains(f3, n) {
          return this[Q5].has(n ? f3 : f3.toLowerCase());
        }
        clear() {
          this[Q5].clear(), this[D3] = null, this.cookies = null;
        }
        append(f3, n, C5) {
          this[D3] = null;
          const w5 = C5 ? f3 : f3.toLowerCase(), S6 = this[Q5].get(w5);
          if (S6) {
            const x5 = w5 === "cookie" ? "; " : ", ";
            this[Q5].set(w5, { name: S6.name, value: `${S6.value}${x5}${n}` });
          } else this[Q5].set(w5, { name: f3, value: n });
          w5 === "set-cookie" && (this.cookies ?? (this.cookies = [])).push(n);
        }
        set(f3, n, C5) {
          this[D3] = null;
          const w5 = C5 ? f3 : f3.toLowerCase();
          w5 === "set-cookie" && (this.cookies = [n]), this[Q5].set(w5, { name: f3, value: n });
        }
        delete(f3, n) {
          this[D3] = null, n || (f3 = f3.toLowerCase()), f3 === "set-cookie" && (this.cookies = null), this[Q5].delete(f3);
        }
        get(f3, n) {
          return this[Q5].get(n ? f3 : f3.toLowerCase())?.value ?? null;
        }
        *[Symbol.iterator]() {
          for (const { 0: f3, 1: { value: n } } of this[Q5]) yield [f3, n];
        }
        get entries() {
          const f3 = {};
          if (this[Q5].size !== 0) for (const { name: n, value: C5 } of this[Q5].values()) f3[n] = C5;
          return f3;
        }
        rawValues() {
          return this[Q5].values();
        }
        get entriesList() {
          const f3 = [];
          if (this[Q5].size !== 0) for (const { 0: n, 1: { name: C5, value: w5 } } of this[Q5]) if (n === "set-cookie") for (const S6 of this.cookies) f3.push([C5, S6]);
          else f3.push([C5, w5]);
          return f3;
        }
        toSortedArray() {
          const f3 = this[Q5].size, n = new Array(f3);
          if (f3 <= 32) {
            if (f3 === 0) return n;
            const C5 = this[Q5][Symbol.iterator](), w5 = C5.next().value;
            n[0] = [w5[0], w5[1].value], R4(w5[1].value !== null);
            for (let S6 = 1, x5 = 0, z4 = 0, $6 = 0, K4 = 0, nA, iA; S6 < f3; ++S6) {
              for (iA = C5.next().value, nA = n[S6] = [iA[0], iA[1].value], R4(nA[1] !== null), $6 = 0, z4 = S6; $6 < z4; ) K4 = $6 + (z4 - $6 >> 1), n[K4][0] <= nA[0] ? $6 = K4 + 1 : z4 = K4;
              if (S6 !== K4) {
                for (x5 = S6; x5 > $6; ) n[x5] = n[--x5];
                n[$6] = nA;
              }
            }
            if (!C5.next().done) throw new TypeError("Unreachable");
            return n;
          } else {
            let C5 = 0;
            for (const { 0: w5, 1: { value: S6 } } of this[Q5]) n[C5++] = [w5, S6], R4(S6 !== null);
            return n.sort(l3);
          }
        }
      };
      e3(_5, "HeadersList");
      let I5 = _5;
      const Y4 = class Y5 {
        constructor(f3 = void 0) {
          SA(this, q6);
          SA(this, M4);
          y3.util.markAsUncloneable(this), f3 !== A2 && (mA(this, M4, new I5()), mA(this, q6, "none"), f3 !== void 0 && (f3 = y3.converters.HeadersInit(f3, "Headers contructor", "init"), o(this, f3)));
        }
        append(f3, n) {
          y3.brandCheck(this, Y5), y3.argumentLengthCheck(arguments, 2, "Headers.append");
          const C5 = "Headers.append";
          return f3 = y3.converters.ByteString(f3, C5, "name"), n = y3.converters.ByteString(n, C5, "value"), N6(this, f3, n);
        }
        delete(f3) {
          if (y3.brandCheck(this, Y5), y3.argumentLengthCheck(arguments, 1, "Headers.delete"), f3 = y3.converters.ByteString(f3, "Headers.delete", "name"), !B3(f3)) throw y3.errors.invalidArgument({ prefix: "Headers.delete", value: f3, type: "header name" });
          if (Z4(this, q6) === "immutable") throw new TypeError("immutable");
          Z4(this, M4).contains(f3, false) && Z4(this, M4).delete(f3, false);
        }
        get(f3) {
          y3.brandCheck(this, Y5), y3.argumentLengthCheck(arguments, 1, "Headers.get");
          const n = "Headers.get";
          if (f3 = y3.converters.ByteString(f3, n, "name"), !B3(f3)) throw y3.errors.invalidArgument({ prefix: n, value: f3, type: "header name" });
          return Z4(this, M4).get(f3, false);
        }
        has(f3) {
          y3.brandCheck(this, Y5), y3.argumentLengthCheck(arguments, 1, "Headers.has");
          const n = "Headers.has";
          if (f3 = y3.converters.ByteString(f3, n, "name"), !B3(f3)) throw y3.errors.invalidArgument({ prefix: n, value: f3, type: "header name" });
          return Z4(this, M4).contains(f3, false);
        }
        set(f3, n) {
          y3.brandCheck(this, Y5), y3.argumentLengthCheck(arguments, 2, "Headers.set");
          const C5 = "Headers.set";
          if (f3 = y3.converters.ByteString(f3, C5, "name"), n = y3.converters.ByteString(n, C5, "value"), n = r6(n), B3(f3)) {
            if (!t2(n)) throw y3.errors.invalidArgument({ prefix: C5, value: n, type: "header value" });
          } else throw y3.errors.invalidArgument({ prefix: C5, value: f3, type: "header name" });
          if (Z4(this, q6) === "immutable") throw new TypeError("immutable");
          Z4(this, M4).set(f3, n, false);
        }
        getSetCookie() {
          y3.brandCheck(this, Y5);
          const f3 = Z4(this, M4).cookies;
          return f3 ? [...f3] : [];
        }
        get [D3]() {
          if (Z4(this, M4)[D3]) return Z4(this, M4)[D3];
          const f3 = [], n = Z4(this, M4).toSortedArray(), C5 = Z4(this, M4).cookies;
          if (C5 === null || C5.length === 1) return Z4(this, M4)[D3] = n;
          for (let w5 = 0; w5 < n.length; ++w5) {
            const { 0: S6, 1: x5 } = n[w5];
            if (S6 === "set-cookie") for (let z4 = 0; z4 < C5.length; ++z4) f3.push([S6, C5[z4]]);
            else f3.push([S6, x5]);
          }
          return Z4(this, M4)[D3] = f3;
        }
        [F2.inspect.custom](f3, n) {
          return n.depth ?? (n.depth = f3), `Headers ${F2.formatWithOptions(n, Z4(this, M4).entries)}`;
        }
        static getHeadersGuard(f3) {
          return Z4(f3, q6);
        }
        static setHeadersGuard(f3, n) {
          mA(f3, q6, n);
        }
        static getHeadersList(f3) {
          return Z4(f3, M4);
        }
        static setHeadersList(f3, n) {
          mA(f3, M4, n);
        }
      };
      q6 = /* @__PURE__ */ new WeakMap(), M4 = /* @__PURE__ */ new WeakMap(), e3(Y4, "Headers");
      let p3 = Y4;
      const { getHeadersGuard: b6, setHeadersGuard: G3, getHeadersList: J5, setHeadersList: V4 } = p3;
      return Reflect.deleteProperty(p3, "getHeadersGuard"), Reflect.deleteProperty(p3, "setHeadersGuard"), Reflect.deleteProperty(p3, "getHeadersList"), Reflect.deleteProperty(p3, "setHeadersList"), c2("Headers", p3, D3, 0, 1), Object.defineProperties(p3.prototype, { append: k4, delete: k4, get: k4, has: k4, set: k4, getSetCookie: k4, [Symbol.toStringTag]: { value: "Headers", configurable: true }, [F2.inspect.custom]: { enumerable: false } }), y3.converters.HeadersInit = function(m4, f3, n) {
        if (y3.util.Type(m4) === "Object") {
          const C5 = Reflect.get(m4, Symbol.iterator);
          if (!F2.types.isProxy(m4) && C5 === p3.prototype.entries) try {
            return J5(m4).entriesList;
          } catch {
          }
          return typeof C5 == "function" ? y3.converters["sequence<sequence<ByteString>>"](m4, f3, n, C5.bind(m4)) : y3.converters["record<ByteString, ByteString>"](m4, f3, n);
        }
        throw y3.errors.conversionFailed({ prefix: "Headers constructor", argument: "Argument 1", types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"] });
      }, headers = { fill: o, compareHeaderName: l3, Headers: p3, HeadersList: I5, getHeadersGuard: b6, setHeadersGuard: G3, setHeadersList: V4, getHeadersList: J5 }, headers;
    }
    e3(requireHeaders, "requireHeaders");
    var response;
    var hasRequiredResponse;
    function requireResponse() {
      if (hasRequiredResponse) return response;
      hasRequiredResponse = 1;
      const { Headers: A2, HeadersList: k4, fill: c2, getHeadersGuard: B3, setHeadersGuard: t2, setHeadersList: y3 } = requireHeaders(), { extractBody: R4, cloneBody: F2, mixinBody: Q5, hasFinalizationRegistry: D3, streamRegistry: U6, bodyUnusable: r6 } = requireBody(), o = requireUtil$7(), N6 = require$$0__default$3, { kEnumerableProperty: l3 } = o, { isValidReasonPhrase: I5, isCancelled: p3, isAborted: b6, isBlobLike: G3, serializeJavascriptValueToJSONString: J5, isErrorLike: V4, isomorphicEncode: _5, environmentSettingsObject: q6 } = requireUtil$6(), { redirectStatusSet: M4, nullBodyStatus: Y4 } = requireConstants$2(), { kState: m4, kHeaders: f3 } = requireSymbols$3(), { webidl: n } = requireWebidl(), { FormData: C5 } = requireFormdata(), { URLSerializer: w5 } = requireDataUrl(), { kConstruct: S6 } = requireSymbols$4(), x5 = require$$0__default$1, { types: z4 } = require$$0__default$3, $6 = new TextEncoder("utf-8"), bA = class bA2 {
        static error() {
          return kA(uA(), "immutable");
        }
        static json(DA, oA = {}) {
          n.argumentLengthCheck(arguments, 1, "Response.json"), oA !== null && (oA = n.converters.ResponseInit(oA));
          const aA = $6.encode(J5(DA)), EA = R4(aA), sA = kA(iA({}), "response");
          return fA(sA, oA, { body: EA[0], type: "application/json" }), sA;
        }
        static redirect(DA, oA = 302) {
          n.argumentLengthCheck(arguments, 1, "Response.redirect"), DA = n.converters.USVString(DA), oA = n.converters["unsigned short"](oA);
          let aA;
          try {
            aA = new URL(DA, q6.settingsObject.baseUrl);
          } catch (NA) {
            throw new TypeError(`Failed to parse URL from ${DA}`, { cause: NA });
          }
          if (!M4.has(oA)) throw new RangeError(`Invalid status code ${oA}`);
          const EA = kA(iA({}), "immutable");
          EA[m4].status = oA;
          const sA = _5(w5(aA));
          return EA[m4].headersList.append("location", sA, true), EA;
        }
        constructor(DA = null, oA = {}) {
          if (n.util.markAsUncloneable(this), DA === S6) return;
          DA !== null && (DA = n.converters.BodyInit(DA)), oA = n.converters.ResponseInit(oA), this[m4] = iA({}), this[f3] = new A2(S6), t2(this[f3], "response"), y3(this[f3], this[m4].headersList);
          let aA = null;
          if (DA != null) {
            const [EA, sA] = R4(DA);
            aA = { body: EA, type: sA };
          }
          fA(this, oA, aA);
        }
        get type() {
          return n.brandCheck(this, bA2), this[m4].type;
        }
        get url() {
          n.brandCheck(this, bA2);
          const DA = this[m4].urlList, oA = DA[DA.length - 1] ?? null;
          return oA === null ? "" : w5(oA, true);
        }
        get redirected() {
          return n.brandCheck(this, bA2), this[m4].urlList.length > 1;
        }
        get status() {
          return n.brandCheck(this, bA2), this[m4].status;
        }
        get ok() {
          return n.brandCheck(this, bA2), this[m4].status >= 200 && this[m4].status <= 299;
        }
        get statusText() {
          return n.brandCheck(this, bA2), this[m4].statusText;
        }
        get headers() {
          return n.brandCheck(this, bA2), this[f3];
        }
        get body() {
          return n.brandCheck(this, bA2), this[m4].body ? this[m4].body.stream : null;
        }
        get bodyUsed() {
          return n.brandCheck(this, bA2), !!this[m4].body && o.isDisturbed(this[m4].body.stream);
        }
        clone() {
          if (n.brandCheck(this, bA2), r6(this)) throw n.errors.exception({ header: "Response.clone", message: "Body has already been consumed." });
          const DA = nA(this[m4]);
          return kA(DA, B3(this[f3]));
        }
        [N6.inspect.custom](DA, oA) {
          oA.depth === null && (oA.depth = 2), oA.colors ?? (oA.colors = true);
          const aA = { status: this.status, statusText: this.statusText, headers: this.headers, body: this.body, bodyUsed: this.bodyUsed, ok: this.ok, redirected: this.redirected, type: this.type, url: this.url };
          return `Response ${N6.formatWithOptions(oA, aA)}`;
        }
      };
      e3(bA, "Response");
      let K4 = bA;
      Q5(K4), Object.defineProperties(K4.prototype, { type: l3, url: l3, status: l3, ok: l3, redirected: l3, statusText: l3, headers: l3, clone: l3, body: l3, bodyUsed: l3, [Symbol.toStringTag]: { value: "Response", configurable: true } }), Object.defineProperties(K4, { json: l3, redirect: l3, error: l3 });
      function nA(gA) {
        if (gA.internalResponse) return CA(nA(gA.internalResponse), gA.type);
        const DA = iA({ ...gA, body: null });
        return gA.body != null && (DA.body = F2(DA, gA.body)), DA;
      }
      e3(nA, "cloneResponse");
      function iA(gA) {
        return { aborted: false, rangeRequested: false, timingAllowPassed: false, requestIncludesCredentials: false, type: "default", status: 200, timingInfo: null, cacheState: "", statusText: "", ...gA, headersList: gA?.headersList ? new k4(gA?.headersList) : new k4(), urlList: gA?.urlList ? [...gA.urlList] : [] };
      }
      e3(iA, "makeResponse");
      function uA(gA) {
        const DA = V4(gA);
        return iA({ type: "error", status: 0, error: DA ? gA : new Error(gA && String(gA)), aborted: gA && gA.name === "AbortError" });
      }
      e3(uA, "makeNetworkError");
      function RA(gA) {
        return gA.type === "error" && gA.status === 0;
      }
      e3(RA, "isNetworkError");
      function IA(gA, DA) {
        return DA = { internalResponse: gA, ...DA }, new Proxy(gA, { get(oA, aA) {
          return aA in DA ? DA[aA] : oA[aA];
        }, set(oA, aA, EA) {
          return x5(!(aA in DA)), oA[aA] = EA, true;
        } });
      }
      e3(IA, "makeFilteredResponse");
      function CA(gA, DA) {
        if (DA === "basic") return IA(gA, { type: "basic", headersList: gA.headersList });
        if (DA === "cors") return IA(gA, { type: "cors", headersList: gA.headersList });
        if (DA === "opaque") return IA(gA, { type: "opaque", urlList: Object.freeze([]), status: 0, statusText: "", body: null });
        if (DA === "opaqueredirect") return IA(gA, { type: "opaqueredirect", status: 0, statusText: "", headersList: [], body: null });
        x5(false);
      }
      e3(CA, "filterResponse");
      function pA(gA, DA = null) {
        return x5(p3(gA)), b6(gA) ? uA(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: DA })) : uA(Object.assign(new DOMException("Request was cancelled."), { cause: DA }));
      }
      e3(pA, "makeAppropriateNetworkError");
      function fA(gA, DA, oA) {
        if (DA.status !== null && (DA.status < 200 || DA.status > 599)) throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
        if ("statusText" in DA && DA.statusText != null && !I5(String(DA.statusText))) throw new TypeError("Invalid statusText");
        if ("status" in DA && DA.status != null && (gA[m4].status = DA.status), "statusText" in DA && DA.statusText != null && (gA[m4].statusText = DA.statusText), "headers" in DA && DA.headers != null && c2(gA[f3], DA.headers), oA) {
          if (Y4.includes(gA.status)) throw n.errors.exception({ header: "Response constructor", message: `Invalid response status code ${gA.status}` });
          gA[m4].body = oA.body, oA.type != null && !gA[m4].headersList.contains("content-type", true) && gA[m4].headersList.append("content-type", oA.type, true);
        }
      }
      e3(fA, "initializeResponse");
      function kA(gA, DA) {
        const oA = new K4(S6);
        return oA[m4] = gA, oA[f3] = new A2(S6), y3(oA[f3], gA.headersList), t2(oA[f3], DA), D3 && gA.body?.stream && U6.register(oA, new WeakRef(gA.body.stream)), oA;
      }
      return e3(kA, "fromInnerResponse"), n.converters.ReadableStream = n.interfaceConverter(ReadableStream), n.converters.FormData = n.interfaceConverter(C5), n.converters.URLSearchParams = n.interfaceConverter(URLSearchParams), n.converters.XMLHttpRequestBodyInit = function(gA, DA, oA) {
        return typeof gA == "string" ? n.converters.USVString(gA, DA, oA) : G3(gA) ? n.converters.Blob(gA, DA, oA, { strict: false }) : ArrayBuffer.isView(gA) || z4.isArrayBuffer(gA) ? n.converters.BufferSource(gA, DA, oA) : o.isFormDataLike(gA) ? n.converters.FormData(gA, DA, oA, { strict: false }) : gA instanceof URLSearchParams ? n.converters.URLSearchParams(gA, DA, oA) : n.converters.DOMString(gA, DA, oA);
      }, n.converters.BodyInit = function(gA, DA, oA) {
        return gA instanceof ReadableStream ? n.converters.ReadableStream(gA, DA, oA) : gA?.[Symbol.asyncIterator] ? gA : n.converters.XMLHttpRequestBodyInit(gA, DA, oA);
      }, n.converters.ResponseInit = n.dictionaryConverter([{ key: "status", converter: n.converters["unsigned short"], defaultValue: e3(() => 200, "defaultValue") }, { key: "statusText", converter: n.converters.ByteString, defaultValue: e3(() => "", "defaultValue") }, { key: "headers", converter: n.converters.HeadersInit }]), response = { isNetworkError: RA, makeNetworkError: uA, makeResponse: iA, makeAppropriateNetworkError: pA, filterResponse: CA, Response: K4, cloneResponse: nA, fromInnerResponse: kA }, response;
    }
    e3(requireResponse, "requireResponse");
    var dispatcherWeakref;
    var hasRequiredDispatcherWeakref;
    function requireDispatcherWeakref() {
      if (hasRequiredDispatcherWeakref) return dispatcherWeakref;
      hasRequiredDispatcherWeakref = 1;
      const { kConnected: A2, kSize: k4 } = requireSymbols$4(), t2 = class t {
        constructor(F2) {
          this.value = F2;
        }
        deref() {
          return this.value[A2] === 0 && this.value[k4] === 0 ? void 0 : this.value;
        }
      };
      e3(t2, "CompatWeakRef");
      let c2 = t2;
      const y3 = class y {
        constructor(F2) {
          this.finalizer = F2;
        }
        register(F2, Q5) {
          F2.on && F2.on("disconnect", () => {
            F2[A2] === 0 && F2[k4] === 0 && this.finalizer(Q5);
          });
        }
        unregister(F2) {
        }
      };
      e3(y3, "CompatFinalizer");
      let B3 = y3;
      return dispatcherWeakref = e3(function() {
        return process.env.NODE_V8_COVERAGE && process.version.startsWith("v18") ? (process._rawDebug("Using compatibility WeakRef and FinalizationRegistry"), { WeakRef: c2, FinalizationRegistry: B3 }) : { WeakRef, FinalizationRegistry };
      }, "dispatcherWeakref"), dispatcherWeakref;
    }
    e3(requireDispatcherWeakref, "requireDispatcherWeakref");
    var request;
    var hasRequiredRequest;
    function requireRequest() {
      if (hasRequiredRequest) return request;
      hasRequiredRequest = 1;
      const { extractBody: A2, mixinBody: k4, cloneBody: c2, bodyUnusable: B3 } = requireBody(), { Headers: t2, fill: y3, HeadersList: R4, setHeadersGuard: F2, getHeadersGuard: Q5, setHeadersList: D3, getHeadersList: U6 } = requireHeaders(), { FinalizationRegistry: r6 } = requireDispatcherWeakref()(), o = requireUtil$7(), N6 = require$$0__default$3, { isValidHTTPToken: l3, sameOrigin: I5, environmentSettingsObject: p3 } = requireUtil$6(), { forbiddenMethodsSet: b6, corsSafeListedMethodsSet: G3, referrerPolicy: J5, requestRedirect: V4, requestMode: _5, requestCredentials: q6, requestCache: M4, requestDuplex: Y4 } = requireConstants$2(), { kEnumerableProperty: m4, normalizedMethodRecordsBase: f3, normalizedMethodRecords: n } = o, { kHeaders: C5, kSignal: w5, kState: S6, kDispatcher: x5 } = requireSymbols$3(), { webidl: z4 } = requireWebidl(), { URLSerializer: $6 } = requireDataUrl(), { kConstruct: K4 } = requireSymbols$4(), nA = require$$0__default$1, { getMaxListeners: iA, setMaxListeners: uA, getEventListeners: RA, defaultMaxListeners: IA } = require$$8__default, CA = Symbol("abortController"), pA = new r6(({ signal: sA, abort: NA }) => {
        sA.removeEventListener("abort", NA);
      }), fA = /* @__PURE__ */ new WeakMap();
      function kA(sA) {
        return NA;
        function NA() {
          const wA = sA.deref();
          if (wA !== void 0) {
            pA.unregister(NA), this.removeEventListener("abort", NA), wA.abort(this.reason);
            const vA = fA.get(wA.signal);
            if (vA !== void 0) {
              if (vA.size !== 0) {
                for (const dA of vA) {
                  const XA = dA.deref();
                  XA !== void 0 && XA.abort(this.reason);
                }
                vA.clear();
              }
              fA.delete(wA.signal);
            }
          }
        }
      }
      e3(kA, "buildAbort");
      let bA = false;
      const EA = class EA2 {
        constructor(NA, wA = {}) {
          if (z4.util.markAsUncloneable(this), NA === K4) return;
          const vA = "Request constructor";
          z4.argumentLengthCheck(arguments, 1, vA), NA = z4.converters.RequestInfo(NA, vA, "input"), wA = z4.converters.RequestInit(wA, vA, "init");
          let dA = null, XA = null;
          const KA = p3.settingsObject.baseUrl;
          let OA = null;
          if (typeof NA == "string") {
            this[x5] = wA.dispatcher;
            let cA;
            try {
              cA = new URL(NA, KA);
            } catch (yA) {
              throw new TypeError("Failed to parse URL from " + NA, { cause: yA });
            }
            if (cA.username || cA.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + NA);
            dA = DA({ urlList: [cA] }), XA = "cors";
          } else this[x5] = wA.dispatcher || NA[x5], nA(NA instanceof EA2), dA = NA[S6], OA = NA[w5];
          const PA = p3.settingsObject.origin;
          let ZA = "client";
          if (dA.window?.constructor?.name === "EnvironmentSettingsObject" && I5(dA.window, PA) && (ZA = dA.window), wA.window != null) throw new TypeError(`'window' option '${ZA}' must be null`);
          "window" in wA && (ZA = "no-window"), dA = DA({ method: dA.method, headersList: dA.headersList, unsafeRequest: dA.unsafeRequest, client: p3.settingsObject, window: ZA, priority: dA.priority, origin: dA.origin, referrer: dA.referrer, referrerPolicy: dA.referrerPolicy, mode: dA.mode, credentials: dA.credentials, cache: dA.cache, redirect: dA.redirect, integrity: dA.integrity, keepalive: dA.keepalive, reloadNavigation: dA.reloadNavigation, historyNavigation: dA.historyNavigation, urlList: [...dA.urlList] });
          const HA = Object.keys(wA).length !== 0;
          if (HA && (dA.mode === "navigate" && (dA.mode = "same-origin"), dA.reloadNavigation = false, dA.historyNavigation = false, dA.origin = "client", dA.referrer = "client", dA.referrerPolicy = "", dA.url = dA.urlList[dA.urlList.length - 1], dA.urlList = [dA.url]), wA.referrer !== void 0) {
            const cA = wA.referrer;
            if (cA === "") dA.referrer = "no-referrer";
            else {
              let yA;
              try {
                yA = new URL(cA, KA);
              } catch (LA) {
                throw new TypeError(`Referrer "${cA}" is not a valid URL.`, { cause: LA });
              }
              yA.protocol === "about:" && yA.hostname === "client" || PA && !I5(yA, p3.settingsObject.baseUrl) ? dA.referrer = "client" : dA.referrer = yA;
            }
          }
          wA.referrerPolicy !== void 0 && (dA.referrerPolicy = wA.referrerPolicy);
          let se2;
          if (wA.mode !== void 0 ? se2 = wA.mode : se2 = XA, se2 === "navigate") throw z4.errors.exception({ header: "Request constructor", message: "invalid request mode navigate." });
          if (se2 != null && (dA.mode = se2), wA.credentials !== void 0 && (dA.credentials = wA.credentials), wA.cache !== void 0 && (dA.cache = wA.cache), dA.cache === "only-if-cached" && dA.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
          if (wA.redirect !== void 0 && (dA.redirect = wA.redirect), wA.integrity != null && (dA.integrity = String(wA.integrity)), wA.keepalive !== void 0 && (dA.keepalive = !!wA.keepalive), wA.method !== void 0) {
            let cA = wA.method;
            const yA = n[cA];
            if (yA !== void 0) dA.method = yA;
            else {
              if (!l3(cA)) throw new TypeError(`'${cA}' is not a valid HTTP method.`);
              const LA = cA.toUpperCase();
              if (b6.has(LA)) throw new TypeError(`'${cA}' HTTP method is unsupported.`);
              cA = f3[LA] ?? cA, dA.method = cA;
            }
            !bA && dA.method === "patch" && (process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", { code: "UNDICI-FETCH-patch" }), bA = true);
          }
          wA.signal !== void 0 && (OA = wA.signal), this[S6] = dA;
          const ne3 = new AbortController();
          if (this[w5] = ne3.signal, OA != null) {
            if (!OA || typeof OA.aborted != "boolean" || typeof OA.addEventListener != "function") throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
            if (OA.aborted) ne3.abort(OA.reason);
            else {
              this[CA] = ne3;
              const cA = new WeakRef(ne3), yA = kA(cA);
              try {
                (typeof iA == "function" && iA(OA) === IA || RA(OA, "abort").length >= IA) && uA(1500, OA);
              } catch {
              }
              o.addAbortListener(OA, yA), pA.register(ne3, { signal: OA, abort: yA }, yA);
            }
          }
          if (this[C5] = new t2(K4), D3(this[C5], dA.headersList), F2(this[C5], "request"), se2 === "no-cors") {
            if (!G3.has(dA.method)) throw new TypeError(`'${dA.method} is unsupported in no-cors mode.`);
            F2(this[C5], "request-no-cors");
          }
          if (HA) {
            const cA = U6(this[C5]), yA = wA.headers !== void 0 ? wA.headers : new R4(cA);
            if (cA.clear(), yA instanceof R4) {
              for (const { name: LA, value: JA } of yA.rawValues()) cA.append(LA, JA, false);
              cA.cookies = yA.cookies;
            } else y3(this[C5], yA);
          }
          const jA = NA instanceof EA2 ? NA[S6].body : null;
          if ((wA.body != null || jA != null) && (dA.method === "GET" || dA.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
          let Ae = null;
          if (wA.body != null) {
            const [cA, yA] = A2(wA.body, dA.keepalive);
            Ae = cA, yA && !U6(this[C5]).contains("content-type", true) && this[C5].append("content-type", yA);
          }
          const QA = Ae ?? jA;
          if (QA != null && QA.source == null) {
            if (Ae != null && wA.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
            if (dA.mode !== "same-origin" && dA.mode !== "cors") throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
            dA.useCORSPreflightFlag = true;
          }
          let W6 = QA;
          if (Ae == null && jA != null) {
            if (B3(NA)) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
            const cA = new TransformStream();
            jA.stream.pipeThrough(cA), W6 = { source: jA.source, length: jA.length, stream: cA.readable };
          }
          this[S6].body = W6;
        }
        get method() {
          return z4.brandCheck(this, EA2), this[S6].method;
        }
        get url() {
          return z4.brandCheck(this, EA2), $6(this[S6].url);
        }
        get headers() {
          return z4.brandCheck(this, EA2), this[C5];
        }
        get destination() {
          return z4.brandCheck(this, EA2), this[S6].destination;
        }
        get referrer() {
          return z4.brandCheck(this, EA2), this[S6].referrer === "no-referrer" ? "" : this[S6].referrer === "client" ? "about:client" : this[S6].referrer.toString();
        }
        get referrerPolicy() {
          return z4.brandCheck(this, EA2), this[S6].referrerPolicy;
        }
        get mode() {
          return z4.brandCheck(this, EA2), this[S6].mode;
        }
        get credentials() {
          return this[S6].credentials;
        }
        get cache() {
          return z4.brandCheck(this, EA2), this[S6].cache;
        }
        get redirect() {
          return z4.brandCheck(this, EA2), this[S6].redirect;
        }
        get integrity() {
          return z4.brandCheck(this, EA2), this[S6].integrity;
        }
        get keepalive() {
          return z4.brandCheck(this, EA2), this[S6].keepalive;
        }
        get isReloadNavigation() {
          return z4.brandCheck(this, EA2), this[S6].reloadNavigation;
        }
        get isHistoryNavigation() {
          return z4.brandCheck(this, EA2), this[S6].historyNavigation;
        }
        get signal() {
          return z4.brandCheck(this, EA2), this[w5];
        }
        get body() {
          return z4.brandCheck(this, EA2), this[S6].body ? this[S6].body.stream : null;
        }
        get bodyUsed() {
          return z4.brandCheck(this, EA2), !!this[S6].body && o.isDisturbed(this[S6].body.stream);
        }
        get duplex() {
          return z4.brandCheck(this, EA2), "half";
        }
        clone() {
          if (z4.brandCheck(this, EA2), B3(this)) throw new TypeError("unusable");
          const NA = oA(this[S6]), wA = new AbortController();
          if (this.signal.aborted) wA.abort(this.signal.reason);
          else {
            let vA = fA.get(this.signal);
            vA === void 0 && (vA = /* @__PURE__ */ new Set(), fA.set(this.signal, vA));
            const dA = new WeakRef(wA);
            vA.add(dA), o.addAbortListener(wA.signal, kA(dA));
          }
          return aA(NA, wA.signal, Q5(this[C5]));
        }
        [N6.inspect.custom](NA, wA) {
          wA.depth === null && (wA.depth = 2), wA.colors ?? (wA.colors = true);
          const vA = { method: this.method, url: this.url, headers: this.headers, destination: this.destination, referrer: this.referrer, referrerPolicy: this.referrerPolicy, mode: this.mode, credentials: this.credentials, cache: this.cache, redirect: this.redirect, integrity: this.integrity, keepalive: this.keepalive, isReloadNavigation: this.isReloadNavigation, isHistoryNavigation: this.isHistoryNavigation, signal: this.signal };
          return `Request ${N6.formatWithOptions(wA, vA)}`;
        }
      };
      e3(EA, "Request");
      let gA = EA;
      k4(gA);
      function DA(sA) {
        return { method: sA.method ?? "GET", localURLsOnly: sA.localURLsOnly ?? false, unsafeRequest: sA.unsafeRequest ?? false, body: sA.body ?? null, client: sA.client ?? null, reservedClient: sA.reservedClient ?? null, replacesClientId: sA.replacesClientId ?? "", window: sA.window ?? "client", keepalive: sA.keepalive ?? false, serviceWorkers: sA.serviceWorkers ?? "all", initiator: sA.initiator ?? "", destination: sA.destination ?? "", priority: sA.priority ?? null, origin: sA.origin ?? "client", policyContainer: sA.policyContainer ?? "client", referrer: sA.referrer ?? "client", referrerPolicy: sA.referrerPolicy ?? "", mode: sA.mode ?? "no-cors", useCORSPreflightFlag: sA.useCORSPreflightFlag ?? false, credentials: sA.credentials ?? "same-origin", useCredentials: sA.useCredentials ?? false, cache: sA.cache ?? "default", redirect: sA.redirect ?? "follow", integrity: sA.integrity ?? "", cryptoGraphicsNonceMetadata: sA.cryptoGraphicsNonceMetadata ?? "", parserMetadata: sA.parserMetadata ?? "", reloadNavigation: sA.reloadNavigation ?? false, historyNavigation: sA.historyNavigation ?? false, userActivation: sA.userActivation ?? false, taintedOrigin: sA.taintedOrigin ?? false, redirectCount: sA.redirectCount ?? 0, responseTainting: sA.responseTainting ?? "basic", preventNoCacheCacheControlHeaderModification: sA.preventNoCacheCacheControlHeaderModification ?? false, done: sA.done ?? false, timingAllowFailed: sA.timingAllowFailed ?? false, urlList: sA.urlList, url: sA.urlList[0], headersList: sA.headersList ? new R4(sA.headersList) : new R4() };
      }
      e3(DA, "makeRequest");
      function oA(sA) {
        const NA = DA({ ...sA, body: null });
        return sA.body != null && (NA.body = c2(NA, sA.body)), NA;
      }
      e3(oA, "cloneRequest");
      function aA(sA, NA, wA) {
        const vA = new gA(K4);
        return vA[S6] = sA, vA[w5] = NA, vA[C5] = new t2(K4), D3(vA[C5], sA.headersList), F2(vA[C5], wA), vA;
      }
      return e3(aA, "fromInnerRequest"), Object.defineProperties(gA.prototype, { method: m4, url: m4, headers: m4, redirect: m4, clone: m4, signal: m4, duplex: m4, destination: m4, body: m4, bodyUsed: m4, isHistoryNavigation: m4, isReloadNavigation: m4, keepalive: m4, integrity: m4, cache: m4, credentials: m4, attribute: m4, referrerPolicy: m4, referrer: m4, mode: m4, [Symbol.toStringTag]: { value: "Request", configurable: true } }), z4.converters.Request = z4.interfaceConverter(gA), z4.converters.RequestInfo = function(sA, NA, wA) {
        return typeof sA == "string" ? z4.converters.USVString(sA, NA, wA) : sA instanceof gA ? z4.converters.Request(sA, NA, wA) : z4.converters.USVString(sA, NA, wA);
      }, z4.converters.AbortSignal = z4.interfaceConverter(AbortSignal), z4.converters.RequestInit = z4.dictionaryConverter([{ key: "method", converter: z4.converters.ByteString }, { key: "headers", converter: z4.converters.HeadersInit }, { key: "body", converter: z4.nullableConverter(z4.converters.BodyInit) }, { key: "referrer", converter: z4.converters.USVString }, { key: "referrerPolicy", converter: z4.converters.DOMString, allowedValues: J5 }, { key: "mode", converter: z4.converters.DOMString, allowedValues: _5 }, { key: "credentials", converter: z4.converters.DOMString, allowedValues: q6 }, { key: "cache", converter: z4.converters.DOMString, allowedValues: M4 }, { key: "redirect", converter: z4.converters.DOMString, allowedValues: V4 }, { key: "integrity", converter: z4.converters.DOMString }, { key: "keepalive", converter: z4.converters.boolean }, { key: "signal", converter: z4.nullableConverter((sA) => z4.converters.AbortSignal(sA, "RequestInit", "signal", { strict: false })) }, { key: "window", converter: z4.converters.any }, { key: "duplex", converter: z4.converters.DOMString, allowedValues: Y4 }, { key: "dispatcher", converter: z4.converters.any }]), request = { Request: gA, makeRequest: DA, fromInnerRequest: aA, cloneRequest: oA }, request;
    }
    e3(requireRequest, "requireRequest");
    var fetch_1;
    var hasRequiredFetch;
    function requireFetch() {
      if (hasRequiredFetch) return fetch_1;
      hasRequiredFetch = 1;
      const { makeNetworkError: A2, makeAppropriateNetworkError: k4, filterResponse: c2, makeResponse: B3, fromInnerResponse: t2 } = requireResponse(), { HeadersList: y3 } = requireHeaders(), { Request: R4, cloneRequest: F2 } = requireRequest(), Q5 = zlib__default, { bytesMatch: D3, makePolicyContainer: U6, clonePolicyContainer: r6, requestBadPort: o, TAOCheck: N6, appendRequestOriginHeader: l3, responseLocationURL: I5, requestCurrentURL: p3, setRequestReferrerPolicyOnRedirect: b6, tryUpgradeRequestToAPotentiallyTrustworthyURL: G3, createOpaqueTimingInfo: J5, appendFetchMetadata: V4, corsCheck: _5, crossOriginResourcePolicyCheck: q6, determineRequestsReferrer: M4, coarsenedSharedCurrentTime: Y4, createDeferredPromise: m4, isBlobLike: f3, sameOrigin: n, isCancelled: C5, isAborted: w5, isErrorLike: S6, fullyReadBody: x5, readableStreamClose: z4, isomorphicEncode: $6, urlIsLocal: K4, urlIsHttpHttpsScheme: nA, urlHasHttpsScheme: iA, clampAndCoarsenConnectionTimingInfo: uA, simpleRangeHeaderValue: RA, buildContentRange: IA, createInflate: CA, extractMimeType: pA } = requireUtil$6(), { kState: fA, kDispatcher: kA } = requireSymbols$3(), bA = require$$0__default$1, { safelyExtractBody: gA, extractBody: DA } = requireBody(), { redirectStatusSet: oA, nullBodyStatus: aA, safeMethodsSet: EA, requestBodyHeader: sA, subresourceSet: NA } = requireConstants$2(), wA = require$$8__default, { Readable: vA, pipeline: dA, finished: XA } = Stream__default, { addAbortListener: KA, isErrored: OA, isReadable: PA, bufferToLowerCasedHeaderName: ZA } = requireUtil$7(), { dataURLProcessor: HA, serializeAMimeType: se2, minimizeSupportedMimeType: ne3 } = requireDataUrl(), { getGlobalDispatcher: jA } = requireGlobal(), { webidl: Ae } = requireWebidl(), { STATUS_CODES: QA } = http__default, W6 = ["GET", "HEAD"], cA = typeof __UNDICI_IS_NODE__ < "u" || typeof esbuildDetection < "u" ? "node" : "undici";
      let yA;
      const UA = class UA extends wA {
        constructor(v4) {
          super(), this.dispatcher = v4, this.connection = null, this.dump = false, this.state = "ongoing";
        }
        terminate(v4) {
          this.state === "ongoing" && (this.state = "terminated", this.connection?.destroy(v4), this.emit("terminated", v4));
        }
        abort(v4) {
          this.state === "ongoing" && (this.state = "aborted", v4 || (v4 = new DOMException("The operation was aborted.", "AbortError")), this.serializedAbortReason = v4, this.connection?.destroy(v4), this.emit("terminated", v4));
        }
      };
      e3(UA, "Fetch");
      let LA = UA;
      function JA(AA) {
        te3(AA, "fetch");
      }
      e3(JA, "handleFetchDone");
      function WA(AA, v4 = void 0) {
        Ae.argumentLengthCheck(arguments, 1, "globalThis.fetch");
        let X5 = m4(), j3;
        try {
          j3 = new R4(AA, v4);
        } catch (_A) {
          return X5.reject(_A), X5.promise;
        }
        const tA = j3[fA];
        if (j3.signal.aborted) return oe3(X5, tA, null, j3.signal.reason), X5.promise;
        tA.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope" && (tA.serviceWorkers = "none");
        let FA = null, TA = false, VA = null;
        return KA(j3.signal, () => {
          TA = true, bA(VA != null), VA.abort(j3.signal.reason);
          const _A = FA?.deref();
          oe3(X5, tA, _A, j3.signal.reason);
        }), VA = Ie2({ request: tA, processResponseEndOfBody: JA, processResponse: e3((_A) => {
          if (!TA) {
            if (_A.aborted) {
              oe3(X5, tA, FA, VA.serializedAbortReason);
              return;
            }
            if (_A.type === "error") {
              X5.reject(new TypeError("fetch failed", { cause: _A.error }));
              return;
            }
            FA = new WeakRef(t2(_A, "immutable")), X5.resolve(FA.deref()), X5 = null;
          }
        }, "processResponse"), dispatcher: j3[kA] }), X5.promise;
      }
      e3(WA, "fetch");
      function te3(AA, v4 = "other") {
        if (AA.type === "error" && AA.aborted || !AA.urlList?.length) return;
        const X5 = AA.urlList[0];
        let j3 = AA.timingInfo, tA = AA.cacheState;
        nA(X5) && j3 !== null && (AA.timingAllowPassed || (j3 = J5({ startTime: j3.startTime }), tA = ""), j3.endTime = Y4(), AA.timingInfo = j3, ie3(j3, X5.href, v4, globalThis, tA));
      }
      e3(te3, "finalizeAndReportTiming");
      const ie3 = performance.markResourceTiming;
      function oe3(AA, v4, X5, j3) {
        if (AA && AA.reject(j3), v4.body != null && PA(v4.body?.stream) && v4.body.stream.cancel(j3).catch((rA) => {
          if (rA.code !== "ERR_INVALID_STATE") throw rA;
        }), X5 == null) return;
        const tA = X5[fA];
        tA.body != null && PA(tA.body?.stream) && tA.body.stream.cancel(j3).catch((rA) => {
          if (rA.code !== "ERR_INVALID_STATE") throw rA;
        });
      }
      e3(oe3, "abortFetch");
      function Ie2({ request: AA, processRequestBodyChunkLength: v4, processRequestEndOfBody: X5, processResponse: j3, processResponseEndOfBody: tA, processResponseConsumeBody: rA, useParallelQueue: FA = false, dispatcher: TA = jA() }) {
        bA(TA);
        let VA = null, YA = false;
        AA.client != null && (VA = AA.client.globalObject, YA = AA.client.crossOriginIsolatedCapability);
        const _A = Y4(YA), Qe2 = J5({ startTime: _A }), qA = { controller: new LA(TA), request: AA, timingInfo: Qe2, processRequestBodyChunkLength: v4, processRequestEndOfBody: X5, processResponse: j3, processResponseConsumeBody: rA, processResponseEndOfBody: tA, taskDestination: VA, crossOriginIsolatedCapability: YA };
        return bA(!AA.body || AA.body.stream), AA.window === "client" && (AA.window = AA.client?.globalObject?.constructor?.name === "Window" ? AA.client : "no-window"), AA.origin === "client" && (AA.origin = AA.client.origin), AA.policyContainer === "client" && (AA.client != null ? AA.policyContainer = r6(AA.client.policyContainer) : AA.policyContainer = U6()), AA.headersList.contains("accept", true) || AA.headersList.append("accept", "*/*", true), AA.headersList.contains("accept-language", true) || AA.headersList.append("accept-language", "*", true), AA.priority, NA.has(AA.destination), GA(qA).catch((ae3) => {
          qA.controller.terminate(ae3);
        }), qA.controller;
      }
      e3(Ie2, "fetching");
      async function GA(AA, v4 = false) {
        const X5 = AA.request;
        let j3 = null;
        if (X5.localURLsOnly && !K4(p3(X5)) && (j3 = A2("local URLs only")), G3(X5), o(X5) === "blocked" && (j3 = A2("bad port")), X5.referrerPolicy === "" && (X5.referrerPolicy = X5.policyContainer.referrerPolicy), X5.referrer !== "no-referrer" && (X5.referrer = M4(X5)), j3 === null && (j3 = await (async () => {
          const rA = p3(X5);
          return n(rA, X5.url) && X5.responseTainting === "basic" || rA.protocol === "data:" || X5.mode === "navigate" || X5.mode === "websocket" ? (X5.responseTainting = "basic", await eA(AA)) : X5.mode === "same-origin" ? A2('request mode cannot be "same-origin"') : X5.mode === "no-cors" ? X5.redirect !== "follow" ? A2('redirect mode cannot be "follow" for "no-cors" request') : (X5.responseTainting = "opaque", await eA(AA)) : nA(p3(X5)) ? (X5.responseTainting = "cors", await hA(AA)) : A2("URL scheme must be a HTTP(S) scheme");
        })()), v4) return j3;
        j3.status !== 0 && !j3.internalResponse && (X5.responseTainting, X5.responseTainting === "basic" ? j3 = c2(j3, "basic") : X5.responseTainting === "cors" ? j3 = c2(j3, "cors") : X5.responseTainting === "opaque" ? j3 = c2(j3, "opaque") : bA(false));
        let tA = j3.status === 0 ? j3 : j3.internalResponse;
        if (tA.urlList.length === 0 && tA.urlList.push(...X5.urlList), X5.timingAllowFailed || (j3.timingAllowPassed = true), j3.type === "opaque" && tA.status === 206 && tA.rangeRequested && !X5.headers.contains("range", true) && (j3 = tA = A2()), j3.status !== 0 && (X5.method === "HEAD" || X5.method === "CONNECT" || aA.includes(tA.status)) && (tA.body = null, AA.controller.dump = true), X5.integrity) {
          const rA = e3((TA) => BA(AA, A2(TA)), "processBodyError");
          if (X5.responseTainting === "opaque" || j3.body == null) {
            rA(j3.error);
            return;
          }
          const FA = e3((TA) => {
            if (!D3(TA, X5.integrity)) {
              rA("integrity mismatch");
              return;
            }
            j3.body = gA(TA)[0], BA(AA, j3);
          }, "processBody");
          await x5(j3.body, FA, rA);
        } else BA(AA, j3);
      }
      e3(GA, "mainFetch");
      function eA(AA) {
        if (C5(AA) && AA.request.redirectCount === 0) return Promise.resolve(k4(AA));
        const { request: v4 } = AA, { protocol: X5 } = p3(v4);
        switch (X5) {
          case "about:":
            return Promise.resolve(A2("about scheme is not supported"));
          case "blob:": {
            yA || (yA = require$$0__default.resolveObjectURL);
            const j3 = p3(v4);
            if (j3.search.length !== 0) return Promise.resolve(A2("NetworkError when attempting to fetch resource."));
            const tA = yA(j3.toString());
            if (v4.method !== "GET" || !f3(tA)) return Promise.resolve(A2("invalid method"));
            const rA = B3(), FA = tA.size, TA = $6(`${FA}`), VA = tA.type;
            if (v4.headersList.contains("range", true)) {
              rA.rangeRequested = true;
              const YA = v4.headersList.get("range", true), _A = RA(YA, true);
              if (_A === "failure") return Promise.resolve(A2("failed to fetch the data URL"));
              let { rangeStartValue: Qe2, rangeEndValue: qA } = _A;
              if (Qe2 === null) Qe2 = FA - qA, qA = Qe2 + qA - 1;
              else {
                if (Qe2 >= FA) return Promise.resolve(A2("Range start is greater than the blob's size."));
                (qA === null || qA >= FA) && (qA = FA - 1);
              }
              const ae3 = tA.slice(Qe2, qA, VA), ce2 = DA(ae3);
              rA.body = ce2[0];
              const re3 = $6(`${ae3.size}`), Be2 = IA(Qe2, qA, FA);
              rA.status = 206, rA.statusText = "Partial Content", rA.headersList.set("content-length", re3, true), rA.headersList.set("content-type", VA, true), rA.headersList.set("content-range", Be2, true);
            } else {
              const YA = DA(tA);
              rA.statusText = "OK", rA.body = YA[0], rA.headersList.set("content-length", TA, true), rA.headersList.set("content-type", VA, true);
            }
            return Promise.resolve(rA);
          }
          case "data:": {
            const j3 = p3(v4), tA = HA(j3);
            if (tA === "failure") return Promise.resolve(A2("failed to fetch the data URL"));
            const rA = se2(tA.mimeType);
            return Promise.resolve(B3({ statusText: "OK", headersList: [["content-type", { name: "Content-Type", value: rA }]], body: gA(tA.body)[0] }));
          }
          case "file:":
            return Promise.resolve(A2("not implemented... yet..."));
          case "http:":
          case "https:":
            return hA(AA).catch((j3) => A2(j3));
          default:
            return Promise.resolve(A2("unknown scheme"));
        }
      }
      e3(eA, "schemeFetch");
      function lA(AA, v4) {
        AA.request.done = true, AA.processResponseDone != null && queueMicrotask(() => AA.processResponseDone(v4));
      }
      e3(lA, "finalizeResponse");
      function BA(AA, v4) {
        let X5 = AA.timingInfo;
        const j3 = e3(() => {
          const rA = Date.now();
          AA.request.destination === "document" && (AA.controller.fullTimingInfo = X5), AA.controller.reportTimingSteps = () => {
            if (AA.request.url.protocol !== "https:") return;
            X5.endTime = rA;
            let TA = v4.cacheState;
            const VA = v4.bodyInfo;
            v4.timingAllowPassed || (X5 = J5(X5), TA = "");
            let YA = 0;
            if (AA.request.mode !== "navigator" || !v4.hasCrossOriginRedirects) {
              YA = v4.status;
              const _A = pA(v4.headersList);
              _A !== "failure" && (VA.contentType = ne3(_A));
            }
            AA.request.initiatorType != null && ie3(X5, AA.request.url.href, AA.request.initiatorType, globalThis, TA, VA, YA);
          };
          const FA = e3(() => {
            AA.request.done = true, AA.processResponseEndOfBody != null && queueMicrotask(() => AA.processResponseEndOfBody(v4)), AA.request.initiatorType != null && AA.controller.reportTimingSteps();
          }, "processResponseEndOfBodyTask");
          queueMicrotask(() => FA());
        }, "processResponseEndOfBody");
        AA.processResponse != null && queueMicrotask(() => {
          AA.processResponse(v4), AA.processResponse = null;
        });
        const tA = v4.type === "error" ? v4 : v4.internalResponse ?? v4;
        tA.body == null ? j3() : XA(tA.body.stream, () => {
          j3();
        });
      }
      e3(BA, "fetchFinale");
      async function hA(AA) {
        const v4 = AA.request;
        let X5 = null, j3 = null;
        const tA = AA.timingInfo;
        if (v4.serviceWorkers, X5 === null) {
          if (v4.redirect === "follow" && (v4.serviceWorkers = "none"), j3 = X5 = await xA(AA), v4.responseTainting === "cors" && _5(v4, X5) === "failure") return A2("cors failure");
          N6(v4, X5) === "failure" && (v4.timingAllowFailed = true);
        }
        return (v4.responseTainting === "opaque" || X5.type === "opaque") && q6(v4.origin, v4.client, v4.destination, j3) === "blocked" ? A2("blocked") : (oA.has(j3.status) && (v4.redirect !== "manual" && AA.controller.connection.destroy(void 0, false), v4.redirect === "error" ? X5 = A2("unexpected redirect") : v4.redirect === "manual" ? X5 = j3 : v4.redirect === "follow" ? X5 = await MA(AA, X5) : bA(false)), X5.timingInfo = tA, X5);
      }
      e3(hA, "httpFetch");
      function MA(AA, v4) {
        const X5 = AA.request, j3 = v4.internalResponse ? v4.internalResponse : v4;
        let tA;
        try {
          if (tA = I5(j3, p3(X5).hash), tA == null) return v4;
        } catch (FA) {
          return Promise.resolve(A2(FA));
        }
        if (!nA(tA)) return Promise.resolve(A2("URL scheme must be a HTTP(S) scheme"));
        if (X5.redirectCount === 20) return Promise.resolve(A2("redirect count exceeded"));
        if (X5.redirectCount += 1, X5.mode === "cors" && (tA.username || tA.password) && !n(X5, tA)) return Promise.resolve(A2('cross origin not allowed for request mode "cors"'));
        if (X5.responseTainting === "cors" && (tA.username || tA.password)) return Promise.resolve(A2('URL cannot contain credentials for request mode "cors"'));
        if (j3.status !== 303 && X5.body != null && X5.body.source == null) return Promise.resolve(A2());
        if ([301, 302].includes(j3.status) && X5.method === "POST" || j3.status === 303 && !W6.includes(X5.method)) {
          X5.method = "GET", X5.body = null;
          for (const FA of sA) X5.headersList.delete(FA);
        }
        n(p3(X5), tA) || (X5.headersList.delete("authorization", true), X5.headersList.delete("proxy-authorization", true), X5.headersList.delete("cookie", true), X5.headersList.delete("host", true)), X5.body != null && (bA(X5.body.source != null), X5.body = gA(X5.body.source)[0]);
        const rA = AA.timingInfo;
        return rA.redirectEndTime = rA.postRedirectStartTime = Y4(AA.crossOriginIsolatedCapability), rA.redirectStartTime === 0 && (rA.redirectStartTime = rA.startTime), X5.urlList.push(tA), b6(X5, j3), GA(AA, true);
      }
      e3(MA, "httpRedirectFetch");
      async function xA(AA, v4 = false, X5 = false) {
        const j3 = AA.request;
        let tA = null, rA = null, FA = null;
        j3.window === "no-window" && j3.redirect === "error" ? (tA = AA, rA = j3) : (rA = F2(j3), tA = { ...AA }, tA.request = rA);
        const TA = j3.credentials === "include" || j3.credentials === "same-origin" && j3.responseTainting === "basic", VA = rA.body ? rA.body.length : null;
        let YA = null;
        if (rA.body == null && ["POST", "PUT"].includes(rA.method) && (YA = "0"), VA != null && (YA = $6(`${VA}`)), YA != null && rA.headersList.append("content-length", YA, true), VA != null && rA.keepalive, rA.referrer instanceof URL && rA.headersList.append("referer", $6(rA.referrer.href), true), l3(rA), V4(rA), rA.headersList.contains("user-agent", true) || rA.headersList.append("user-agent", cA), rA.cache === "default" && (rA.headersList.contains("if-modified-since", true) || rA.headersList.contains("if-none-match", true) || rA.headersList.contains("if-unmodified-since", true) || rA.headersList.contains("if-match", true) || rA.headersList.contains("if-range", true)) && (rA.cache = "no-store"), rA.cache === "no-cache" && !rA.preventNoCacheCacheControlHeaderModification && !rA.headersList.contains("cache-control", true) && rA.headersList.append("cache-control", "max-age=0", true), (rA.cache === "no-store" || rA.cache === "reload") && (rA.headersList.contains("pragma", true) || rA.headersList.append("pragma", "no-cache", true), rA.headersList.contains("cache-control", true) || rA.headersList.append("cache-control", "no-cache", true)), rA.headersList.contains("range", true) && rA.headersList.append("accept-encoding", "identity", true), rA.headersList.contains("accept-encoding", true) || (iA(p3(rA)) ? rA.headersList.append("accept-encoding", "br, gzip, deflate", true) : rA.headersList.append("accept-encoding", "gzip, deflate", true)), rA.headersList.delete("host", true), rA.cache = "no-store", rA.cache !== "no-store" && rA.cache, FA == null) {
          if (rA.cache === "only-if-cached") return A2("only if cached");
          const _A = await zA(tA, TA, X5);
          !EA.has(rA.method) && _A.status >= 200 && _A.status <= 399, FA == null && (FA = _A);
        }
        if (FA.urlList = [...rA.urlList], rA.headersList.contains("range", true) && (FA.rangeRequested = true), FA.requestIncludesCredentials = TA, FA.status === 407) return j3.window === "no-window" ? A2() : C5(AA) ? k4(AA) : A2("proxy authentication required");
        if (FA.status === 421 && !X5 && (j3.body == null || j3.body.source != null)) {
          if (C5(AA)) return k4(AA);
          AA.controller.connection.destroy(), FA = await xA(AA, v4, true);
        }
        return FA;
      }
      e3(xA, "httpNetworkOrCacheFetch");
      async function zA(AA, v4 = false, X5 = false) {
        bA(!AA.controller.connection || AA.controller.connection.destroyed), AA.controller.connection = { abort: null, destroyed: false, destroy(qA, ae3 = true) {
          this.destroyed || (this.destroyed = true, ae3 && this.abort?.(qA ?? new DOMException("The operation was aborted.", "AbortError")));
        } };
        const j3 = AA.request;
        let tA = null;
        const rA = AA.timingInfo;
        j3.cache = "no-store", j3.mode;
        let FA = null;
        if (j3.body == null && AA.processRequestEndOfBody) queueMicrotask(() => AA.processRequestEndOfBody());
        else if (j3.body != null) {
          const qA = e3(async function* (re3) {
            C5(AA) || (yield re3, AA.processRequestBodyChunkLength?.(re3.byteLength));
          }, "processBodyChunk"), ae3 = e3(() => {
            C5(AA) || AA.processRequestEndOfBody && AA.processRequestEndOfBody();
          }, "processEndOfBody"), ce2 = e3((re3) => {
            C5(AA) || (re3.name === "AbortError" ? AA.controller.abort() : AA.controller.terminate(re3));
          }, "processBodyError");
          FA = (async function* () {
            try {
              for await (const re3 of j3.body.stream) yield* qA(re3);
              ae3();
            } catch (re3) {
              ce2(re3);
            }
          })();
        }
        try {
          const { body: qA, status: ae3, statusText: ce2, headersList: re3, socket: Be2 } = await Qe2({ body: FA });
          if (Be2) tA = B3({ status: ae3, statusText: ce2, headersList: re3, socket: Be2 });
          else {
            const ge3 = qA[Symbol.asyncIterator]();
            AA.controller.next = () => ge3.next(), tA = B3({ status: ae3, statusText: ce2, headersList: re3 });
          }
        } catch (qA) {
          return qA.name === "AbortError" ? (AA.controller.connection.destroy(), k4(AA, qA)) : A2(qA);
        }
        const TA = e3(async () => {
          await AA.controller.resume();
        }, "pullAlgorithm"), VA = e3((qA) => {
          C5(AA) || AA.controller.abort(qA);
        }, "cancelAlgorithm"), YA = new ReadableStream({ async start(qA) {
          AA.controller.controller = qA;
        }, async pull(qA) {
          await TA();
        }, async cancel(qA) {
          await VA(qA);
        }, type: "bytes" });
        tA.body = { stream: YA, source: null, length: null }, AA.controller.onAborted = _A, AA.controller.on("terminated", _A), AA.controller.resume = async () => {
          for (; ; ) {
            let qA, ae3;
            try {
              const { done: re3, value: Be2 } = await AA.controller.next();
              if (w5(AA)) break;
              qA = re3 ? void 0 : Be2;
            } catch (re3) {
              AA.controller.ended && !rA.encodedBodySize ? qA = void 0 : (qA = re3, ae3 = true);
            }
            if (qA === void 0) {
              z4(AA.controller.controller), lA(AA, tA);
              return;
            }
            if (rA.decodedBodySize += qA?.byteLength ?? 0, ae3) {
              AA.controller.terminate(qA);
              return;
            }
            const ce2 = new Uint8Array(qA);
            if (ce2.byteLength && AA.controller.controller.enqueue(ce2), OA(YA)) {
              AA.controller.terminate();
              return;
            }
            if (AA.controller.controller.desiredSize <= 0) return;
          }
        };
        function _A(qA) {
          w5(AA) ? (tA.aborted = true, PA(YA) && AA.controller.controller.error(AA.controller.serializedAbortReason)) : PA(YA) && AA.controller.controller.error(new TypeError("terminated", { cause: S6(qA) ? qA : void 0 })), AA.controller.connection.destroy();
        }
        return e3(_A, "onAborted"), tA;
        function Qe2({ body: qA }) {
          const ae3 = p3(j3), ce2 = AA.controller.dispatcher;
          return new Promise((re3, Be2) => ce2.dispatch({ path: ae3.pathname + ae3.search, origin: ae3.origin, method: j3.method, body: ce2.isMockActive ? j3.body && (j3.body.source || j3.body.stream) : qA, headers: j3.headersList.entries, maxRedirections: 0, upgrade: j3.mode === "websocket" ? "websocket" : void 0 }, { body: null, abort: null, onConnect(ge3) {
            const { connection: Ee3 } = AA.controller;
            rA.finalConnectionTimingInfo = uA(void 0, rA.postRedirectStartTime, AA.crossOriginIsolatedCapability), Ee3.destroyed ? ge3(new DOMException("The operation was aborted.", "AbortError")) : (AA.controller.on("terminated", ge3), this.abort = Ee3.abort = ge3), rA.finalNetworkRequestStartTime = Y4(AA.crossOriginIsolatedCapability);
          }, onResponseStarted() {
            rA.finalNetworkResponseStartTime = Y4(AA.crossOriginIsolatedCapability);
          }, onHeaders(ge3, Ee3, Fe2, we3) {
            if (ge3 < 200) return;
            let le3 = [], Se2 = "";
            const ye2 = new y3();
            for (let Ce2 = 0; Ce2 < Ee3.length; Ce2 += 2) ye2.append(ZA(Ee3[Ce2]), Ee3[Ce2 + 1].toString("latin1"), true);
            const Le2 = ye2.get("content-encoding", true);
            Le2 && (le3 = Le2.toLowerCase().split(",").map((Ce2) => Ce2.trim())), Se2 = ye2.get("location", true), this.body = new vA({ read: Fe2 });
            const he3 = [], Ke2 = Se2 && j3.redirect === "follow" && oA.has(ge3);
            if (le3.length !== 0 && j3.method !== "HEAD" && j3.method !== "CONNECT" && !aA.includes(ge3) && !Ke2) for (let Ce2 = le3.length - 1; Ce2 >= 0; --Ce2) {
              const De2 = le3[Ce2];
              if (De2 === "x-gzip" || De2 === "gzip") he3.push(Q5.createGunzip({ flush: Q5.constants.Z_SYNC_FLUSH, finishFlush: Q5.constants.Z_SYNC_FLUSH }));
              else if (De2 === "deflate") he3.push(CA({ flush: Q5.constants.Z_SYNC_FLUSH, finishFlush: Q5.constants.Z_SYNC_FLUSH }));
              else if (De2 === "br") he3.push(Q5.createBrotliDecompress({ flush: Q5.constants.BROTLI_OPERATION_FLUSH, finishFlush: Q5.constants.BROTLI_OPERATION_FLUSH }));
              else {
                he3.length = 0;
                break;
              }
            }
            const Te2 = this.onError.bind(this);
            return re3({ status: ge3, statusText: we3, headersList: ye2, body: he3.length ? dA(this.body, ...he3, (Ce2) => {
              Ce2 && this.onError(Ce2);
            }).on("error", Te2) : this.body.on("error", Te2) }), true;
          }, onData(ge3) {
            if (AA.controller.dump) return;
            const Ee3 = ge3;
            return rA.encodedBodySize += Ee3.byteLength, this.body.push(Ee3);
          }, onComplete() {
            this.abort && AA.controller.off("terminated", this.abort), AA.controller.onAborted && AA.controller.off("terminated", AA.controller.onAborted), AA.controller.ended = true, this.body.push(null);
          }, onError(ge3) {
            this.abort && AA.controller.off("terminated", this.abort), this.body?.destroy(ge3), AA.controller.terminate(ge3), Be2(ge3);
          }, onUpgrade(ge3, Ee3, Fe2) {
            if (ge3 !== 101) return;
            const we3 = new y3();
            for (let le3 = 0; le3 < Ee3.length; le3 += 2) we3.append(ZA(Ee3[le3]), Ee3[le3 + 1].toString("latin1"), true);
            return re3({ status: ge3, statusText: QA[ge3], headersList: we3, socket: Fe2 }), true;
          } }));
        }
        e3(Qe2, "dispatch");
      }
      return e3(zA, "httpNetworkFetch"), fetch_1 = { fetch: WA, Fetch: LA, fetching: Ie2, finalizeAndReportTiming: te3 }, fetch_1;
    }
    e3(requireFetch, "requireFetch");
    var symbols$2;
    var hasRequiredSymbols$2;
    function requireSymbols$2() {
      return hasRequiredSymbols$2 || (hasRequiredSymbols$2 = 1, symbols$2 = { kState: Symbol("FileReader state"), kResult: Symbol("FileReader result"), kError: Symbol("FileReader error"), kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"), kEvents: Symbol("FileReader events"), kAborted: Symbol("FileReader aborted") }), symbols$2;
    }
    e3(requireSymbols$2, "requireSymbols$2");
    var progressevent;
    var hasRequiredProgressevent;
    function requireProgressevent() {
      if (hasRequiredProgressevent) return progressevent;
      hasRequiredProgressevent = 1;
      const { webidl: A2 } = requireWebidl(), k4 = Symbol("ProgressEvent state"), B3 = class B4 extends Event {
        constructor(y3, R4 = {}) {
          y3 = A2.converters.DOMString(y3, "ProgressEvent constructor", "type"), R4 = A2.converters.ProgressEventInit(R4 ?? {}), super(y3, R4), this[k4] = { lengthComputable: R4.lengthComputable, loaded: R4.loaded, total: R4.total };
        }
        get lengthComputable() {
          return A2.brandCheck(this, B4), this[k4].lengthComputable;
        }
        get loaded() {
          return A2.brandCheck(this, B4), this[k4].loaded;
        }
        get total() {
          return A2.brandCheck(this, B4), this[k4].total;
        }
      };
      e3(B3, "ProgressEvent");
      let c2 = B3;
      return A2.converters.ProgressEventInit = A2.dictionaryConverter([{ key: "lengthComputable", converter: A2.converters.boolean, defaultValue: e3(() => false, "defaultValue") }, { key: "loaded", converter: A2.converters["unsigned long long"], defaultValue: e3(() => 0, "defaultValue") }, { key: "total", converter: A2.converters["unsigned long long"], defaultValue: e3(() => 0, "defaultValue") }, { key: "bubbles", converter: A2.converters.boolean, defaultValue: e3(() => false, "defaultValue") }, { key: "cancelable", converter: A2.converters.boolean, defaultValue: e3(() => false, "defaultValue") }, { key: "composed", converter: A2.converters.boolean, defaultValue: e3(() => false, "defaultValue") }]), progressevent = { ProgressEvent: c2 }, progressevent;
    }
    e3(requireProgressevent, "requireProgressevent");
    var encoding;
    var hasRequiredEncoding;
    function requireEncoding() {
      if (hasRequiredEncoding) return encoding;
      hasRequiredEncoding = 1;
      function A2(k4) {
        if (!k4) return "failure";
        switch (k4.trim().toLowerCase()) {
          case "unicode-1-1-utf-8":
          case "unicode11utf8":
          case "unicode20utf8":
          case "utf-8":
          case "utf8":
          case "x-unicode20utf8":
            return "UTF-8";
          case "866":
          case "cp866":
          case "csibm866":
          case "ibm866":
            return "IBM866";
          case "csisolatin2":
          case "iso-8859-2":
          case "iso-ir-101":
          case "iso8859-2":
          case "iso88592":
          case "iso_8859-2":
          case "iso_8859-2:1987":
          case "l2":
          case "latin2":
            return "ISO-8859-2";
          case "csisolatin3":
          case "iso-8859-3":
          case "iso-ir-109":
          case "iso8859-3":
          case "iso88593":
          case "iso_8859-3":
          case "iso_8859-3:1988":
          case "l3":
          case "latin3":
            return "ISO-8859-3";
          case "csisolatin4":
          case "iso-8859-4":
          case "iso-ir-110":
          case "iso8859-4":
          case "iso88594":
          case "iso_8859-4":
          case "iso_8859-4:1988":
          case "l4":
          case "latin4":
            return "ISO-8859-4";
          case "csisolatincyrillic":
          case "cyrillic":
          case "iso-8859-5":
          case "iso-ir-144":
          case "iso8859-5":
          case "iso88595":
          case "iso_8859-5":
          case "iso_8859-5:1988":
            return "ISO-8859-5";
          case "arabic":
          case "asmo-708":
          case "csiso88596e":
          case "csiso88596i":
          case "csisolatinarabic":
          case "ecma-114":
          case "iso-8859-6":
          case "iso-8859-6-e":
          case "iso-8859-6-i":
          case "iso-ir-127":
          case "iso8859-6":
          case "iso88596":
          case "iso_8859-6":
          case "iso_8859-6:1987":
            return "ISO-8859-6";
          case "csisolatingreek":
          case "ecma-118":
          case "elot_928":
          case "greek":
          case "greek8":
          case "iso-8859-7":
          case "iso-ir-126":
          case "iso8859-7":
          case "iso88597":
          case "iso_8859-7":
          case "iso_8859-7:1987":
          case "sun_eu_greek":
            return "ISO-8859-7";
          case "csiso88598e":
          case "csisolatinhebrew":
          case "hebrew":
          case "iso-8859-8":
          case "iso-8859-8-e":
          case "iso-ir-138":
          case "iso8859-8":
          case "iso88598":
          case "iso_8859-8":
          case "iso_8859-8:1988":
          case "visual":
            return "ISO-8859-8";
          case "csiso88598i":
          case "iso-8859-8-i":
          case "logical":
            return "ISO-8859-8-I";
          case "csisolatin6":
          case "iso-8859-10":
          case "iso-ir-157":
          case "iso8859-10":
          case "iso885910":
          case "l6":
          case "latin6":
            return "ISO-8859-10";
          case "iso-8859-13":
          case "iso8859-13":
          case "iso885913":
            return "ISO-8859-13";
          case "iso-8859-14":
          case "iso8859-14":
          case "iso885914":
            return "ISO-8859-14";
          case "csisolatin9":
          case "iso-8859-15":
          case "iso8859-15":
          case "iso885915":
          case "iso_8859-15":
          case "l9":
            return "ISO-8859-15";
          case "iso-8859-16":
            return "ISO-8859-16";
          case "cskoi8r":
          case "koi":
          case "koi8":
          case "koi8-r":
          case "koi8_r":
            return "KOI8-R";
          case "koi8-ru":
          case "koi8-u":
            return "KOI8-U";
          case "csmacintosh":
          case "mac":
          case "macintosh":
          case "x-mac-roman":
            return "macintosh";
          case "iso-8859-11":
          case "iso8859-11":
          case "iso885911":
          case "tis-620":
          case "windows-874":
            return "windows-874";
          case "cp1250":
          case "windows-1250":
          case "x-cp1250":
            return "windows-1250";
          case "cp1251":
          case "windows-1251":
          case "x-cp1251":
            return "windows-1251";
          case "ansi_x3.4-1968":
          case "ascii":
          case "cp1252":
          case "cp819":
          case "csisolatin1":
          case "ibm819":
          case "iso-8859-1":
          case "iso-ir-100":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "iso_8859-1:1987":
          case "l1":
          case "latin1":
          case "us-ascii":
          case "windows-1252":
          case "x-cp1252":
            return "windows-1252";
          case "cp1253":
          case "windows-1253":
          case "x-cp1253":
            return "windows-1253";
          case "cp1254":
          case "csisolatin5":
          case "iso-8859-9":
          case "iso-ir-148":
          case "iso8859-9":
          case "iso88599":
          case "iso_8859-9":
          case "iso_8859-9:1989":
          case "l5":
          case "latin5":
          case "windows-1254":
          case "x-cp1254":
            return "windows-1254";
          case "cp1255":
          case "windows-1255":
          case "x-cp1255":
            return "windows-1255";
          case "cp1256":
          case "windows-1256":
          case "x-cp1256":
            return "windows-1256";
          case "cp1257":
          case "windows-1257":
          case "x-cp1257":
            return "windows-1257";
          case "cp1258":
          case "windows-1258":
          case "x-cp1258":
            return "windows-1258";
          case "x-mac-cyrillic":
          case "x-mac-ukrainian":
            return "x-mac-cyrillic";
          case "chinese":
          case "csgb2312":
          case "csiso58gb231280":
          case "gb2312":
          case "gb_2312":
          case "gb_2312-80":
          case "gbk":
          case "iso-ir-58":
          case "x-gbk":
            return "GBK";
          case "gb18030":
            return "gb18030";
          case "big5":
          case "big5-hkscs":
          case "cn-big5":
          case "csbig5":
          case "x-x-big5":
            return "Big5";
          case "cseucpkdfmtjapanese":
          case "euc-jp":
          case "x-euc-jp":
            return "EUC-JP";
          case "csiso2022jp":
          case "iso-2022-jp":
            return "ISO-2022-JP";
          case "csshiftjis":
          case "ms932":
          case "ms_kanji":
          case "shift-jis":
          case "shift_jis":
          case "sjis":
          case "windows-31j":
          case "x-sjis":
            return "Shift_JIS";
          case "cseuckr":
          case "csksc56011987":
          case "euc-kr":
          case "iso-ir-149":
          case "korean":
          case "ks_c_5601-1987":
          case "ks_c_5601-1989":
          case "ksc5601":
          case "ksc_5601":
          case "windows-949":
            return "EUC-KR";
          case "csiso2022kr":
          case "hz-gb-2312":
          case "iso-2022-cn":
          case "iso-2022-cn-ext":
          case "iso-2022-kr":
          case "replacement":
            return "replacement";
          case "unicodefffe":
          case "utf-16be":
            return "UTF-16BE";
          case "csunicode":
          case "iso-10646-ucs-2":
          case "ucs-2":
          case "unicode":
          case "unicodefeff":
          case "utf-16":
          case "utf-16le":
            return "UTF-16LE";
          case "x-user-defined":
            return "x-user-defined";
          default:
            return "failure";
        }
      }
      return e3(A2, "getEncoding"), encoding = { getEncoding: A2 }, encoding;
    }
    e3(requireEncoding, "requireEncoding");
    var util$4;
    var hasRequiredUtil$4;
    function requireUtil$4() {
      if (hasRequiredUtil$4) return util$4;
      hasRequiredUtil$4 = 1;
      const { kState: A2, kError: k4, kResult: c2, kAborted: B3, kLastProgressEventFired: t2 } = requireSymbols$2(), { ProgressEvent: y3 } = requireProgressevent(), { getEncoding: R4 } = requireEncoding(), { serializeAMimeType: F2, parseMIMEType: Q5 } = requireDataUrl(), { types: D3 } = require$$0__default$3, { StringDecoder: U6 } = require$$5__default$3, { btoa: r6 } = require$$0__default, o = { enumerable: true, writable: false, configurable: false };
      function N6(J5, V4, _5, q6) {
        if (J5[A2] === "loading") throw new DOMException("Invalid state", "InvalidStateError");
        J5[A2] = "loading", J5[c2] = null, J5[k4] = null;
        const Y4 = V4.stream().getReader(), m4 = [];
        let f3 = Y4.read(), n = true;
        (async () => {
          for (; !J5[B3]; ) try {
            const { done: C5, value: w5 } = await f3;
            if (n && !J5[B3] && queueMicrotask(() => {
              l3("loadstart", J5);
            }), n = false, !C5 && D3.isUint8Array(w5)) m4.push(w5), (J5[t2] === void 0 || Date.now() - J5[t2] >= 50) && !J5[B3] && (J5[t2] = Date.now(), queueMicrotask(() => {
              l3("progress", J5);
            })), f3 = Y4.read();
            else if (C5) {
              queueMicrotask(() => {
                J5[A2] = "done";
                try {
                  const S6 = I5(m4, _5, V4.type, q6);
                  if (J5[B3]) return;
                  J5[c2] = S6, l3("load", J5);
                } catch (S6) {
                  J5[k4] = S6, l3("error", J5);
                }
                J5[A2] !== "loading" && l3("loadend", J5);
              });
              break;
            }
          } catch (C5) {
            if (J5[B3]) return;
            queueMicrotask(() => {
              J5[A2] = "done", J5[k4] = C5, l3("error", J5), J5[A2] !== "loading" && l3("loadend", J5);
            });
            break;
          }
        })();
      }
      e3(N6, "readOperation");
      function l3(J5, V4) {
        const _5 = new y3(J5, { bubbles: false, cancelable: false });
        V4.dispatchEvent(_5);
      }
      e3(l3, "fireAProgressEvent");
      function I5(J5, V4, _5, q6) {
        switch (V4) {
          case "DataURL": {
            let M4 = "data:";
            const Y4 = Q5(_5 || "application/octet-stream");
            Y4 !== "failure" && (M4 += F2(Y4)), M4 += ";base64,";
            const m4 = new U6("latin1");
            for (const f3 of J5) M4 += r6(m4.write(f3));
            return M4 += r6(m4.end()), M4;
          }
          case "Text": {
            let M4 = "failure";
            if (q6 && (M4 = R4(q6)), M4 === "failure" && _5) {
              const Y4 = Q5(_5);
              Y4 !== "failure" && (M4 = R4(Y4.parameters.get("charset")));
            }
            return M4 === "failure" && (M4 = "UTF-8"), p3(J5, M4);
          }
          case "ArrayBuffer":
            return G3(J5).buffer;
          case "BinaryString": {
            let M4 = "";
            const Y4 = new U6("latin1");
            for (const m4 of J5) M4 += Y4.write(m4);
            return M4 += Y4.end(), M4;
          }
        }
      }
      e3(I5, "packageData");
      function p3(J5, V4) {
        const _5 = G3(J5), q6 = b6(_5);
        let M4 = 0;
        q6 !== null && (V4 = q6, M4 = q6 === "UTF-8" ? 3 : 2);
        const Y4 = _5.slice(M4);
        return new TextDecoder(V4).decode(Y4);
      }
      e3(p3, "decode");
      function b6(J5) {
        const [V4, _5, q6] = J5;
        return V4 === 239 && _5 === 187 && q6 === 191 ? "UTF-8" : V4 === 254 && _5 === 255 ? "UTF-16BE" : V4 === 255 && _5 === 254 ? "UTF-16LE" : null;
      }
      e3(b6, "BOMSniffing");
      function G3(J5) {
        const V4 = J5.reduce((q6, M4) => q6 + M4.byteLength, 0);
        let _5 = 0;
        return J5.reduce((q6, M4) => (q6.set(M4, _5), _5 += M4.byteLength, q6), new Uint8Array(V4));
      }
      return e3(G3, "combineByteSequences"), util$4 = { staticPropertyDescriptors: o, readOperation: N6, fireAProgressEvent: l3 }, util$4;
    }
    e3(requireUtil$4, "requireUtil$4");
    var filereader;
    var hasRequiredFilereader;
    function requireFilereader() {
      if (hasRequiredFilereader) return filereader;
      hasRequiredFilereader = 1;
      const { staticPropertyDescriptors: A2, readOperation: k4, fireAProgressEvent: c2 } = requireUtil$4(), { kState: B3, kError: t2, kResult: y3, kEvents: R4, kAborted: F2 } = requireSymbols$2(), { webidl: Q5 } = requireWebidl(), { kEnumerableProperty: D3 } = requireUtil$7(), r6 = class r7 extends EventTarget {
        constructor() {
          super(), this[B3] = "empty", this[y3] = null, this[t2] = null, this[R4] = { loadend: null, error: null, abort: null, load: null, progress: null, loadstart: null };
        }
        readAsArrayBuffer(N6) {
          Q5.brandCheck(this, r7), Q5.argumentLengthCheck(arguments, 1, "FileReader.readAsArrayBuffer"), N6 = Q5.converters.Blob(N6, { strict: false }), k4(this, N6, "ArrayBuffer");
        }
        readAsBinaryString(N6) {
          Q5.brandCheck(this, r7), Q5.argumentLengthCheck(arguments, 1, "FileReader.readAsBinaryString"), N6 = Q5.converters.Blob(N6, { strict: false }), k4(this, N6, "BinaryString");
        }
        readAsText(N6, l3 = void 0) {
          Q5.brandCheck(this, r7), Q5.argumentLengthCheck(arguments, 1, "FileReader.readAsText"), N6 = Q5.converters.Blob(N6, { strict: false }), l3 !== void 0 && (l3 = Q5.converters.DOMString(l3, "FileReader.readAsText", "encoding")), k4(this, N6, "Text", l3);
        }
        readAsDataURL(N6) {
          Q5.brandCheck(this, r7), Q5.argumentLengthCheck(arguments, 1, "FileReader.readAsDataURL"), N6 = Q5.converters.Blob(N6, { strict: false }), k4(this, N6, "DataURL");
        }
        abort() {
          if (this[B3] === "empty" || this[B3] === "done") {
            this[y3] = null;
            return;
          }
          this[B3] === "loading" && (this[B3] = "done", this[y3] = null), this[F2] = true, c2("abort", this), this[B3] !== "loading" && c2("loadend", this);
        }
        get readyState() {
          switch (Q5.brandCheck(this, r7), this[B3]) {
            case "empty":
              return this.EMPTY;
            case "loading":
              return this.LOADING;
            case "done":
              return this.DONE;
          }
        }
        get result() {
          return Q5.brandCheck(this, r7), this[y3];
        }
        get error() {
          return Q5.brandCheck(this, r7), this[t2];
        }
        get onloadend() {
          return Q5.brandCheck(this, r7), this[R4].loadend;
        }
        set onloadend(N6) {
          Q5.brandCheck(this, r7), this[R4].loadend && this.removeEventListener("loadend", this[R4].loadend), typeof N6 == "function" ? (this[R4].loadend = N6, this.addEventListener("loadend", N6)) : this[R4].loadend = null;
        }
        get onerror() {
          return Q5.brandCheck(this, r7), this[R4].error;
        }
        set onerror(N6) {
          Q5.brandCheck(this, r7), this[R4].error && this.removeEventListener("error", this[R4].error), typeof N6 == "function" ? (this[R4].error = N6, this.addEventListener("error", N6)) : this[R4].error = null;
        }
        get onloadstart() {
          return Q5.brandCheck(this, r7), this[R4].loadstart;
        }
        set onloadstart(N6) {
          Q5.brandCheck(this, r7), this[R4].loadstart && this.removeEventListener("loadstart", this[R4].loadstart), typeof N6 == "function" ? (this[R4].loadstart = N6, this.addEventListener("loadstart", N6)) : this[R4].loadstart = null;
        }
        get onprogress() {
          return Q5.brandCheck(this, r7), this[R4].progress;
        }
        set onprogress(N6) {
          Q5.brandCheck(this, r7), this[R4].progress && this.removeEventListener("progress", this[R4].progress), typeof N6 == "function" ? (this[R4].progress = N6, this.addEventListener("progress", N6)) : this[R4].progress = null;
        }
        get onload() {
          return Q5.brandCheck(this, r7), this[R4].load;
        }
        set onload(N6) {
          Q5.brandCheck(this, r7), this[R4].load && this.removeEventListener("load", this[R4].load), typeof N6 == "function" ? (this[R4].load = N6, this.addEventListener("load", N6)) : this[R4].load = null;
        }
        get onabort() {
          return Q5.brandCheck(this, r7), this[R4].abort;
        }
        set onabort(N6) {
          Q5.brandCheck(this, r7), this[R4].abort && this.removeEventListener("abort", this[R4].abort), typeof N6 == "function" ? (this[R4].abort = N6, this.addEventListener("abort", N6)) : this[R4].abort = null;
        }
      };
      e3(r6, "FileReader");
      let U6 = r6;
      return U6.EMPTY = U6.prototype.EMPTY = 0, U6.LOADING = U6.prototype.LOADING = 1, U6.DONE = U6.prototype.DONE = 2, Object.defineProperties(U6.prototype, { EMPTY: A2, LOADING: A2, DONE: A2, readAsArrayBuffer: D3, readAsBinaryString: D3, readAsText: D3, readAsDataURL: D3, abort: D3, readyState: D3, result: D3, error: D3, onloadstart: D3, onprogress: D3, onload: D3, onabort: D3, onerror: D3, onloadend: D3, [Symbol.toStringTag]: { value: "FileReader", writable: false, enumerable: false, configurable: true } }), Object.defineProperties(U6, { EMPTY: A2, LOADING: A2, DONE: A2 }), filereader = { FileReader: U6 }, filereader;
    }
    e3(requireFilereader, "requireFilereader");
    var symbols$1;
    var hasRequiredSymbols$1;
    function requireSymbols$1() {
      return hasRequiredSymbols$1 || (hasRequiredSymbols$1 = 1, symbols$1 = { kConstruct: requireSymbols$4().kConstruct }), symbols$1;
    }
    e3(requireSymbols$1, "requireSymbols$1");
    var util$3;
    var hasRequiredUtil$3;
    function requireUtil$3() {
      if (hasRequiredUtil$3) return util$3;
      hasRequiredUtil$3 = 1;
      const A2 = require$$0__default$1, { URLSerializer: k4 } = requireDataUrl(), { isValidHeaderName: c2 } = requireUtil$6();
      function B3(y3, R4, F2 = false) {
        const Q5 = k4(y3, F2), D3 = k4(R4, F2);
        return Q5 === D3;
      }
      e3(B3, "urlEquals");
      function t2(y3) {
        A2(y3 !== null);
        const R4 = [];
        for (let F2 of y3.split(",")) F2 = F2.trim(), c2(F2) && R4.push(F2);
        return R4;
      }
      return e3(t2, "getFieldValues"), util$3 = { urlEquals: B3, getFieldValues: t2 }, util$3;
    }
    e3(requireUtil$3, "requireUtil$3");
    var cache2;
    var hasRequiredCache;
    function requireCache() {
      var J5, V4, pe2, ue3, Oe2, be3;
      if (hasRequiredCache) return cache2;
      hasRequiredCache = 1;
      const { kConstruct: A2 } = requireSymbols$1(), { urlEquals: k4, getFieldValues: c2 } = requireUtil$3(), { kEnumerableProperty: B3, isDisturbed: t2 } = requireUtil$7(), { webidl: y3 } = requireWebidl(), { Response: R4, cloneResponse: F2, fromInnerResponse: Q5 } = requireResponse(), { Request: D3, fromInnerRequest: U6 } = requireRequest(), { kState: r6 } = requireSymbols$3(), { fetching: o } = requireFetch(), { urlIsHttpHttpsScheme: N6, createDeferredPromise: l3, readAllBytes: I5 } = requireUtil$6(), p3 = require$$0__default$1, m4 = class m5 {
        constructor() {
          SA(this, V4);
          SA(this, J5);
          arguments[0] !== A2 && y3.illegalConstructor(), y3.util.markAsUncloneable(this), mA(this, J5, arguments[1]);
        }
        async match(n, C5 = {}) {
          y3.brandCheck(this, m5);
          const w5 = "Cache.match";
          y3.argumentLengthCheck(arguments, 1, w5), n = y3.converters.RequestInfo(n, w5, "request"), C5 = y3.converters.CacheQueryOptions(C5, w5, "options");
          const S6 = ee3(this, V4, be3).call(this, n, C5, 1);
          if (S6.length !== 0) return S6[0];
        }
        async matchAll(n = void 0, C5 = {}) {
          y3.brandCheck(this, m5);
          const w5 = "Cache.matchAll";
          return n !== void 0 && (n = y3.converters.RequestInfo(n, w5, "request")), C5 = y3.converters.CacheQueryOptions(C5, w5, "options"), ee3(this, V4, be3).call(this, n, C5);
        }
        async add(n) {
          y3.brandCheck(this, m5);
          const C5 = "Cache.add";
          y3.argumentLengthCheck(arguments, 1, C5), n = y3.converters.RequestInfo(n, C5, "request");
          const w5 = [n];
          return await this.addAll(w5);
        }
        async addAll(n) {
          y3.brandCheck(this, m5);
          const C5 = "Cache.addAll";
          y3.argumentLengthCheck(arguments, 1, C5);
          const w5 = [], S6 = [];
          for (let RA of n) {
            if (RA === void 0) throw y3.errors.conversionFailed({ prefix: C5, argument: "Argument 1", types: ["undefined is not allowed"] });
            if (RA = y3.converters.RequestInfo(RA), typeof RA == "string") continue;
            const IA = RA[r6];
            if (!N6(IA.url) || IA.method !== "GET") throw y3.errors.exception({ header: C5, message: "Expected http/s scheme when method is not GET." });
          }
          const x5 = [];
          for (const RA of n) {
            const IA = new D3(RA)[r6];
            if (!N6(IA.url)) throw y3.errors.exception({ header: C5, message: "Expected http/s scheme." });
            IA.initiator = "fetch", IA.destination = "subresource", S6.push(IA);
            const CA = l3();
            x5.push(o({ request: IA, processResponse(pA) {
              if (pA.type === "error" || pA.status === 206 || pA.status < 200 || pA.status > 299) CA.reject(y3.errors.exception({ header: "Cache.addAll", message: "Received an invalid status code or the request failed." }));
              else if (pA.headersList.contains("vary")) {
                const fA = c2(pA.headersList.get("vary"));
                for (const kA of fA) if (kA === "*") {
                  CA.reject(y3.errors.exception({ header: "Cache.addAll", message: "invalid vary field value" }));
                  for (const bA of x5) bA.abort();
                  return;
                }
              }
            }, processResponseEndOfBody(pA) {
              if (pA.aborted) {
                CA.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              CA.resolve(pA);
            } })), w5.push(CA.promise);
          }
          const $6 = await Promise.all(w5), K4 = [];
          let nA = 0;
          for (const RA of $6) {
            const IA = { type: "put", request: S6[nA], response: RA };
            K4.push(IA), nA++;
          }
          const iA = l3();
          let uA = null;
          try {
            ee3(this, V4, pe2).call(this, K4);
          } catch (RA) {
            uA = RA;
          }
          return queueMicrotask(() => {
            uA === null ? iA.resolve(void 0) : iA.reject(uA);
          }), iA.promise;
        }
        async put(n, C5) {
          y3.brandCheck(this, m5);
          const w5 = "Cache.put";
          y3.argumentLengthCheck(arguments, 2, w5), n = y3.converters.RequestInfo(n, w5, "request"), C5 = y3.converters.Response(C5, w5, "response");
          let S6 = null;
          if (n instanceof D3 ? S6 = n[r6] : S6 = new D3(n)[r6], !N6(S6.url) || S6.method !== "GET") throw y3.errors.exception({ header: w5, message: "Expected an http/s scheme when method is not GET" });
          const x5 = C5[r6];
          if (x5.status === 206) throw y3.errors.exception({ header: w5, message: "Got 206 status" });
          if (x5.headersList.contains("vary")) {
            const IA = c2(x5.headersList.get("vary"));
            for (const CA of IA) if (CA === "*") throw y3.errors.exception({ header: w5, message: "Got * vary field value" });
          }
          if (x5.body && (t2(x5.body.stream) || x5.body.stream.locked)) throw y3.errors.exception({ header: w5, message: "Response body is locked or disturbed" });
          const z4 = F2(x5), $6 = l3();
          if (x5.body != null) {
            const CA = x5.body.stream.getReader();
            I5(CA).then($6.resolve, $6.reject);
          } else $6.resolve(void 0);
          const K4 = [], nA = { type: "put", request: S6, response: z4 };
          K4.push(nA);
          const iA = await $6.promise;
          z4.body != null && (z4.body.source = iA);
          const uA = l3();
          let RA = null;
          try {
            ee3(this, V4, pe2).call(this, K4);
          } catch (IA) {
            RA = IA;
          }
          return queueMicrotask(() => {
            RA === null ? uA.resolve() : uA.reject(RA);
          }), uA.promise;
        }
        async delete(n, C5 = {}) {
          y3.brandCheck(this, m5);
          const w5 = "Cache.delete";
          y3.argumentLengthCheck(arguments, 1, w5), n = y3.converters.RequestInfo(n, w5, "request"), C5 = y3.converters.CacheQueryOptions(C5, w5, "options");
          let S6 = null;
          if (n instanceof D3) {
            if (S6 = n[r6], S6.method !== "GET" && !C5.ignoreMethod) return false;
          } else p3(typeof n == "string"), S6 = new D3(n)[r6];
          const x5 = [], z4 = { type: "delete", request: S6, options: C5 };
          x5.push(z4);
          const $6 = l3();
          let K4 = null, nA;
          try {
            nA = ee3(this, V4, pe2).call(this, x5);
          } catch (iA) {
            K4 = iA;
          }
          return queueMicrotask(() => {
            K4 === null ? $6.resolve(!!nA?.length) : $6.reject(K4);
          }), $6.promise;
        }
        async keys(n = void 0, C5 = {}) {
          y3.brandCheck(this, m5);
          const w5 = "Cache.keys";
          n !== void 0 && (n = y3.converters.RequestInfo(n, w5, "request")), C5 = y3.converters.CacheQueryOptions(C5, w5, "options");
          let S6 = null;
          if (n !== void 0) if (n instanceof D3) {
            if (S6 = n[r6], S6.method !== "GET" && !C5.ignoreMethod) return [];
          } else typeof n == "string" && (S6 = new D3(n)[r6]);
          const x5 = l3(), z4 = [];
          if (n === void 0) for (const $6 of Z4(this, J5)) z4.push($6[0]);
          else {
            const $6 = ee3(this, V4, ue3).call(this, S6, C5);
            for (const K4 of $6) z4.push(K4[0]);
          }
          return queueMicrotask(() => {
            const $6 = [];
            for (const K4 of z4) {
              const nA = U6(K4, new AbortController().signal, "immutable");
              $6.push(nA);
            }
            x5.resolve(Object.freeze($6));
          }), x5.promise;
        }
      };
      J5 = /* @__PURE__ */ new WeakMap(), V4 = /* @__PURE__ */ new WeakSet(), pe2 = e3(function(n) {
        const C5 = Z4(this, J5), w5 = [...C5], S6 = [], x5 = [];
        try {
          for (const z4 of n) {
            if (z4.type !== "delete" && z4.type !== "put") throw y3.errors.exception({ header: "Cache.#batchCacheOperations", message: 'operation type does not match "delete" or "put"' });
            if (z4.type === "delete" && z4.response != null) throw y3.errors.exception({ header: "Cache.#batchCacheOperations", message: "delete operation should not have an associated response" });
            if (ee3(this, V4, ue3).call(this, z4.request, z4.options, S6).length) throw new DOMException("???", "InvalidStateError");
            let $6;
            if (z4.type === "delete") {
              if ($6 = ee3(this, V4, ue3).call(this, z4.request, z4.options), $6.length === 0) return [];
              for (const K4 of $6) {
                const nA = C5.indexOf(K4);
                p3(nA !== -1), C5.splice(nA, 1);
              }
            } else if (z4.type === "put") {
              if (z4.response == null) throw y3.errors.exception({ header: "Cache.#batchCacheOperations", message: "put operation should have an associated response" });
              const K4 = z4.request;
              if (!N6(K4.url)) throw y3.errors.exception({ header: "Cache.#batchCacheOperations", message: "expected http or https scheme" });
              if (K4.method !== "GET") throw y3.errors.exception({ header: "Cache.#batchCacheOperations", message: "not get method" });
              if (z4.options != null) throw y3.errors.exception({ header: "Cache.#batchCacheOperations", message: "options must not be defined" });
              $6 = ee3(this, V4, ue3).call(this, z4.request);
              for (const nA of $6) {
                const iA = C5.indexOf(nA);
                p3(iA !== -1), C5.splice(iA, 1);
              }
              C5.push([z4.request, z4.response]), S6.push([z4.request, z4.response]);
            }
            x5.push([z4.request, z4.response]);
          }
          return x5;
        } catch (z4) {
          throw Z4(this, J5).length = 0, mA(this, J5, w5), z4;
        }
      }, "#batchCacheOperations"), ue3 = e3(function(n, C5, w5) {
        const S6 = [], x5 = w5 ?? Z4(this, J5);
        for (const z4 of x5) {
          const [$6, K4] = z4;
          ee3(this, V4, Oe2).call(this, n, $6, K4, C5) && S6.push(z4);
        }
        return S6;
      }, "#queryCache"), Oe2 = e3(function(n, C5, w5 = null, S6) {
        const x5 = new URL(n.url), z4 = new URL(C5.url);
        if (S6?.ignoreSearch && (z4.search = "", x5.search = ""), !k4(x5, z4, true)) return false;
        if (w5 == null || S6?.ignoreVary || !w5.headersList.contains("vary")) return true;
        const $6 = c2(w5.headersList.get("vary"));
        for (const K4 of $6) {
          if (K4 === "*") return false;
          const nA = C5.headersList.get(K4), iA = n.headersList.get(K4);
          if (nA !== iA) return false;
        }
        return true;
      }, "#requestMatchesCachedItem"), be3 = e3(function(n, C5, w5 = 1 / 0) {
        let S6 = null;
        if (n !== void 0) if (n instanceof D3) {
          if (S6 = n[r6], S6.method !== "GET" && !C5.ignoreMethod) return [];
        } else typeof n == "string" && (S6 = new D3(n)[r6]);
        const x5 = [];
        if (n === void 0) for (const $6 of Z4(this, J5)) x5.push($6[1]);
        else {
          const $6 = ee3(this, V4, ue3).call(this, S6, C5);
          for (const K4 of $6) x5.push(K4[1]);
        }
        const z4 = [];
        for (const $6 of x5) {
          const K4 = Q5($6, "immutable");
          if (z4.push(K4.clone()), z4.length >= w5) break;
        }
        return Object.freeze(z4);
      }, "#internalMatchAll"), e3(m4, "Cache");
      let b6 = m4;
      Object.defineProperties(b6.prototype, { [Symbol.toStringTag]: { value: "Cache", configurable: true }, match: B3, matchAll: B3, add: B3, addAll: B3, put: B3, delete: B3, keys: B3 });
      const G3 = [{ key: "ignoreSearch", converter: y3.converters.boolean, defaultValue: e3(() => false, "defaultValue") }, { key: "ignoreMethod", converter: y3.converters.boolean, defaultValue: e3(() => false, "defaultValue") }, { key: "ignoreVary", converter: y3.converters.boolean, defaultValue: e3(() => false, "defaultValue") }];
      return y3.converters.CacheQueryOptions = y3.dictionaryConverter(G3), y3.converters.MultiCacheQueryOptions = y3.dictionaryConverter([...G3, { key: "cacheName", converter: y3.converters.DOMString }]), y3.converters.Response = y3.interfaceConverter(R4), y3.converters["sequence<RequestInfo>"] = y3.sequenceConverter(y3.converters.RequestInfo), cache2 = { Cache: b6 }, cache2;
    }
    e3(requireCache, "requireCache");
    var cachestorage;
    var hasRequiredCachestorage;
    function requireCachestorage() {
      var y3;
      if (hasRequiredCachestorage) return cachestorage;
      hasRequiredCachestorage = 1;
      const { kConstruct: A2 } = requireSymbols$1(), { Cache: k4 } = requireCache(), { webidl: c2 } = requireWebidl(), { kEnumerableProperty: B3 } = requireUtil$7(), R4 = class R5 {
        constructor() {
          SA(this, y3, /* @__PURE__ */ new Map());
          arguments[0] !== A2 && c2.illegalConstructor(), c2.util.markAsUncloneable(this);
        }
        async match(Q5, D3 = {}) {
          if (c2.brandCheck(this, R5), c2.argumentLengthCheck(arguments, 1, "CacheStorage.match"), Q5 = c2.converters.RequestInfo(Q5), D3 = c2.converters.MultiCacheQueryOptions(D3), D3.cacheName != null) {
            if (Z4(this, y3).has(D3.cacheName)) {
              const U6 = Z4(this, y3).get(D3.cacheName);
              return await new k4(A2, U6).match(Q5, D3);
            }
          } else for (const U6 of Z4(this, y3).values()) {
            const o = await new k4(A2, U6).match(Q5, D3);
            if (o !== void 0) return o;
          }
        }
        async has(Q5) {
          c2.brandCheck(this, R5);
          const D3 = "CacheStorage.has";
          return c2.argumentLengthCheck(arguments, 1, D3), Q5 = c2.converters.DOMString(Q5, D3, "cacheName"), Z4(this, y3).has(Q5);
        }
        async open(Q5) {
          c2.brandCheck(this, R5);
          const D3 = "CacheStorage.open";
          if (c2.argumentLengthCheck(arguments, 1, D3), Q5 = c2.converters.DOMString(Q5, D3, "cacheName"), Z4(this, y3).has(Q5)) {
            const r6 = Z4(this, y3).get(Q5);
            return new k4(A2, r6);
          }
          const U6 = [];
          return Z4(this, y3).set(Q5, U6), new k4(A2, U6);
        }
        async delete(Q5) {
          c2.brandCheck(this, R5);
          const D3 = "CacheStorage.delete";
          return c2.argumentLengthCheck(arguments, 1, D3), Q5 = c2.converters.DOMString(Q5, D3, "cacheName"), Z4(this, y3).delete(Q5);
        }
        async keys() {
          return c2.brandCheck(this, R5), [...Z4(this, y3).keys()];
        }
      };
      y3 = /* @__PURE__ */ new WeakMap(), e3(R4, "CacheStorage");
      let t2 = R4;
      return Object.defineProperties(t2.prototype, { [Symbol.toStringTag]: { value: "CacheStorage", configurable: true }, match: B3, has: B3, open: B3, delete: B3, keys: B3 }), cachestorage = { CacheStorage: t2 }, cachestorage;
    }
    e3(requireCachestorage, "requireCachestorage");
    var constants$1;
    var hasRequiredConstants$1;
    function requireConstants$1() {
      return hasRequiredConstants$1 || (hasRequiredConstants$1 = 1, constants$1 = { maxAttributeValueSize: 1024, maxNameValuePairSize: 4096 }), constants$1;
    }
    e3(requireConstants$1, "requireConstants$1");
    var util$2;
    var hasRequiredUtil$2;
    function requireUtil$2() {
      if (hasRequiredUtil$2) return util$2;
      hasRequiredUtil$2 = 1;
      function A2(r6) {
        for (let o = 0; o < r6.length; ++o) {
          const N6 = r6.charCodeAt(o);
          if (N6 >= 0 && N6 <= 8 || N6 >= 10 && N6 <= 31 || N6 === 127) return true;
        }
        return false;
      }
      e3(A2, "isCTLExcludingHtab");
      function k4(r6) {
        for (let o = 0; o < r6.length; ++o) {
          const N6 = r6.charCodeAt(o);
          if (N6 < 33 || N6 > 126 || N6 === 34 || N6 === 40 || N6 === 41 || N6 === 60 || N6 === 62 || N6 === 64 || N6 === 44 || N6 === 59 || N6 === 58 || N6 === 92 || N6 === 47 || N6 === 91 || N6 === 93 || N6 === 63 || N6 === 61 || N6 === 123 || N6 === 125) throw new Error("Invalid cookie name");
        }
      }
      e3(k4, "validateCookieName");
      function c2(r6) {
        let o = r6.length, N6 = 0;
        if (r6[0] === '"') {
          if (o === 1 || r6[o - 1] !== '"') throw new Error("Invalid cookie value");
          --o, ++N6;
        }
        for (; N6 < o; ) {
          const l3 = r6.charCodeAt(N6++);
          if (l3 < 33 || l3 > 126 || l3 === 34 || l3 === 44 || l3 === 59 || l3 === 92) throw new Error("Invalid cookie value");
        }
      }
      e3(c2, "validateCookieValue");
      function B3(r6) {
        for (let o = 0; o < r6.length; ++o) {
          const N6 = r6.charCodeAt(o);
          if (N6 < 32 || N6 === 127 || N6 === 59) throw new Error("Invalid cookie path");
        }
      }
      e3(B3, "validateCookiePath");
      function t2(r6) {
        if (r6.startsWith("-") || r6.endsWith(".") || r6.endsWith("-")) throw new Error("Invalid cookie domain");
      }
      e3(t2, "validateCookieDomain");
      const y3 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], R4 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], F2 = Array(61).fill(0).map((r6, o) => o.toString().padStart(2, "0"));
      function Q5(r6) {
        return typeof r6 == "number" && (r6 = new Date(r6)), `${y3[r6.getUTCDay()]}, ${F2[r6.getUTCDate()]} ${R4[r6.getUTCMonth()]} ${r6.getUTCFullYear()} ${F2[r6.getUTCHours()]}:${F2[r6.getUTCMinutes()]}:${F2[r6.getUTCSeconds()]} GMT`;
      }
      e3(Q5, "toIMFDate");
      function D3(r6) {
        if (r6 < 0) throw new Error("Invalid cookie max-age");
      }
      e3(D3, "validateCookieMaxAge");
      function U6(r6) {
        if (r6.name.length === 0) return null;
        k4(r6.name), c2(r6.value);
        const o = [`${r6.name}=${r6.value}`];
        r6.name.startsWith("__Secure-") && (r6.secure = true), r6.name.startsWith("__Host-") && (r6.secure = true, r6.domain = null, r6.path = "/"), r6.secure && o.push("Secure"), r6.httpOnly && o.push("HttpOnly"), typeof r6.maxAge == "number" && (D3(r6.maxAge), o.push(`Max-Age=${r6.maxAge}`)), r6.domain && (t2(r6.domain), o.push(`Domain=${r6.domain}`)), r6.path && (B3(r6.path), o.push(`Path=${r6.path}`)), r6.expires && r6.expires.toString() !== "Invalid Date" && o.push(`Expires=${Q5(r6.expires)}`), r6.sameSite && o.push(`SameSite=${r6.sameSite}`);
        for (const N6 of r6.unparsed) {
          if (!N6.includes("=")) throw new Error("Invalid unparsed");
          const [l3, ...I5] = N6.split("=");
          o.push(`${l3.trim()}=${I5.join("=")}`);
        }
        return o.join("; ");
      }
      return e3(U6, "stringify"), util$2 = { isCTLExcludingHtab: A2, validateCookieName: k4, validateCookiePath: B3, validateCookieValue: c2, toIMFDate: Q5, stringify: U6 }, util$2;
    }
    e3(requireUtil$2, "requireUtil$2");
    var parse6;
    var hasRequiredParse;
    function requireParse() {
      if (hasRequiredParse) return parse6;
      hasRequiredParse = 1;
      const { maxNameValuePairSize: A2, maxAttributeValueSize: k4 } = requireConstants$1(), { isCTLExcludingHtab: c2 } = requireUtil$2(), { collectASequenceOfCodePointsFast: B3 } = requireDataUrl(), t2 = require$$0__default$1;
      function y3(F2) {
        if (c2(F2)) return null;
        let Q5 = "", D3 = "", U6 = "", r6 = "";
        if (F2.includes(";")) {
          const o = { position: 0 };
          Q5 = B3(";", F2, o), D3 = F2.slice(o.position);
        } else Q5 = F2;
        if (!Q5.includes("=")) r6 = Q5;
        else {
          const o = { position: 0 };
          U6 = B3("=", Q5, o), r6 = Q5.slice(o.position + 1);
        }
        return U6 = U6.trim(), r6 = r6.trim(), U6.length + r6.length > A2 ? null : { name: U6, value: r6, ...R4(D3) };
      }
      e3(y3, "parseSetCookie");
      function R4(F2, Q5 = {}) {
        if (F2.length === 0) return Q5;
        t2(F2[0] === ";"), F2 = F2.slice(1);
        let D3 = "";
        F2.includes(";") ? (D3 = B3(";", F2, { position: 0 }), F2 = F2.slice(D3.length)) : (D3 = F2, F2 = "");
        let U6 = "", r6 = "";
        if (D3.includes("=")) {
          const N6 = { position: 0 };
          U6 = B3("=", D3, N6), r6 = D3.slice(N6.position + 1);
        } else U6 = D3;
        if (U6 = U6.trim(), r6 = r6.trim(), r6.length > k4) return R4(F2, Q5);
        const o = U6.toLowerCase();
        if (o === "expires") {
          const N6 = new Date(r6);
          Q5.expires = N6;
        } else if (o === "max-age") {
          const N6 = r6.charCodeAt(0);
          if ((N6 < 48 || N6 > 57) && r6[0] !== "-" || !/^\d+$/.test(r6)) return R4(F2, Q5);
          const l3 = Number(r6);
          Q5.maxAge = l3;
        } else if (o === "domain") {
          let N6 = r6;
          N6[0] === "." && (N6 = N6.slice(1)), N6 = N6.toLowerCase(), Q5.domain = N6;
        } else if (o === "path") {
          let N6 = "";
          r6.length === 0 || r6[0] !== "/" ? N6 = "/" : N6 = r6, Q5.path = N6;
        } else if (o === "secure") Q5.secure = true;
        else if (o === "httponly") Q5.httpOnly = true;
        else if (o === "samesite") {
          let N6 = "Default";
          const l3 = r6.toLowerCase();
          l3.includes("none") && (N6 = "None"), l3.includes("strict") && (N6 = "Strict"), l3.includes("lax") && (N6 = "Lax"), Q5.sameSite = N6;
        } else Q5.unparsed ?? (Q5.unparsed = []), Q5.unparsed.push(`${U6}=${r6}`);
        return R4(F2, Q5);
      }
      return e3(R4, "parseUnparsedAttributes"), parse6 = { parseSetCookie: y3, parseUnparsedAttributes: R4 }, parse6;
    }
    e3(requireParse, "requireParse");
    var cookies;
    var hasRequiredCookies;
    function requireCookies() {
      if (hasRequiredCookies) return cookies;
      hasRequiredCookies = 1;
      const { parseSetCookie: A2 } = requireParse(), { stringify: k4 } = requireUtil$2(), { webidl: c2 } = requireWebidl(), { Headers: B3 } = requireHeaders();
      function t2(Q5) {
        c2.argumentLengthCheck(arguments, 1, "getCookies"), c2.brandCheck(Q5, B3, { strict: false });
        const D3 = Q5.get("cookie"), U6 = {};
        if (!D3) return U6;
        for (const r6 of D3.split(";")) {
          const [o, ...N6] = r6.split("=");
          U6[o.trim()] = N6.join("=");
        }
        return U6;
      }
      e3(t2, "getCookies");
      function y3(Q5, D3, U6) {
        c2.brandCheck(Q5, B3, { strict: false });
        const r6 = "deleteCookie";
        c2.argumentLengthCheck(arguments, 2, r6), D3 = c2.converters.DOMString(D3, r6, "name"), U6 = c2.converters.DeleteCookieAttributes(U6), F2(Q5, { name: D3, value: "", expires: /* @__PURE__ */ new Date(0), ...U6 });
      }
      e3(y3, "deleteCookie");
      function R4(Q5) {
        c2.argumentLengthCheck(arguments, 1, "getSetCookies"), c2.brandCheck(Q5, B3, { strict: false });
        const D3 = Q5.getSetCookie();
        return D3 ? D3.map((U6) => A2(U6)) : [];
      }
      e3(R4, "getSetCookies");
      function F2(Q5, D3) {
        c2.argumentLengthCheck(arguments, 2, "setCookie"), c2.brandCheck(Q5, B3, { strict: false }), D3 = c2.converters.Cookie(D3);
        const U6 = k4(D3);
        U6 && Q5.append("Set-Cookie", U6);
      }
      return e3(F2, "setCookie"), c2.converters.DeleteCookieAttributes = c2.dictionaryConverter([{ converter: c2.nullableConverter(c2.converters.DOMString), key: "path", defaultValue: e3(() => null, "defaultValue") }, { converter: c2.nullableConverter(c2.converters.DOMString), key: "domain", defaultValue: e3(() => null, "defaultValue") }]), c2.converters.Cookie = c2.dictionaryConverter([{ converter: c2.converters.DOMString, key: "name" }, { converter: c2.converters.DOMString, key: "value" }, { converter: c2.nullableConverter((Q5) => typeof Q5 == "number" ? c2.converters["unsigned long long"](Q5) : new Date(Q5)), key: "expires", defaultValue: e3(() => null, "defaultValue") }, { converter: c2.nullableConverter(c2.converters["long long"]), key: "maxAge", defaultValue: e3(() => null, "defaultValue") }, { converter: c2.nullableConverter(c2.converters.DOMString), key: "domain", defaultValue: e3(() => null, "defaultValue") }, { converter: c2.nullableConverter(c2.converters.DOMString), key: "path", defaultValue: e3(() => null, "defaultValue") }, { converter: c2.nullableConverter(c2.converters.boolean), key: "secure", defaultValue: e3(() => null, "defaultValue") }, { converter: c2.nullableConverter(c2.converters.boolean), key: "httpOnly", defaultValue: e3(() => null, "defaultValue") }, { converter: c2.converters.USVString, key: "sameSite", allowedValues: ["Strict", "Lax", "None"] }, { converter: c2.sequenceConverter(c2.converters.DOMString), key: "unparsed", defaultValue: e3(() => new Array(0), "defaultValue") }]), cookies = { getCookies: t2, deleteCookie: y3, getSetCookies: R4, setCookie: F2 }, cookies;
    }
    e3(requireCookies, "requireCookies");
    var events;
    var hasRequiredEvents;
    function requireEvents() {
      var D3, o, l3;
      if (hasRequiredEvents) return events;
      hasRequiredEvents = 1;
      const { webidl: A2 } = requireWebidl(), { kEnumerableProperty: k4 } = requireUtil$7(), { kConstruct: c2 } = requireSymbols$4(), { MessagePort: B3 } = require$$1__default, r6 = class r7 extends Event {
        constructor(G3, J5 = {}) {
          var b6 = (...U6) => (super(...U6), SA(this, D3), this);
          if (G3 === c2) {
            b6(arguments[1], arguments[2]), A2.util.markAsUncloneable(this);
            return;
          }
          const V4 = "MessageEvent constructor";
          A2.argumentLengthCheck(arguments, 1, V4), G3 = A2.converters.DOMString(G3, V4, "type"), J5 = A2.converters.MessageEventInit(J5, V4, "eventInitDict"), b6(G3, J5), mA(this, D3, J5), A2.util.markAsUncloneable(this);
        }
        get data() {
          return A2.brandCheck(this, r7), Z4(this, D3).data;
        }
        get origin() {
          return A2.brandCheck(this, r7), Z4(this, D3).origin;
        }
        get lastEventId() {
          return A2.brandCheck(this, r7), Z4(this, D3).lastEventId;
        }
        get source() {
          return A2.brandCheck(this, r7), Z4(this, D3).source;
        }
        get ports() {
          return A2.brandCheck(this, r7), Object.isFrozen(Z4(this, D3).ports) || Object.freeze(Z4(this, D3).ports), Z4(this, D3).ports;
        }
        initMessageEvent(G3, J5 = false, V4 = false, _5 = null, q6 = "", M4 = "", Y4 = null, m4 = []) {
          return A2.brandCheck(this, r7), A2.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent"), new r7(G3, { bubbles: J5, cancelable: V4, data: _5, origin: q6, lastEventId: M4, source: Y4, ports: m4 });
        }
        static createFastMessageEvent(G3, J5) {
          var _5, q6, M4, Y4, m4;
          const V4 = new r7(c2, G3, J5);
          return mA(V4, D3, J5), (_5 = Z4(V4, D3)).data ?? (_5.data = null), (q6 = Z4(V4, D3)).origin ?? (q6.origin = ""), (M4 = Z4(V4, D3)).lastEventId ?? (M4.lastEventId = ""), (Y4 = Z4(V4, D3)).source ?? (Y4.source = null), (m4 = Z4(V4, D3)).ports ?? (m4.ports = []), V4;
        }
      };
      D3 = /* @__PURE__ */ new WeakMap(), e3(r6, "MessageEvent");
      let t2 = r6;
      const { createFastMessageEvent: y3 } = t2;
      delete t2.createFastMessageEvent;
      const N6 = class N7 extends Event {
        constructor(G3, J5 = {}) {
          const V4 = "CloseEvent constructor";
          A2.argumentLengthCheck(arguments, 1, V4), G3 = A2.converters.DOMString(G3, V4, "type"), J5 = A2.converters.CloseEventInit(J5);
          super(G3, J5);
          SA(this, o);
          mA(this, o, J5), A2.util.markAsUncloneable(this);
        }
        get wasClean() {
          return A2.brandCheck(this, N7), Z4(this, o).wasClean;
        }
        get code() {
          return A2.brandCheck(this, N7), Z4(this, o).code;
        }
        get reason() {
          return A2.brandCheck(this, N7), Z4(this, o).reason;
        }
      };
      o = /* @__PURE__ */ new WeakMap(), e3(N6, "CloseEvent");
      let R4 = N6;
      const I5 = class I6 extends Event {
        constructor(G3, J5) {
          const V4 = "ErrorEvent constructor";
          A2.argumentLengthCheck(arguments, 1, V4);
          super(G3, J5);
          SA(this, l3);
          A2.util.markAsUncloneable(this), G3 = A2.converters.DOMString(G3, V4, "type"), J5 = A2.converters.ErrorEventInit(J5 ?? {}), mA(this, l3, J5);
        }
        get message() {
          return A2.brandCheck(this, I6), Z4(this, l3).message;
        }
        get filename() {
          return A2.brandCheck(this, I6), Z4(this, l3).filename;
        }
        get lineno() {
          return A2.brandCheck(this, I6), Z4(this, l3).lineno;
        }
        get colno() {
          return A2.brandCheck(this, I6), Z4(this, l3).colno;
        }
        get error() {
          return A2.brandCheck(this, I6), Z4(this, l3).error;
        }
      };
      l3 = /* @__PURE__ */ new WeakMap(), e3(I5, "ErrorEvent");
      let F2 = I5;
      Object.defineProperties(t2.prototype, { [Symbol.toStringTag]: { value: "MessageEvent", configurable: true }, data: k4, origin: k4, lastEventId: k4, source: k4, ports: k4, initMessageEvent: k4 }), Object.defineProperties(R4.prototype, { [Symbol.toStringTag]: { value: "CloseEvent", configurable: true }, reason: k4, code: k4, wasClean: k4 }), Object.defineProperties(F2.prototype, { [Symbol.toStringTag]: { value: "ErrorEvent", configurable: true }, message: k4, filename: k4, lineno: k4, colno: k4, error: k4 }), A2.converters.MessagePort = A2.interfaceConverter(B3), A2.converters["sequence<MessagePort>"] = A2.sequenceConverter(A2.converters.MessagePort);
      const Q5 = [{ key: "bubbles", converter: A2.converters.boolean, defaultValue: e3(() => false, "defaultValue") }, { key: "cancelable", converter: A2.converters.boolean, defaultValue: e3(() => false, "defaultValue") }, { key: "composed", converter: A2.converters.boolean, defaultValue: e3(() => false, "defaultValue") }];
      return A2.converters.MessageEventInit = A2.dictionaryConverter([...Q5, { key: "data", converter: A2.converters.any, defaultValue: e3(() => null, "defaultValue") }, { key: "origin", converter: A2.converters.USVString, defaultValue: e3(() => "", "defaultValue") }, { key: "lastEventId", converter: A2.converters.DOMString, defaultValue: e3(() => "", "defaultValue") }, { key: "source", converter: A2.nullableConverter(A2.converters.MessagePort), defaultValue: e3(() => null, "defaultValue") }, { key: "ports", converter: A2.converters["sequence<MessagePort>"], defaultValue: e3(() => new Array(0), "defaultValue") }]), A2.converters.CloseEventInit = A2.dictionaryConverter([...Q5, { key: "wasClean", converter: A2.converters.boolean, defaultValue: e3(() => false, "defaultValue") }, { key: "code", converter: A2.converters["unsigned short"], defaultValue: e3(() => 0, "defaultValue") }, { key: "reason", converter: A2.converters.USVString, defaultValue: e3(() => "", "defaultValue") }]), A2.converters.ErrorEventInit = A2.dictionaryConverter([...Q5, { key: "message", converter: A2.converters.DOMString, defaultValue: e3(() => "", "defaultValue") }, { key: "filename", converter: A2.converters.USVString, defaultValue: e3(() => "", "defaultValue") }, { key: "lineno", converter: A2.converters["unsigned long"], defaultValue: e3(() => 0, "defaultValue") }, { key: "colno", converter: A2.converters["unsigned long"], defaultValue: e3(() => 0, "defaultValue") }, { key: "error", converter: A2.converters.any }]), events = { MessageEvent: t2, CloseEvent: R4, ErrorEvent: F2, createFastMessageEvent: y3 }, events;
    }
    e3(requireEvents, "requireEvents");
    var constants;
    var hasRequiredConstants;
    function requireConstants() {
      if (hasRequiredConstants) return constants;
      hasRequiredConstants = 1;
      const A2 = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", k4 = { enumerable: true, writable: false, configurable: false }, c2 = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 }, B3 = { NOT_SENT: 0, PROCESSING: 1, SENT: 2 }, t2 = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 }, y3 = 2 ** 16 - 1, R4 = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 }, F2 = Buffer.allocUnsafe(0);
      return constants = { uid: A2, sentCloseFrameState: B3, staticPropertyDescriptors: k4, states: c2, opcodes: t2, maxUnsigned16Bit: y3, parserStates: R4, emptyBuffer: F2, sendHints: { string: 1, typedArray: 2, arrayBuffer: 3, blob: 4 } }, constants;
    }
    e3(requireConstants, "requireConstants");
    var symbols;
    var hasRequiredSymbols;
    function requireSymbols() {
      return hasRequiredSymbols || (hasRequiredSymbols = 1, symbols = { kWebSocketURL: Symbol("url"), kReadyState: Symbol("ready state"), kController: Symbol("controller"), kResponse: Symbol("response"), kBinaryType: Symbol("binary type"), kSentClose: Symbol("sent close"), kReceivedClose: Symbol("received close"), kByteParser: Symbol("byte parser") }), symbols;
    }
    e3(requireSymbols, "requireSymbols");
    var util$1;
    var hasRequiredUtil$1;
    function requireUtil$1() {
      if (hasRequiredUtil$1) return util$1;
      hasRequiredUtil$1 = 1;
      const { kReadyState: A2, kController: k4, kResponse: c2, kBinaryType: B3, kWebSocketURL: t2 } = requireSymbols(), { states: y3, opcodes: R4 } = requireConstants(), { ErrorEvent: F2, createFastMessageEvent: Q5 } = requireEvents(), { isUtf8: D3 } = require$$0__default, { collectASequenceOfCodePointsFast: U6, removeHTTPWhitespace: r6 } = requireDataUrl();
      function o(x5) {
        return x5[A2] === y3.CONNECTING;
      }
      e3(o, "isConnecting");
      function N6(x5) {
        return x5[A2] === y3.OPEN;
      }
      e3(N6, "isEstablished");
      function l3(x5) {
        return x5[A2] === y3.CLOSING;
      }
      e3(l3, "isClosing");
      function I5(x5) {
        return x5[A2] === y3.CLOSED;
      }
      e3(I5, "isClosed");
      function p3(x5, z4, $6 = (nA, iA) => new Event(nA, iA), K4 = {}) {
        const nA = $6(x5, K4);
        z4.dispatchEvent(nA);
      }
      e3(p3, "fireEvent");
      function b6(x5, z4, $6) {
        if (x5[A2] !== y3.OPEN) return;
        let K4;
        if (z4 === R4.TEXT) try {
          K4 = S6($6);
        } catch {
          _5(x5, "Received invalid UTF-8 in text frame.");
          return;
        }
        else z4 === R4.BINARY && (x5[B3] === "blob" ? K4 = new Blob([$6]) : K4 = G3($6));
        p3("message", x5, Q5, { origin: x5[t2].origin, data: K4 });
      }
      e3(b6, "websocketMessageReceived");
      function G3(x5) {
        return x5.byteLength === x5.buffer.byteLength ? x5.buffer : x5.buffer.slice(x5.byteOffset, x5.byteOffset + x5.byteLength);
      }
      e3(G3, "toArrayBuffer");
      function J5(x5) {
        if (x5.length === 0) return false;
        for (let z4 = 0; z4 < x5.length; ++z4) {
          const $6 = x5.charCodeAt(z4);
          if ($6 < 33 || $6 > 126 || $6 === 34 || $6 === 40 || $6 === 41 || $6 === 44 || $6 === 47 || $6 === 58 || $6 === 59 || $6 === 60 || $6 === 61 || $6 === 62 || $6 === 63 || $6 === 64 || $6 === 91 || $6 === 92 || $6 === 93 || $6 === 123 || $6 === 125) return false;
        }
        return true;
      }
      e3(J5, "isValidSubprotocol");
      function V4(x5) {
        return x5 >= 1e3 && x5 < 1015 ? x5 !== 1004 && x5 !== 1005 && x5 !== 1006 : x5 >= 3e3 && x5 <= 4999;
      }
      e3(V4, "isValidStatusCode");
      function _5(x5, z4) {
        const { [k4]: $6, [c2]: K4 } = x5;
        $6.abort(), K4?.socket && !K4.socket.destroyed && K4.socket.destroy(), z4 && p3("error", x5, (nA, iA) => new F2(nA, iA), { error: new Error(z4), message: z4 });
      }
      e3(_5, "failWebsocketConnection");
      function q6(x5) {
        return x5 === R4.CLOSE || x5 === R4.PING || x5 === R4.PONG;
      }
      e3(q6, "isControlFrame");
      function M4(x5) {
        return x5 === R4.CONTINUATION;
      }
      e3(M4, "isContinuationFrame");
      function Y4(x5) {
        return x5 === R4.TEXT || x5 === R4.BINARY;
      }
      e3(Y4, "isTextBinaryFrame");
      function m4(x5) {
        return Y4(x5) || M4(x5) || q6(x5);
      }
      e3(m4, "isValidOpcode");
      function f3(x5) {
        const z4 = { position: 0 }, $6 = /* @__PURE__ */ new Map();
        for (; z4.position < x5.length; ) {
          const K4 = U6(";", x5, z4), [nA, iA = ""] = K4.split("=");
          $6.set(r6(nA, true, false), r6(iA, false, true)), z4.position++;
        }
        return $6;
      }
      e3(f3, "parseExtensions");
      function n(x5) {
        for (let z4 = 0; z4 < x5.length; z4++) {
          const $6 = x5.charCodeAt(z4);
          if ($6 < 48 || $6 > 57) return false;
        }
        return true;
      }
      e3(n, "isValidClientWindowBits");
      const C5 = typeof process.versions.icu == "string", w5 = C5 ? new TextDecoder("utf-8", { fatal: true }) : void 0, S6 = C5 ? w5.decode.bind(w5) : function(x5) {
        if (D3(x5)) return x5.toString("utf-8");
        throw new TypeError("Invalid utf-8 received.");
      };
      return util$1 = { isConnecting: o, isEstablished: N6, isClosing: l3, isClosed: I5, fireEvent: p3, isValidSubprotocol: J5, isValidStatusCode: V4, failWebsocketConnection: _5, websocketMessageReceived: b6, utf8Decode: S6, isControlFrame: q6, isContinuationFrame: M4, isTextBinaryFrame: Y4, isValidOpcode: m4, parseExtensions: f3, isValidClientWindowBits: n }, util$1;
    }
    e3(requireUtil$1, "requireUtil$1");
    var frame;
    var hasRequiredFrame;
    function requireFrame() {
      if (hasRequiredFrame) return frame;
      hasRequiredFrame = 1;
      const { maxUnsigned16Bit: A2 } = requireConstants(), k4 = 16386;
      let c2, B3 = null, t2 = k4;
      try {
        c2 = require("crypto");
      } catch {
        c2 = { randomFillSync: e3(function(D3, U6, r6) {
          for (let o = 0; o < D3.length; ++o) D3[o] = Math.random() * 255 | 0;
          return D3;
        }, "randomFillSync") };
      }
      function y3() {
        return t2 === k4 && (t2 = 0, c2.randomFillSync(B3 ?? (B3 = Buffer.allocUnsafe(k4)), 0, k4)), [B3[t2++], B3[t2++], B3[t2++], B3[t2++]];
      }
      e3(y3, "generateMask");
      const F2 = class F {
        constructor(D3) {
          this.frameData = D3;
        }
        createFrame(D3) {
          const U6 = this.frameData, r6 = y3(), o = U6?.byteLength ?? 0;
          let N6 = o, l3 = 6;
          o > A2 ? (l3 += 8, N6 = 127) : o > 125 && (l3 += 2, N6 = 126);
          const I5 = Buffer.allocUnsafe(o + l3);
          I5[0] = I5[1] = 0, I5[0] |= 128, I5[0] = (I5[0] & 240) + D3;
          I5[l3 - 4] = r6[0], I5[l3 - 3] = r6[1], I5[l3 - 2] = r6[2], I5[l3 - 1] = r6[3], I5[1] = N6, N6 === 126 ? I5.writeUInt16BE(o, 2) : N6 === 127 && (I5[2] = I5[3] = 0, I5.writeUIntBE(o, 4, 6)), I5[1] |= 128;
          for (let p3 = 0; p3 < o; ++p3) I5[l3 + p3] = U6[p3] ^ r6[p3 & 3];
          return I5;
        }
      };
      e3(F2, "WebsocketFrameSend");
      let R4 = F2;
      return frame = { WebsocketFrameSend: R4 }, frame;
    }
    e3(requireFrame, "requireFrame");
    var connection;
    var hasRequiredConnection;
    function requireConnection() {
      if (hasRequiredConnection) return connection;
      hasRequiredConnection = 1;
      const { uid: A2, states: k4, sentCloseFrameState: c2, emptyBuffer: B3, opcodes: t2 } = requireConstants(), { kReadyState: y3, kSentClose: R4, kByteParser: F2, kReceivedClose: Q5, kResponse: D3 } = requireSymbols(), { fireEvent: U6, failWebsocketConnection: r6, isClosing: o, isClosed: N6, isEstablished: l3, parseExtensions: I5 } = requireUtil$1(), { channels: p3 } = requireDiagnostics(), { CloseEvent: b6 } = requireEvents(), { makeRequest: G3 } = requireRequest(), { fetching: J5 } = requireFetch(), { Headers: V4, getHeadersList: _5 } = requireHeaders(), { getDecodeSplit: q6 } = requireUtil$6(), { WebsocketFrameSend: M4 } = requireFrame();
      let Y4;
      try {
        Y4 = require("crypto");
      } catch {
      }
      function m4(S6, x5, z4, $6, K4, nA) {
        const iA = S6;
        iA.protocol = S6.protocol === "ws:" ? "http:" : "https:";
        const uA = G3({ urlList: [iA], client: z4, serviceWorkers: "none", referrer: "no-referrer", mode: "websocket", credentials: "include", cache: "no-store", redirect: "error" });
        if (nA.headers) {
          const pA = _5(new V4(nA.headers));
          uA.headersList = pA;
        }
        const RA = Y4.randomBytes(16).toString("base64");
        uA.headersList.append("sec-websocket-key", RA), uA.headersList.append("sec-websocket-version", "13");
        for (const pA of x5) uA.headersList.append("sec-websocket-protocol", pA);
        return uA.headersList.append("sec-websocket-extensions", "permessage-deflate; client_max_window_bits"), J5({ request: uA, useParallelQueue: true, dispatcher: nA.dispatcher, processResponse(pA) {
          if (pA.type === "error" || pA.status !== 101) {
            r6($6, "Received network error or non-101 status code.");
            return;
          }
          if (x5.length !== 0 && !pA.headersList.get("Sec-WebSocket-Protocol")) {
            r6($6, "Server did not respond with sent protocols.");
            return;
          }
          if (pA.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            r6($6, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (pA.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            r6($6, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const fA = pA.headersList.get("Sec-WebSocket-Accept"), kA = Y4.createHash("sha1").update(RA + A2).digest("base64");
          if (fA !== kA) {
            r6($6, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const bA = pA.headersList.get("Sec-WebSocket-Extensions");
          let gA;
          if (bA !== null && (gA = I5(bA), !gA.has("permessage-deflate"))) {
            r6($6, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
          const DA = pA.headersList.get("Sec-WebSocket-Protocol");
          if (DA !== null && !q6("sec-websocket-protocol", uA.headersList).includes(DA)) {
            r6($6, "Protocol was not set in the opening handshake.");
            return;
          }
          pA.socket.on("data", n), pA.socket.on("close", C5), pA.socket.on("error", w5), p3.open.hasSubscribers && p3.open.publish({ address: pA.socket.address(), protocol: DA, extensions: bA }), K4(pA, gA);
        } });
      }
      e3(m4, "establishWebSocketConnection");
      function f3(S6, x5, z4, $6) {
        if (!(o(S6) || N6(S6))) if (!l3(S6)) r6(S6, "Connection was closed before it was established."), S6[y3] = k4.CLOSING;
        else if (S6[R4] === c2.NOT_SENT) {
          S6[R4] = c2.PROCESSING;
          const K4 = new M4();
          x5 !== void 0 && z4 === void 0 ? (K4.frameData = Buffer.allocUnsafe(2), K4.frameData.writeUInt16BE(x5, 0)) : x5 !== void 0 && z4 !== void 0 ? (K4.frameData = Buffer.allocUnsafe(2 + $6), K4.frameData.writeUInt16BE(x5, 0), K4.frameData.write(z4, 2, "utf-8")) : K4.frameData = B3, S6[D3].socket.write(K4.createFrame(t2.CLOSE)), S6[R4] = c2.SENT, S6[y3] = k4.CLOSING;
        } else S6[y3] = k4.CLOSING;
      }
      e3(f3, "closeWebSocketConnection");
      function n(S6) {
        this.ws[F2].write(S6) || this.pause();
      }
      e3(n, "onSocketData");
      function C5() {
        const { ws: S6 } = this, { [D3]: x5 } = S6;
        x5.socket.off("data", n), x5.socket.off("close", C5), x5.socket.off("error", w5);
        const z4 = S6[R4] === c2.SENT && S6[Q5];
        let $6 = 1005, K4 = "";
        const nA = S6[F2].closingInfo;
        nA && !nA.error ? ($6 = nA.code ?? 1005, K4 = nA.reason) : S6[Q5] || ($6 = 1006), S6[y3] = k4.CLOSED, U6("close", S6, (iA, uA) => new b6(iA, uA), { wasClean: z4, code: $6, reason: K4 }), p3.close.hasSubscribers && p3.close.publish({ websocket: S6, code: $6, reason: K4 });
      }
      e3(C5, "onSocketClose");
      function w5(S6) {
        const { ws: x5 } = this;
        x5[y3] = k4.CLOSING, p3.socketError.hasSubscribers && p3.socketError.publish(S6), this.destroy();
      }
      return e3(w5, "onSocketError"), connection = { establishWebSocketConnection: m4, closeWebSocketConnection: f3 }, connection;
    }
    e3(requireConnection, "requireConnection");
    var permessageDeflate;
    var hasRequiredPermessageDeflate;
    function requirePermessageDeflate() {
      var F2, Q5;
      if (hasRequiredPermessageDeflate) return permessageDeflate;
      hasRequiredPermessageDeflate = 1;
      const { createInflateRaw: A2, Z_DEFAULT_WINDOWBITS: k4 } = zlib__default, { isValidClientWindowBits: c2 } = requireUtil$1(), B3 = Buffer.from([0, 0, 255, 255]), t2 = Symbol("kBuffer"), y3 = Symbol("kLength"), D3 = class D {
        constructor(r6) {
          SA(this, F2);
          SA(this, Q5, {});
          Z4(this, Q5).serverNoContextTakeover = r6.has("server_no_context_takeover"), Z4(this, Q5).serverMaxWindowBits = r6.get("server_max_window_bits");
        }
        decompress(r6, o, N6) {
          if (!Z4(this, F2)) {
            let l3 = k4;
            if (Z4(this, Q5).serverMaxWindowBits) {
              if (!c2(Z4(this, Q5).serverMaxWindowBits)) {
                N6(new Error("Invalid server_max_window_bits"));
                return;
              }
              l3 = Number.parseInt(Z4(this, Q5).serverMaxWindowBits);
            }
            mA(this, F2, A2({ windowBits: l3 })), Z4(this, F2)[t2] = [], Z4(this, F2)[y3] = 0, Z4(this, F2).on("data", (I5) => {
              Z4(this, F2)[t2].push(I5), Z4(this, F2)[y3] += I5.length;
            }), Z4(this, F2).on("error", (I5) => {
              mA(this, F2, null), N6(I5);
            });
          }
          Z4(this, F2).write(r6), o && Z4(this, F2).write(B3), Z4(this, F2).flush(() => {
            const l3 = Buffer.concat(Z4(this, F2)[t2], Z4(this, F2)[y3]);
            Z4(this, F2)[t2].length = 0, Z4(this, F2)[y3] = 0, N6(null, l3);
          });
        }
      };
      F2 = /* @__PURE__ */ new WeakMap(), Q5 = /* @__PURE__ */ new WeakMap(), e3(D3, "PerMessageDeflate");
      let R4 = D3;
      return permessageDeflate = { PerMessageDeflate: R4 }, permessageDeflate;
    }
    e3(requirePermessageDeflate, "requirePermessageDeflate");
    var receiver;
    var hasRequiredReceiver;
    function requireReceiver() {
      var Y4, m4, f3, n, C5, w5, S6;
      if (hasRequiredReceiver) return receiver;
      hasRequiredReceiver = 1;
      const { Writable: A2 } = Stream__default, k4 = require$$0__default$1, { parserStates: c2, opcodes: B3, states: t2, emptyBuffer: y3, sentCloseFrameState: R4 } = requireConstants(), { kReadyState: F2, kSentClose: Q5, kResponse: D3, kReceivedClose: U6 } = requireSymbols(), { channels: r6 } = requireDiagnostics(), { isValidStatusCode: o, isValidOpcode: N6, failWebsocketConnection: l3, websocketMessageReceived: I5, utf8Decode: p3, isControlFrame: b6, isTextBinaryFrame: G3, isContinuationFrame: J5 } = requireUtil$1(), { WebsocketFrameSend: V4 } = requireFrame(), { closeWebSocketConnection: _5 } = requireConnection(), { PerMessageDeflate: q6 } = requirePermessageDeflate(), x5 = class x extends A2 {
        constructor(K4, nA) {
          super();
          SA(this, Y4, []);
          SA(this, m4, 0);
          SA(this, f3, false);
          SA(this, n, c2.INFO);
          SA(this, C5, {});
          SA(this, w5, []);
          SA(this, S6);
          this.ws = K4, mA(this, S6, nA ?? /* @__PURE__ */ new Map()), Z4(this, S6).has("permessage-deflate") && Z4(this, S6).set("permessage-deflate", new q6(nA));
        }
        _write(K4, nA, iA) {
          Z4(this, Y4).push(K4), mA(this, m4, Z4(this, m4) + K4.length), mA(this, f3, true), this.run(iA);
        }
        run(K4) {
          for (; Z4(this, f3); ) if (Z4(this, n) === c2.INFO) {
            if (Z4(this, m4) < 2) return K4();
            const nA = this.consume(2), iA = (nA[0] & 128) !== 0, uA = nA[0] & 15, RA = (nA[1] & 128) === 128, IA = !iA && uA !== B3.CONTINUATION, CA = nA[1] & 127, pA = nA[0] & 64, fA = nA[0] & 32, kA = nA[0] & 16;
            if (!N6(uA)) return l3(this.ws, "Invalid opcode received"), K4();
            if (RA) return l3(this.ws, "Frame cannot be masked"), K4();
            if (pA !== 0 && !Z4(this, S6).has("permessage-deflate")) {
              l3(this.ws, "Expected RSV1 to be clear.");
              return;
            }
            if (fA !== 0 || kA !== 0) {
              l3(this.ws, "RSV1, RSV2, RSV3 must be clear");
              return;
            }
            if (IA && !G3(uA)) {
              l3(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            if (G3(uA) && Z4(this, w5).length > 0) {
              l3(this.ws, "Expected continuation frame");
              return;
            }
            if (Z4(this, C5).fragmented && IA) {
              l3(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            }
            if ((CA > 125 || IA) && b6(uA)) {
              l3(this.ws, "Control frame either too large or fragmented");
              return;
            }
            if (J5(uA) && Z4(this, w5).length === 0 && !Z4(this, C5).compressed) {
              l3(this.ws, "Unexpected continuation frame");
              return;
            }
            CA <= 125 ? (Z4(this, C5).payloadLength = CA, mA(this, n, c2.READ_DATA)) : CA === 126 ? mA(this, n, c2.PAYLOADLENGTH_16) : CA === 127 && mA(this, n, c2.PAYLOADLENGTH_64), G3(uA) && (Z4(this, C5).binaryType = uA, Z4(this, C5).compressed = pA !== 0), Z4(this, C5).opcode = uA, Z4(this, C5).masked = RA, Z4(this, C5).fin = iA, Z4(this, C5).fragmented = IA;
          } else if (Z4(this, n) === c2.PAYLOADLENGTH_16) {
            if (Z4(this, m4) < 2) return K4();
            const nA = this.consume(2);
            Z4(this, C5).payloadLength = nA.readUInt16BE(0), mA(this, n, c2.READ_DATA);
          } else if (Z4(this, n) === c2.PAYLOADLENGTH_64) {
            if (Z4(this, m4) < 8) return K4();
            const nA = this.consume(8), iA = nA.readUInt32BE(0);
            if (iA > 2 ** 31 - 1) {
              l3(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const uA = nA.readUInt32BE(4);
            Z4(this, C5).payloadLength = (iA << 8) + uA, mA(this, n, c2.READ_DATA);
          } else if (Z4(this, n) === c2.READ_DATA) {
            if (Z4(this, m4) < Z4(this, C5).payloadLength) return K4();
            const nA = this.consume(Z4(this, C5).payloadLength);
            if (b6(Z4(this, C5).opcode)) mA(this, f3, this.parseControlFrame(nA)), mA(this, n, c2.INFO);
            else if (Z4(this, C5).compressed) {
              Z4(this, S6).get("permessage-deflate").decompress(nA, Z4(this, C5).fin, (iA, uA) => {
                if (iA) {
                  _5(this.ws, 1007, iA.message, iA.message.length);
                  return;
                }
                if (Z4(this, w5).push(uA), !Z4(this, C5).fin) {
                  mA(this, n, c2.INFO), mA(this, f3, true), this.run(K4);
                  return;
                }
                I5(this.ws, Z4(this, C5).binaryType, Buffer.concat(Z4(this, w5))), mA(this, f3, true), mA(this, n, c2.INFO), Z4(this, w5).length = 0, this.run(K4);
              }), mA(this, f3, false);
              break;
            } else {
              if (Z4(this, w5).push(nA), !Z4(this, C5).fragmented && Z4(this, C5).fin) {
                const iA = Buffer.concat(Z4(this, w5));
                I5(this.ws, Z4(this, C5).binaryType, iA), Z4(this, w5).length = 0;
              }
              mA(this, n, c2.INFO);
            }
          }
        }
        consume(K4) {
          if (K4 > Z4(this, m4)) throw new Error("Called consume() before buffers satiated.");
          if (K4 === 0) return y3;
          if (Z4(this, Y4)[0].length === K4) return mA(this, m4, Z4(this, m4) - Z4(this, Y4)[0].length), Z4(this, Y4).shift();
          const nA = Buffer.allocUnsafe(K4);
          let iA = 0;
          for (; iA !== K4; ) {
            const uA = Z4(this, Y4)[0], { length: RA } = uA;
            if (RA + iA === K4) {
              nA.set(Z4(this, Y4).shift(), iA);
              break;
            } else if (RA + iA > K4) {
              nA.set(uA.subarray(0, K4 - iA), iA), Z4(this, Y4)[0] = uA.subarray(K4 - iA);
              break;
            } else nA.set(Z4(this, Y4).shift(), iA), iA += uA.length;
          }
          return mA(this, m4, Z4(this, m4) - K4), nA;
        }
        parseCloseBody(K4) {
          k4(K4.length !== 1);
          let nA;
          if (K4.length >= 2 && (nA = K4.readUInt16BE(0)), nA !== void 0 && !o(nA)) return { code: 1002, reason: "Invalid status code", error: true };
          let iA = K4.subarray(2);
          iA[0] === 239 && iA[1] === 187 && iA[2] === 191 && (iA = iA.subarray(3));
          try {
            iA = p3(iA);
          } catch {
            return { code: 1007, reason: "Invalid UTF-8", error: true };
          }
          return { code: nA, reason: iA, error: false };
        }
        parseControlFrame(K4) {
          const { opcode: nA, payloadLength: iA } = Z4(this, C5);
          if (nA === B3.CLOSE) {
            if (iA === 1) return l3(this.ws, "Received close frame with a 1-byte body."), false;
            if (Z4(this, C5).closeInfo = this.parseCloseBody(K4), Z4(this, C5).closeInfo.error) {
              const { code: uA, reason: RA } = Z4(this, C5).closeInfo;
              return _5(this.ws, uA, RA, RA.length), l3(this.ws, RA), false;
            }
            if (this.ws[Q5] !== R4.SENT) {
              let uA = y3;
              Z4(this, C5).closeInfo.code && (uA = Buffer.allocUnsafe(2), uA.writeUInt16BE(Z4(this, C5).closeInfo.code, 0));
              const RA = new V4(uA);
              this.ws[D3].socket.write(RA.createFrame(B3.CLOSE), (IA) => {
                IA || (this.ws[Q5] = R4.SENT);
              });
            }
            return this.ws[F2] = t2.CLOSING, this.ws[U6] = true, false;
          } else if (nA === B3.PING) {
            if (!this.ws[U6]) {
              const uA = new V4(K4);
              this.ws[D3].socket.write(uA.createFrame(B3.PONG)), r6.ping.hasSubscribers && r6.ping.publish({ payload: K4 });
            }
          } else nA === B3.PONG && r6.pong.hasSubscribers && r6.pong.publish({ payload: K4 });
          return true;
        }
        get closingInfo() {
          return Z4(this, C5).closeInfo;
        }
      };
      Y4 = /* @__PURE__ */ new WeakMap(), m4 = /* @__PURE__ */ new WeakMap(), f3 = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap(), C5 = /* @__PURE__ */ new WeakMap(), w5 = /* @__PURE__ */ new WeakMap(), S6 = /* @__PURE__ */ new WeakMap(), e3(x5, "ByteParser");
      let M4 = x5;
      return receiver = { ByteParser: M4 }, receiver;
    }
    e3(requireReceiver, "requireReceiver");
    var sender;
    var hasRequiredSender;
    function requireSender() {
      var Q5, D3, U6, r6, Pe2;
      if (hasRequiredSender) return sender;
      hasRequiredSender = 1;
      const { WebsocketFrameSend: A2 } = requireFrame(), { opcodes: k4, sendHints: c2 } = requireConstants(), B3 = requireFixedQueue(), t2 = Buffer[Symbol.species], N6 = class N {
        constructor(I5) {
          SA(this, r6);
          SA(this, Q5, new B3());
          SA(this, D3, false);
          SA(this, U6);
          mA(this, U6, I5);
        }
        add(I5, p3, b6) {
          if (b6 !== c2.blob) {
            const J5 = R4(I5, b6);
            if (!Z4(this, D3)) Z4(this, U6).write(J5, p3);
            else {
              const V4 = { promise: null, callback: p3, frame: J5 };
              Z4(this, Q5).push(V4);
            }
            return;
          }
          const G3 = { promise: I5.arrayBuffer().then((J5) => {
            G3.promise = null, G3.frame = R4(J5, b6);
          }), callback: p3, frame: null };
          Z4(this, Q5).push(G3), Z4(this, D3) || ee3(this, r6, Pe2).call(this);
        }
      };
      Q5 = /* @__PURE__ */ new WeakMap(), D3 = /* @__PURE__ */ new WeakMap(), U6 = /* @__PURE__ */ new WeakMap(), r6 = /* @__PURE__ */ new WeakSet(), Pe2 = e3(async function() {
        mA(this, D3, true);
        const I5 = Z4(this, Q5);
        for (; !I5.isEmpty(); ) {
          const p3 = I5.shift();
          p3.promise !== null && await p3.promise, Z4(this, U6).write(p3.frame, p3.callback), p3.callback = p3.frame = null;
        }
        mA(this, D3, false);
      }, "#run"), e3(N6, "SendQueue");
      let y3 = N6;
      function R4(l3, I5) {
        return new A2(F2(l3, I5)).createFrame(I5 === c2.string ? k4.TEXT : k4.BINARY);
      }
      e3(R4, "createFrame");
      function F2(l3, I5) {
        switch (I5) {
          case c2.string:
            return Buffer.from(l3);
          case c2.arrayBuffer:
          case c2.blob:
            return new t2(l3);
          case c2.typedArray:
            return new t2(l3.buffer, l3.byteOffset, l3.byteLength);
        }
      }
      return e3(F2, "toBuffer"), sender = { SendQueue: y3 }, sender;
    }
    e3(requireSender, "requireSender");
    var websocket;
    var hasRequiredWebsocket;
    function requireWebsocket() {
      var z4, $6, K4, nA, iA, uA, Ze2;
      if (hasRequiredWebsocket) return websocket;
      hasRequiredWebsocket = 1;
      const { webidl: A2 } = requireWebidl(), { URLSerializer: k4 } = requireDataUrl(), { environmentSettingsObject: c2 } = requireUtil$6(), { staticPropertyDescriptors: B3, states: t2, sentCloseFrameState: y3, sendHints: R4 } = requireConstants(), { kWebSocketURL: F2, kReadyState: Q5, kController: D3, kBinaryType: U6, kResponse: r6, kSentClose: o, kByteParser: N6 } = requireSymbols(), { isConnecting: l3, isEstablished: I5, isClosing: p3, isValidSubprotocol: b6, fireEvent: G3 } = requireUtil$1(), { establishWebSocketConnection: J5, closeWebSocketConnection: V4 } = requireConnection(), { ByteParser: _5 } = requireReceiver(), { kEnumerableProperty: q6, isBlobLike: M4 } = requireUtil$7(), { getGlobalDispatcher: Y4 } = requireGlobal(), { types: m4 } = require$$0__default$3, { ErrorEvent: f3, CloseEvent: n } = requireEvents(), { SendQueue: C5 } = requireSender(), IA = class IA2 extends EventTarget {
        constructor(fA, kA = []) {
          super();
          SA(this, uA);
          SA(this, z4, { open: null, error: null, close: null, message: null });
          SA(this, $6, 0);
          SA(this, K4, "");
          SA(this, nA, "");
          SA(this, iA);
          A2.util.markAsUncloneable(this);
          const bA = "WebSocket constructor";
          A2.argumentLengthCheck(arguments, 1, bA);
          const gA = A2.converters["DOMString or sequence<DOMString> or WebSocketInit"](kA, bA, "options");
          fA = A2.converters.USVString(fA, bA, "url"), kA = gA.protocols;
          const DA = c2.settingsObject.baseUrl;
          let oA;
          try {
            oA = new URL(fA, DA);
          } catch (EA) {
            throw new DOMException(EA, "SyntaxError");
          }
          if (oA.protocol === "http:" ? oA.protocol = "ws:" : oA.protocol === "https:" && (oA.protocol = "wss:"), oA.protocol !== "ws:" && oA.protocol !== "wss:") throw new DOMException(`Expected a ws: or wss: protocol, got ${oA.protocol}`, "SyntaxError");
          if (oA.hash || oA.href.endsWith("#")) throw new DOMException("Got fragment", "SyntaxError");
          if (typeof kA == "string" && (kA = [kA]), kA.length !== new Set(kA.map((EA) => EA.toLowerCase())).size) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          if (kA.length > 0 && !kA.every((EA) => b6(EA))) throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
          this[F2] = new URL(oA.href);
          const aA = c2.settingsObject;
          this[D3] = J5(oA, kA, aA, this, (EA, sA) => ee3(this, uA, Ze2).call(this, EA, sA), gA), this[Q5] = IA2.CONNECTING, this[o] = y3.NOT_SENT, this[U6] = "blob";
        }
        close(fA = void 0, kA = void 0) {
          A2.brandCheck(this, IA2);
          const bA = "WebSocket.close";
          if (fA !== void 0 && (fA = A2.converters["unsigned short"](fA, bA, "code", { clamp: true })), kA !== void 0 && (kA = A2.converters.USVString(kA, bA, "reason")), fA !== void 0 && fA !== 1e3 && (fA < 3e3 || fA > 4999)) throw new DOMException("invalid code", "InvalidAccessError");
          let gA = 0;
          if (kA !== void 0 && (gA = Buffer.byteLength(kA), gA > 123)) throw new DOMException(`Reason must be less than 123 bytes; received ${gA}`, "SyntaxError");
          V4(this, fA, kA, gA);
        }
        send(fA) {
          A2.brandCheck(this, IA2);
          const kA = "WebSocket.send";
          if (A2.argumentLengthCheck(arguments, 1, kA), fA = A2.converters.WebSocketSendData(fA, kA, "data"), l3(this)) throw new DOMException("Sent before connected.", "InvalidStateError");
          if (!(!I5(this) || p3(this))) if (typeof fA == "string") {
            const bA = Buffer.byteLength(fA);
            mA(this, $6, Z4(this, $6) + bA), Z4(this, iA).add(fA, () => {
              mA(this, $6, Z4(this, $6) - bA);
            }, R4.string);
          } else m4.isArrayBuffer(fA) ? (mA(this, $6, Z4(this, $6) + fA.byteLength), Z4(this, iA).add(fA, () => {
            mA(this, $6, Z4(this, $6) - fA.byteLength);
          }, R4.arrayBuffer)) : ArrayBuffer.isView(fA) ? (mA(this, $6, Z4(this, $6) + fA.byteLength), Z4(this, iA).add(fA, () => {
            mA(this, $6, Z4(this, $6) - fA.byteLength);
          }, R4.typedArray)) : M4(fA) && (mA(this, $6, Z4(this, $6) + fA.size), Z4(this, iA).add(fA, () => {
            mA(this, $6, Z4(this, $6) - fA.size);
          }, R4.blob));
        }
        get readyState() {
          return A2.brandCheck(this, IA2), this[Q5];
        }
        get bufferedAmount() {
          return A2.brandCheck(this, IA2), Z4(this, $6);
        }
        get url() {
          return A2.brandCheck(this, IA2), k4(this[F2]);
        }
        get extensions() {
          return A2.brandCheck(this, IA2), Z4(this, nA);
        }
        get protocol() {
          return A2.brandCheck(this, IA2), Z4(this, K4);
        }
        get onopen() {
          return A2.brandCheck(this, IA2), Z4(this, z4).open;
        }
        set onopen(fA) {
          A2.brandCheck(this, IA2), Z4(this, z4).open && this.removeEventListener("open", Z4(this, z4).open), typeof fA == "function" ? (Z4(this, z4).open = fA, this.addEventListener("open", fA)) : Z4(this, z4).open = null;
        }
        get onerror() {
          return A2.brandCheck(this, IA2), Z4(this, z4).error;
        }
        set onerror(fA) {
          A2.brandCheck(this, IA2), Z4(this, z4).error && this.removeEventListener("error", Z4(this, z4).error), typeof fA == "function" ? (Z4(this, z4).error = fA, this.addEventListener("error", fA)) : Z4(this, z4).error = null;
        }
        get onclose() {
          return A2.brandCheck(this, IA2), Z4(this, z4).close;
        }
        set onclose(fA) {
          A2.brandCheck(this, IA2), Z4(this, z4).close && this.removeEventListener("close", Z4(this, z4).close), typeof fA == "function" ? (Z4(this, z4).close = fA, this.addEventListener("close", fA)) : Z4(this, z4).close = null;
        }
        get onmessage() {
          return A2.brandCheck(this, IA2), Z4(this, z4).message;
        }
        set onmessage(fA) {
          A2.brandCheck(this, IA2), Z4(this, z4).message && this.removeEventListener("message", Z4(this, z4).message), typeof fA == "function" ? (Z4(this, z4).message = fA, this.addEventListener("message", fA)) : Z4(this, z4).message = null;
        }
        get binaryType() {
          return A2.brandCheck(this, IA2), this[U6];
        }
        set binaryType(fA) {
          A2.brandCheck(this, IA2), fA !== "blob" && fA !== "arraybuffer" ? this[U6] = "blob" : this[U6] = fA;
        }
      };
      z4 = /* @__PURE__ */ new WeakMap(), $6 = /* @__PURE__ */ new WeakMap(), K4 = /* @__PURE__ */ new WeakMap(), nA = /* @__PURE__ */ new WeakMap(), iA = /* @__PURE__ */ new WeakMap(), uA = /* @__PURE__ */ new WeakSet(), Ze2 = e3(function(fA, kA) {
        this[r6] = fA;
        const bA = new _5(this, kA);
        bA.on("drain", S6), bA.on("error", x5.bind(this)), fA.socket.ws = this, this[N6] = bA, mA(this, iA, new C5(fA.socket)), this[Q5] = t2.OPEN;
        const gA = fA.headersList.get("sec-websocket-extensions");
        gA !== null && mA(this, nA, gA);
        const DA = fA.headersList.get("sec-websocket-protocol");
        DA !== null && mA(this, K4, DA), G3("open", this);
      }, "#onConnectionEstablished"), e3(IA, "WebSocket");
      let w5 = IA;
      w5.CONNECTING = w5.prototype.CONNECTING = t2.CONNECTING, w5.OPEN = w5.prototype.OPEN = t2.OPEN, w5.CLOSING = w5.prototype.CLOSING = t2.CLOSING, w5.CLOSED = w5.prototype.CLOSED = t2.CLOSED, Object.defineProperties(w5.prototype, { CONNECTING: B3, OPEN: B3, CLOSING: B3, CLOSED: B3, url: q6, readyState: q6, bufferedAmount: q6, onopen: q6, onerror: q6, onclose: q6, close: q6, onmessage: q6, binaryType: q6, send: q6, extensions: q6, protocol: q6, [Symbol.toStringTag]: { value: "WebSocket", writable: false, enumerable: false, configurable: true } }), Object.defineProperties(w5, { CONNECTING: B3, OPEN: B3, CLOSING: B3, CLOSED: B3 }), A2.converters["sequence<DOMString>"] = A2.sequenceConverter(A2.converters.DOMString), A2.converters["DOMString or sequence<DOMString>"] = function(CA, pA, fA) {
        return A2.util.Type(CA) === "Object" && Symbol.iterator in CA ? A2.converters["sequence<DOMString>"](CA) : A2.converters.DOMString(CA, pA, fA);
      }, A2.converters.WebSocketInit = A2.dictionaryConverter([{ key: "protocols", converter: A2.converters["DOMString or sequence<DOMString>"], defaultValue: e3(() => new Array(0), "defaultValue") }, { key: "dispatcher", converter: A2.converters.any, defaultValue: e3(() => Y4(), "defaultValue") }, { key: "headers", converter: A2.nullableConverter(A2.converters.HeadersInit) }]), A2.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(CA) {
        return A2.util.Type(CA) === "Object" && !(Symbol.iterator in CA) ? A2.converters.WebSocketInit(CA) : { protocols: A2.converters["DOMString or sequence<DOMString>"](CA) };
      }, A2.converters.WebSocketSendData = function(CA) {
        if (A2.util.Type(CA) === "Object") {
          if (M4(CA)) return A2.converters.Blob(CA, { strict: false });
          if (ArrayBuffer.isView(CA) || m4.isArrayBuffer(CA)) return A2.converters.BufferSource(CA);
        }
        return A2.converters.USVString(CA);
      };
      function S6() {
        this.ws[r6].socket.resume();
      }
      e3(S6, "onParserDrain");
      function x5(CA) {
        let pA, fA;
        CA instanceof n ? (pA = CA.reason, fA = CA.code) : pA = CA.message, G3("error", this, () => new f3("error", { error: CA, message: pA })), V4(this, fA);
      }
      return e3(x5, "onParserError"), websocket = { WebSocket: w5 }, websocket;
    }
    e3(requireWebsocket, "requireWebsocket");
    var util;
    var hasRequiredUtil;
    function requireUtil() {
      if (hasRequiredUtil) return util;
      hasRequiredUtil = 1;
      function A2(B3) {
        return B3.indexOf("\0") === -1;
      }
      e3(A2, "isValidLastEventId");
      function k4(B3) {
        if (B3.length === 0) return false;
        for (let t2 = 0; t2 < B3.length; t2++) if (B3.charCodeAt(t2) < 48 || B3.charCodeAt(t2) > 57) return false;
        return true;
      }
      e3(k4, "isASCIINumber");
      function c2(B3) {
        return new Promise((t2) => {
          setTimeout(t2, B3).unref();
        });
      }
      return e3(c2, "delay"), util = { isValidLastEventId: A2, isASCIINumber: k4, delay: c2 }, util;
    }
    e3(requireUtil, "requireUtil");
    var eventsourceStream;
    var hasRequiredEventsourceStream;
    function requireEventsourceStream() {
      if (hasRequiredEventsourceStream) return eventsourceStream;
      hasRequiredEventsourceStream = 1;
      const { Transform: A2 } = Stream__default, { isASCIINumber: k4, isValidLastEventId: c2 } = requireUtil(), B3 = [239, 187, 191], t2 = 10, y3 = 13, R4 = 58, F2 = 32, D3 = class D extends A2 {
        constructor(o = {}) {
          o.readableObjectMode = true;
          super(o);
          $A(this, "state", null);
          $A(this, "checkBOM", true);
          $A(this, "crlfCheck", false);
          $A(this, "eventEndCheck", false);
          $A(this, "buffer", null);
          $A(this, "pos", 0);
          $A(this, "event", { data: void 0, event: void 0, id: void 0, retry: void 0 });
          this.state = o.eventSourceSettings || {}, o.push && (this.push = o.push);
        }
        _transform(o, N6, l3) {
          if (o.length === 0) {
            l3();
            return;
          }
          if (this.buffer ? this.buffer = Buffer.concat([this.buffer, o]) : this.buffer = o, this.checkBOM) switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === B3[0]) {
                l3();
                return;
              }
              this.checkBOM = false, l3();
              return;
            case 2:
              if (this.buffer[0] === B3[0] && this.buffer[1] === B3[1]) {
                l3();
                return;
              }
              this.checkBOM = false;
              break;
            case 3:
              if (this.buffer[0] === B3[0] && this.buffer[1] === B3[1] && this.buffer[2] === B3[2]) {
                this.buffer = Buffer.alloc(0), this.checkBOM = false, l3();
                return;
              }
              this.checkBOM = false;
              break;
            default:
              this.buffer[0] === B3[0] && this.buffer[1] === B3[1] && this.buffer[2] === B3[2] && (this.buffer = this.buffer.subarray(3)), this.checkBOM = false;
              break;
          }
          for (; this.pos < this.buffer.length; ) {
            if (this.eventEndCheck) {
              if (this.crlfCheck) {
                if (this.buffer[this.pos] === t2) {
                  this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.crlfCheck = false;
                  continue;
                }
                this.crlfCheck = false;
              }
              if (this.buffer[this.pos] === t2 || this.buffer[this.pos] === y3) {
                this.buffer[this.pos] === y3 && (this.crlfCheck = true), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) && this.processEvent(this.event), this.clearEvent();
                continue;
              }
              this.eventEndCheck = false;
              continue;
            }
            if (this.buffer[this.pos] === t2 || this.buffer[this.pos] === y3) {
              this.buffer[this.pos] === y3 && (this.crlfCheck = true), this.parseLine(this.buffer.subarray(0, this.pos), this.event), this.buffer = this.buffer.subarray(this.pos + 1), this.pos = 0, this.eventEndCheck = true;
              continue;
            }
            this.pos++;
          }
          l3();
        }
        parseLine(o, N6) {
          if (o.length === 0) return;
          const l3 = o.indexOf(R4);
          if (l3 === 0) return;
          let I5 = "", p3 = "";
          if (l3 !== -1) {
            I5 = o.subarray(0, l3).toString("utf8");
            let b6 = l3 + 1;
            o[b6] === F2 && ++b6, p3 = o.subarray(b6).toString("utf8");
          } else I5 = o.toString("utf8"), p3 = "";
          switch (I5) {
            case "data":
              N6[I5] === void 0 ? N6[I5] = p3 : N6[I5] += `
${p3}`;
              break;
            case "retry":
              k4(p3) && (N6[I5] = p3);
              break;
            case "id":
              c2(p3) && (N6[I5] = p3);
              break;
            case "event":
              p3.length > 0 && (N6[I5] = p3);
              break;
          }
        }
        processEvent(o) {
          o.retry && k4(o.retry) && (this.state.reconnectionTime = parseInt(o.retry, 10)), o.id && c2(o.id) && (this.state.lastEventId = o.id), o.data !== void 0 && this.push({ type: o.event || "message", options: { data: o.data, lastEventId: this.state.lastEventId, origin: this.state.origin } });
        }
        clearEvent() {
          this.event = { data: void 0, event: void 0, id: void 0, retry: void 0 };
        }
      };
      e3(D3, "EventSourceStream");
      let Q5 = D3;
      return eventsourceStream = { EventSourceStream: Q5 }, eventsourceStream;
    }
    e3(requireEventsourceStream, "requireEventsourceStream");
    var eventsource;
    var hasRequiredEventsource;
    function requireEventsource() {
      var V4, _5, q6, M4, Y4, m4, f3, n, C5, Ue2, Me2;
      if (hasRequiredEventsource) return eventsource;
      hasRequiredEventsource = 1;
      const { pipeline: A2 } = Stream__default, { fetching: k4 } = requireFetch(), { makeRequest: c2 } = requireRequest(), { webidl: B3 } = requireWebidl(), { EventSourceStream: t2 } = requireEventsourceStream(), { parseMIMEType: y3 } = requireDataUrl(), { createFastMessageEvent: R4 } = requireEvents(), { isNetworkError: F2 } = requireResponse(), { delay: Q5 } = requireUtil(), { kEnumerableProperty: D3 } = requireUtil$7(), { environmentSettingsObject: U6 } = requireUtil$6();
      let r6 = false;
      const o = 3e3, N6 = 0, l3 = 1, I5 = 2, p3 = "anonymous", b6 = "use-credentials", x5 = class x6 extends EventTarget {
        constructor(K4, nA = {}) {
          super();
          SA(this, C5);
          SA(this, V4, { open: null, error: null, message: null });
          SA(this, _5, null);
          SA(this, q6, false);
          SA(this, M4, N6);
          SA(this, Y4, null);
          SA(this, m4, null);
          SA(this, f3);
          SA(this, n);
          B3.util.markAsUncloneable(this);
          const iA = "EventSource constructor";
          B3.argumentLengthCheck(arguments, 1, iA), r6 || (r6 = true, process.emitWarning("EventSource is experimental, expect them to change at any time.", { code: "UNDICI-ES" })), K4 = B3.converters.USVString(K4, iA, "url"), nA = B3.converters.EventSourceInitDict(nA, iA, "eventSourceInitDict"), mA(this, f3, nA.dispatcher), mA(this, n, { lastEventId: "", reconnectionTime: o });
          const uA = U6;
          let RA;
          try {
            RA = new URL(K4, uA.settingsObject.baseUrl), Z4(this, n).origin = RA.origin;
          } catch (pA) {
            throw new DOMException(pA, "SyntaxError");
          }
          mA(this, _5, RA.href);
          let IA = p3;
          nA.withCredentials && (IA = b6, mA(this, q6, true));
          const CA = { redirect: "follow", keepalive: true, mode: "cors", credentials: IA === "anonymous" ? "same-origin" : "omit", referrer: "no-referrer" };
          CA.client = U6.settingsObject, CA.headersList = [["accept", { name: "accept", value: "text/event-stream" }]], CA.cache = "no-store", CA.initiator = "other", CA.urlList = [new URL(Z4(this, _5))], mA(this, Y4, c2(CA)), ee3(this, C5, Ue2).call(this);
        }
        get readyState() {
          return Z4(this, M4);
        }
        get url() {
          return Z4(this, _5);
        }
        get withCredentials() {
          return Z4(this, q6);
        }
        close() {
          B3.brandCheck(this, x6), Z4(this, M4) !== I5 && (mA(this, M4, I5), Z4(this, m4).abort(), mA(this, Y4, null));
        }
        get onopen() {
          return Z4(this, V4).open;
        }
        set onopen(K4) {
          Z4(this, V4).open && this.removeEventListener("open", Z4(this, V4).open), typeof K4 == "function" ? (Z4(this, V4).open = K4, this.addEventListener("open", K4)) : Z4(this, V4).open = null;
        }
        get onmessage() {
          return Z4(this, V4).message;
        }
        set onmessage(K4) {
          Z4(this, V4).message && this.removeEventListener("message", Z4(this, V4).message), typeof K4 == "function" ? (Z4(this, V4).message = K4, this.addEventListener("message", K4)) : Z4(this, V4).message = null;
        }
        get onerror() {
          return Z4(this, V4).error;
        }
        set onerror(K4) {
          Z4(this, V4).error && this.removeEventListener("error", Z4(this, V4).error), typeof K4 == "function" ? (Z4(this, V4).error = K4, this.addEventListener("error", K4)) : Z4(this, V4).error = null;
        }
      };
      V4 = /* @__PURE__ */ new WeakMap(), _5 = /* @__PURE__ */ new WeakMap(), q6 = /* @__PURE__ */ new WeakMap(), M4 = /* @__PURE__ */ new WeakMap(), Y4 = /* @__PURE__ */ new WeakMap(), m4 = /* @__PURE__ */ new WeakMap(), f3 = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap(), C5 = /* @__PURE__ */ new WeakSet(), Ue2 = e3(function() {
        if (Z4(this, M4) === I5) return;
        mA(this, M4, N6);
        const K4 = { request: Z4(this, Y4), dispatcher: Z4(this, f3) }, nA = e3((iA) => {
          F2(iA) && (this.dispatchEvent(new Event("error")), this.close()), ee3(this, C5, Me2).call(this);
        }, "processEventSourceEndOfBody");
        K4.processResponseEndOfBody = nA, K4.processResponse = (iA) => {
          if (F2(iA)) if (iA.aborted) {
            this.close(), this.dispatchEvent(new Event("error"));
            return;
          } else {
            ee3(this, C5, Me2).call(this);
            return;
          }
          const uA = iA.headersList.get("content-type", true), RA = uA !== null ? y3(uA) : "failure", IA = RA !== "failure" && RA.essence === "text/event-stream";
          if (iA.status !== 200 || IA === false) {
            this.close(), this.dispatchEvent(new Event("error"));
            return;
          }
          mA(this, M4, l3), this.dispatchEvent(new Event("open")), Z4(this, n).origin = iA.urlList[iA.urlList.length - 1].origin;
          const CA = new t2({ eventSourceSettings: Z4(this, n), push: e3((pA) => {
            this.dispatchEvent(R4(pA.type, pA.options));
          }, "push") });
          A2(iA.body.stream, CA, (pA) => {
            pA?.aborted === false && (this.close(), this.dispatchEvent(new Event("error")));
          });
        }, mA(this, m4, k4(K4));
      }, "#connect"), Me2 = e3(async function() {
        Z4(this, M4) !== I5 && (mA(this, M4, N6), this.dispatchEvent(new Event("error")), await Q5(Z4(this, n).reconnectionTime), Z4(this, M4) === N6 && (Z4(this, n).lastEventId.length && Z4(this, Y4).headersList.set("last-event-id", Z4(this, n).lastEventId, true), ee3(this, C5, Ue2).call(this)));
      }, "#reconnect"), e3(x5, "EventSource");
      let G3 = x5;
      const J5 = { CONNECTING: { __proto__: null, configurable: false, enumerable: true, value: N6, writable: false }, OPEN: { __proto__: null, configurable: false, enumerable: true, value: l3, writable: false }, CLOSED: { __proto__: null, configurable: false, enumerable: true, value: I5, writable: false } };
      return Object.defineProperties(G3, J5), Object.defineProperties(G3.prototype, J5), Object.defineProperties(G3.prototype, { close: D3, onerror: D3, onmessage: D3, onopen: D3, readyState: D3, url: D3, withCredentials: D3 }), B3.converters.EventSourceInitDict = B3.dictionaryConverter([{ key: "withCredentials", converter: B3.converters.boolean, defaultValue: e3(() => false, "defaultValue") }, { key: "dispatcher", converter: B3.converters.any }]), eventsource = { EventSource: G3, defaultReconnectionTime: o }, eventsource;
    }
    e3(requireEventsource, "requireEventsource");
    var hasRequiredUndici;
    function requireUndici() {
      if (hasRequiredUndici) return undici;
      hasRequiredUndici = 1;
      const A2 = requireClient(), k4 = requireDispatcher(), c2 = requirePool(), B3 = requireBalancedPool(), t2 = requireAgent(), y3 = requireProxyAgent(), R4 = requireEnvHttpProxyAgent(), F2 = requireRetryAgent(), Q5 = requireErrors(), D3 = requireUtil$7(), { InvalidArgumentError: U6 } = Q5, r6 = requireApi(), o = requireConnect(), N6 = requireMockClient(), l3 = requireMockAgent(), I5 = requireMockPool(), p3 = requireMockErrors(), b6 = requireRetryHandler(), { getGlobalDispatcher: G3, setGlobalDispatcher: J5 } = requireGlobal(), V4 = requireDecoratorHandler(), _5 = requireRedirectHandler(), q6 = requireRedirectInterceptor();
      Object.assign(k4.prototype, r6), undici.Dispatcher = k4, undici.Client = A2, undici.Pool = c2, undici.BalancedPool = B3, undici.Agent = t2, undici.ProxyAgent = y3, undici.EnvHttpProxyAgent = R4, undici.RetryAgent = F2, undici.RetryHandler = b6, undici.DecoratorHandler = V4, undici.RedirectHandler = _5, undici.createRedirectInterceptor = q6, undici.interceptors = { redirect: requireRedirect(), retry: requireRetry(), dump: requireDump(), dns: requireDns() }, undici.buildConnector = o, undici.errors = Q5, undici.util = { parseHeaders: D3.parseHeaders, headerNameToString: D3.headerNameToString };
      function M4(IA) {
        return (CA, pA, fA) => {
          if (typeof pA == "function" && (fA = pA, pA = null), !CA || typeof CA != "string" && typeof CA != "object" && !(CA instanceof URL)) throw new U6("invalid url");
          if (pA != null && typeof pA != "object") throw new U6("invalid opts");
          if (pA && pA.path != null) {
            if (typeof pA.path != "string") throw new U6("invalid opts.path");
            let gA = pA.path;
            pA.path.startsWith("/") || (gA = `/${gA}`), CA = new URL(D3.parseOrigin(CA).origin + gA);
          } else pA || (pA = typeof CA == "object" ? CA : {}), CA = D3.parseURL(CA);
          const { agent: kA, dispatcher: bA = G3() } = pA;
          if (kA) throw new U6("unsupported opts.agent. Did you mean opts.client?");
          return IA.call(bA, { ...pA, origin: CA.origin, path: CA.search ? `${CA.pathname}${CA.search}` : CA.pathname, method: pA.method || (pA.body ? "PUT" : "GET") }, fA);
        };
      }
      e3(M4, "makeDispatcher"), undici.setGlobalDispatcher = J5, undici.getGlobalDispatcher = G3;
      const Y4 = requireFetch().fetch;
      undici.fetch = e3(async function(CA, pA = void 0) {
        try {
          return await Y4(CA, pA);
        } catch (fA) {
          throw fA && typeof fA == "object" && Error.captureStackTrace(fA), fA;
        }
      }, "fetch"), undici.Headers = requireHeaders().Headers, undici.Response = requireResponse().Response, undici.Request = requireRequest().Request, undici.FormData = requireFormdata().FormData, undici.File = globalThis.File ?? require$$0__default.File, undici.FileReader = requireFilereader().FileReader;
      const { setGlobalOrigin: m4, getGlobalOrigin: f3 } = requireGlobal$1();
      undici.setGlobalOrigin = m4, undici.getGlobalOrigin = f3;
      const { CacheStorage: n } = requireCachestorage(), { kConstruct: C5 } = requireSymbols$1();
      undici.caches = new n(C5);
      const { deleteCookie: w5, getCookies: S6, getSetCookies: x5, setCookie: z4 } = requireCookies();
      undici.deleteCookie = w5, undici.getCookies = S6, undici.getSetCookies = x5, undici.setCookie = z4;
      const { parseMIMEType: $6, serializeAMimeType: K4 } = requireDataUrl();
      undici.parseMIMEType = $6, undici.serializeAMimeType = K4;
      const { CloseEvent: nA, ErrorEvent: iA, MessageEvent: uA } = requireEvents();
      undici.WebSocket = requireWebsocket().WebSocket, undici.CloseEvent = nA, undici.ErrorEvent = iA, undici.MessageEvent = uA, undici.request = M4(r6.request), undici.stream = M4(r6.stream), undici.pipeline = M4(r6.pipeline), undici.connect = M4(r6.connect), undici.upgrade = M4(r6.upgrade), undici.MockClient = N6, undici.MockPool = I5, undici.MockAgent = l3, undici.mockErrors = p3;
      const { EventSource: RA } = requireEventsource();
      return undici.EventSource = RA, undici;
    }
    e3(requireUndici, "requireUndici");
    var undiciExports = requireUndici();
    var dist$2 = {};
    var helpers = {};
    var hasRequiredHelpers;
    function requireHelpers() {
      if (hasRequiredHelpers) return helpers;
      hasRequiredHelpers = 1;
      var A2 = helpers && helpers.__createBinding || (Object.create ? function(Q5, D3, U6, r6) {
        r6 === void 0 && (r6 = U6);
        var o = Object.getOwnPropertyDescriptor(D3, U6);
        (!o || ("get" in o ? !D3.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: e3(function() {
          return D3[U6];
        }, "get") }), Object.defineProperty(Q5, r6, o);
      } : function(Q5, D3, U6, r6) {
        r6 === void 0 && (r6 = U6), Q5[r6] = D3[U6];
      }), k4 = helpers && helpers.__setModuleDefault || (Object.create ? function(Q5, D3) {
        Object.defineProperty(Q5, "default", { enumerable: true, value: D3 });
      } : function(Q5, D3) {
        Q5.default = D3;
      }), c2 = helpers && helpers.__importStar || function(Q5) {
        if (Q5 && Q5.__esModule) return Q5;
        var D3 = {};
        if (Q5 != null) for (var U6 in Q5) U6 !== "default" && Object.prototype.hasOwnProperty.call(Q5, U6) && A2(D3, Q5, U6);
        return k4(D3, Q5), D3;
      };
      Object.defineProperty(helpers, "__esModule", { value: true }), helpers.req = helpers.json = helpers.toBuffer = void 0;
      const B3 = c2(require$$0__default$5), t2 = c2(require$$1__default$4);
      async function y3(Q5) {
        let D3 = 0;
        const U6 = [];
        for await (const r6 of Q5) D3 += r6.length, U6.push(r6);
        return Buffer.concat(U6, D3);
      }
      e3(y3, "toBuffer"), helpers.toBuffer = y3;
      async function R4(Q5) {
        const U6 = (await y3(Q5)).toString("utf8");
        try {
          return JSON.parse(U6);
        } catch (r6) {
          const o = r6;
          throw o.message += ` (input: ${U6})`, o;
        }
      }
      e3(R4, "json"), helpers.json = R4;
      function F2(Q5, D3 = {}) {
        const r6 = ((typeof Q5 == "string" ? Q5 : Q5.href).startsWith("https:") ? t2 : B3).request(Q5, D3), o = new Promise((N6, l3) => {
          r6.once("response", N6).once("error", l3).end();
        });
        return r6.then = o.then.bind(o), r6;
      }
      return e3(F2, "req"), helpers.req = F2, helpers;
    }
    e3(requireHelpers, "requireHelpers");
    var hasRequiredDist$2;
    function requireDist$2() {
      return hasRequiredDist$2 || (hasRequiredDist$2 = 1, (function(A2) {
        var k4 = dist$2 && dist$2.__createBinding || (Object.create ? function(r6, o, N6, l3) {
          l3 === void 0 && (l3 = N6);
          var I5 = Object.getOwnPropertyDescriptor(o, N6);
          (!I5 || ("get" in I5 ? !o.__esModule : I5.writable || I5.configurable)) && (I5 = { enumerable: true, get: e3(function() {
            return o[N6];
          }, "get") }), Object.defineProperty(r6, l3, I5);
        } : function(r6, o, N6, l3) {
          l3 === void 0 && (l3 = N6), r6[l3] = o[N6];
        }), c2 = dist$2 && dist$2.__setModuleDefault || (Object.create ? function(r6, o) {
          Object.defineProperty(r6, "default", { enumerable: true, value: o });
        } : function(r6, o) {
          r6.default = o;
        }), B3 = dist$2 && dist$2.__importStar || function(r6) {
          if (r6 && r6.__esModule) return r6;
          var o = {};
          if (r6 != null) for (var N6 in r6) N6 !== "default" && Object.prototype.hasOwnProperty.call(r6, N6) && k4(o, r6, N6);
          return c2(o, r6), o;
        }, t2 = dist$2 && dist$2.__exportStar || function(r6, o) {
          for (var N6 in r6) N6 !== "default" && !Object.prototype.hasOwnProperty.call(o, N6) && k4(o, r6, N6);
        };
        Object.defineProperty(A2, "__esModule", { value: true }), A2.Agent = void 0;
        const y3 = B3(require$$0__default$6), R4 = B3(require$$0__default$5), F2 = require$$1__default$4;
        t2(requireHelpers(), A2);
        const Q5 = Symbol("AgentBaseInternalState"), U6 = class U extends R4.Agent {
          constructor(o) {
            super(o), this[Q5] = {};
          }
          isSecureEndpoint(o) {
            if (o) {
              if (typeof o.secureEndpoint == "boolean") return o.secureEndpoint;
              if (typeof o.protocol == "string") return o.protocol === "https:";
            }
            const { stack: N6 } = new Error();
            return typeof N6 != "string" ? false : N6.split(`
`).some((l3) => l3.indexOf("(https.js:") !== -1 || l3.indexOf("node:https:") !== -1);
          }
          incrementSockets(o) {
            if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0) return null;
            this.sockets[o] || (this.sockets[o] = []);
            const N6 = new y3.Socket({ writable: false });
            return this.sockets[o].push(N6), this.totalSocketCount++, N6;
          }
          decrementSockets(o, N6) {
            if (!this.sockets[o] || N6 === null) return;
            const l3 = this.sockets[o], I5 = l3.indexOf(N6);
            I5 !== -1 && (l3.splice(I5, 1), this.totalSocketCount--, l3.length === 0 && delete this.sockets[o]);
          }
          getName(o) {
            return this.isSecureEndpoint(o) ? F2.Agent.prototype.getName.call(this, o) : super.getName(o);
          }
          createSocket(o, N6, l3) {
            const I5 = { ...N6, secureEndpoint: this.isSecureEndpoint(N6) }, p3 = this.getName(I5), b6 = this.incrementSockets(p3);
            Promise.resolve().then(() => this.connect(o, I5)).then((G3) => {
              if (this.decrementSockets(p3, b6), G3 instanceof R4.Agent) try {
                return G3.addRequest(o, I5);
              } catch (J5) {
                return l3(J5);
              }
              this[Q5].currentSocket = G3, super.createSocket(o, N6, l3);
            }, (G3) => {
              this.decrementSockets(p3, b6), l3(G3);
            });
          }
          createConnection() {
            const o = this[Q5].currentSocket;
            if (this[Q5].currentSocket = void 0, !o) throw new Error("No socket was returned in the `connect()` function");
            return o;
          }
          get defaultPort() {
            return this[Q5].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
          }
          set defaultPort(o) {
            this[Q5] && (this[Q5].defaultPort = o);
          }
          get protocol() {
            return this[Q5].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
          }
          set protocol(o) {
            this[Q5] && (this[Q5].protocol = o);
          }
        };
        e3(U6, "Agent");
        let D3 = U6;
        A2.Agent = D3;
      })(dist$2)), dist$2;
    }
    e3(requireDist$2, "requireDist$2");
    var distExports$2 = requireDist$2();
    var dist$1 = {};
    var src = { exports: {} };
    var browser = { exports: {} };
    var ms;
    var hasRequiredMs;
    function requireMs() {
      if (hasRequiredMs) return ms;
      hasRequiredMs = 1;
      var A2 = 1e3, k4 = A2 * 60, c2 = k4 * 60, B3 = c2 * 24, t2 = B3 * 7, y3 = B3 * 365.25;
      ms = e3(function(U6, r6) {
        r6 = r6 || {};
        var o = typeof U6;
        if (o === "string" && U6.length > 0) return R4(U6);
        if (o === "number" && isFinite(U6)) return r6.long ? Q5(U6) : F2(U6);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(U6));
      }, "ms");
      function R4(U6) {
        if (U6 = String(U6), !(U6.length > 100)) {
          var r6 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(U6);
          if (r6) {
            var o = parseFloat(r6[1]), N6 = (r6[2] || "ms").toLowerCase();
            switch (N6) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return o * y3;
              case "weeks":
              case "week":
              case "w":
                return o * t2;
              case "days":
              case "day":
              case "d":
                return o * B3;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return o * c2;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return o * k4;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return o * A2;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return o;
              default:
                return;
            }
          }
        }
      }
      e3(R4, "parse");
      function F2(U6) {
        var r6 = Math.abs(U6);
        return r6 >= B3 ? Math.round(U6 / B3) + "d" : r6 >= c2 ? Math.round(U6 / c2) + "h" : r6 >= k4 ? Math.round(U6 / k4) + "m" : r6 >= A2 ? Math.round(U6 / A2) + "s" : U6 + "ms";
      }
      e3(F2, "fmtShort");
      function Q5(U6) {
        var r6 = Math.abs(U6);
        return r6 >= B3 ? D3(U6, r6, B3, "day") : r6 >= c2 ? D3(U6, r6, c2, "hour") : r6 >= k4 ? D3(U6, r6, k4, "minute") : r6 >= A2 ? D3(U6, r6, A2, "second") : U6 + " ms";
      }
      e3(Q5, "fmtLong");
      function D3(U6, r6, o, N6) {
        var l3 = r6 >= o * 1.5;
        return Math.round(U6 / o) + " " + N6 + (l3 ? "s" : "");
      }
      return e3(D3, "plural"), ms;
    }
    e3(requireMs, "requireMs");
    var common;
    var hasRequiredCommon;
    function requireCommon() {
      if (hasRequiredCommon) return common;
      hasRequiredCommon = 1;
      function A2(k4) {
        B3.debug = B3, B3.default = B3, B3.coerce = D3, B3.disable = F2, B3.enable = y3, B3.enabled = Q5, B3.humanize = requireMs(), B3.destroy = U6, Object.keys(k4).forEach((r6) => {
          B3[r6] = k4[r6];
        }), B3.names = [], B3.skips = [], B3.formatters = {};
        function c2(r6) {
          let o = 0;
          for (let N6 = 0; N6 < r6.length; N6++) o = (o << 5) - o + r6.charCodeAt(N6), o |= 0;
          return B3.colors[Math.abs(o) % B3.colors.length];
        }
        e3(c2, "selectColor"), B3.selectColor = c2;
        function B3(r6) {
          let o, N6 = null, l3, I5;
          function p3(...b6) {
            if (!p3.enabled) return;
            const G3 = p3, J5 = Number(/* @__PURE__ */ new Date()), V4 = J5 - (o || J5);
            G3.diff = V4, G3.prev = o, G3.curr = J5, o = J5, b6[0] = B3.coerce(b6[0]), typeof b6[0] != "string" && b6.unshift("%O");
            let _5 = 0;
            b6[0] = b6[0].replace(/%([a-zA-Z%])/g, (M4, Y4) => {
              if (M4 === "%%") return "%";
              _5++;
              const m4 = B3.formatters[Y4];
              if (typeof m4 == "function") {
                const f3 = b6[_5];
                M4 = m4.call(G3, f3), b6.splice(_5, 1), _5--;
              }
              return M4;
            }), B3.formatArgs.call(G3, b6), (G3.log || B3.log).apply(G3, b6);
          }
          return e3(p3, "debug"), p3.namespace = r6, p3.useColors = B3.useColors(), p3.color = B3.selectColor(r6), p3.extend = t2, p3.destroy = B3.destroy, Object.defineProperty(p3, "enabled", { enumerable: true, configurable: false, get: e3(() => N6 !== null ? N6 : (l3 !== B3.namespaces && (l3 = B3.namespaces, I5 = B3.enabled(r6)), I5), "get"), set: e3((b6) => {
            N6 = b6;
          }, "set") }), typeof B3.init == "function" && B3.init(p3), p3;
        }
        e3(B3, "createDebug");
        function t2(r6, o) {
          const N6 = B3(this.namespace + (typeof o > "u" ? ":" : o) + r6);
          return N6.log = this.log, N6;
        }
        e3(t2, "extend");
        function y3(r6) {
          B3.save(r6), B3.namespaces = r6, B3.names = [], B3.skips = [];
          const o = (typeof r6 == "string" ? r6 : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
          for (const N6 of o) N6[0] === "-" ? B3.skips.push(N6.slice(1)) : B3.names.push(N6);
        }
        e3(y3, "enable");
        function R4(r6, o) {
          let N6 = 0, l3 = 0, I5 = -1, p3 = 0;
          for (; N6 < r6.length; ) if (l3 < o.length && (o[l3] === r6[N6] || o[l3] === "*")) o[l3] === "*" ? (I5 = l3, p3 = N6, l3++) : (N6++, l3++);
          else if (I5 !== -1) l3 = I5 + 1, p3++, N6 = p3;
          else return false;
          for (; l3 < o.length && o[l3] === "*"; ) l3++;
          return l3 === o.length;
        }
        e3(R4, "matchesTemplate");
        function F2() {
          const r6 = [...B3.names, ...B3.skips.map((o) => "-" + o)].join(",");
          return B3.enable(""), r6;
        }
        e3(F2, "disable");
        function Q5(r6) {
          for (const o of B3.skips) if (R4(r6, o)) return false;
          for (const o of B3.names) if (R4(r6, o)) return true;
          return false;
        }
        e3(Q5, "enabled");
        function D3(r6) {
          return r6 instanceof Error ? r6.stack || r6.message : r6;
        }
        e3(D3, "coerce");
        function U6() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        return e3(U6, "destroy"), B3.enable(B3.load()), B3;
      }
      return e3(A2, "setup"), common = A2, common;
    }
    e3(requireCommon, "requireCommon");
    var hasRequiredBrowser;
    function requireBrowser() {
      return hasRequiredBrowser || (hasRequiredBrowser = 1, (function(A2, k4) {
        k4.formatArgs = B3, k4.save = t2, k4.load = y3, k4.useColors = c2, k4.storage = R4(), k4.destroy = /* @__PURE__ */ (() => {
          let Q5 = false;
          return () => {
            Q5 || (Q5 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })(), k4.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
        function c2() {
          if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
          if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
          let Q5;
          return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (Q5 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(Q5[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        e3(c2, "useColors");
        function B3(Q5) {
          if (Q5[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + Q5[0] + (this.useColors ? "%c " : " ") + "+" + A2.exports.humanize(this.diff), !this.useColors) return;
          const D3 = "color: " + this.color;
          Q5.splice(1, 0, D3, "color: inherit");
          let U6 = 0, r6 = 0;
          Q5[0].replace(/%[a-zA-Z%]/g, (o) => {
            o !== "%%" && (U6++, o === "%c" && (r6 = U6));
          }), Q5.splice(r6, 0, D3);
        }
        e3(B3, "formatArgs"), k4.log = console.debug || console.log || (() => {
        });
        function t2(Q5) {
          try {
            Q5 ? k4.storage.setItem("debug", Q5) : k4.storage.removeItem("debug");
          } catch {
          }
        }
        e3(t2, "save");
        function y3() {
          let Q5;
          try {
            Q5 = k4.storage.getItem("debug") || k4.storage.getItem("DEBUG");
          } catch {
          }
          return !Q5 && typeof process < "u" && "env" in process && (Q5 = process.env.DEBUG), Q5;
        }
        e3(y3, "load");
        function R4() {
          try {
            return localStorage;
          } catch {
          }
        }
        e3(R4, "localstorage"), A2.exports = requireCommon()(k4);
        const { formatters: F2 } = A2.exports;
        F2.j = function(Q5) {
          try {
            return JSON.stringify(Q5);
          } catch (D3) {
            return "[UnexpectedJSONParseError]: " + D3.message;
          }
        };
      })(browser, browser.exports)), browser.exports;
    }
    e3(requireBrowser, "requireBrowser");
    var node = { exports: {} };
    var hasFlag;
    var hasRequiredHasFlag;
    function requireHasFlag() {
      return hasRequiredHasFlag || (hasRequiredHasFlag = 1, hasFlag = e3((A2, k4 = process.argv) => {
        const c2 = A2.startsWith("-") ? "" : A2.length === 1 ? "-" : "--", B3 = k4.indexOf(c2 + A2), t2 = k4.indexOf("--");
        return B3 !== -1 && (t2 === -1 || B3 < t2);
      }, "hasFlag")), hasFlag;
    }
    e3(requireHasFlag, "requireHasFlag");
    var supportsColor_1;
    var hasRequiredSupportsColor;
    function requireSupportsColor() {
      if (hasRequiredSupportsColor) return supportsColor_1;
      hasRequiredSupportsColor = 1;
      const A2 = require$$0__default$7, k4 = require$$1__default$5, c2 = requireHasFlag(), { env: B3 } = process;
      let t2;
      c2("no-color") || c2("no-colors") || c2("color=false") || c2("color=never") ? t2 = 0 : (c2("color") || c2("colors") || c2("color=true") || c2("color=always")) && (t2 = 1), "FORCE_COLOR" in B3 && (B3.FORCE_COLOR === "true" ? t2 = 1 : B3.FORCE_COLOR === "false" ? t2 = 0 : t2 = B3.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(B3.FORCE_COLOR, 10), 3));
      function y3(Q5) {
        return Q5 === 0 ? false : { level: Q5, hasBasic: true, has256: Q5 >= 2, has16m: Q5 >= 3 };
      }
      e3(y3, "translateLevel");
      function R4(Q5, D3) {
        if (t2 === 0) return 0;
        if (c2("color=16m") || c2("color=full") || c2("color=truecolor")) return 3;
        if (c2("color=256")) return 2;
        if (Q5 && !D3 && t2 === void 0) return 0;
        const U6 = t2 || 0;
        if (B3.TERM === "dumb") return U6;
        if (process.platform === "win32") {
          const r6 = A2.release().split(".");
          return Number(r6[0]) >= 10 && Number(r6[2]) >= 10586 ? Number(r6[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in B3) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((r6) => r6 in B3) || B3.CI_NAME === "codeship" ? 1 : U6;
        if ("TEAMCITY_VERSION" in B3) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(B3.TEAMCITY_VERSION) ? 1 : 0;
        if (B3.COLORTERM === "truecolor") return 3;
        if ("TERM_PROGRAM" in B3) {
          const r6 = parseInt((B3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (B3.TERM_PROGRAM) {
            case "iTerm.app":
              return r6 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(B3.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(B3.TERM) || "COLORTERM" in B3 ? 1 : U6;
      }
      e3(R4, "supportsColor");
      function F2(Q5) {
        const D3 = R4(Q5, Q5 && Q5.isTTY);
        return y3(D3);
      }
      return e3(F2, "getSupportLevel"), supportsColor_1 = { supportsColor: F2, stdout: y3(R4(true, k4.isatty(1))), stderr: y3(R4(true, k4.isatty(2))) }, supportsColor_1;
    }
    e3(requireSupportsColor, "requireSupportsColor");
    var hasRequiredNode;
    function requireNode() {
      return hasRequiredNode || (hasRequiredNode = 1, (function(A2, k4) {
        const c2 = require$$1__default$5, B3 = require$$1__default$6;
        k4.init = U6, k4.log = F2, k4.formatArgs = y3, k4.save = Q5, k4.load = D3, k4.useColors = t2, k4.destroy = B3.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), k4.colors = [6, 2, 3, 4, 5, 1];
        try {
          const o = requireSupportsColor();
          o && (o.stderr || o).level >= 2 && (k4.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
        } catch {
        }
        k4.inspectOpts = Object.keys(process.env).filter((o) => /^debug_/i.test(o)).reduce((o, N6) => {
          const l3 = N6.substring(6).toLowerCase().replace(/_([a-z])/g, (p3, b6) => b6.toUpperCase());
          let I5 = process.env[N6];
          return /^(yes|on|true|enabled)$/i.test(I5) ? I5 = true : /^(no|off|false|disabled)$/i.test(I5) ? I5 = false : I5 === "null" ? I5 = null : I5 = Number(I5), o[l3] = I5, o;
        }, {});
        function t2() {
          return "colors" in k4.inspectOpts ? !!k4.inspectOpts.colors : c2.isatty(process.stderr.fd);
        }
        e3(t2, "useColors");
        function y3(o) {
          const { namespace: N6, useColors: l3 } = this;
          if (l3) {
            const I5 = this.color, p3 = "\x1B[3" + (I5 < 8 ? I5 : "8;5;" + I5), b6 = `  ${p3};1m${N6} \x1B[0m`;
            o[0] = b6 + o[0].split(`
`).join(`
` + b6), o.push(p3 + "m+" + A2.exports.humanize(this.diff) + "\x1B[0m");
          } else o[0] = R4() + N6 + " " + o[0];
        }
        e3(y3, "formatArgs");
        function R4() {
          return k4.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
        }
        e3(R4, "getDate");
        function F2(...o) {
          return process.stderr.write(B3.formatWithOptions(k4.inspectOpts, ...o) + `
`);
        }
        e3(F2, "log");
        function Q5(o) {
          o ? process.env.DEBUG = o : delete process.env.DEBUG;
        }
        e3(Q5, "save");
        function D3() {
          return process.env.DEBUG;
        }
        e3(D3, "load");
        function U6(o) {
          o.inspectOpts = {};
          const N6 = Object.keys(k4.inspectOpts);
          for (let l3 = 0; l3 < N6.length; l3++) o.inspectOpts[N6[l3]] = k4.inspectOpts[N6[l3]];
        }
        e3(U6, "init"), A2.exports = requireCommon()(k4);
        const { formatters: r6 } = A2.exports;
        r6.o = function(o) {
          return this.inspectOpts.colors = this.useColors, B3.inspect(o, this.inspectOpts).split(`
`).map((N6) => N6.trim()).join(" ");
        }, r6.O = function(o) {
          return this.inspectOpts.colors = this.useColors, B3.inspect(o, this.inspectOpts);
        };
      })(node, node.exports)), node.exports;
    }
    e3(requireNode, "requireNode");
    var hasRequiredSrc;
    function requireSrc() {
      return hasRequiredSrc || (hasRequiredSrc = 1, typeof process > "u" || process.type === "renderer" || process.browser === true || process.__nwjs ? src.exports = requireBrowser() : src.exports = requireNode()), src.exports;
    }
    e3(requireSrc, "requireSrc");
    var hasRequiredDist$1;
    function requireDist$1() {
      if (hasRequiredDist$1) return dist$1;
      hasRequiredDist$1 = 1;
      var A2 = dist$1 && dist$1.__createBinding || (Object.create ? function(l3, I5, p3, b6) {
        b6 === void 0 && (b6 = p3);
        var G3 = Object.getOwnPropertyDescriptor(I5, p3);
        (!G3 || ("get" in G3 ? !I5.__esModule : G3.writable || G3.configurable)) && (G3 = { enumerable: true, get: e3(function() {
          return I5[p3];
        }, "get") }), Object.defineProperty(l3, b6, G3);
      } : function(l3, I5, p3, b6) {
        b6 === void 0 && (b6 = p3), l3[b6] = I5[p3];
      }), k4 = dist$1 && dist$1.__setModuleDefault || (Object.create ? function(l3, I5) {
        Object.defineProperty(l3, "default", { enumerable: true, value: I5 });
      } : function(l3, I5) {
        l3.default = I5;
      }), c2 = dist$1 && dist$1.__importStar || function(l3) {
        if (l3 && l3.__esModule) return l3;
        var I5 = {};
        if (l3 != null) for (var p3 in l3) p3 !== "default" && Object.prototype.hasOwnProperty.call(l3, p3) && A2(I5, l3, p3);
        return k4(I5, l3), I5;
      }, B3 = dist$1 && dist$1.__importDefault || function(l3) {
        return l3 && l3.__esModule ? l3 : { default: l3 };
      };
      Object.defineProperty(dist$1, "__esModule", { value: true }), dist$1.HttpProxyAgent = void 0;
      const t2 = c2(require$$0__default$6), y3 = c2(require$$1__default$7), R4 = B3(requireSrc()), F2 = require$$3__default, Q5 = requireDist$2(), D3 = require$$5__default$4, U6 = (0, R4.default)("http-proxy-agent"), N6 = class N extends Q5.Agent {
        constructor(I5, p3) {
          super(p3), this.proxy = typeof I5 == "string" ? new D3.URL(I5) : I5, this.proxyHeaders = p3?.headers ?? {}, U6("Creating new HttpProxyAgent instance: %o", this.proxy.href);
          const b6 = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), G3 = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
          this.connectOpts = { ...p3 ? o(p3, "headers") : null, host: b6, port: G3 };
        }
        addRequest(I5, p3) {
          I5._header = null, this.setRequestProps(I5, p3), super.addRequest(I5, p3);
        }
        setRequestProps(I5, p3) {
          const { proxy: b6 } = this, G3 = p3.secureEndpoint ? "https:" : "http:", J5 = I5.getHeader("host") || "localhost", V4 = `${G3}//${J5}`, _5 = new D3.URL(I5.path, V4);
          p3.port !== 80 && (_5.port = String(p3.port)), I5.path = String(_5);
          const q6 = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
          if (b6.username || b6.password) {
            const M4 = `${decodeURIComponent(b6.username)}:${decodeURIComponent(b6.password)}`;
            q6["Proxy-Authorization"] = `Basic ${Buffer.from(M4).toString("base64")}`;
          }
          q6["Proxy-Connection"] || (q6["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
          for (const M4 of Object.keys(q6)) {
            const Y4 = q6[M4];
            Y4 && I5.setHeader(M4, Y4);
          }
        }
        async connect(I5, p3) {
          I5._header = null, I5.path.includes("://") || this.setRequestProps(I5, p3);
          let b6, G3;
          U6("Regenerating stored HTTP header string for request"), I5._implicitHeader(), I5.outputData && I5.outputData.length > 0 && (U6("Patching connection write() output buffer with updated header"), b6 = I5.outputData[0].data, G3 = b6.indexOf(`\r
\r
`) + 4, I5.outputData[0].data = I5._header + b6.substring(G3), U6("Output buffer: %o", I5.outputData[0].data));
          let J5;
          return this.proxy.protocol === "https:" ? (U6("Creating `tls.Socket`: %o", this.connectOpts), J5 = y3.connect(this.connectOpts)) : (U6("Creating `net.Socket`: %o", this.connectOpts), J5 = t2.connect(this.connectOpts)), await (0, F2.once)(J5, "connect"), J5;
        }
      };
      e3(N6, "HttpProxyAgent");
      let r6 = N6;
      r6.protocols = ["http", "https"], dist$1.HttpProxyAgent = r6;
      function o(l3, ...I5) {
        const p3 = {};
        let b6;
        for (b6 in l3) I5.includes(b6) || (p3[b6] = l3[b6]);
        return p3;
      }
      return e3(o, "omit"), dist$1;
    }
    e3(requireDist$1, "requireDist$1");
    var distExports$1 = requireDist$1();
    var dist = {};
    var parseProxyResponse = {};
    var hasRequiredParseProxyResponse;
    function requireParseProxyResponse() {
      if (hasRequiredParseProxyResponse) return parseProxyResponse;
      hasRequiredParseProxyResponse = 1;
      var A2 = parseProxyResponse && parseProxyResponse.__importDefault || function(t2) {
        return t2 && t2.__esModule ? t2 : { default: t2 };
      };
      Object.defineProperty(parseProxyResponse, "__esModule", { value: true }), parseProxyResponse.parseProxyResponse = void 0;
      const c2 = (0, A2(requireSrc()).default)("https-proxy-agent:parse-proxy-response");
      function B3(t2) {
        return new Promise((y3, R4) => {
          let F2 = 0;
          const Q5 = [];
          function D3() {
            const l3 = t2.read();
            l3 ? N6(l3) : t2.once("readable", D3);
          }
          e3(D3, "read");
          function U6() {
            t2.removeListener("end", r6), t2.removeListener("error", o), t2.removeListener("readable", D3);
          }
          e3(U6, "cleanup");
          function r6() {
            U6(), c2("onend"), R4(new Error("Proxy connection ended before receiving CONNECT response"));
          }
          e3(r6, "onend");
          function o(l3) {
            U6(), c2("onerror %o", l3), R4(l3);
          }
          e3(o, "onerror");
          function N6(l3) {
            Q5.push(l3), F2 += l3.length;
            const I5 = Buffer.concat(Q5, F2), p3 = I5.indexOf(`\r
\r
`);
            if (p3 === -1) {
              c2("have not received end of HTTP headers yet..."), D3();
              return;
            }
            const b6 = I5.slice(0, p3).toString("ascii").split(`\r
`), G3 = b6.shift();
            if (!G3) return t2.destroy(), R4(new Error("No header received from proxy CONNECT response"));
            const J5 = G3.split(" "), V4 = +J5[1], _5 = J5.slice(2).join(" "), q6 = {};
            for (const M4 of b6) {
              if (!M4) continue;
              const Y4 = M4.indexOf(":");
              if (Y4 === -1) return t2.destroy(), R4(new Error(`Invalid header from proxy CONNECT response: "${M4}"`));
              const m4 = M4.slice(0, Y4).toLowerCase(), f3 = M4.slice(Y4 + 1).trimStart(), n = q6[m4];
              typeof n == "string" ? q6[m4] = [n, f3] : Array.isArray(n) ? n.push(f3) : q6[m4] = f3;
            }
            c2("got proxy server response: %o %o", G3, q6), U6(), y3({ connect: { statusCode: V4, statusText: _5, headers: q6 }, buffered: I5 });
          }
          e3(N6, "ondata"), t2.on("error", o), t2.on("end", r6), D3();
        });
      }
      return e3(B3, "parseProxyResponse$1"), parseProxyResponse.parseProxyResponse = B3, parseProxyResponse;
    }
    e3(requireParseProxyResponse, "requireParseProxyResponse");
    var hasRequiredDist;
    function requireDist() {
      if (hasRequiredDist) return dist;
      hasRequiredDist = 1;
      var A2 = dist && dist.__createBinding || (Object.create ? function(b6, G3, J5, V4) {
        V4 === void 0 && (V4 = J5);
        var _5 = Object.getOwnPropertyDescriptor(G3, J5);
        (!_5 || ("get" in _5 ? !G3.__esModule : _5.writable || _5.configurable)) && (_5 = { enumerable: true, get: e3(function() {
          return G3[J5];
        }, "get") }), Object.defineProperty(b6, V4, _5);
      } : function(b6, G3, J5, V4) {
        V4 === void 0 && (V4 = J5), b6[V4] = G3[J5];
      }), k4 = dist && dist.__setModuleDefault || (Object.create ? function(b6, G3) {
        Object.defineProperty(b6, "default", { enumerable: true, value: G3 });
      } : function(b6, G3) {
        b6.default = G3;
      }), c2 = dist && dist.__importStar || function(b6) {
        if (b6 && b6.__esModule) return b6;
        var G3 = {};
        if (b6 != null) for (var J5 in b6) J5 !== "default" && Object.prototype.hasOwnProperty.call(b6, J5) && A2(G3, b6, J5);
        return k4(G3, b6), G3;
      }, B3 = dist && dist.__importDefault || function(b6) {
        return b6 && b6.__esModule ? b6 : { default: b6 };
      };
      Object.defineProperty(dist, "__esModule", { value: true }), dist.HttpsProxyAgent = void 0;
      const t2 = c2(require$$0__default$6), y3 = c2(require$$1__default$7), R4 = B3(require$$2__default), F2 = B3(requireSrc()), Q5 = requireDist$2(), D3 = require$$5__default$4, U6 = requireParseProxyResponse(), r6 = (0, F2.default)("https-proxy-agent"), o = e3((b6) => b6.servername === void 0 && b6.host && !t2.isIP(b6.host) ? { ...b6, servername: b6.host } : b6, "setServernameFromNonIpHost"), p3 = class p extends Q5.Agent {
        constructor(G3, J5) {
          super(J5), this.options = { path: void 0 }, this.proxy = typeof G3 == "string" ? new D3.URL(G3) : G3, this.proxyHeaders = J5?.headers ?? {}, r6("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
          const V4 = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), _5 = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
          this.connectOpts = { ALPNProtocols: ["http/1.1"], ...J5 ? I5(J5, "headers") : null, host: V4, port: _5 };
        }
        async connect(G3, J5) {
          const { proxy: V4 } = this;
          if (!J5.host) throw new TypeError('No "host" provided');
          let _5;
          V4.protocol === "https:" ? (r6("Creating `tls.Socket`: %o", this.connectOpts), _5 = y3.connect(o(this.connectOpts))) : (r6("Creating `net.Socket`: %o", this.connectOpts), _5 = t2.connect(this.connectOpts));
          const q6 = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders }, M4 = t2.isIPv6(J5.host) ? `[${J5.host}]` : J5.host;
          let Y4 = `CONNECT ${M4}:${J5.port} HTTP/1.1\r
`;
          if (V4.username || V4.password) {
            const w5 = `${decodeURIComponent(V4.username)}:${decodeURIComponent(V4.password)}`;
            q6["Proxy-Authorization"] = `Basic ${Buffer.from(w5).toString("base64")}`;
          }
          q6.Host = `${M4}:${J5.port}`, q6["Proxy-Connection"] || (q6["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
          for (const w5 of Object.keys(q6)) Y4 += `${w5}: ${q6[w5]}\r
`;
          const m4 = (0, U6.parseProxyResponse)(_5);
          _5.write(`${Y4}\r
`);
          const { connect: f3, buffered: n } = await m4;
          if (G3.emit("proxyConnect", f3), this.emit("proxyConnect", f3, G3), f3.statusCode === 200) return G3.once("socket", l3), J5.secureEndpoint ? (r6("Upgrading socket connection to TLS"), y3.connect({ ...I5(o(J5), "host", "path", "port"), socket: _5 })) : _5;
          _5.destroy();
          const C5 = new t2.Socket({ writable: false });
          return C5.readable = true, G3.once("socket", (w5) => {
            r6("Replaying proxy buffer for failed request"), (0, R4.default)(w5.listenerCount("data") > 0), w5.push(n), w5.push(null);
          }), C5;
        }
      };
      e3(p3, "HttpsProxyAgent");
      let N6 = p3;
      N6.protocols = ["http", "https"], dist.HttpsProxyAgent = N6;
      function l3(b6) {
        b6.resume();
      }
      e3(l3, "resume");
      function I5(b6, ...G3) {
        const J5 = {};
        let V4;
        for (V4 in b6) G3.includes(V4) || (J5[V4] = b6[V4]);
        return J5;
      }
      return e3(I5, "omit"), dist;
    }
    e3(requireDist, "requireDist");
    var distExports = requireDist();
    var d4 = Object.defineProperty;
    var O4 = e3((A2, k4, c2) => k4 in A2 ? d4(A2, k4, { enumerable: true, configurable: true, writable: true, value: c2 }) : A2[k4] = c2, "O");
    var s4 = e3((A2, k4) => d4(A2, "name", { value: k4, configurable: true }), "s");
    var i2 = e3((A2, k4, c2) => O4(A2, typeof k4 != "symbol" ? k4 + "" : k4, c2), "i");
    function H5(...A2) {
      process.env.DEBUG && console.debug("[node-fetch-native] [proxy]", ...A2);
    }
    e3(H5, "H"), s4(H5, "debug");
    function P5(A2, k4) {
      if (!k4) return false;
      for (const c2 of k4) if (c2 === A2 || c2[0] === "." && A2.endsWith(c2.slice(1))) return true;
      return false;
    }
    e3(P5, "P"), s4(P5, "bypassProxy");
    var g4 = (fe4 = class extends undiciExports.ProxyAgent {
      constructor(k4) {
        super(k4), this._options = k4, i2(this, "_agent"), this._agent = new undiciExports.Agent();
      }
      dispatch(k4, c2) {
        const B3 = new require$$1$1.URL(k4.origin).hostname;
        return P5(B3, this._options.noProxy) ? (H5(`Bypassing proxy for: ${B3}`), this._agent.dispatch(k4, c2)) : super.dispatch(k4, c2);
      }
    }, e3(fe4, "g"), fe4);
    s4(g4, "UndiciProxyAgent");
    var h8 = g4;
    var T5 = ["http", "https"];
    var E3 = { http: [distExports$1.HttpProxyAgent, distExports.HttpsProxyAgent], https: [distExports$1.HttpProxyAgent, distExports.HttpsProxyAgent] };
    function L4(A2) {
      return T5.includes(A2);
    }
    e3(L4, "L"), s4(L4, "isValidProtocol");
    var u4 = (de3 = class extends distExports$2.Agent {
      constructor(k4) {
        super({}), this._options = k4, i2(this, "cache", /* @__PURE__ */ new Map()), i2(this, "httpAgent"), i2(this, "httpsAgent"), this.httpAgent = new http__namespace.Agent({}), this.httpsAgent = new https__namespace.Agent({});
      }
      connect(k4, c2) {
        const B3 = k4.getHeader("upgrade") === "websocket", t2 = c2.secureEndpoint ? B3 ? "wss:" : "https:" : B3 ? "ws:" : "http:", y3 = k4.getHeader("host");
        if (P5(y3, this._options.noProxy)) return c2.secureEndpoint ? this.httpsAgent : this.httpAgent;
        const R4 = `${t2}+${this._options.uri}`;
        let F2 = this.cache.get(R4);
        if (!F2) {
          const Q5 = new require$$1$1.URL(this._options.uri).protocol.replace(":", "");
          if (!L4(Q5)) throw new Error(`Unsupported protocol for proxy URL: ${this._options.uri}`);
          const D3 = E3[Q5][c2.secureEndpoint || B3 ? 1 : 0];
          F2 = new D3(this._options.uri, this._options), this.cache.set(R4, F2);
        }
        return F2;
      }
      destroy() {
        for (const k4 of this.cache.values()) k4.destroy();
        super.destroy();
      }
    }, e3(de3, "u"), de3);
    s4(u4, "NodeProxyAgent");
    var a3 = u4;
    function createProxy(A2 = {}) {
      const k4 = A2.url || process.env.https_proxy || process.env.http_proxy || process.env.HTTPS_PROXY || process.env.HTTP_PROXY;
      if (!k4) return { agent: void 0, dispatcher: void 0 };
      const c2 = A2.noProxy || process.env.no_proxy || process.env.NO_PROXY, B3 = typeof c2 == "string" ? c2.split(",") : c2, t2 = new a3({ uri: k4, noProxy: B3 }), y3 = new h8({ uri: k4, noProxy: B3 });
      return { agent: t2, dispatcher: y3 };
    }
    e3(createProxy, "createProxy"), s4(createProxy, "createProxy");
    function createFetch(A2 = {}) {
      const k4 = createProxy(A2);
      return (c2, B3) => nodeFetchNative.fetch(c2, { ...k4, ...B3 });
    }
    e3(createFetch, "createFetch"), s4(createFetch, "createFetch");
    var fetch3 = createFetch({});
    exports2.createFetch = createFetch, exports2.createProxy = createProxy, exports2.fetch = fetch3;
  }
});

// ../../node_modules/.pnpm/giget@1.2.5/node_modules/giget/dist/shared/giget.BgKdRmJH.mjs
async function download(url, filePath, options = {}) {
  const infoPath = filePath + ".json";
  const info = JSON.parse(
    await (0, import_promises5.readFile)(infoPath, "utf8").catch(() => "{}")
  );
  const headResponse = await sendFetch(url, {
    method: "HEAD",
    headers: options.headers
  }).catch(() => void 0);
  const etag = headResponse?.headers.get("etag");
  if (info.etag === etag && (0, import_node_fs6.existsSync)(filePath)) {
    return;
  }
  if (typeof etag === "string") {
    info.etag = etag;
  }
  const response = await sendFetch(url, { headers: options.headers });
  if (response.status >= 400) {
    throw new Error(
      `Failed to download ${url}: ${response.status} ${response.statusText}`
    );
  }
  const stream = (0, import_node_fs6.createWriteStream)(filePath);
  await (0, import_node_util2.promisify)(import_node_stream.pipeline)(response.body, stream);
  await (0, import_promises5.writeFile)(infoPath, JSON.stringify(info), "utf8");
}
function parseGitURI(input) {
  const m4 = input.match(inputRegex)?.groups || {};
  return {
    repo: m4.repo,
    subdir: m4.subdir || "/",
    ref: m4.ref ? m4.ref.slice(1) : "main"
  };
}
function debug(...args) {
  if (process.env.DEBUG) {
    console.debug("[giget]", ...args);
  }
}
async function sendFetch(url, options = {}) {
  if (options.headers?.["sec-fetch-mode"]) {
    options.mode = options.headers["sec-fetch-mode"];
  }
  const res = await (0, import_proxy.fetch)(url, {
    ...options,
    headers: normalizeHeaders(options.headers)
  }).catch((error) => {
    throw new Error(`Failed to download ${url}: ${error}`, { cause: error });
  });
  if (options.validateStatus && res.status >= 400) {
    throw new Error(`Failed to fetch ${url}: ${res.status} ${res.statusText}`);
  }
  return res;
}
function cacheDirectory() {
  return process.env.XDG_CACHE_HOME ? resolve2(process.env.XDG_CACHE_HOME, "giget") : resolve2((0, import_node_os3.homedir)(), ".cache/giget");
}
function normalizeHeaders(headers = {}) {
  const normalized = {};
  for (const [key, value] of Object.entries(headers)) {
    if (!value) {
      continue;
    }
    normalized[key.toLowerCase()] = value;
  }
  return normalized;
}
function currentShell() {
  if (process.env.SHELL) {
    return process.env.SHELL;
  }
  if (process.platform === "win32") {
    return "cmd.exe";
  }
  return "/bin/bash";
}
function startShell(cwd2) {
  cwd2 = resolve2(cwd2);
  const shell = currentShell();
  console.info(
    `(experimental) Opening shell in ${relative(process.cwd(), cwd2)}...`
  );
  (0, import_node_child_process.spawnSync)(shell, [], {
    cwd: cwd2,
    shell: true,
    stdio: "inherit"
  });
}
async function downloadTemplate(input, options = {}) {
  options = defu(
    {
      registry: process.env.GIGET_REGISTRY,
      auth: process.env.GIGET_AUTH
    },
    options
  );
  const registry = options.registry === false ? void 0 : registryProvider(options.registry, { auth: options.auth });
  let providerName = options.provider || (registry ? "registry" : "github");
  let source = input;
  const sourceProviderMatch = input.match(sourceProtoRe);
  if (sourceProviderMatch) {
    providerName = sourceProviderMatch[1];
    source = input.slice(sourceProviderMatch[0].length);
    if (providerName === "http" || providerName === "https") {
      source = input;
    }
  }
  const provider = options.providers?.[providerName] || providers[providerName] || registry;
  if (!provider) {
    throw new Error(`Unsupported provider: ${providerName}`);
  }
  const template = await Promise.resolve().then(() => provider(source, { auth: options.auth })).catch((error) => {
    throw new Error(
      `Failed to download template from ${providerName}: ${error.message}`
    );
  });
  if (!template) {
    throw new Error(`Failed to resolve template from ${providerName}`);
  }
  template.name = (template.name || "template").replace(/[^\da-z-]/gi, "-");
  template.defaultDir = (template.defaultDir || template.name).replace(
    /[^\da-z-]/gi,
    "-"
  );
  const temporaryDirectory = resolve2(
    cacheDirectory(),
    providerName,
    template.name
  );
  const tarPath = resolve2(
    temporaryDirectory,
    (template.version || template.name) + ".tar.gz"
  );
  if (options.preferOffline && (0, import_node_fs6.existsSync)(tarPath)) {
    options.offline = true;
  }
  if (!options.offline) {
    await (0, import_promises5.mkdir)(dirname(tarPath), { recursive: true });
    const s22 = Date.now();
    await download(template.tar, tarPath, {
      headers: {
        Authorization: options.auth ? `Bearer ${options.auth}` : void 0,
        ...normalizeHeaders(template.headers)
      }
    }).catch((error) => {
      if (!(0, import_node_fs6.existsSync)(tarPath)) {
        throw error;
      }
      debug("Download error. Using cached version:", error);
      options.offline = true;
    });
    debug(`Downloaded ${template.tar} to ${tarPath} in ${Date.now() - s22}ms`);
  }
  if (!(0, import_node_fs6.existsSync)(tarPath)) {
    throw new Error(
      `Tarball not found: ${tarPath} (offline: ${options.offline})`
    );
  }
  const cwd2 = resolve2(options.cwd || ".");
  const extractPath = resolve2(cwd2, options.dir || template.defaultDir);
  if (options.forceClean) {
    await (0, import_promises5.rm)(extractPath, { recursive: true, force: true });
  }
  if (!options.force && (0, import_node_fs6.existsSync)(extractPath) && (0, import_node_fs6.readdirSync)(extractPath).length > 0) {
    throw new Error(`Destination ${extractPath} already exists.`);
  }
  await (0, import_promises5.mkdir)(extractPath, { recursive: true });
  const s4 = Date.now();
  const subdir = template.subdir?.replace(/^\//, "") || "";
  await (0, import_tar.extract)({
    file: tarPath,
    cwd: extractPath,
    onentry(entry) {
      entry.path = entry.path.split("/").splice(1).join("/");
      if (subdir) {
        if (entry.path.startsWith(subdir + "/")) {
          entry.path = entry.path.slice(subdir.length);
        } else {
          entry.path = "";
        }
      }
    }
  });
  debug(`Extracted to ${extractPath} in ${Date.now() - s4}ms`);
  if (options.install) {
    debug("Installing dependencies...");
    await installDependencies({
      cwd: extractPath,
      silent: options.silent
    });
  }
  return {
    ...template,
    source,
    dir: extractPath
  };
}
var import_promises5, import_node_fs6, import_tar, import_node_stream, import_node_child_process, import_node_os3, import_node_util2, import_proxy, inputRegex, http, _httpJSON, github, gitlab, bitbucket, sourcehut, providers, DEFAULT_REGISTRY, registryProvider, sourceProtoRe;
var init_giget_BgKdRmJH = __esm({
  "../../node_modules/.pnpm/giget@1.2.5/node_modules/giget/dist/shared/giget.BgKdRmJH.mjs"() {
    "use strict";
    import_promises5 = require("fs/promises");
    import_node_fs6 = require("fs");
    import_tar = __toESM(require_tar(), 1);
    init_dist();
    init_defu();
    init_dist6();
    import_node_stream = require("stream");
    import_node_child_process = require("child_process");
    import_node_os3 = require("os");
    import_node_util2 = require("util");
    import_proxy = __toESM(require_proxy(), 1);
    inputRegex = /^(?<repo>[\w.-]+\/[\w.-]+)(?<subdir>[^#]+)?(?<ref>#[\w./@-]+)?/;
    http = async (input, options) => {
      if (input.endsWith(".json")) {
        return await _httpJSON(input, options);
      }
      const url = new URL(input);
      let name = basename2(url.pathname);
      try {
        const head = await sendFetch(url.href, {
          method: "HEAD",
          validateStatus: true,
          headers: {
            authorization: options.auth ? `Bearer ${options.auth}` : void 0
          }
        });
        const _contentType = head.headers.get("content-type") || "";
        if (_contentType.includes("application/json")) {
          return await _httpJSON(input, options);
        }
        const filename = head.headers.get("content-disposition")?.match(/filename="?(.+)"?/)?.[1];
        if (filename) {
          name = filename.split(".")[0];
        }
      } catch (error) {
        debug(`Failed to fetch HEAD for ${url.href}:`, error);
      }
      return {
        name: `${name}-${url.href.slice(0, 8)}`,
        version: "",
        subdir: "",
        tar: url.href,
        defaultDir: name,
        headers: {
          Authorization: options.auth ? `Bearer ${options.auth}` : void 0
        }
      };
    };
    _httpJSON = async (input, options) => {
      const result = await sendFetch(input, {
        validateStatus: true,
        headers: {
          authorization: options.auth ? `Bearer ${options.auth}` : void 0
        }
      });
      const info = await result.json();
      if (!info.tar || !info.name) {
        throw new Error(
          `Invalid template info from ${input}. name or tar fields are missing!`
        );
      }
      return info;
    };
    github = (input, options) => {
      const parsed = parseGitURI(input);
      const githubAPIURL = process.env.GIGET_GITHUB_URL || "https://api.github.com";
      return {
        name: parsed.repo.replace("/", "-"),
        version: parsed.ref,
        subdir: parsed.subdir,
        headers: {
          Authorization: options.auth ? `Bearer ${options.auth}` : void 0,
          Accept: "application/vnd.github+json",
          "X-GitHub-Api-Version": "2022-11-28"
        },
        url: `${githubAPIURL.replace("api.github.com", "github.com")}/${parsed.repo}/tree/${parsed.ref}${parsed.subdir}`,
        tar: `${githubAPIURL}/repos/${parsed.repo}/tarball/${parsed.ref}`
      };
    };
    gitlab = (input, options) => {
      const parsed = parseGitURI(input);
      const gitlab2 = process.env.GIGET_GITLAB_URL || "https://gitlab.com";
      return {
        name: parsed.repo.replace("/", "-"),
        version: parsed.ref,
        subdir: parsed.subdir,
        headers: {
          authorization: options.auth ? `Bearer ${options.auth}` : void 0,
          // https://gitlab.com/gitlab-org/gitlab/-/commit/50c11f278d18fe1f3fb12eb595067216bb58ade2
          "sec-fetch-mode": "same-origin"
        },
        url: `${gitlab2}/${parsed.repo}/tree/${parsed.ref}${parsed.subdir}`,
        tar: `${gitlab2}/${parsed.repo}/-/archive/${parsed.ref}.tar.gz`
      };
    };
    bitbucket = (input, options) => {
      const parsed = parseGitURI(input);
      return {
        name: parsed.repo.replace("/", "-"),
        version: parsed.ref,
        subdir: parsed.subdir,
        headers: {
          authorization: options.auth ? `Bearer ${options.auth}` : void 0
        },
        url: `https://bitbucket.com/${parsed.repo}/src/${parsed.ref}${parsed.subdir}`,
        tar: `https://bitbucket.org/${parsed.repo}/get/${parsed.ref}.tar.gz`
      };
    };
    sourcehut = (input, options) => {
      const parsed = parseGitURI(input);
      return {
        name: parsed.repo.replace("/", "-"),
        version: parsed.ref,
        subdir: parsed.subdir,
        headers: {
          authorization: options.auth ? `Bearer ${options.auth}` : void 0
        },
        url: `https://git.sr.ht/~${parsed.repo}/tree/${parsed.ref}/item${parsed.subdir}`,
        tar: `https://git.sr.ht/~${parsed.repo}/archive/${parsed.ref}.tar.gz`
      };
    };
    providers = {
      http,
      https: http,
      github,
      gh: github,
      gitlab,
      bitbucket,
      sourcehut
    };
    DEFAULT_REGISTRY = "https://raw.githubusercontent.com/unjs/giget/main/templates";
    registryProvider = (registryEndpoint = DEFAULT_REGISTRY, options = {}) => {
      return async (input) => {
        const start = Date.now();
        const registryURL = `${registryEndpoint}/${input}.json`;
        const result = await sendFetch(registryURL, {
          headers: {
            authorization: options.auth ? `Bearer ${options.auth}` : void 0
          }
        });
        if (result.status >= 400) {
          throw new Error(
            `Failed to download ${input} template info from ${registryURL}: ${result.status} ${result.statusText}`
          );
        }
        const info = await result.json();
        if (!info.tar || !info.name) {
          throw new Error(
            `Invalid template info from ${registryURL}. name or tar fields are missing!`
          );
        }
        debug(
          `Fetched ${input} template info from ${registryURL} in ${Date.now() - start}ms`
        );
        return info;
      };
    };
    sourceProtoRe = /^([\w-.]+):/;
  }
});

// ../../node_modules/.pnpm/giget@1.2.5/node_modules/giget/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  downloadTemplate: () => downloadTemplate,
  registryProvider: () => registryProvider,
  startShell: () => startShell
});
var import_promises6, import_node_fs7, import_tar2, import_node_stream2, import_node_child_process2, import_node_os4, import_node_util3, import_proxy2;
var init_dist7 = __esm({
  "../../node_modules/.pnpm/giget@1.2.5/node_modules/giget/dist/index.mjs"() {
    "use strict";
    init_giget_BgKdRmJH();
    import_promises6 = require("fs/promises");
    import_node_fs7 = require("fs");
    import_tar2 = __toESM(require_tar(), 1);
    init_defu();
    import_node_stream2 = require("stream");
    import_node_child_process2 = require("child_process");
    import_node_os4 = require("os");
    import_node_util3 = require("util");
    import_proxy2 = __toESM(require_proxy(), 1);
  }
});

// ../../node_modules/.pnpm/ohash@2.0.11/node_modules/ohash/dist/shared/ohash.D__AXeF1.mjs
function serialize(o) {
  return typeof o == "string" ? `'${o}'` : new c().serialize(o);
}
function isEqual(object1, object2) {
  if (object1 === object2) {
    return true;
  }
  if (serialize(object1) === serialize(object2)) {
    return true;
  }
  return false;
}
var c;
var init_ohash_D_AXeF1 = __esm({
  "../../node_modules/.pnpm/ohash@2.0.11/node_modules/ohash/dist/shared/ohash.D__AXeF1.mjs"() {
    "use strict";
    c = /* @__PURE__ */ (function() {
      var _t;
      class o {
        constructor() {
          __privateAdd(this, _t, /* @__PURE__ */ new Map());
        }
        compare(t2, r6) {
          const e3 = typeof t2, n = typeof r6;
          return e3 === "string" && n === "string" ? t2.localeCompare(r6) : e3 === "number" && n === "number" ? t2 - r6 : String.prototype.localeCompare.call(this.serialize(t2, true), this.serialize(r6, true));
        }
        serialize(t2, r6) {
          if (t2 === null) return "null";
          switch (typeof t2) {
            case "string":
              return r6 ? t2 : `'${t2}'`;
            case "bigint":
              return `${t2}n`;
            case "object":
              return this.$object(t2);
            case "function":
              return this.$function(t2);
          }
          return String(t2);
        }
        serializeObject(t2) {
          const r6 = Object.prototype.toString.call(t2);
          if (r6 !== "[object Object]") return this.serializeBuiltInType(r6.length < 10 ? `unknown:${r6}` : r6.slice(8, -1), t2);
          const e3 = t2.constructor, n = e3 === Object || e3 === void 0 ? "" : e3.name;
          if (n !== "" && globalThis[n] === e3) return this.serializeBuiltInType(n, t2);
          if (typeof t2.toJSON == "function") {
            const i2 = t2.toJSON();
            return n + (i2 !== null && typeof i2 == "object" ? this.$object(i2) : `(${this.serialize(i2)})`);
          }
          return this.serializeObjectEntries(n, Object.entries(t2));
        }
        serializeBuiltInType(t2, r6) {
          const e3 = this["$" + t2];
          if (e3) return e3.call(this, r6);
          if (typeof r6?.entries == "function") return this.serializeObjectEntries(t2, r6.entries());
          throw new Error(`Cannot serialize ${t2}`);
        }
        serializeObjectEntries(t2, r6) {
          const e3 = Array.from(r6).sort((i2, a3) => this.compare(i2[0], a3[0]));
          let n = `${t2}{`;
          for (let i2 = 0; i2 < e3.length; i2++) {
            const [a3, l3] = e3[i2];
            n += `${this.serialize(a3, true)}:${this.serialize(l3)}`, i2 < e3.length - 1 && (n += ",");
          }
          return n + "}";
        }
        $object(t2) {
          let r6 = __privateGet(this, _t).get(t2);
          return r6 === void 0 && (__privateGet(this, _t).set(t2, `#${__privateGet(this, _t).size}`), r6 = this.serializeObject(t2), __privateGet(this, _t).set(t2, r6)), r6;
        }
        $function(t2) {
          const r6 = Function.prototype.toString.call(t2);
          return r6.slice(-15) === "[native code] }" ? `${t2.name || ""}()[native]` : `${t2.name}(${t2.length})${r6.replace(/\s*\n\s*/g, "")}`;
        }
        $Array(t2) {
          let r6 = "[";
          for (let e3 = 0; e3 < t2.length; e3++) r6 += this.serialize(t2[e3]), e3 < t2.length - 1 && (r6 += ",");
          return r6 + "]";
        }
        $Date(t2) {
          try {
            return `Date(${t2.toISOString()})`;
          } catch {
            return "Date(null)";
          }
        }
        $ArrayBuffer(t2) {
          return `ArrayBuffer[${new Uint8Array(t2).join(",")}]`;
        }
        $Set(t2) {
          return `Set${this.$Array(Array.from(t2).sort((r6, e3) => this.compare(r6, e3)))}`;
        }
        $Map(t2) {
          return this.serializeObjectEntries("Map", t2.entries());
        }
      }
      _t = new WeakMap();
      for (const s4 of ["Error", "RegExp", "URL"]) o.prototype["$" + s4] = function(t2) {
        return `${s4}(${t2})`;
      };
      for (const s4 of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) o.prototype["$" + s4] = function(t2) {
        return `${s4}[${t2.join(",")}]`;
      };
      for (const s4 of ["BigInt64Array", "BigUint64Array"]) o.prototype["$" + s4] = function(t2) {
        return `${s4}[${t2.join("n,")}${t2.length > 0 ? "n" : ""}]`;
      };
      return o;
    })();
  }
});

// ../../node_modules/.pnpm/ohash@2.0.11/node_modules/ohash/dist/crypto/node/index.mjs
function digest(t2) {
  if (e2) return e2(r5, t2, s3);
  const o = (0, import_node_crypto.createHash)(r5).update(t2);
  return globalThis.process?.versions?.webcontainer ? o.digest().toString(s3) : o.digest(s3);
}
var import_node_crypto, e2, r5, s3;
var init_node = __esm({
  "../../node_modules/.pnpm/ohash@2.0.11/node_modules/ohash/dist/crypto/node/index.mjs"() {
    "use strict";
    import_node_crypto = require("crypto");
    e2 = globalThis.process?.getBuiltinModule?.("crypto")?.hash;
    r5 = "sha256";
    s3 = "base64url";
  }
});

// ../../node_modules/.pnpm/ohash@2.0.11/node_modules/ohash/dist/index.mjs
var dist_exports2 = {};
__export(dist_exports2, {
  digest: () => digest,
  hash: () => hash,
  isEqual: () => isEqual,
  serialize: () => serialize
});
function hash(input) {
  return digest(serialize(input));
}
var init_dist8 = __esm({
  "../../node_modules/.pnpm/ohash@2.0.11/node_modules/ohash/dist/index.mjs"() {
    "use strict";
    init_ohash_D_AXeF1();
    init_ohash_D_AXeF1();
    init_node();
    init_node();
  }
});

// src/bin.ts
var bin_exports = {};
__export(bin_exports, {
  program: () => program
});
module.exports = __toCommonJS(bin_exports);
var import_commander5 = require("commander");

// src/cli/commands/push.command.ts
var import_commander = require("commander");

// src/transpiler.ts
var import_esbuild = require("esbuild");
var import_node_os = __toESM(require("os"), 1);
var import_promises = __toESM(require("fs/promises"), 1);
var import_node_path = __toESM(require("path"), 1);
var import_node_path2 = require("path");
async function loadPromptModule(filePath) {
  const result = await (0, import_esbuild.build)({
    entryPoints: [filePath],
    bundle: true,
    write: false,
    platform: "node",
    format: "esm",
    target: ["node18"],
    sourcemap: false,
    external: [
      // Only Node.js built-ins should be external
      "fs",
      "fs/promises",
      "node:fs",
      "node:fs/promises",
      "readline",
      "node:readline",
      "path",
      "node:path",
      "os",
      "node:os",
      "url",
      "node:url",
      "util",
      "node:util",
      "crypto",
      "node:crypto",
      "events",
      "node:events",
      "stream",
      "node:stream",
      "buffer",
      "node:buffer",
      "process",
      "node:process"
    ]
  });
  const code = result.outputFiles[0].text;
  const tempDir = import_node_os.default.tmpdir();
  const tempFileName = `axiom-ai-prompt-${Date.now()}-${Math.random().toString(36).substring(2)}.mjs`;
  const tempFilePath = import_node_path.default.join(tempDir, tempFileName);
  try {
    await import_promises.default.writeFile(tempFilePath, code, "utf-8");
    const moduleUrl = `file://${tempFilePath}`;
    const module2 = await import(moduleUrl);
    return module2.default || module2;
  } finally {
    try {
      await import_promises.default.unlink(tempFilePath);
    } catch (error) {
      console.warn(`Failed to clean up temporary file ${tempFilePath}:`, error);
    }
  }
}
function convertTypeBoxArgumentsToJsonSchema(arguments_) {
  if (!arguments_ || typeof arguments_ !== "object") {
    return {
      type: "object",
      properties: {},
      required: [],
      additionalProperties: false
    };
  }
  const properties = {};
  const required = [];
  for (const [key, value] of Object.entries(arguments_)) {
    if (value && typeof value === "object" && value.type) {
      properties[key] = {
        type: value.type,
        ...value.description && { description: value.description },
        ...value.enum && { enum: value.enum },
        ...value.items && { items: value.items },
        ...value.properties && { properties: value.properties },
        ...value.required && { required: value.required }
      };
      required.push(key);
    }
  }
  return {
    type: "object",
    properties,
    required,
    additionalProperties: false
  };
}
function extractPromptFromModule(moduleContent, filePath) {
  const fileBaseName = (0, import_node_path2.basename)(filePath, ".ts");
  const defaultId = fileBaseName.toLowerCase().replace(/[^a-z0-9]/g, "-");
  const convertedArguments = convertTypeBoxArgumentsToJsonSchema(moduleContent.arguments);
  const prompt = {
    name: moduleContent.name || "Untitled Prompt",
    slug: moduleContent.slug || defaultId,
    messages: moduleContent.messages || [],
    model: moduleContent.model,
    options: moduleContent.options,
    arguments: convertedArguments,
    id: moduleContent.id || defaultId,
    version: moduleContent.version || "1.0.0",
    // Optional fields from API response
    ...moduleContent.promptId && { promptId: moduleContent.promptId },
    ...moduleContent.description && { description: moduleContent.description }
  };
  if (!prompt.name) {
    throw new Error("Prompt must have a name");
  }
  if (!prompt.slug) {
    throw new Error("Prompt must have a slug");
  }
  if (!Array.isArray(prompt.messages)) {
    throw new Error("Prompt messages must be an array");
  }
  if (!prompt.model) {
    throw new Error("Prompt must have a model");
  }
  return prompt;
}
function transformJsonSchemaToTypeBox(schema) {
  if (schema.type === "string") {
    if (schema.enum && Array.isArray(schema.enum)) {
      const literals = schema.enum.map((value) => `Type.Literal('${value}')`).join(", ");
      const options = schema.description ? `, { description: '${schema.description}' }` : "";
      return `Type.Union([${literals}]${options})`;
    } else {
      const options = schema.description ? `{ description: '${schema.description}' }` : "";
      return `Type.String(${options})`;
    }
  }
  if (schema.type === "number" || schema.type === "integer") {
    const typeMethod = schema.type === "integer" ? "Integer" : "Number";
    const options = schema.description ? `{ description: '${schema.description}' }` : "";
    return `Type.${typeMethod}(${options})`;
  }
  if (schema.type === "boolean") {
    const options = schema.description ? `{ description: '${schema.description}' }` : "";
    return `Type.Boolean(${options})`;
  }
  if (schema.type === "array") {
    const itemsType = schema.items ? transformJsonSchemaToTypeBox(schema.items) : "Type.String()";
    const options = schema.description ? `, { description: '${schema.description}' }` : "";
    return `Type.Array(${itemsType}${options})`;
  }
  if (schema.type === "object") {
    if (schema.properties) {
      const props = Object.entries(schema.properties).map(([key, value]) => {
        const isRequired = schema.required && schema.required.includes(key);
        const propType = transformJsonSchemaToTypeBox(value);
        return `    ${key}: ${isRequired ? propType : `Type.Optional(${propType})`}`;
      }).join(",\n");
      const options = schema.description ? `, { description: '${schema.description}' }` : "";
      return `Type.Object({
${props}
  }${options})`;
    } else {
      const options = schema.description ? `{ description: '${schema.description}' }` : "";
      return `Type.Object({}${options ? `, ${options}` : ""})`;
    }
  }
  return "Type.String()";
}
function generatePromptFileFromApiResponse(apiResponse) {
  const { prompt, version: version2 } = apiResponse;
  const { data: data2, options } = version2;
  let argumentsCode = "{}";
  if (data2.arguments && data2.arguments.properties) {
    const argEntries = Object.entries(data2.arguments.properties).map(([key, schema]) => {
      const isRequired = data2.arguments.required && data2.arguments.required.includes(key);
      const typeCode = transformJsonSchemaToTypeBox(schema);
      return `    ${key}: ${isRequired ? typeCode : `Type.Optional(${typeCode})`}`;
    }).join(",\n");
    if (argEntries) {
      argumentsCode = `{
${argEntries}
  }`;
    }
  }
  return `import { Type } from 'axiom/ai';

export default {
  name: '${prompt.name}',
  slug: '${prompt.slug}',
  description: '${prompt.description || ""}',
  messages: [${data2.messages.map(
    (msg) => `
    {
      role: '${msg.role}',
      content: '${msg.content.replace(/'/g, "\\'")}',
    }`
  ).join(",")}
  ],
  model: '${data2.model || "gpt-4"}',
  options: {
${options ? Object.entries(options).map(([key, value]) => `    ${key}: ${value}`).join(",\n") : ""}
  },
  arguments: ${argumentsCode},
  version: '${version2.version}',
  promptId: '${prompt.promptId}',
};
`;
}

// src/cli/commands/push.command.ts
var import_promises2 = __toESM(require("fs/promises"), 1);
var import_node_readline = __toESM(require("readline"), 1);
async function askConfirmation(message) {
  const rl = import_node_readline.default.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return new Promise((resolve5) => {
    rl.question(`${message} (y/N): `, (answer) => {
      rl.close();
      resolve5(answer.toLowerCase() === "y" || answer.toLowerCase() === "yes");
    });
  });
}
var loadPushCommand = (program2) => {
  const push = new import_commander.Command("push").description("Push a new version of an object").argument(
    "<object>",
    "The object to push, could be a prompt, en eval, a monitor, a dashboard, etc."
  ).option("--prod", "Adds the production tag to the prompt").option("--yes", "Automatically confirm overwriting the file with server response").action(async (filePath, options) => {
    let content = null;
    if (!filePath.endsWith(".prompt.ts")) {
      console.error("Prompt files must end with .prompt.ts");
      process.exit(1);
    }
    try {
      const moduleContent = await loadPromptModule(filePath);
      const promptData = extractPromptFromModule(moduleContent, filePath);
      content = promptData;
      console.log(`Transpiled prompt: ${promptData.name} (${promptData.slug})`);
    } catch (error) {
      console.error("Failed to transpile prompt file:", error);
      process.exit(1);
    }
    if (!content) {
      console.error("No content found");
      process.exit(1);
    }
    let shouldProceed = options.yes;
    if (!shouldProceed) {
      shouldProceed = await askConfirmation(
        `This will push "${content.name}" to Axiom and overwrite ${filePath}, are you sure you want to continue?`
      );
    }
    if (!shouldProceed) {
      console.log("Push operation cancelled.");
      process.exit(0);
    }
    try {
      const response = await fetch(`${process.env.AXIOM_URL}/v1/prompts`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${process.env.AXIOM_TOKEN}`,
          "Content-Type": "application/json",
          "x-axiom-client": "axiom-ai-cli",
          "x-axiom-check": "good"
        },
        body: JSON.stringify({
          ...content,
          tags: options.yes ? ["production"] : []
        })
      });
      if (!response.ok) {
        try {
          const errorText = await response.clone().json();
          console.error(`Failed to fetch prompt: ${response.status} ${response.statusText}`);
          console.error(JSON.stringify(errorText, null, 2));
          process.exit(1);
        } catch (_error) {
          const errorText = await response.clone().text();
          console.error(`Failed to fetch prompt: ${response.status} ${response.statusText}`);
          console.error(errorText);
          process.exit(1);
        }
      }
      const apiResponse = await response.json();
      console.log(
        `Successfully pushed prompt: ${apiResponse.prompt.name} (${apiResponse.prompt.slug})`
      );
      console.log(`Version: ${apiResponse.version.version}`);
      const updatedTsContent = generatePromptFileFromApiResponse(apiResponse);
      await import_promises2.default.writeFile(filePath, updatedTsContent, "utf-8");
      console.log(`Successfully updated ${filePath}`);
    } catch (error) {
      console.error("Failed to push prompt:", error);
      process.exit(1);
    }
  });
  program2.addCommand(push);
};

// src/cli/commands/pull.command.ts
var import_commander2 = require("commander");
var fs3 = __toESM(require("fs/promises"), 1);
var path2 = __toESM(require("path"), 1);
var loadPullCommand = (program2) => {
  const pull = new import_commander2.Command("pull").description("Pull a version of an object").argument(
    "<slug>",
    "The object to pull, could be a prompt, en eval, a monitor, a dashboard, etc."
  ).option("--version <version>", "The version to pull, default: latest", "latest").option("--output <path>", "Output file path (optional, defaults to <slug>.prompt.ts)").action(async (slug, options) => {
    try {
      console.log(`Pulling prompt: ${slug} (version: ${options.version})`);
      const url = `${process.env.AXIOM_URL}/v1/prompts/${slug}`;
      const response = await fetch(url, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${process.env.AXIOM_TOKEN}`,
          "Content-Type": "application/json",
          "x-axiom-client": "axiom-ai-cli",
          "x-axiom-check": "good"
        }
      });
      if (!response.ok) {
        try {
          const errorText = await response.clone().json();
          console.error(`Failed to fetch prompt: ${response.status} ${response.statusText}`);
          console.error(JSON.stringify(errorText, null, 2));
          process.exit(1);
        } catch (_error) {
          const errorText = await response.clone().text();
          console.error(`Failed to fetch prompt: ${response.status} ${response.statusText}`);
          console.error(errorText);
          process.exit(1);
        }
      }
      const apiResponse = await response.json();
      const tsContent = generatePromptFileFromApiResponse(apiResponse);
      const outputPath = options.output || `${slug}.prompt.ts`;
      const fullPath = path2.resolve(outputPath);
      await fs3.writeFile(fullPath, tsContent, "utf-8");
      console.log(`Successfully generated prompt file: ${fullPath}`);
      console.log(`Prompt: ${apiResponse.prompt.name} (${apiResponse.prompt.slug})`);
      console.log(`Version: ${apiResponse.version.version}`);
    } catch (error) {
      console.error("Failed to pull prompt:", error);
      process.exit(1);
    }
  });
  program2.addCommand(pull);
};

// src/cli/commands/eval.command.ts
var import_commander3 = require("commander");

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js
var f = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
var h = Object.entries(f);
function a(n) {
  return String(n);
}
a.open = "";
a.close = "";
function C(n = false) {
  let e3 = typeof process != "undefined" ? process : void 0, i2 = (e3 == null ? void 0 : e3.env) || {}, g4 = (e3 == null ? void 0 : e3.argv) || [];
  return !("NO_COLOR" in i2 || g4.includes("--no-color")) && ("FORCE_COLOR" in i2 || g4.includes("--color") || (e3 == null ? void 0 : e3.platform) === "win32" || n && i2.TERM !== "dumb" || "CI" in i2) || typeof window != "undefined" && !!window.chrome;
}
function p(n = false) {
  let e3 = C(n), i2 = (r6, t2, c2, o) => {
    let l3 = "", s4 = 0;
    do
      l3 += r6.substring(s4, o) + c2, s4 = o + t2.length, o = r6.indexOf(t2, s4);
    while (~o);
    return l3 + r6.substring(s4);
  }, g4 = (r6, t2, c2 = r6) => {
    let o = (l3) => {
      let s4 = String(l3), b6 = s4.indexOf(t2, r6.length);
      return ~b6 ? r6 + i2(s4, t2, c2, b6) + t2 : r6 + s4 + t2;
    };
    return o.open = r6, o.close = t2, o;
  }, u4 = {
    isColorSupported: e3
  }, d4 = (r6) => `\x1B[${r6}m`;
  for (let [r6, t2] of h)
    u4[r6] = e3 ? g4(
      d4(t2[0]),
      d4(t2[1]),
      t2[2]
    ) : a;
  return u4;
}

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js
var import_tty = require("tty");
var r = process.env.FORCE_TTY !== void 0 || (0, import_tty.isatty)(1);
var u = p(r);

// src/evals/run-vitest.ts
var import_node = require("vitest/node");

// src/evals/context/global-flags.ts
var GLOBAL_OVERRIDES_SYMBOL = Symbol.for("axiom.global_flag_overrides");
function getRoot() {
  return globalThis[GLOBAL_OVERRIDES_SYMBOL] ?? {};
}
function setRoot(val) {
  globalThis[GLOBAL_OVERRIDES_SYMBOL] = val;
}
function setGlobalFlagOverrides(overrides2) {
  setRoot(overrides2);
}
function getGlobalFlagOverrides() {
  return getRoot();
}

// src/evals/context/storage.ts
var import_api9 = require("@opentelemetry/api");

// src/evals/context/manager.ts
var import_node_module = require("module");
var import_meta = {};
var CONTEXT_MANAGER_SYMBOL = Symbol.for("axiom.context_manager");
function getGlobalContextManager() {
  return globalThis[CONTEXT_MANAGER_SYMBOL];
}
function setGlobalContextManager(manager) {
  globalThis[CONTEXT_MANAGER_SYMBOL] = manager;
}
var isNodeJS = typeof process !== "undefined" && !!process.versions?.node;
function getContextManager() {
  const existing = getGlobalContextManager();
  if (existing) return existing;
  let manager;
  if (isNodeJS) {
    try {
      let AsyncLocalStorage;
      const req = (0, import_node_module.createRequire)(import_meta.url);
      try {
        AsyncLocalStorage = req("node:async_hooks").AsyncLocalStorage;
      } catch {
        AsyncLocalStorage = req("async_hooks").AsyncLocalStorage;
      }
      manager = new AsyncLocalStorage();
    } catch (error) {
      console.warn("AsyncLocalStorage not available, using fallback context manager:", error);
      manager = createFallbackManager();
    }
  } else {
    console.warn("AsyncLocalStorage not available, using fallback context manager");
    manager = createFallbackManager();
  }
  setGlobalContextManager(manager);
  return manager;
}
function createFallbackManager() {
  let currentContext = null;
  return {
    getStore: () => currentContext,
    run: (value, fn2) => {
      const prev = currentContext;
      currentContext = value;
      try {
        return fn2();
      } finally {
        currentContext = prev;
      }
    }
  };
}
function createAsyncHook(_name) {
  return {
    get() {
      const manager = getContextManager();
      if (manager.getStore) {
        return manager.getStore();
      }
      return void 0;
    },
    run(value, fn2) {
      const manager = getContextManager();
      return manager.run(value, fn2);
    }
  };
}

// src/validate-flags.ts
var import_zod3 = require("zod");

// src/cli/utils/format-zod-errors.ts
var import_zod = require("zod");

// src/util/dot-path.ts
var import_zod2 = require("zod");
function flattenObject(obj, prefix = "") {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const newKey = prefix ? `${prefix}.${key}` : key;
    if (value && typeof value === "object" && !Array.isArray(value)) {
      Object.assign(result, flattenObject(value, newKey));
    } else {
      result[newKey] = value;
    }
  }
  return result;
}

// src/app-scope.ts
var import_api8 = require("@opentelemetry/api");
var import_zod4 = require("zod");

// src/otel/utils/to-otel-attribute.ts
var import_api = require("@opentelemetry/api");

// src/otel/withSpan.ts
var import_api6 = require("@opentelemetry/api");

// src/otel/utils/wrapperUtils.ts
var import_api5 = require("@opentelemetry/api");

// src/otel/semconv/attributes.ts
var import_semantic_conventions = require("@opentelemetry/semantic-conventions");
var import_incubating = require("@opentelemetry/semantic-conventions/incubating");

// src/otel/startActiveSpan.ts
var import_api2 = require("@opentelemetry/api");

// src/otel/initAxiomAI.ts
var import_api4 = require("@opentelemetry/api");

// package.json
var package_default = {
  name: "axiom",
  version: "0.22.0",
  type: "module",
  author: "Axiom, Inc.",
  contributors: [
    "Islam Shehata <islam@axiom.co>",
    "Chris Ehrlich <chris@axiom.co>",
    "Gabriel de Andrade <gabriel@axiom.co>"
  ],
  scripts: {
    dev: "tsup --watch",
    build: "tsup && chmod +x dist/bin.js",
    format: "prettier --write .",
    "format:check": "prettier --check .",
    lint: "eslint './**/*.{js,ts}'",
    typecheck: "tsc --noEmit",
    test: "vitest run",
    "test:watch": "vitest --watch",
    publint: "npx publint"
  },
  types: "./dist/index.d.ts",
  main: "./dist/index.cjs",
  module: "./dist/index.js",
  bin: {
    axiom: "./dist/bin.js"
  },
  exports: {
    "./ai": {
      import: {
        types: "./dist/index.d.ts",
        default: "./dist/index.js"
      },
      require: {
        types: "./dist/index.d.cts",
        default: "./dist/index.cjs"
      }
    },
    "./ai/evals": {
      import: {
        types: "./dist/evals.d.ts",
        default: "./dist/evals.js"
      },
      require: {
        types: "./dist/evals.d.cts",
        default: "./dist/evals.cjs"
      }
    },
    "./ai/config": {
      import: {
        types: "./dist/config.d.ts",
        default: "./dist/config.js"
      },
      require: {
        types: "./dist/config.d.cts",
        default: "./dist/config.cjs"
      }
    }
  },
  keywords: [
    "axiom",
    "logging",
    "ai",
    "otel",
    "opentelemetry"
  ],
  repository: {
    type: "git",
    url: "git+https://github.com/axiomhq/ai.git",
    directory: "packages/ai"
  },
  license: "MIT",
  dependencies: {
    "@next/env": "^15.4.2",
    "@opentelemetry/auto-instrumentations-node": "^0.60.1",
    "@opentelemetry/context-async-hooks": "^2.0.1",
    "@opentelemetry/exporter-trace-otlp-http": "^0.202.0",
    "@opentelemetry/resources": "^2.0.1",
    "@opentelemetry/sdk-trace-node": "^2.0.1",
    "@opentelemetry/semantic-conventions": "^1.37.0",
    "@sinclair/typebox": "^0.34.37",
    commander: "^14.0.0",
    handlebars: "^4.7.8",
    nanoid: "^5.1.5"
  },
  peerDependencies: {
    "@opentelemetry/api": "^1.9.0",
    zod: "^3.25.0 || ^4.0.0"
  },
  devDependencies: {
    "@ai-sdk/anthropicv1": "npm:@ai-sdk/anthropic@^1.2.12",
    "@ai-sdk/anthropicv2": "npm:@ai-sdk/anthropic@2.0.0-beta.9",
    "@ai-sdk/openaiv1": "npm:@ai-sdk/openai@^1.3.23",
    "@ai-sdk/openaiv2": "npm:@ai-sdk/openai@2.0.0-beta.12",
    "@ai-sdk/providerv1": "npm:@ai-sdk/provider@^1.1.3",
    "@ai-sdk/providerv2": "npm:@ai-sdk/provider@2.0.0-beta.1",
    "@opentelemetry/api": "^1.9.0",
    "@opentelemetry/core": "^2.0.1",
    "@opentelemetry/sdk-trace-base": "^2.0.1",
    "@opentelemetry/sdk-trace-node": "^2.0.1",
    "@repo/eslint-config": "workspace:*",
    "@types/node": "^22.15.29",
    "@vitest/coverage-v8": "^3.2.4",
    aiv4: "npm:ai@^4.3.19",
    aiv5: "npm:ai@^5.0.0",
    c12: "^2.0.4",
    defu: "^6.1.4",
    esbuild: "^0.25.8",
    eslint: "catalog:",
    prettier: "catalog:",
    tinyrainbow: "^2.0.0",
    tsup: "catalog:",
    typescript: "catalog:",
    vitest: "catalog:",
    zod: "catalog:"
  },
  files: [
    "dist"
  ],
  packageManager: "pnpm@10.16.1"
};

// src/otel/utils/redaction.ts
var import_api3 = require("@opentelemetry/api");
var AXIOM_AI_REDACTION_KEY = Symbol.for("__axiom_ai_redaction__");

// src/otel/initAxiomAI.ts
var AXIOM_AI_SCOPE_KEY = Symbol.for("__axiom_ai_scope__");
function extractTracerScope(tracer) {
  const tracerAny = tracer;
  const name = tracerAny._instrumentationScope?.name || tracerAny.instrumentationLibrary?.name || package_default.name;
  const version2 = tracerAny._instrumentationScope?.version || tracerAny.instrumentationLibrary?.version || package_default.version;
  return { name, version: version2 };
}
function initAxiomAI(config) {
  const newScope = extractTracerScope(config.tracer);
  const existingScope = globalThis[AXIOM_AI_SCOPE_KEY];
  if (existingScope && existingScope.name === newScope.name && existingScope.version === newScope.version) {
    return;
  }
  if (existingScope) {
    console.warn(
      `[AxiomAI] initAxiomAI() called multiple times with different scopes. Previous: ${existingScope.name}@${existingScope.version}, New: ${newScope.name}@${newScope.version}`
    );
  }
  globalThis[AXIOM_AI_SCOPE_KEY] = newScope;
  if (config.redactionPolicy) {
    globalThis[AXIOM_AI_REDACTION_KEY] = config.redactionPolicy;
  }
}

// src/otel/middleware.ts
var import_api7 = require("@opentelemetry/api");

// src/evals/context/storage.ts
var CONFIG_SCOPE_SYMBOL = Symbol.for("axiom.eval.configScope");
function getGlobalConfigScope() {
  return globalThis[CONFIG_SCOPE_SYMBOL];
}
var AXIOM_CONFIG_SYMBOL = Symbol.for("axiom.eval.config");
function getAxiomConfig() {
  return globalThis[AXIOM_CONFIG_SYMBOL];
}
function setAxiomConfig(config) {
  globalThis[AXIOM_CONFIG_SYMBOL] = config;
}
var EVAL_CONTEXT = createAsyncHook("eval-context");
function getEvalContext() {
  const ctx = EVAL_CONTEXT.get();
  if (!ctx) {
    return {
      flags: {},
      facts: {},
      pickedFlags: void 0,
      outOfScopeFlags: void 0
    };
  }
  return {
    flags: ctx.flags,
    facts: ctx.facts,
    pickedFlags: ctx.pickedFlags,
    outOfScopeFlags: ctx.outOfScopeFlags,
    parent: ctx.parent,
    overrides: ctx.overrides,
    accessedFlagKeys: ctx.accessedFlagKeys
  };
}
function putOnSpan(kind, key, value) {
  const span = import_api9.trace.getActiveSpan();
  if (span?.isRecording()) {
    span.setAttributes({ [`${kind}.${key}`]: value });
  }
}
function withEvalContext(options = {}, fn2) {
  const { initialFlags = {}, pickedFlags = [] } = options;
  return EVAL_CONTEXT.run(
    {
      flags: { ...initialFlags },
      facts: {},
      pickedFlags,
      outOfScopeFlags: [],
      accessedFlagKeys: []
    },
    fn2
  );
}
function getConfigScope() {
  const current2 = EVAL_CONTEXT.get();
  return current2?.configScope ?? getGlobalConfigScope();
}

// src/config/resolver.ts
function resolveAxiomConnection(config) {
  return {
    url: config.eval.url,
    token: config.eval.token,
    dataset: config.eval.dataset
  };
}

// src/evals/eval.service.ts
var findEvaluationCases = async (evalId, config) => {
  try {
    const { dataset, url, token } = resolveAxiomConnection(config);
    const apl = `['${dataset}'] | where trace_id == "${evalId}" | order by _time`;
    const headers = new Headers({
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json"
    });
    const resp = await fetch(`${url}/v1/datasets/_apl?format=legacy`, {
      headers,
      method: "POST",
      body: JSON.stringify({ apl })
    });
    const payload = await resp.json();
    if (!resp.ok) {
      console.log(payload);
      return void 0;
    }
    if (payload.matches.length) {
      return buildSpanTree(payload.matches);
    }
  } catch (err) {
    console.log(err);
    return void 0;
  }
};
var mapSpanToEval = (span) => {
  const flagConfigRaw = span.data.attributes["eval.config.flags"] ?? span.data.attributes.custom["eval.config.flags"];
  return {
    id: span.data.attributes.custom["eval.id"],
    name: span.data.attributes.custom["eval.name"],
    type: span.data.attributes.custom["eval.type"],
    version: span.data.attributes.custom["eval.version"],
    collection: {
      name: span.data.attributes.custom["eval.collection.name"],
      size: span.data.attributes.custom["eval.collection.size"]
    },
    baseline: {
      id: span.data.attributes.custom["eval.baseline.id"],
      name: span.data.attributes.custom["eval.baseline.name"]
    },
    prompt: {
      model: span.data.attributes.custom["eval.prompt.model"],
      params: span.data.attributes.custom["eval.prompt.params"]
    },
    duration: span.data.duration,
    status: span.data.status.code,
    traceId: span.data.trace_id,
    runAt: span._time,
    tags: span.data.attributes.custom["eval.tags"].length ? JSON.parse(span.data.attributes.custom["eval.tags"]) : [],
    user: {
      name: span.data.attributes.custom["eval.user.name"],
      email: span.data.attributes.custom["eval.user.email"]
    },
    cases: [],
    flagConfig: flagConfigRaw ? JSON.parse(flagConfigRaw) : void 0
  };
};
var mapSpanToCase = (item) => {
  const data2 = item.data;
  const d4 = data2.duration;
  let duration = "-";
  if (d4.endsWith("s")) {
    duration = `${Number(d4.replace("s", "")).toFixed(2)}s`;
  } else {
    duration = d4;
  }
  const runtimeFlagsRaw = data2.attributes.custom["eval.case.config.runtime_flags"];
  return {
    index: data2.attributes.custom["eval.case.index"],
    input: data2.attributes.custom["eval.case.input"],
    output: data2.attributes.custom["eval.case.output"],
    expected: data2.attributes.custom["eval.case.expected"],
    duration,
    status: data2.status.code,
    scores: data2.attributes.custom["eval.case.scores"] ? JSON.parse(data2.attributes.custom["eval.case.scores"]) : {},
    runAt: item._time,
    spanId: data2.span_id,
    traceId: data2.trace_id,
    runtimeFlags: runtimeFlagsRaw ? JSON.parse(runtimeFlagsRaw) : void 0
  };
};
var buildSpanTree = (spans) => {
  if (!spans.length) {
    return null;
  }
  const evalSpan = spans.find((span) => span.data.attributes.gen_ai.operation.name === "eval");
  if (!evalSpan) {
    return null;
  }
  const rootSpan = mapSpanToEval(evalSpan);
  const caseSpans = spans.filter((span) => span.data.name.startsWith("case"));
  for (const caseSpan of caseSpans) {
    const caseData = mapSpanToCase(caseSpan);
    const taskSpans = spans.filter(
      (span) => span.data.name.startsWith("task") && span.data.parent_span_id === caseSpan.data.span_id
    );
    if (taskSpans.length > 0) {
      const taskSpan = taskSpans[0];
      const chatSpans = spans.filter(
        (span) => span.data.name.startsWith("chat") && span.data.parent_span_id === taskSpan.data.span_id
      );
      const chatData = chatSpans.map((chatSpan) => ({
        operation: chatSpan.data.attributes.custom?.operation || "",
        capability: chatSpan.data.attributes.custom?.capability || "",
        step: chatSpan.data.attributes.custom?.step || "",
        request: {
          max_token: chatSpan.data.attributes.custom?.["request.max_token"] || "",
          model: chatSpan.data.attributes.custom?.["request.model"] || "",
          temperature: chatSpan.data.attributes.custom?.["request.temperature"] || 0
        },
        response: {
          finish_reasons: chatSpan.data.attributes.custom?.["response.finish_reasons"] || ""
        },
        usage: {
          input_tokens: chatSpan.data.attributes.gen_ai?.usage?.input_tokens || 0,
          output_tokens: chatSpan.data.attributes.gen_ai?.usage?.output_tokens || 0
        }
      }));
      const taskData = {
        name: taskSpan.data.name,
        output: taskSpan.data.attributes.custom?.output || "",
        trial: taskSpan.data.attributes.custom?.trial || 0,
        type: taskSpan.data.attributes.custom?.type || "",
        error: taskSpan.data.attributes.custom?.error,
        chat: chatData[0] || {
          operation: "",
          capability: "",
          step: "",
          request: { max_token: "", model: "", temperature: 0 },
          response: { finish_reasons: "" },
          usage: { input_tokens: 0, output_tokens: 0 }
        }
      };
      caseData.task = taskData;
    }
    const scoreSpans = spans.filter(
      (span) => span.data.attributes.gen_ai.operation.name === "eval.score" && span.data.parent_span_id === caseSpan.data.span_id
    );
    caseData.scores = {};
    scoreSpans.forEach((score) => {
      const name = score.data.attributes.custom["eval.score.name"];
      caseData.scores[name] = {
        name,
        value: score.data.attributes.custom["eval.score.value"],
        metadata: {
          error: score.data.attributes.error
        }
      };
    });
    rootSpan.cases.push(caseData);
  }
  rootSpan.cases.sort((a3, b6) => a3.index - b6.index);
  return rootSpan;
};

// src/util/deep-equal.ts
function deepEqual(data2, other) {
  if (data2 === other) {
    return true;
  }
  if (Object.is(data2, other)) {
    return true;
  }
  if (typeof data2 !== "object" || typeof other !== "object") {
    return false;
  }
  if (data2 === null || other === null) {
    return false;
  }
  if (Object.getPrototypeOf(data2) !== Object.getPrototypeOf(other)) {
    return false;
  }
  if (Array.isArray(data2)) {
    return isDeepEqualArrays(data2, other);
  }
  if (data2 instanceof Map) {
    return isDeepEqualMaps(data2, other);
  }
  if (data2 instanceof Set) {
    return isDeepEqualSets(data2, other);
  }
  if (data2 instanceof Date) {
    return data2.getTime() === other.getTime();
  }
  if (data2 instanceof RegExp) {
    return data2.toString() === other.toString();
  }
  if (Object.keys(data2).length !== Object.keys(other).length) {
    return false;
  }
  for (const [key, value] of Object.entries(data2)) {
    if (!(key in other)) {
      return false;
    }
    if (!deepEqual(
      value,
      // @ts-expect-error [ts7053] - We already checked that `other` has `key`
      other[key]
    )) {
      return false;
    }
  }
  return true;
}
function isDeepEqualArrays(data2, other) {
  if (data2.length !== other.length) {
    return false;
  }
  for (const [index, item] of data2.entries()) {
    if (!deepEqual(item, other[index])) {
      return false;
    }
  }
  return true;
}
function isDeepEqualMaps(data2, other) {
  if (data2.size !== other.size) {
    return false;
  }
  for (const [key, value] of data2.entries()) {
    if (!other.has(key)) {
      return false;
    }
    if (!deepEqual(value, other.get(key))) {
      return false;
    }
  }
  return true;
}
function isDeepEqualSets(data2, other) {
  if (data2.size !== other.size) {
    return false;
  }
  const otherCopy = [...other];
  for (const dataItem of data2) {
    let isFound = false;
    for (const [index, otherItem] of otherCopy.entries()) {
      if (deepEqual(dataItem, otherItem)) {
        isFound = true;
        otherCopy.splice(index, 1);
        break;
      }
    }
    if (!isFound) {
      return false;
    }
  }
  return true;
}

// src/evals/reporter.console-utils.ts
function truncate(str, max) {
  return str.length > max ? str.slice(0, max) + "\u2026" : str;
}
function stringify(value) {
  try {
    if (typeof value === "string") return value;
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}
function printEvalNameAndFileName(testSuite, meta) {
  const cwd2 = process.cwd();
  console.log(
    " ",
    u.bgCyan(u.black(` ${testSuite.project.name} `)),
    u.bgBlue(u.black(` ${meta.evaluation.name}-${meta.evaluation.version} `)),
    u.dim(`(${testSuite.children.size} cases)`)
  );
  console.log(" ", u.dim(testSuite.module.moduleId.replace(cwd2, "")));
}
function printBaselineNameAndVersion(testMeta) {
  if (testMeta.evaluation.baseline) {
    console.log(
      " ",
      " baseline ",
      u.bgMagenta(
        u.black(` ${testMeta.evaluation.baseline.name}-${testMeta.evaluation.baseline.version} `)
      )
    );
  } else {
    console.log(" ", u.bgWhite(u.blackBright(" baseline: ")), "none");
  }
  console.log("");
}
function printRuntimeFlags(testMeta) {
  if (testMeta.case.runtimeFlags && Object.keys(testMeta.case.runtimeFlags).length > 0) {
    const entries = Object.entries(testMeta.case.runtimeFlags);
    console.log("   ", u.dim("runtime flags"));
    for (const [k4, v4] of entries) {
      switch (v4.kind) {
        case "replaced": {
          const valText = truncate(stringify(v4.value), 80);
          const defText = truncate(stringify(v4.default), 80);
          console.log("     ", `${k4}: ${valText} (default: ${defText})`);
          break;
        }
        case "introduced": {
          const valText = truncate(stringify(v4.value), 80);
          console.log("     ", `${k4}: ${valText} (no default)`);
          break;
        }
      }
    }
  }
}
function printTestCaseCountStartDuration(testSuite, startTime, duration) {
  console.log(" ");
  console.log(" ", u.dim("Cases"), testSuite.children.size);
  console.log(" ", u.dim("Start at"), new Date(startTime).toTimeString());
  console.log(" ", u.dim("Duration"), `${duration}s`);
}
function printTestCaseSuccessOrFailed(testMeta, ok) {
  const index = testMeta.case.index;
  if (ok) {
    console.log(" ", u.yellow(` \u2714 case ${index}:`));
  } else {
    console.log(" ", u.red(` \u2716 case ${index}: failed`));
    for (const e3 of testMeta.case.errors ?? []) {
      console.log("", e3.message);
    }
  }
}
function printTestCaseScores(testMeta, baseline) {
  const index = testMeta.case.index;
  Object.keys(testMeta.case.scores).forEach((k4) => {
    const v4 = testMeta.case.scores[k4].score ? testMeta.case.scores[k4].score : 0;
    const scoreValue = Number(v4 * 100).toFixed(2) + "%";
    if (baseline?.cases[index]?.scores[k4]) {
      const baselineScoreValue = baseline.cases[index].scores[k4].value;
      const diff = v4 - baselineScoreValue;
      const diffText = Number(diff * 100).toFixed(2) + "%";
      const blScoreText = Number(baselineScoreValue * 100).toFixed(2) + "%";
      console.log(
        "   ",
        k4,
        u.magentaBright(blScoreText),
        "->",
        u.blueBright(scoreValue),
        diff > 0 ? u.green("+" + diffText) : diff < 0 ? u.red(diffText) : diffText
      );
    } else {
      console.log("   ", k4, u.blueBright(scoreValue));
    }
    return [k4, scoreValue];
  });
}
function printOutOfScopeFlags(testMeta) {
  if (testMeta.case.outOfScopeFlags && testMeta.case.outOfScopeFlags.length > 0) {
    const pickedFlagsText = testMeta.case.pickedFlags ? `(picked: ${testMeta.case.pickedFlags.map((f3) => `'${f3}'`).join(", ")})` : "(none)";
    console.log("   ", u.yellow(`\u26A0 Out-of-scope flags: ${pickedFlagsText}`));
    testMeta.case.outOfScopeFlags.forEach((flag) => {
      const timeStr = new Date(flag.accessedAt).toLocaleTimeString();
      console.log("     ", `${flag.flagPath} (at ${timeStr})`);
      if (flag.stackTrace && flag.stackTrace.length > 0) {
        flag.stackTrace.forEach((frame, i2) => {
          const prefix = i2 === flag.stackTrace.length - 1 ? " \u2514\u2500" : " \u251C\u2500";
          console.log("     ", u.dim(`${prefix} ${frame}`));
        });
      }
    });
  }
}
function printConfigHeader() {
  console.log("");
  console.log(" ", u.bgWhite(u.blackBright(" Config ")));
}
function maybePrintFlags(configEnd) {
  const defaults2 = configEnd?.flags ?? {};
  const overrides2 = configEnd?.overrides ?? {};
  const defaultKeys = Object.keys(defaults2);
  const overrideKeys = Object.keys(overrides2);
  const allKeys = Array.from(/* @__PURE__ */ new Set([...defaultKeys, ...overrideKeys])).sort();
  if (allKeys.length === 0) {
    return;
  }
  for (const key of allKeys) {
    const hasDefault = key in defaults2;
    const hasOverride = key in overrides2;
    if (hasDefault && hasOverride) {
      const defVal = defaults2[key];
      const ovVal = overrides2[key];
      const changed = !deepEqual(ovVal, defVal);
      const ovText = truncate(stringify(ovVal), 80);
      const defText = truncate(stringify(defVal), 80);
      if (changed) {
        console.log(
          "   ",
          `${key}: ${ovText} ${u.dim(`(overridden by CLI, original: ${defText})`)}`
        );
      } else {
        console.log("   ", `${key}: ${defText}`);
      }
    } else if (hasOverride) {
      const ovText = truncate(stringify(overrides2[key]), 80);
      console.log("   ", `${key}: ${ovText} ${u.dim("(added by CLI)")}`);
    } else if (hasDefault) {
      const defText = truncate(stringify(defaults2[key]), 80);
      console.log("   ", `${key}: ${defText}`);
    }
  }
  console.log("");
}
var reporterDate = (d4) => {
  const date = d4.toISOString().slice(0, 10);
  const hours = d4.getUTCHours().toString().padStart(2, "0");
  const minutes = d4.getUTCMinutes().toString().padStart(2, "0");
  return `${date}, ${hours}:${minutes} UTC`;
};
function printGlobalFlagOverrides(overrides2, defaults2) {
  if (Object.keys(overrides2).length === 0) {
    console.log("");
    console.log(u.dim("Flag overrides: (none)"));
    console.log("");
    return;
  }
  console.log("");
  console.log("Flag overrides:");
  for (const [key, value] of Object.entries(overrides2)) {
    const defaultValue = defaults2[key];
    const valueStr = JSON.stringify(value);
    const defaultStr = defaultValue !== void 0 ? JSON.stringify(defaultValue) : "none";
    console.log(`  \u2022 ${key}: ${valueStr} ${u.dim(`(default: ${defaultStr})`)}`);
  }
  console.log("");
}
function printSuiteBox({
  suite,
  scorerAverages,
  calculateBaselineScorerAverage,
  flagDiff
}) {
  const filename = suite.file.split("/").pop();
  console.log("\u250C\u2500");
  console.log(`\u2502  ${u.blue(suite.name)} ${u.gray(`(${filename})`)}`);
  console.log("\u251C\u2500");
  const scorerNames = Object.keys(scorerAverages);
  const maxNameLength = Math.max(...scorerNames.map((name) => name.length));
  for (const scorerName of scorerNames) {
    const avg = scorerAverages[scorerName];
    const paddedName = scorerName.padEnd(maxNameLength);
    if (suite.baseline) {
      const baselineAvg = calculateBaselineScorerAverage(suite.baseline, scorerName);
      if (baselineAvg !== null) {
        const currentPercent = (avg * 100).toFixed(2) + "%";
        const baselinePercent = (baselineAvg * 100).toFixed(2) + "%";
        const diff = avg - baselineAvg;
        const diffText = (diff >= 0 ? "+" : "") + (diff * 100).toFixed(2) + "%";
        const diffColor = diff > 0 ? u.green : diff < 0 ? u.red : u.dim;
        const paddedBaseline = baselinePercent.padStart(7);
        const paddedCurrent = currentPercent.padStart(7);
        const paddedDiff = diffText.padStart(8);
        console.log(
          `\u2502  ${paddedName}  ${u.blueBright(paddedBaseline)} \u2192 ${u.magentaBright(paddedCurrent)}  (${diffColor(paddedDiff)})`
        );
      } else {
        const currentPercent = (avg * 100).toFixed(2) + "%";
        console.log(`\u2502   \u2022 ${paddedName}  ${currentPercent}`);
      }
    } else {
      const currentPercent = (avg * 100).toFixed(2) + "%";
      console.log(`\u2502   \u2022 ${paddedName}  ${currentPercent}`);
    }
  }
  console.log("\u251C\u2500");
  if (suite.baseline) {
    const baselineTimestamp = suite.baseline.runAt ? reporterDate(new Date(suite.baseline.runAt)) : "unknown time";
    console.log(
      `\u2502  Baseline: ${suite.baseline.name}-${suite.baseline.version} ${u.gray(`(${baselineTimestamp})`)}`
    );
  } else {
    console.log(`\u2502  Baseline: ${u.gray("(none)")}`);
  }
  if (suite.baseline) {
    const hasConfigChanges = flagDiff.length > 0;
    console.log("\u2502  Config changes:", hasConfigChanges ? "" : u.gray("(none)"));
    if (hasConfigChanges) {
      for (const { flag, current: current2, baseline } of flagDiff) {
        console.log(
          `\u2502   \u2022 ${flag}: ${current2 ?? "<not set>"} ${u.gray(`(baseline: ${baseline ?? "<not set>"})`)}`
        );
      }
    }
  }
  if (suite.outOfScopeFlags && suite.outOfScopeFlags.length > 0) {
    const pickedFlagsText = suite.configFlags && suite.configFlags.length > 0 ? suite.configFlags.map((f3) => `'${f3}'`).join(", ") : "none";
    console.log("\u2502");
    console.log(
      `\u2502  ${u.yellow("\u26A0 Out-of-scope flags")} ${u.gray(`(picked: ${pickedFlagsText})`)}:`
    );
    for (const flag of suite.outOfScopeFlags) {
      const lastStackTraceFrame = flag.stackTrace[0];
      const lastStackTraceFnName = lastStackTraceFrame.split(" ").shift();
      const lastStackTraceFile = lastStackTraceFrame.split("/").pop()?.slice(0, -1);
      console.log(
        `\u2502   \u2022 ${flag.flagPath} ${u.gray(`at ${lastStackTraceFnName} (${lastStackTraceFile})`)}`
      );
    }
  }
  console.log("\u2514\u2500");
}
function printFinalReport({
  suiteData,
  calculateScorerAverages,
  calculateBaselineScorerAverage,
  calculateFlagDiff
}) {
  console.log("");
  console.log(u.bgBlue(u.white(" FINAL EVALUATION REPORT ")));
  console.log("");
  for (const suite of suiteData) {
    const scorerAverages = calculateScorerAverages(suite);
    const flagDiff = suite.baseline ? calculateFlagDiff(suite) : [];
    printSuiteBox({ suite, scorerAverages, calculateBaselineScorerAverage, flagDiff });
    console.log("");
  }
  console.log("View full report:");
  console.log("https://app.axiom.co/evaluations/run/<run-id>");
}

// src/cli/errors.ts
var AxiomCLIError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AxiomCLIError";
  }
};
function errorToString(error) {
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}

// src/evals/reporter.ts
var AxiomReporter = class {
  constructor() {
    __publicField(this, "startTime", 0);
    __publicField(this, "start", 0);
    __publicField(this, "_endOfRunConfigEnd");
    __publicField(this, "_suiteData", []);
    __publicField(this, "_baselines", /* @__PURE__ */ new Map());
  }
  onTestRunStart() {
    this.start = performance.now();
    this.startTime = (/* @__PURE__ */ new Date()).getTime();
    const overrides2 = getGlobalFlagOverrides();
    const defaults2 = getConfigScope()?.getAllDefaultFlags?.() ?? {};
    printGlobalFlagOverrides(overrides2, defaults2);
  }
  async onTestSuiteReady(_testSuite) {
    const meta = _testSuite.meta();
    if (_testSuite.state() === "skipped") {
      return;
    }
    const baseline = meta.evaluation.baseline;
    if (baseline) {
      const config = getAxiomConfig();
      if (!config) {
        throw new AxiomCLIError("Axiom config not available in reporter");
      }
      const baselineData = await findEvaluationCases(baseline.id, config);
      this._baselines.set(meta.evaluation.name, baselineData || null);
    } else {
      this._baselines.set(meta.evaluation.name, null);
    }
    if (meta.evaluation.configEnd && !this._endOfRunConfigEnd) {
      this._endOfRunConfigEnd = meta.evaluation.configEnd;
    }
  }
  onTestCaseReady(test) {
    const meta = test.meta();
    if (!meta.case) return;
  }
  async onTestSuiteResult(testSuite) {
    const meta = testSuite.meta();
    if (testSuite.state() === "skipped") {
      return;
    }
    const durationSeconds = Number((performance.now() - this.start) / 1e3).toFixed(2);
    const cases = [];
    for (const test of testSuite.children) {
      if (test.type !== "test") continue;
      const testMeta = test.meta();
      if (!testMeta?.case) continue;
      cases.push({
        index: testMeta.case.index,
        scores: testMeta.case.scores,
        outOfScopeFlags: testMeta.case.outOfScopeFlags,
        errors: testMeta.case.errors,
        runtimeFlags: testMeta.case.runtimeFlags
      });
    }
    const cwd2 = process.cwd();
    const relativePath = testSuite.module.moduleId.replace(cwd2, "").replace(/^\//, "");
    let suiteBaseline = this._baselines.get(meta.evaluation.name);
    if (suiteBaseline === void 0 && meta.evaluation.baseline) {
      const config = getAxiomConfig();
      if (!config) {
        throw new AxiomCLIError("Axiom config not available in reporter");
      }
      const baselineData = await findEvaluationCases(meta.evaluation.baseline.id, config);
      suiteBaseline = baselineData || null;
      this._baselines.set(meta.evaluation.name, suiteBaseline);
    }
    this._suiteData.push({
      name: meta.evaluation.name,
      file: relativePath,
      duration: durationSeconds + "s",
      baseline: suiteBaseline || null,
      configFlags: meta.evaluation.configFlags,
      flagConfig: meta.evaluation.flagConfig,
      cases,
      outOfScopeFlags: meta.evaluation.outOfScopeFlags
    });
    printEvalNameAndFileName(testSuite, meta);
    printBaselineNameAndVersion(meta);
    printTestCaseCountStartDuration(testSuite, this.startTime, durationSeconds);
    for (const test of testSuite.children) {
      if (test.type !== "test") continue;
      this.printCaseResult(test, suiteBaseline || null);
    }
    console.log("");
  }
  async onTestRunEnd(_testModules, _errors, _reason) {
    const shouldClear = !process.env.CI && process.stdout.isTTY !== false;
    if (shouldClear) {
      process.stdout.write("\x1B[2J\x1B[0f");
    }
    printFinalReport({
      suiteData: this._suiteData,
      calculateScorerAverages: this.calculateScorerAverages.bind(this),
      calculateBaselineScorerAverage: this.calculateBaselineScorerAverage.bind(this),
      calculateFlagDiff: this.calculateFlagDiff.bind(this)
    });
    const DEBUG = process.env.AXIOM_DEBUG === "true";
    if (DEBUG && this._endOfRunConfigEnd) {
      this.printConfigEnd(this._endOfRunConfigEnd);
    }
  }
  printCaseResult(test, baseline) {
    const ok = test.ok();
    const testMeta = test.meta();
    if (!testMeta?.case) {
      return;
    }
    printTestCaseSuccessOrFailed(testMeta, ok);
    printTestCaseScores(testMeta, baseline);
    printRuntimeFlags(testMeta);
    printOutOfScopeFlags(testMeta);
  }
  /**
   * Calculate average scores per scorer for a suite
   */
  calculateScorerAverages(suite) {
    const scorerTotals = {};
    for (const caseData of suite.cases) {
      for (const [scorerName, score] of Object.entries(caseData.scores)) {
        if (!scorerTotals[scorerName]) {
          scorerTotals[scorerName] = { sum: 0, count: 0 };
        }
        scorerTotals[scorerName].sum += score.score || 0;
        scorerTotals[scorerName].count += 1;
      }
    }
    const averages = {};
    for (const [scorerName, totals] of Object.entries(scorerTotals)) {
      averages[scorerName] = totals.count > 0 ? totals.sum / totals.count : 0;
    }
    return averages;
  }
  /**
   * Calculate average score for a specific scorer from baseline data
   */
  calculateBaselineScorerAverage(baseline, scorerName) {
    const scores = [];
    for (const caseData of baseline.cases) {
      if (caseData.scores[scorerName]) {
        scores.push(caseData.scores[scorerName].value);
      }
    }
    if (scores.length === 0) return null;
    const sum = scores.reduce((acc, val) => acc + val, 0);
    return sum / scores.length;
  }
  /**
   * Calculate flag diff between current run and baseline (filtered by configFlags)
   */
  calculateFlagDiff(suite) {
    if (!suite.baseline || !suite.configFlags || suite.configFlags.length === 0) {
      return [];
    }
    const diffs = [];
    const currentConfig = suite.flagConfig || {};
    const baselineConfig = suite.baseline.flagConfig || {};
    const currentFlat = flattenObject(currentConfig);
    const baselineFlat = flattenObject(baselineConfig);
    const allKeys = /* @__PURE__ */ new Set([...Object.keys(currentFlat), ...Object.keys(baselineFlat)]);
    for (const key of allKeys) {
      const isInScope = suite.configFlags.some((pattern) => key.startsWith(pattern));
      if (!isInScope) continue;
      const currentValue = currentFlat[key];
      const baselineValue = baselineFlat[key];
      if (JSON.stringify(currentValue) !== JSON.stringify(baselineValue)) {
        diffs.push({
          flag: key,
          current: currentValue ? JSON.stringify(currentValue) : void 0,
          baseline: baselineValue ? JSON.stringify(baselineValue) : void 0
        });
      }
    }
    return diffs;
  }
  /**
   * End-of-suite config summary (console only)
   */
  printConfigEnd(configEnd) {
    printConfigHeader();
    maybePrintFlags(configEnd);
  }
};

// src/evals/instrument.ts
var import_sdk_trace_node = require("@opentelemetry/sdk-trace-node");
var import_resources = require("@opentelemetry/resources");
var import_exporter_trace_otlp_http = require("@opentelemetry/exporter-trace-otlp-http");
var import_api10 = require("@opentelemetry/api");
var axiomProvider;
var axiomTracer;
var userProvider;
var initializationPromise = null;
var initialized = false;
async function runInstrumentationHook(hook, options) {
  try {
    return await hook(options);
  } catch (error) {
    throw new AxiomCLIError(`Failed to execute instrumentation hook: ${errorToString(error)}`);
  }
}
function setupEvalProvider(connection) {
  const headers = {
    "X-Axiom-Dataset": connection.dataset
  };
  if (connection.token) {
    headers.Authorization = `Bearer ${connection.token}`;
  }
  const collectorOptions = {
    url: `${connection.url}/v1/traces`,
    headers,
    concurrencyLimit: 10
  };
  const exporter = new import_exporter_trace_otlp_http.OTLPTraceExporter(collectorOptions);
  const processor = new import_sdk_trace_node.BatchSpanProcessor(exporter, {
    maxQueueSize: 2048,
    maxExportBatchSize: 512,
    scheduledDelayMillis: 5e3,
    exportTimeoutMillis: 3e4
  });
  axiomProvider = new import_sdk_trace_node.NodeTracerProvider({
    resource: (0, import_resources.resourceFromAttributes)({
      ["service.name"]: "axiom",
      ["service.version"]: "0.22.0"
    }),
    spanProcessors: [processor]
  });
  axiomTracer = axiomProvider.getTracer("axiom", "0.22.0");
}
async function initInstrumentation(config) {
  if (initialized) {
    return;
  }
  if (initializationPromise) {
    await initializationPromise;
    return;
  }
  initializationPromise = (async () => {
    if (!config.enabled) {
      axiomTracer = import_api10.trace.getTracer("axiom", "0.22.0");
      initialized = true;
      return;
    }
    const connection = resolveAxiomConnection(config.config);
    const hook = config.config.eval.instrumentation;
    let hookResult = void 0;
    if (hook) {
      config.config.eval.instrumentation = hook;
      hookResult = await runInstrumentationHook(hook, {
        dataset: connection.dataset,
        token: connection.token,
        url: connection.url
      });
      userProvider = hookResult?.provider ?? userProvider;
    }
    setupEvalProvider(connection);
    if (!hook) {
      axiomProvider?.register();
      if (axiomTracer) {
        initAxiomAI({ tracer: axiomTracer });
      }
    }
    initialized = true;
  })();
  try {
    await initializationPromise;
  } finally {
    initializationPromise = null;
  }
}
var flush = async () => {
  if (initializationPromise) {
    await initializationPromise;
  }
  const tasks = [];
  if (axiomProvider) {
    tasks.push(axiomProvider.forceFlush());
  }
  const candidateProviders = /* @__PURE__ */ new Set();
  if (userProvider) {
    candidateProviders.add(userProvider);
  }
  const globalProvider = import_api10.trace.getTracerProvider();
  if (globalProvider) {
    candidateProviders.add(globalProvider);
  }
  for (const provider of candidateProviders) {
    const flushFn = provider.forceFlush;
    if (typeof flushFn === "function") {
      tasks.push(
        flushFn.call(provider).catch((error) => {
          console.warn("[AxiomAI] Failed to flush tracer provider:", errorToString(error));
        })
      );
    }
  }
  if (tasks.length > 0) {
    await Promise.all(tasks);
  }
};

// src/evals/run-vitest.ts
var runVitest = async (dir, opts) => {
  setAxiomConfig(opts.config);
  await initInstrumentation({
    enabled: !opts.debug,
    config: opts.config
  });
  const providedConfig = {
    ...opts.config,
    eval: {
      ...opts.config.eval,
      // function can't be serialized, so we need to remove it
      instrumentation: null
    }
  };
  if (opts.debug) {
    console.log(u.bgWhite(u.blackBright(" Debug mode enabled ")));
  }
  const vi2 = await (0, import_node.createVitest)("test", {
    root: dir ? dir : process.cwd(),
    mode: "test",
    include: opts.include,
    exclude: opts.exclude,
    testNamePattern: opts.testNamePattern,
    reporters: ["verbose", new AxiomReporter()],
    environment: "node",
    browser: void 0,
    watch: opts.watch,
    name: "axiom:eval",
    printConsoleTrace: true,
    silent: false,
    disableConsoleIntercept: true,
    testTimeout: opts.config?.eval?.timeoutMs || 6e4,
    globals: true,
    provide: {
      baseline: opts.baseline,
      debug: opts.debug,
      overrides: opts.overrides,
      axiomConfig: providedConfig
    }
  });
  await vi2.start();
  const dispose = (0, import_node.registerConsoleShortcuts)(vi2, process.stdin, process.stdout);
  if (!vi2.shouldKeepServer()) {
    dispose();
    await flush();
    await vi2.close();
    process.exit(0);
  }
  await flush();
};

// src/cli/commands/eval.command.ts
var import_node_fs10 = require("fs");

// src/context.ts
function overrideFlags(partial) {
  const current2 = getEvalContext();
  if (!current2) {
    if (process.env.NODE_ENV !== "test") {
      console.warn("overrideFlags called outside of evaluation context");
    }
    return;
  }
  const overlayContext = {
    ...current2,
    flags: { ...current2.flags, ...partial },
    // Merge for backwards compatibility
    parent: current2,
    overrides: { ...partial }
  };
  const currentCtx = EVAL_CONTEXT.get();
  if (currentCtx) {
    Object.assign(currentCtx, overlayContext);
  }
  for (const [key, value] of Object.entries(partial)) {
    putOnSpan("flag", key, value);
  }
}

// src/cli/utils/eval-context-runner.ts
async function runEvalWithContext(overrides2, runFn) {
  setGlobalFlagOverrides(overrides2);
  return withEvalContext({ initialFlags: overrides2 }, async () => {
    if (Object.keys(overrides2).length > 0) {
      overrideFlags(overrides2);
    }
    return runFn();
  });
}

// src/cli/utils/glob-utils.ts
function isGlob(str) {
  return /[*?[\]{}!]/.test(str);
}

// ../../node_modules/.pnpm/c12@2.0.4_magicast@0.3.5/node_modules/c12/dist/shared/c12.PQMoYrit.mjs
var import_node_fs8 = require("fs");
var import_promises7 = require("fs/promises");
var import_node_os5 = require("os");
init_dist();

// ../../node_modules/.pnpm/jiti@2.6.1/node_modules/jiti/lib/jiti.mjs
var import_node_module2 = require("module");
var import_jiti = __toESM(require_jiti(), 1);
var import_meta2 = {};
function onError(err) {
  throw err;
}
var nativeImport = (id) => import(id);
var _transform;
function lazyTransform(...args) {
  if (!_transform) {
    _transform = (0, import_node_module2.createRequire)(import_meta2.url)("../dist/babel.cjs");
  }
  return _transform(...args);
}
function createJiti(id, opts = {}) {
  if (!opts.transform) {
    opts = { ...opts, transform: lazyTransform };
  }
  return (0, import_jiti.default)(id, opts, {
    onError,
    nativeImport,
    createRequire: import_node_module2.createRequire
  });
}

// ../../node_modules/.pnpm/c12@2.0.4_magicast@0.3.5/node_modules/c12/dist/shared/c12.PQMoYrit.mjs
init_dist5();

// ../../node_modules/.pnpm/rc9@2.1.2/node_modules/rc9/dist/index.mjs
var import_node_fs3 = require("fs");
var import_node_path4 = require("path");
var import_node_os2 = require("os");

// ../../node_modules/.pnpm/destr@2.0.5/node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// ../../node_modules/.pnpm/rc9@2.1.2/node_modules/rc9/dist/index.mjs
init_defu();
function isBuffer(obj) {
  return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function keyIdentity(key) {
  return key;
}
function flatten(target, opts) {
  opts = opts || {};
  const delimiter = opts.delimiter || ".";
  const maxDepth = opts.maxDepth;
  const transformKey = opts.transformKey || keyIdentity;
  const output = {};
  function step(object, prev, currentDepth) {
    currentDepth = currentDepth || 1;
    Object.keys(object).forEach(function(key) {
      const value = object[key];
      const isarray = opts.safe && Array.isArray(value);
      const type = Object.prototype.toString.call(value);
      const isbuffer = isBuffer(value);
      const isobject = type === "[object Object]" || type === "[object Array]";
      const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
      if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
        return step(value, newKey, currentDepth + 1);
      }
      output[newKey] = value;
    });
  }
  step(target);
  return output;
}
function unflatten(target, opts) {
  opts = opts || {};
  const delimiter = opts.delimiter || ".";
  const overwrite = opts.overwrite || false;
  const transformKey = opts.transformKey || keyIdentity;
  const result = {};
  const isbuffer = isBuffer(target);
  if (isbuffer || Object.prototype.toString.call(target) !== "[object Object]") {
    return target;
  }
  function getkey(key) {
    const parsedKey = Number(key);
    return isNaN(parsedKey) || key.indexOf(".") !== -1 || opts.object ? key : parsedKey;
  }
  function addKeys(keyPrefix, recipient, target2) {
    return Object.keys(target2).reduce(function(result2, key) {
      result2[keyPrefix + delimiter + key] = target2[key];
      return result2;
    }, recipient);
  }
  function isEmpty(val) {
    const type = Object.prototype.toString.call(val);
    const isArray2 = type === "[object Array]";
    const isObject = type === "[object Object]";
    if (!val) {
      return true;
    } else if (isArray2) {
      return !val.length;
    } else if (isObject) {
      return !Object.keys(val).length;
    }
  }
  target = Object.keys(target).reduce(function(result2, key) {
    const type = Object.prototype.toString.call(target[key]);
    const isObject = type === "[object Object]" || type === "[object Array]";
    if (!isObject || isEmpty(target[key])) {
      result2[key] = target[key];
      return result2;
    } else {
      return addKeys(
        key,
        result2,
        flatten(target[key], opts)
      );
    }
  }, {});
  Object.keys(target).forEach(function(key) {
    const split = key.split(delimiter).map(transformKey);
    let key1 = getkey(split.shift());
    let key2 = getkey(split[0]);
    let recipient = result;
    while (key2 !== void 0) {
      if (key1 === "__proto__") {
        return;
      }
      const type = Object.prototype.toString.call(recipient[key1]);
      const isobject = type === "[object Object]" || type === "[object Array]";
      if (!overwrite && !isobject && typeof recipient[key1] !== "undefined") {
        return;
      }
      if (overwrite && !isobject || !overwrite && recipient[key1] == null) {
        recipient[key1] = typeof key2 === "number" && !opts.object ? [] : {};
      }
      recipient = recipient[key1];
      if (split.length > 0) {
        key1 = getkey(split.shift());
        key2 = getkey(split[0]);
      }
    }
    recipient[key1] = unflatten(target[key], opts);
  });
  return result;
}
var RE_KEY_VAL = /^\s*([^\s=]+)\s*=\s*(.*)?\s*$/;
var RE_LINES = /\n|\r|\r\n/;
var defaults = {
  name: ".conf",
  dir: process.cwd(),
  flat: false
};
function withDefaults(options) {
  if (typeof options === "string") {
    options = { name: options };
  }
  return { ...defaults, ...options };
}
function parse4(contents, options = {}) {
  const config = {};
  const lines = contents.split(RE_LINES);
  for (const line of lines) {
    const match = line.match(RE_KEY_VAL);
    if (!match) {
      continue;
    }
    const key = match[1];
    if (!key || key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = destr(
      (match[2] || "").trim()
      /* val */
    );
    if (key.endsWith("[]")) {
      const nkey = key.slice(0, Math.max(0, key.length - 2));
      config[nkey] = (config[nkey] || []).concat(value);
      continue;
    }
    config[key] = value;
  }
  return options.flat ? config : unflatten(config, { overwrite: true });
}
function parseFile(path4, options) {
  if (!(0, import_node_fs3.existsSync)(path4)) {
    return {};
  }
  return parse4((0, import_node_fs3.readFileSync)(path4, "utf8"), options);
}
function read2(options) {
  options = withDefaults(options);
  return parseFile((0, import_node_path4.resolve)(options.dir, options.name), options);
}
function readUser(options) {
  options = withDefaults(options);
  options.dir = process.env.XDG_CONFIG_HOME || (0, import_node_os2.homedir)();
  return read2(options);
}

// ../../node_modules/.pnpm/c12@2.0.4_magicast@0.3.5/node_modules/c12/dist/shared/c12.PQMoYrit.mjs
init_defu();
init_dist4();
var dotenv = __toESM(require_main(), 1);
async function setupDotenv(options) {
  const targetEnvironment = options.env ?? process.env;
  const environment = await loadDotenv({
    cwd: options.cwd,
    fileName: options.fileName ?? ".env",
    env: targetEnvironment,
    interpolate: options.interpolate ?? true
  });
  for (const key in environment) {
    if (!key.startsWith("_") && targetEnvironment[key] === void 0) {
      targetEnvironment[key] = environment[key];
    }
  }
  return environment;
}
async function loadDotenv(options) {
  const environment = /* @__PURE__ */ Object.create(null);
  const dotenvFile = resolve2(options.cwd, options.fileName);
  if ((0, import_node_fs8.existsSync)(dotenvFile)) {
    const parsed = dotenv.parse(await import_node_fs8.promises.readFile(dotenvFile, "utf8"));
    Object.assign(environment, parsed);
  }
  if (!options.env?._applied) {
    Object.assign(environment, options.env);
    environment._applied = true;
  }
  if (options.interpolate) {
    interpolate(environment);
  }
  return environment;
}
function interpolate(target, source = {}, parse6 = (v4) => v4) {
  function getValue(key) {
    return source[key] === void 0 ? target[key] : source[key];
  }
  function interpolate2(value, parents = []) {
    if (typeof value !== "string") {
      return value;
    }
    const matches = value.match(/(.?\${?(?:[\w:]+)?}?)/g) || [];
    return parse6(
      // eslint-disable-next-line unicorn/no-array-reduce
      matches.reduce((newValue, match) => {
        const parts = /(.?)\${?([\w:]+)?}?/g.exec(match) || [];
        const prefix = parts[1];
        let value2, replacePart;
        if (prefix === "\\") {
          replacePart = parts[0] || "";
          value2 = replacePart.replace(String.raw`\$`, "$");
        } else {
          const key = parts[2];
          replacePart = (parts[0] || "").slice(prefix.length);
          if (parents.includes(key)) {
            console.warn(
              `Please avoid recursive environment variables ( loop: ${parents.join(
                " > "
              )} > ${key} )`
            );
            return "";
          }
          value2 = getValue(key);
          value2 = interpolate2(value2, [...parents, key]);
        }
        return value2 === void 0 ? newValue : newValue.replace(replacePart, value2);
      }, value)
    );
  }
  for (const key in target) {
    target[key] = interpolate2(getValue(key));
  }
}
var _normalize = (p3) => p3?.replace(/\\/g, "/");
var ASYNC_LOADERS = {
  ".yaml": () => Promise.resolve().then(() => (init_yaml(), yaml_exports)).then((r6) => r6.parseYAML),
  ".yml": () => Promise.resolve().then(() => (init_yaml(), yaml_exports)).then((r6) => r6.parseYAML),
  ".jsonc": () => Promise.resolve().then(() => (init_jsonc(), jsonc_exports)).then((r6) => r6.parseJSONC),
  ".json5": () => Promise.resolve().then(() => (init_json5(), json5_exports)).then((r6) => r6.parseJSON5),
  ".toml": () => Promise.resolve().then(() => (init_toml(), toml_exports)).then((r6) => r6.parseTOML)
};
var SUPPORTED_EXTENSIONS = [
  // with jiti
  ".js",
  ".ts",
  ".mjs",
  ".cjs",
  ".mts",
  ".cts",
  ".json",
  // with confbox
  ".jsonc",
  ".json5",
  ".yaml",
  ".yml",
  ".toml"
];
async function loadConfig(options) {
  options.cwd = resolve2(process.cwd(), options.cwd || ".");
  options.name = options.name || "config";
  options.envName = options.envName ?? process.env.NODE_ENV;
  options.configFile = options.configFile ?? (options.name === "config" ? "config" : `${options.name}.config`);
  options.rcFile = options.rcFile ?? `.${options.name}rc`;
  if (options.extend !== false) {
    options.extend = {
      extendKey: "extends",
      ...options.extend
    };
  }
  const _merger = options.merger || defu;
  options.jiti = options.jiti || createJiti(join(options.cwd, options.configFile), {
    interopDefault: true,
    moduleCache: false,
    extensions: [...SUPPORTED_EXTENSIONS],
    ...options.jitiOptions
  });
  const r6 = {
    config: {},
    cwd: options.cwd,
    configFile: resolve2(options.cwd, options.configFile),
    layers: []
  };
  const _configs = {
    overrides: options.overrides,
    main: void 0,
    rc: void 0,
    packageJson: void 0,
    defaultConfig: options.defaultConfig
  };
  if (options.dotenv) {
    await setupDotenv({
      cwd: options.cwd,
      ...options.dotenv === true ? {} : options.dotenv
    });
  }
  const _mainConfig = await resolveConfig(".", options);
  if (_mainConfig.configFile) {
    _configs.main = _mainConfig.config;
    r6.configFile = _mainConfig.configFile;
  }
  if (_mainConfig.meta) {
    r6.meta = _mainConfig.meta;
  }
  if (options.rcFile) {
    const rcSources = [];
    rcSources.push(read2({ name: options.rcFile, dir: options.cwd }));
    if (options.globalRc) {
      const workspaceDir = await findWorkspaceDir(options.cwd).catch(() => {
      });
      if (workspaceDir) {
        rcSources.push(read2({ name: options.rcFile, dir: workspaceDir }));
      }
      rcSources.push(readUser({ name: options.rcFile, dir: options.cwd }));
    }
    _configs.rc = _merger({}, ...rcSources);
  }
  if (options.packageJson) {
    const keys = (Array.isArray(options.packageJson) ? options.packageJson : [
      typeof options.packageJson === "string" ? options.packageJson : options.name
    ]).filter((t2) => t2 && typeof t2 === "string");
    const pkgJsonFile = await readPackageJSON(options.cwd).catch(() => {
    });
    const values = keys.map((key) => pkgJsonFile?.[key]);
    _configs.packageJson = _merger({}, ...values);
  }
  const configs = {};
  for (const key in _configs) {
    const value = _configs[key];
    configs[key] = await (typeof value === "function" ? value({ configs }) : value);
  }
  r6.config = _merger(
    configs.overrides,
    configs.main,
    configs.rc,
    configs.packageJson,
    configs.defaultConfig
  );
  if (options.extend) {
    await extendConfig(r6.config, options);
    r6.layers = r6.config._layers;
    delete r6.config._layers;
    r6.config = _merger(r6.config, ...r6.layers.map((e3) => e3.config));
  }
  const baseLayers = [
    configs.overrides && {
      config: configs.overrides,
      configFile: void 0,
      cwd: void 0
    },
    { config: configs.main, configFile: options.configFile, cwd: options.cwd },
    configs.rc && { config: configs.rc, configFile: options.rcFile },
    configs.packageJson && {
      config: configs.packageJson,
      configFile: "package.json"
    }
  ].filter((l3) => l3 && l3.config);
  r6.layers = [...baseLayers, ...r6.layers];
  if (options.defaults) {
    r6.config = _merger(r6.config, options.defaults);
  }
  if (options.omit$Keys) {
    for (const key in r6.config) {
      if (key.startsWith("$")) {
        delete r6.config[key];
      }
    }
  }
  return r6;
}
async function extendConfig(config, options) {
  config._layers = config._layers || [];
  if (!options.extend) {
    return;
  }
  let keys = options.extend.extendKey;
  if (typeof keys === "string") {
    keys = [keys];
  }
  const extendSources = [];
  for (const key of keys) {
    extendSources.push(
      ...(Array.isArray(config[key]) ? config[key] : [config[key]]).filter(
        Boolean
      )
    );
    delete config[key];
  }
  for (let extendSource of extendSources) {
    const originalExtendSource = extendSource;
    let sourceOptions = {};
    if (extendSource.source) {
      sourceOptions = extendSource.options || {};
      extendSource = extendSource.source;
    }
    if (Array.isArray(extendSource)) {
      sourceOptions = extendSource[1] || {};
      extendSource = extendSource[0];
    }
    if (typeof extendSource !== "string") {
      console.warn(
        `Cannot extend config from \`${JSON.stringify(
          originalExtendSource
        )}\` in ${options.cwd}`
      );
      continue;
    }
    const _config = await resolveConfig(extendSource, options, sourceOptions);
    if (!_config.config) {
      console.warn(
        `Cannot extend config from \`${extendSource}\` in ${options.cwd}`
      );
      continue;
    }
    await extendConfig(_config.config, { ...options, cwd: _config.cwd });
    config._layers.push(_config);
    if (_config.config._layers) {
      config._layers.push(..._config.config._layers);
      delete _config.config._layers;
    }
  }
}
var GIGET_PREFIXES = [
  "gh:",
  "github:",
  "gitlab:",
  "bitbucket:",
  "https://",
  "http://"
];
var NPM_PACKAGE_RE = /^(@[\da-z~-][\d._a-z~-]*\/)?[\da-z~-][\d._a-z~-]*($|\/.*)/;
async function resolveConfig(source, options, sourceOptions = {}) {
  if (options.resolve) {
    const res2 = await options.resolve(source, options);
    if (res2) {
      return res2;
    }
  }
  const _merger = options.merger || defu;
  if (options.giget !== false && GIGET_PREFIXES.some((prefix) => source.startsWith(prefix))) {
    const { downloadTemplate: downloadTemplate2 } = await Promise.resolve().then(() => (init_dist7(), dist_exports));
    const { digest: digest2 } = await Promise.resolve().then(() => (init_dist8(), dist_exports2));
    const cloneName = source.replace(/\W+/g, "_").split("_").splice(0, 3).join("_") + "_" + digest2(source).slice(0, 10).replace(/[-_]/g, "");
    let cloneDir;
    const localNodeModules = resolve2(options.cwd, "node_modules");
    const parentDir = dirname(options.cwd);
    if (basename2(parentDir) === ".c12") {
      cloneDir = join(parentDir, cloneName);
    } else if ((0, import_node_fs8.existsSync)(localNodeModules)) {
      cloneDir = join(localNodeModules, ".c12", cloneName);
    } else {
      cloneDir = process.env.XDG_CACHE_HOME ? resolve2(process.env.XDG_CACHE_HOME, "c12", cloneName) : resolve2((0, import_node_os5.homedir)(), ".cache/c12", cloneName);
    }
    if ((0, import_node_fs8.existsSync)(cloneDir) && !sourceOptions.install) {
      await (0, import_promises7.rm)(cloneDir, { recursive: true });
    }
    const cloned = await downloadTemplate2(source, {
      dir: cloneDir,
      install: sourceOptions.install,
      force: sourceOptions.install,
      auth: sourceOptions.auth,
      ...options.giget,
      ...sourceOptions.giget
    });
    source = cloned.dir;
  }
  const tryResolve = (id) => {
    const resolved = options.jiti.esmResolve(id, { try: true });
    return resolved ? fileURLToPath(resolved) : void 0;
  };
  if (NPM_PACKAGE_RE.test(source)) {
    source = tryResolve(source) || source;
  }
  const ext = extname(source);
  const isDir = !ext || ext === basename2(source);
  const cwd2 = resolve2(options.cwd, isDir ? source : dirname(source));
  if (isDir) {
    source = options.configFile;
  }
  const res = {
    config: void 0,
    configFile: void 0,
    cwd: cwd2,
    source,
    sourceOptions
  };
  res.configFile = tryResolve(resolve2(cwd2, source)) || tryResolve(resolve2(cwd2, ".config", source.replace(/\.config$/, ""))) || tryResolve(resolve2(cwd2, ".config", source)) || source;
  if (!(0, import_node_fs8.existsSync)(res.configFile)) {
    return res;
  }
  const configFileExt = extname(res.configFile) || "";
  if (configFileExt in ASYNC_LOADERS) {
    const asyncLoader = await ASYNC_LOADERS[configFileExt]();
    const contents = await (0, import_promises7.readFile)(res.configFile, "utf8");
    res.config = asyncLoader(contents);
  } else {
    res.config = await options.jiti.import(res.configFile, {
      default: true
    });
  }
  if (res.config instanceof Function) {
    res.config = await res.config();
  }
  if (options.envName) {
    const envConfig = {
      ...res.config["$" + options.envName],
      ...res.config.$env?.[options.envName]
    };
    if (Object.keys(envConfig).length > 0) {
      res.config = _merger(envConfig, res.config);
    }
  }
  res.meta = defu(res.sourceOptions.meta, res.config.$meta);
  delete res.config.$meta;
  if (res.sourceOptions.overrides) {
    res.config = _merger(res.sourceOptions.overrides, res.config);
  }
  res.configFile = _normalize(res.configFile);
  res.source = _normalize(res.source);
  return res;
}

// ../../node_modules/.pnpm/c12@2.0.4_magicast@0.3.5/node_modules/c12/dist/index.mjs
var import_node_fs9 = require("fs");
var import_promises8 = require("fs/promises");
var import_node_os6 = require("os");
init_defu();
var import_dotenv = __toESM(require_main(), 1);

// src/config/loader.ts
init_defu();

// src/config/index.ts
var DEFAULT_EVAL_INCLUDE = ["**/*.eval.{ts,js,mts,mjs,cts,cjs}"];
function createPartialDefaults() {
  return {
    eval: {
      url: process.env.AXIOM_URL || "https://api.axiom.co",
      token: process.env.AXIOM_TOKEN,
      dataset: process.env.AXIOM_DATASET,
      instrumentation: null,
      include: [...DEFAULT_EVAL_INCLUDE],
      exclude: [],
      timeoutMs: 6e4
    }
  };
}
function validateConfig(config) {
  const errors = [];
  if (!config.eval?.token) {
    errors.push(
      "eval.token is required (set in axiom.config.ts or AXIOM_TOKEN environment variable)"
    );
  }
  if (!config.eval?.dataset) {
    errors.push(
      "eval.dataset is required (set in axiom.config.ts or AXIOM_DATASET environment variable)"
    );
  }
  if (!config.eval?.url) {
    console.log(
      "eval.url was not specified. Defaulting to `https://api.axiom.co`. Please set it in axiom.config.ts or AXIOM_URL environment variable if you want to use a different endpoint."
    );
  }
  const instrumentation = config.eval?.instrumentation;
  if (instrumentation !== null && instrumentation !== void 0 && typeof instrumentation !== "function") {
    errors.push(
      "eval.instrumentation must be a function returning OTEL setup information or null."
    );
  }
  if (errors.length > 0) {
    throw new AxiomCLIError(`Invalid Axiom configuration:
  - ${errors.join("\n  - ")}`);
  }
  return config;
}

// src/config/loader.ts
function customMerger(target, source) {
  const merged = defu(source, target);
  if (source?.eval && "include" in source.eval) {
    merged.eval.include = source.eval.include;
  }
  return merged;
}
async function loadConfig2(cwd2 = process.cwd()) {
  try {
    const defaults2 = createPartialDefaults();
    const result = await loadConfig({
      name: "axiom",
      cwd: cwd2,
      // Support common config file extensions
      configFile: "axiom.config",
      // Don't use defaultConfig - we'll merge manually to control array behavior
      // Disable configs other than .ts/.js/.mts/.mjs/.cts/.cjs
      rcFile: false,
      globalRc: false,
      packageJson: false,
      giget: false
    });
    const mergedConfig = customMerger(defaults2, result.config);
    const validatedConfig = validateConfig(mergedConfig);
    return {
      config: validatedConfig
    };
  } catch (error) {
    if (error instanceof AxiomCLIError) {
      throw error;
    }
    throw new AxiomCLIError(`Failed to load config file: ${errorToString(error)}`);
  }
}

// src/cli/commands/eval.command.ts
var loadEvalCommand = (program2, flagOverrides = {}) => {
  return program2.addCommand(
    new import_commander3.Command("eval").description("run evals locally").addArgument(
      new import_commander3.Argument("[target]", "file, directory, glob pattern, or eval name").default(
        ".",
        "any *.eval.ts file in current directory"
      )
    ).option("-w, --watch true", "keep server running and watch for changes", false).option("-t, --token <TOKEN>", "axiom token", process.env.AXIOM_TOKEN).option("-d, --dataset <DATASET>", "axiom dataset name", process.env.AXIOM_DATASET).option("-u, --url <AXIOM URL>", "axiom url", process.env.AXIOM_URL ?? "https://api.axiom.co").option("-b, --baseline <BASELINE ID>", "id of baseline evaluation to compare against").option("--debug", "run locally without sending to Axiom or loading baselines", false).action(async (target, options) => {
      try {
        if (options.debug) {
          process.env.AXIOM_DEBUG = "true";
        }
        let include = [];
        let exclude;
        let testNamePattern;
        const isGlobPattern = isGlob(target);
        const { config } = await loadConfig2(".");
        if (isGlobPattern) {
          include = [target];
        } else {
          try {
            const stat = (0, import_node_fs10.lstatSync)(target);
            if (stat.isDirectory()) {
              include = config?.eval?.include || [];
            } else {
              include = [target];
            }
          } catch {
            testNamePattern = new RegExp(target, "i");
            include = config?.eval?.include || [];
          }
        }
        exclude = config?.eval?.exclude;
        if (!config?.eval?.instrumentation) {
          console.warn(
            u.yellow(
              "\u26A0 App instrumentation (`eval.instrumentation` in `axiom.config.ts`) not configured. Using default provider."
            )
          );
          console.log("");
        }
        await runEvalWithContext(flagOverrides, async () => {
          return runVitest(".", {
            watch: options.watch,
            baseline: options.baseline,
            include,
            exclude,
            testNamePattern,
            debug: options.debug,
            overrides: flagOverrides,
            config
          });
        });
      } catch (error) {
        if (error instanceof AxiomCLIError) {
          console.error(`
\u274C ${error.message}
`);
          process.exit(1);
        }
        throw error;
      }
    })
  );
};

// src/cli/utils/parse-flag-overrides.ts
var import_zod5 = require("zod");
var import_node_fs11 = require("fs");
var import_node_path5 = require("path");
var FLAG_RE = /^--flag\.([^=]+)(?:=(.*))?$/;
var CONFIG_RE = /^--flags-config(?:=(.*))?$/;
function ensureNoSpaceSeparatedSyntax(flagName, value, nextToken, flagType) {
  if (value === void 0 && nextToken !== void 0) {
    if (flagType === "flag" && !nextToken.startsWith("-") && nextToken !== "true" && nextToken !== "false") {
      console.error(`\u274C Invalid syntax: --flag.${flagName} ${nextToken}`);
      console.error(`\u{1F4A1} Use: --flag.${flagName}=${nextToken}`);
      process.exit(1);
    } else if (flagType === "config" && !nextToken.startsWith("-")) {
      console.error(`\u274C Invalid syntax: --flags-config ${nextToken}`);
      console.error(`\u{1F4A1} Use: --flags-config=${nextToken}`);
      process.exit(1);
    }
  }
}
function coerceValue(raw) {
  if (raw === "true") return true;
  if (raw === "false") return false;
  const num = Number(raw);
  if (!Number.isNaN(num) && raw.trim() === num.toString()) {
    return num;
  }
  try {
    return JSON.parse(raw);
  } catch {
    return raw;
  }
}
function loadConfigFile(path4) {
  const abs = (0, import_node_path5.resolve)(process.cwd(), path4);
  try {
    const contents = (0, import_node_fs11.readFileSync)(abs, "utf8");
    const parsed = JSON.parse(contents);
    if (typeof parsed !== "object" || Array.isArray(parsed) || parsed === null) {
      console.error(
        `\u274C Flags config must be a JSON object, got ${Array.isArray(parsed) ? "array" : typeof parsed}`
      );
      process.exit(1);
    }
    return parsed;
  } catch (err) {
    console.error(`\u274C Could not read or parse flags config "${path4}": ${err.message}`);
    process.exit(1);
  }
}
function extractOverrides(argv) {
  const cleanedArgv2 = [];
  const overrides2 = {};
  let configPath = null;
  let hasCliFlags = false;
  let configPathCount = 0;
  for (let i2 = 0; i2 < argv.length; i2++) {
    const token = argv[i2];
    const configMatch = token.match(CONFIG_RE);
    const flagMatch = token.match(FLAG_RE);
    if (configMatch) {
      configPathCount++;
      if (configPathCount > 1) {
        console.error("\u274C Only one --flags-config can be supplied.");
        process.exit(1);
      }
      const value = configMatch[1];
      const nextToken = argv.length > i2 + 1 ? argv[i2 + 1] : void 0;
      ensureNoSpaceSeparatedSyntax("flags-config", value, nextToken, "config");
      if (!value) {
        console.error("\u274C --flags-config requires a file path");
        console.error("\u{1F4A1} Use: --flags-config=path/to/config.json");
        process.exit(1);
      }
      configPath = value;
    } else if (flagMatch) {
      hasCliFlags = true;
      const key = flagMatch[1];
      const value = flagMatch[2];
      const nextToken = argv.length > i2 + 1 ? argv[i2 + 1] : void 0;
      ensureNoSpaceSeparatedSyntax(key, value, nextToken, "flag");
      const finalValue = value === void 0 ? "true" : value;
      overrides2[key] = coerceValue(finalValue);
    } else {
      cleanedArgv2.push(token);
    }
  }
  if (configPath && hasCliFlags) {
    console.error("\u274C Cannot use both --flags-config and --flag.* arguments together.");
    console.error("Choose one approach:");
    console.error("  \u2022 Config file: --flags-config=my-flags.json");
    console.error("  \u2022 CLI flags: --flag.temperature=0.9 --flag.model=gpt-4o");
    process.exit(1);
  }
  if (configPath) {
    const configOverrides = loadConfigFile(configPath);
    return { cleanedArgv: cleanedArgv2, overrides: configOverrides };
  }
  return { cleanedArgv: cleanedArgv2, overrides: overrides2 };
}

// src/bin.ts
var import_env = __toESM(require("@next/env"), 1);

// src/cli/commands/version.command.ts
var import_commander4 = require("commander");
var loadVersionCommand = (program2) => {
  return program2.addCommand(
    new import_commander4.Command("version").description("cli version").action(() => {
      console.log("0.22.0");
    })
  );
};

// src/bin.ts
var { loadEnvConfig } = import_env.default;
loadEnvConfig(process.cwd());
var { cleanedArgv, overrides } = extractOverrides(process.argv.slice(2));
var program = new import_commander5.Command();
program.name("axiom").description("Axiom's CLI to manage your objects and run evals").version("0.22.0");
loadPushCommand(program);
loadPullCommand(program);
loadEvalCommand(program, overrides);
loadVersionCommand(program);
program.parse(["node", "axiom", ...cleanedArgv]);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  program
});
/*! Bundled license information:

confbox/dist/yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)

confbox/dist/toml.mjs:
  (*!
  * Copyright (c) Squirrel Chat et al., All rights reserved.
  * SPDX-License-Identifier: BSD-3-Clause
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
  * 3. Neither the name of the copyright holder nor the names of its contributors
  *    may be used to endorse or promote products derived from this software without
  *    specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *)

node-fetch-native/dist/node.cjs:
  (**
  * @license
  * web-streams-polyfill v3.3.3
  * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
  * This code is released under the MIT license.
  * SPDX-License-Identifier: MIT
  *)
  (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

node-fetch-native/dist/proxy.cjs:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
*/
//# sourceMappingURL=bin.cjs.map