{"version":3,"sources":["../src/evals/eval.ts","../src/evals/git-info.ts","../src/evals/builder.ts","../src/evals/scorer.factory.ts"],"sourcesContent":["import { afterAll, beforeAll, describe, inject, it } from 'vitest';\nimport { context, SpanStatusCode, trace, type Context } from '@opentelemetry/api';\nimport { customAlphabet } from 'nanoid';\nimport { withEvalContext, getEvalContext, getConfigScope } from './context/storage';\n\nimport { Attr } from '../otel/semconv/attributes';\nimport type { ResolvedAxiomConfig } from '../config/index';\nimport { startSpan, flush, ensureInstrumentationInitialized } from './instrument';\nimport { getGitUserInfo } from './git-info';\nimport type {\n  CollectionRecord,\n  EvalParams,\n  EvalTask,\n  InputOf,\n  ExpectedOf,\n  EvaluationReport,\n  EvalCaseReport,\n  RuntimeFlagLog,\n  OutOfScopeFlag,\n} from './eval.types';\nimport type { Score, Scorer } from './scorers';\nimport { findBaseline, findEvaluationCases } from './eval.service';\nimport { getGlobalFlagOverrides, setGlobalFlagOverrides } from './context/global-flags';\nimport { deepEqual } from '../util/deep-equal';\nimport { dotNotationToNested } from '../util/dot-path';\nimport { AxiomCLIError } from '../cli/errors';\n\ndeclare module 'vitest' {\n  interface TestSuiteMeta {\n    evaluation: EvaluationReport;\n  }\n  interface TaskMeta {\n    case: EvalCaseReport;\n    evaluation: EvaluationReport;\n  }\n  export interface ProvidedContext {\n    baseline?: string;\n    debug?: boolean;\n    overrides?: Record<string, any>;\n    axiomConfig?: ResolvedAxiomConfig;\n  }\n}\n\nconst nanoid = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyz', 10);\n\n/**\n * Creates and registers an evaluation suite with the given name and parameters.\n *\n * This function sets up a complete evaluation pipeline that will run your {@link EvalTask}\n * against a dataset, score the results, and provide detailed {@link EvalCaseReport} reporting.\n *\n * @experimental This API is experimental and may change in future versions.\n *\n * @param name - Human-readable name for the evaluation suite\n * @param params - {@link EvalParams} configuration parameters for the evaluation\n *\n * @example\n * ```typescript\n * import { experimental_Eval as Eval } from 'axiom/ai/evals';\n *\n * Eval('Text Generation Quality', {\n *   data: async () => [\n *     { input: 'Explain photosynthesis', expected: 'Plants convert light to energy...' },\n *     { input: 'What is gravity?', expected: 'Gravity is a fundamental force...' }\n *   ],\n *   task: async ({ input }) => {\n *     const result = await generateText({\n *       model: yourModel,\n *       prompt: input\n *     });\n *     return result.text;\n *   },\n *   scorers: [similarityScorer, factualAccuracyScorer],\n * });\n * ```\n */\nexport function Eval<\n  // Inference-friendly overload – no explicit generics required by callers.\n  const Data extends readonly { input: any; expected: any }[],\n  Out extends string | Record<string, any>,\n  TaskFn extends EvalTask<InputOf<Data>, ExpectedOf<Data>, Out>,\n  In = InputOf<Data>,\n  Exp = ExpectedOf<Data>,\n>(\n  name: string,\n  params: {\n    data: () => Data | Promise<Data>;\n    task: TaskFn;\n    scorers: ReadonlyArray<Scorer<In, Exp, Out>>;\n    metadata?: Record<string, unknown>;\n    timeout?: number;\n    configFlags?: string[];\n  },\n): void;\n\n/**\n *\n */\nexport function Eval<\n  // Explicit generics overload – allows users to pass explicit types.\n  TInput extends string | Record<string, any>,\n  TExpected extends string | Record<string, any>,\n  TOutput extends string | Record<string, any>,\n>(name: string, params: EvalParams<TInput, TExpected, TOutput>): void;\n\n/**\n * Implementation\n */\nexport function Eval(name: string, params: any): void {\n  registerEval(name, params as EvalParams<any, any, any>).catch(console.error);\n}\n\n/**\n * Capture full flag configuration filtered by configFlags scope\n */\nfunction captureFlagConfig(configFlags?: string[]): Record<string, any> {\n  if (!configFlags || configFlags.length === 0) {\n    return {};\n  }\n\n  const scope = getConfigScope();\n  const allDefaults = scope?.getAllDefaultFlags?.() ?? {};\n  const overrides = getGlobalFlagOverrides();\n\n  const merged = { ...allDefaults, ...overrides };\n\n  // Filter to only flags in configFlags scope\n  const filtered: Record<string, any> = {};\n  for (const [key, value] of Object.entries(merged)) {\n    const isInScope = configFlags.some((pattern) => key.startsWith(pattern));\n    if (isInScope) {\n      filtered[key] = value;\n    }\n  }\n\n  return dotNotationToNested(filtered);\n}\n\nasync function registerEval<\n  TInput extends string | Record<string, any>,\n  TExpected extends string | Record<string, any>,\n  TOutput extends string | Record<string, any>,\n>(evalName: string, opts: EvalParams<TInput, TExpected, TOutput>) {\n  const datasetPromise = opts.data();\n  const user = getGitUserInfo();\n\n  // TODO: EXPERIMENTS - we were creating `evalScope` here before\n\n  // check if user passed a specific baseline id to the CLI\n  const baselineId = inject('baseline');\n  const isDebug = inject('debug');\n  const injectedOverrides = inject('overrides');\n  const axiomConfig = inject('axiomConfig');\n\n  if (!axiomConfig) {\n    throw new AxiomCLIError('Axiom config not found');\n  }\n\n  const instrumentationReady = !isDebug\n    ? ensureInstrumentationInitialized(axiomConfig)\n    : Promise.resolve();\n\n  const result = await describe(\n    `evaluate: ${evalName}`,\n    async () => {\n      const dataset = await datasetPromise;\n\n      const baseline = isDebug\n        ? undefined\n        : baselineId\n          ? await findEvaluationCases(baselineId, axiomConfig)\n          : await findBaseline(evalName, axiomConfig);\n\n      // create a version code\n      const evalVersion = nanoid();\n      let evalId = ''; // get traceId\n\n      let suiteSpan: ReturnType<typeof startSpan> | undefined;\n      let suiteContext: Context | undefined;\n      let instrumentationError: unknown = undefined;\n\n      // Track out-of-scope flags across all cases for evaluation-level reporting\n      const allOutOfScopeFlags: { flagPath: string; accessedAt: number; stackTrace: string[] }[] =\n        [];\n\n      // Track final config snapshot from the last executed case for reporter printing\n      let finalConfigSnapshot:\n        | { flags: Record<string, any>; pickedFlags?: string[]; overrides?: Record<string, any> }\n        | undefined;\n\n      beforeAll(async (suite) => {\n        try {\n          await instrumentationReady;\n        } catch (error) {\n          instrumentationError = error;\n          throw error;\n        }\n\n        suiteSpan = startSpan(`eval ${evalName}-${evalVersion}`, {\n          attributes: {\n            [Attr.GenAI.Operation.Name]: 'eval',\n            [Attr.Eval.Name]: evalName,\n            [Attr.Eval.Version]: evalVersion,\n            [Attr.Eval.Type]: 'regression', // TODO: where to get experiment type value from?\n            [Attr.Eval.Tags]: [],\n            [Attr.Eval.Collection.ID]: 'custom', // TODO: where to get dataset split value from?\n            [Attr.Eval.Collection.Name]: 'custom', // TODO: where to get dataset name from?\n            [Attr.Eval.Collection.Size]: dataset.length,\n            // metadata\n            'eval.metadata': JSON.stringify(opts.metadata),\n            // baseline\n            [Attr.Eval.BaselineID]: baseline ? baseline.id : undefined,\n            [Attr.Eval.BaselineName]: baseline ? baseline.name : undefined,\n            // user info\n            [Attr.Eval.User.Name]: user?.name,\n            [Attr.Eval.User.Email]: user?.email,\n          },\n        });\n        evalId = suiteSpan.spanContext().traceId;\n        suiteSpan.setAttribute(Attr.Eval.ID, evalId);\n        suiteContext = trace.setSpan(context.active(), suiteSpan);\n\n        // Ensure worker process knows CLI overrides\n        if (injectedOverrides && Object.keys(injectedOverrides).length > 0) {\n          try {\n            setGlobalFlagOverrides(injectedOverrides);\n          } catch {}\n        }\n\n        suite.meta.evaluation = {\n          id: evalId,\n          name: evalName,\n          version: evalVersion,\n          baseline: baseline ?? undefined,\n          configFlags: opts.configFlags,\n        };\n\n        const flagConfig = captureFlagConfig(opts.configFlags);\n        suite.meta.evaluation.flagConfig = flagConfig;\n        const flagConfigJson = JSON.stringify(flagConfig);\n        suiteSpan.setAttribute('eval.config.flags', flagConfigJson);\n      });\n\n      afterAll(async (suite) => {\n        if (instrumentationError) {\n          throw instrumentationError;\n        }\n\n        const tags: string[] = ['offline'];\n        suiteSpan?.setAttribute(Attr.Eval.Tags, JSON.stringify(tags));\n\n        // Aggregate out-of-scope flags for evaluation-level reporting\n        const flagSummary = new Map<string, OutOfScopeFlag>();\n\n        for (const flag of allOutOfScopeFlags) {\n          if (flagSummary.has(flag.flagPath)) {\n            const existing = flagSummary.get(flag.flagPath)!;\n            existing.count++;\n            existing.firstAccessedAt = Math.min(existing.firstAccessedAt, flag.accessedAt);\n            existing.lastAccessedAt = Math.max(existing.lastAccessedAt, flag.accessedAt);\n          } else {\n            flagSummary.set(flag.flagPath, {\n              flagPath: flag.flagPath,\n              count: 1,\n              firstAccessedAt: flag.accessedAt,\n              lastAccessedAt: flag.accessedAt,\n              stackTrace: flag.stackTrace,\n            });\n          }\n        }\n\n        // Update evaluation report with aggregated out-of-scope flags\n        if (suite.meta.evaluation && suiteSpan) {\n          suite.meta.evaluation.outOfScopeFlags = Array.from(flagSummary.entries()).map(\n            ([_flagPath, stats]) => stats,\n          );\n\n          // Attach end-of-suite config snapshot for reporter printing\n          const allDefaults = getConfigScope()?.getAllDefaultFlags();\n          const pickedFlags = finalConfigSnapshot?.pickedFlags;\n          const overrides = injectedOverrides ?? getGlobalFlagOverrides();\n\n          suite.meta.evaluation.configEnd = {\n            flags: allDefaults,\n            pickedFlags,\n            overrides,\n          };\n        }\n\n        // end root span\n        suiteSpan?.setStatus({ code: SpanStatusCode.OK });\n        suiteSpan?.end();\n        await flush();\n      });\n\n      type CollectionRecordWithIndex = { index: number } & CollectionRecord<TInput, TExpected>;\n\n      await it.concurrent.for(\n        dataset.map((d, index) => ({ ...d, index }) satisfies CollectionRecordWithIndex),\n      )('case', async (data: CollectionRecordWithIndex, { task }) => {\n        const start = performance.now();\n        if (!suiteContext) {\n          throw new Error(\n            '[Axiom AI] Suite context not initialized. This is likely a bug – instrumentation should complete before tests run.',\n          );\n        }\n\n        const caseSpan = startSpan(\n          `case ${data.index}`,\n          {\n            attributes: {\n              [Attr.GenAI.Operation.Name]: 'eval.case',\n              [Attr.Eval.ID]: evalId,\n              [Attr.Eval.Name]: evalName,\n              [Attr.Eval.Version]: evalVersion,\n              [Attr.Eval.Case.Index]: data.index,\n              [Attr.Eval.Case.Input]:\n                typeof data.input === 'string' ? data.input : JSON.stringify(data.input),\n              [Attr.Eval.Case.Expected]:\n                typeof data.expected === 'string' ? data.expected : JSON.stringify(data.expected),\n              // user info\n              [Attr.Eval.User.Name]: user?.name,\n              [Attr.Eval.User.Email]: user?.email,\n            },\n          },\n          suiteContext,\n        );\n        const caseContext = trace.setSpan(context.active(), caseSpan);\n\n        let outOfScopeFlags: { flagPath: string; accessedAt: number; stackTrace: string[] }[] = [];\n        try {\n          const result = await runTask(\n            caseContext,\n            {\n              id: evalId,\n              version: evalVersion,\n              name: evalName,\n            },\n            {\n              index: data.index,\n              expected: data.expected,\n              input: data.input,\n              scorers: opts.scorers,\n              task: opts.task,\n              metadata: opts.metadata,\n              configFlags: opts.configFlags,\n            },\n          );\n          const { output, duration } = result;\n          outOfScopeFlags = result.outOfScopeFlags;\n\n          finalConfigSnapshot = {\n            flags: result.finalFlags || {},\n            pickedFlags: opts.configFlags,\n            overrides: result.overrides,\n          };\n\n          const scoreList: Score[] = await Promise.all(\n            opts.scorers.map(async (scorer) => {\n              const scorerSpan = startSpan(\n                `score ${scorer.name}`,\n                {\n                  attributes: {\n                    [Attr.GenAI.Operation.Name]: 'eval.score',\n                    [Attr.Eval.ID]: evalId,\n                    [Attr.Eval.Name]: evalName,\n                    [Attr.Eval.Version]: evalVersion,\n                  },\n                },\n                caseContext,\n              );\n\n              const start = performance.now();\n              const result = await scorer({\n                input: data.input,\n                output,\n                expected: data.expected,\n              });\n\n              const duration = Math.round(performance.now() - start);\n              const scoreValue = result.score as number;\n\n              scorerSpan.setAttributes({\n                [Attr.Eval.Score.Name]: result.name,\n                [Attr.Eval.Score.Value]: scoreValue,\n              });\n\n              scorerSpan.setStatus({ code: SpanStatusCode.OK });\n              scorerSpan.end();\n\n              return {\n                ...result,\n                metadata: { duration, startedAt: start, error: null },\n              };\n            }),\n          );\n\n          const scores = Object.fromEntries(scoreList.map((s) => [s.name, s]));\n\n          caseSpan.setAttributes({\n            [Attr.Eval.Case.Output]: typeof output === 'string' ? output : JSON.stringify(output),\n            [Attr.Eval.Case.Scores]: JSON.stringify(scores ? scores : {}),\n          });\n          caseSpan.setStatus({ code: SpanStatusCode.OK });\n\n          // set task meta for showing result in vitest report\n          task.meta.case = {\n            index: data.index,\n            name: evalName,\n            expected: data.expected,\n            input: data.input,\n            output: output,\n            scores,\n            status: 'success',\n            errors: [],\n            duration,\n            startedAt: start,\n            outOfScopeFlags,\n            pickedFlags: opts.configFlags,\n          };\n\n          // Collect out-of-scope flags for evaluation-level aggregation\n          allOutOfScopeFlags.push(...outOfScopeFlags);\n        } catch (e) {\n          console.log(e);\n          const error = e as Error;\n          caseSpan.recordException(error);\n          caseSpan.setStatus({ code: SpanStatusCode.ERROR, message: error.message });\n\n          const ctx = getEvalContext();\n          outOfScopeFlags =\n            ctx.outOfScopeFlags ||\n            ([] as { flagPath: string; accessedAt: number; stackTrace: string[] }[]);\n\n          task.meta.case = {\n            name: evalName,\n            index: data.index,\n            expected: data.expected,\n            input: data.input,\n            output: String(e),\n            scores: {},\n            status: 'fail',\n            errors: [error],\n            startedAt: start,\n            duration: Math.round(performance.now() - start),\n            outOfScopeFlags,\n            pickedFlags: opts.configFlags,\n          };\n\n          allOutOfScopeFlags.push(...outOfScopeFlags);\n          throw e;\n        } finally {\n          // Compute per-case runtime flags report and attach to span/meta\n          try {\n            const DEBUG = process.env.AXIOM_DEBUG === 'true';\n\n            const accessedFlags: Record<string, any> = finalConfigSnapshot?.flags || {};\n\n            const accessed = Object.keys(accessedFlags);\n            const allDefaults = getConfigScope()?.getAllDefaultFlags?.() ?? {};\n\n            const runtimeFlags: Record<string, RuntimeFlagLog> = {};\n            for (const key of accessed) {\n              const value = accessedFlags[key];\n              if (key in allDefaults) {\n                const replaced = !deepEqual(value, allDefaults[key]);\n                if (replaced) {\n                  runtimeFlags[key] = { kind: 'replaced', value, default: allDefaults[key] };\n                }\n              } else {\n                runtimeFlags[key] = { kind: 'introduced', value };\n              }\n            }\n\n            if (!DEBUG && Object.keys(runtimeFlags).length > 0) {\n              const serialized = JSON.stringify(runtimeFlags);\n              caseSpan.setAttribute('eval.case.config.runtime_flags', serialized);\n            }\n\n            if (task.meta.case) {\n              task.meta.case.runtimeFlags = runtimeFlags;\n            }\n          } catch {}\n          caseSpan.end();\n        }\n      });\n    },\n    axiomConfig?.eval.timeoutMs,\n  );\n\n  return result;\n}\n\nconst joinArrayOfUnknownResults = <T extends string | Record<string, any>>(results: T[]): T => {\n  if (results.length === 0) {\n    return '' as unknown as T;\n  }\n\n  // If all results are strings, concatenate them\n  if (results.every((r) => typeof r === 'string')) {\n    return results.join('') as unknown as T;\n  }\n\n  // If we have objects, return the last one (streaming typically overwrites)\n  return results[results.length - 1];\n};\n\nconst executeTask = async <\n  TInput extends string | Record<string, any>,\n  TExpected extends string | Record<string, any>,\n  TOutput extends string | Record<string, any>,\n>(\n  task: EvalTask<TInput, TExpected, TOutput>,\n  input: TInput,\n  expected: TExpected,\n): Promise<TOutput> => {\n  const taskResultOrStream = await task({ input, expected });\n\n  if (\n    typeof taskResultOrStream === 'object' &&\n    taskResultOrStream &&\n    Symbol.asyncIterator in taskResultOrStream\n  ) {\n    const chunks: TOutput[] = [];\n\n    for await (const chunk of taskResultOrStream) {\n      chunks.push(chunk);\n    }\n\n    return joinArrayOfUnknownResults<TOutput>(chunks as TOutput[]);\n  }\n\n  return taskResultOrStream;\n};\n\nconst runTask = async <\n  TInput extends string | Record<string, any>,\n  TExpected extends string | Record<string, any>,\n  TOutput extends string | Record<string, any>,\n>(\n  caseContext: Context,\n  evaluation: {\n    id: string;\n    name: string;\n    version: string;\n  },\n  opts: {\n    index: number;\n    input: TInput;\n    expected: TExpected | undefined;\n  } & Omit<EvalParams<TInput, TExpected, TOutput>, 'data'>,\n  // TODO: EXPERIMENTS - we had `evalScope` here before... need to figure out what to do instead\n) => {\n  const taskName = opts.task.name ?? 'anonymous';\n  // start task span\n  const taskSpan = startSpan(\n    `task`,\n    {\n      attributes: {\n        [Attr.GenAI.Operation.Name]: 'eval.task',\n        [Attr.Eval.Task.Name]: taskName,\n        [Attr.Eval.Task.Type]: 'llm_completion', // TODO: How to determine task type?\n        [Attr.Eval.ID]: evaluation.id,\n        [Attr.Eval.Name]: evaluation.name,\n        [Attr.Eval.Version]: evaluation.version,\n      },\n    },\n    caseContext,\n  );\n\n  const { output, duration, outOfScopeFlags, finalFlags, overrides } = await context.with(\n    trace.setSpan(context.active(), taskSpan),\n    async (): Promise<{\n      output: TOutput;\n      duration: number;\n      outOfScopeFlags: { flagPath: string; accessedAt: number; stackTrace: string[] }[];\n      finalFlags: Record<string, any>;\n      overrides?: Record<string, any>;\n    }> => {\n      // Initialize evaluation context for flag/fact access\n      return withEvalContext(\n        { pickedFlags: opts.configFlags },\n        async (): Promise<{\n          output: TOutput;\n          duration: number;\n          outOfScopeFlags: { flagPath: string; accessedAt: number; stackTrace: string[] }[];\n          finalFlags: Record<string, any>;\n          overrides?: Record<string, any>;\n        }> => {\n          // TODO: EXPERIMENTS - before we were setting config scope if provided here\n\n          const start = performance.now();\n          const output = await executeTask(opts.task, opts.input, opts.expected!);\n          const duration = Math.round(performance.now() - start);\n          // set task output\n          taskSpan.setAttributes({\n            [Attr.Eval.Task.Output]: JSON.stringify(output),\n          });\n\n          taskSpan.setStatus({ code: SpanStatusCode.OK });\n          taskSpan.end();\n\n          // Get out-of-scope flags from the evaluation context\n          const ctx = getEvalContext();\n          const outOfScopeFlags = ctx.outOfScopeFlags || [];\n\n          return {\n            output,\n            duration,\n            outOfScopeFlags,\n            finalFlags: ctx.flags || {},\n            overrides: ctx.overrides,\n          };\n        },\n      );\n    },\n  );\n\n  return {\n    output,\n    duration,\n    outOfScopeFlags,\n    finalFlags,\n    overrides,\n  };\n};\n","import { execSync } from 'node:child_process';\n\nexport function getGitUserInfo() {\n  try {\n    const name = execSync('git config --get user.name').toString().trim();\n    const email = execSync('git config --get user.email').toString().trim();\n    return { name, email };\n  } catch {\n    return null; // Git not installed or not configured\n  }\n}\n","import type { EvalParams } from './eval.types';\nimport { Eval } from './eval'; // existing Eval function\nimport { withEvalContext } from './context/storage';\n\nexport interface EvalBuilder<\n  AllowedFlags extends Record<string, any> = {},\n  TInput extends string | Record<string, any> = string,\n  TExpected extends string | Record<string, any> = string,\n  TOutput extends string | Record<string, any> = string,\n> {\n  withFlags<F extends Partial<AllowedFlags>>(\n    flags: F,\n  ): EvalBuilder<AllowedFlags, TInput, TExpected, TOutput>;\n  withModel(model: string): EvalBuilder<AllowedFlags, TInput, TExpected, TOutput>;\n  withTimeout(timeout: number): EvalBuilder<AllowedFlags, TInput, TExpected, TOutput>;\n  run(suffix?: string): void; // registers with Vitest\n}\n\nclass EvalBuilderImpl<\n  AllowedFlags extends Record<string, any> = {},\n  TInput extends string | Record<string, any> = string,\n  TExpected extends string | Record<string, any> = string,\n  TOutput extends string | Record<string, any> = string,\n> implements EvalBuilder<AllowedFlags, TInput, TExpected, TOutput>\n{\n  private hasRun = false; // Prevent double registration\n\n  constructor(\n    private name: string,\n    private params: EvalParams<TInput, TExpected, TOutput>,\n    private overrides: {\n      flags?: Partial<AllowedFlags>;\n      model?: string;\n      timeout?: number;\n    } = {},\n  ) {}\n\n  withFlags<F extends Partial<AllowedFlags>>(\n    flags: F,\n  ): EvalBuilder<AllowedFlags, TInput, TExpected, TOutput> {\n    return new EvalBuilderImpl<AllowedFlags, TInput, TExpected, TOutput>(this.name, this.params, {\n      ...this.overrides,\n      flags: { ...this.overrides.flags, ...flags },\n    });\n  }\n\n  withModel(model: string): EvalBuilder<AllowedFlags, TInput, TExpected, TOutput> {\n    return new EvalBuilderImpl<AllowedFlags, TInput, TExpected, TOutput>(this.name, this.params, {\n      ...this.overrides,\n      model,\n    });\n  }\n\n  withTimeout(timeout: number): EvalBuilder<AllowedFlags, TInput, TExpected, TOutput> {\n    return new EvalBuilderImpl<AllowedFlags, TInput, TExpected, TOutput>(this.name, this.params, {\n      ...this.overrides,\n      timeout,\n    });\n  }\n\n  run(suffix = ''): void {\n    if (this.hasRun) {\n      throw new Error(`Eval \"${this.name}\" has already been run. Create a new builder instance.`);\n    }\n    this.hasRun = true;\n\n    const finalName = suffix ? `${this.name}:${suffix}` : this.name;\n    const finalParams: EvalParams<TInput, TExpected, TOutput> = {\n      ...this.params,\n      ...(this.overrides.model && { model: this.overrides.model }),\n      ...(this.overrides.timeout && { timeout: this.overrides.timeout }),\n    };\n\n    // If flags are overridden, wrap the task to set flag context\n    if (this.overrides.flags && Object.keys(this.overrides.flags).length > 0) {\n      const originalTask = finalParams.task;\n      finalParams.task = (args: { input: TInput; expected: TExpected }) => {\n        return withEvalContext({ initialFlags: this.overrides.flags! }, () => originalTask(args));\n      };\n    }\n\n    // Call existing Eval function - this handles all Vitest registration\n    Eval<TInput, TExpected, TOutput>(finalName, finalParams);\n  }\n}\n\n/**\n * Create a new eval builder that can be composed with .withFlags(), .run(), etc.\n * This is the new API alongside the existing Eval() function.\n */\nexport function defineEval<\n  TInput extends string | Record<string, any> = string,\n  TExpected extends string | Record<string, any> = string,\n  TOutput extends string | Record<string, any> = string,\n  AllowedFlags extends Record<string, any> = {},\n>(\n  name: string,\n  params: EvalParams<TInput, TExpected, TOutput>,\n): EvalBuilder<AllowedFlags, TInput, TExpected, TOutput> {\n  return new EvalBuilderImpl<AllowedFlags, TInput, TExpected, TOutput>(name, params);\n}\n\n/**\n * Pre-typed defineEval for app-specific flag/fact types.\n * Created by: const defineAppEval = createTypedDefineEval<AppFlags>();\n */\nexport function createTypedDefineEval<AppFlags extends Record<string, any>>() {\n  return function defineAppEval<\n    TInput extends string | Record<string, any> = string,\n    TExpected extends string | Record<string, any> = string,\n    TOutput extends string | Record<string, any> = string,\n  >(\n    name: string,\n    params: EvalParams<TInput, TExpected, TOutput>,\n  ): EvalBuilder<AppFlags, TInput, TExpected, TOutput> {\n    return defineEval<TInput, TExpected, TOutput, AppFlags>(name, params);\n  };\n}\n","import type { Score, Scorer } from './scorers';\n\n/**\n * Creates a scorer that is both ergonomic for authors and fully generic for\n * the type-system.\n *\n * • If the callback returns a `number`, it is wrapped into { name, score }\n * • If it returns a full `Score`, we only ensure the `name` field is present\n */\nexport function createScorer<TInput = unknown, TExpected = unknown, TOutput = unknown>(\n  name: string,\n  fn: (args: {\n    input: TInput;\n    expected: TExpected;\n    output: TOutput;\n  }) => number | Score | Promise<number | Score>,\n): Scorer<TInput, TExpected, TOutput> {\n  const scorer: Scorer<TInput, TExpected, TOutput> = async (args) => {\n    const res = await fn(args);\n\n    if (typeof res === 'number') {\n      return { name, score: res };\n    }\n\n    // ensure name is always filled in\n    return { ...res, name };\n  };\n\n  // Note: scorer function name will be set by runtime for observability\n\n  return scorer;\n}\n"],"mappings":"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","names":["result","start","duration","output","outOfScopeFlags"]}