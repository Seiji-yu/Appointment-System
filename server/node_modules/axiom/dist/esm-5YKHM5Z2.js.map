{"version":3,"sources":["../../../node_modules/.pnpm/chokidar@4.0.3/node_modules/chokidar/esm/index.js","../../../node_modules/.pnpm/readdirp@4.1.2/node_modules/readdirp/esm/index.js","../../../node_modules/.pnpm/chokidar@4.0.3/node_modules/chokidar/esm/handler.js"],"sourcesContent":["/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */\nimport { stat as statcb } from 'fs';\nimport { stat, readdir } from 'fs/promises';\nimport { EventEmitter } from 'events';\nimport * as sysPath from 'path';\nimport { readdirp } from 'readdirp';\nimport { NodeFsHandler, EVENTS as EV, isWindows, isIBMi, EMPTY_FN, STR_CLOSE, STR_END, } from './handler.js';\nconst SLASH = '/';\nconst SLASH_SLASH = '//';\nconst ONE_DOT = '.';\nconst TWO_DOTS = '..';\nconst STRING_TYPE = 'string';\nconst BACK_SLASH_RE = /\\\\/g;\nconst DOUBLE_SLASH_RE = /\\/\\//;\nconst DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nconst REPLACER_RE = /^\\.[/\\\\]/;\nfunction arrify(item) {\n    return Array.isArray(item) ? item : [item];\n}\nconst isMatcherObject = (matcher) => typeof matcher === 'object' && matcher !== null && !(matcher instanceof RegExp);\nfunction createPattern(matcher) {\n    if (typeof matcher === 'function')\n        return matcher;\n    if (typeof matcher === 'string')\n        return (string) => matcher === string;\n    if (matcher instanceof RegExp)\n        return (string) => matcher.test(string);\n    if (typeof matcher === 'object' && matcher !== null) {\n        return (string) => {\n            if (matcher.path === string)\n                return true;\n            if (matcher.recursive) {\n                const relative = sysPath.relative(matcher.path, string);\n                if (!relative) {\n                    return false;\n                }\n                return !relative.startsWith('..') && !sysPath.isAbsolute(relative);\n            }\n            return false;\n        };\n    }\n    return () => false;\n}\nfunction normalizePath(path) {\n    if (typeof path !== 'string')\n        throw new Error('string expected');\n    path = sysPath.normalize(path);\n    path = path.replace(/\\\\/g, '/');\n    let prepend = false;\n    if (path.startsWith('//'))\n        prepend = true;\n    const DOUBLE_SLASH_RE = /\\/\\//;\n    while (path.match(DOUBLE_SLASH_RE))\n        path = path.replace(DOUBLE_SLASH_RE, '/');\n    if (prepend)\n        path = '/' + path;\n    return path;\n}\nfunction matchPatterns(patterns, testString, stats) {\n    const path = normalizePath(testString);\n    for (let index = 0; index < patterns.length; index++) {\n        const pattern = patterns[index];\n        if (pattern(path, stats)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction anymatch(matchers, testString) {\n    if (matchers == null) {\n        throw new TypeError('anymatch: specify first argument');\n    }\n    // Early cache for matchers.\n    const matchersArray = arrify(matchers);\n    const patterns = matchersArray.map((matcher) => createPattern(matcher));\n    if (testString == null) {\n        return (testString, stats) => {\n            return matchPatterns(patterns, testString, stats);\n        };\n    }\n    return matchPatterns(patterns, testString);\n}\nconst unifyPaths = (paths_) => {\n    const paths = arrify(paths_).flat();\n    if (!paths.every((p) => typeof p === STRING_TYPE)) {\n        throw new TypeError(`Non-string provided as watch path: ${paths}`);\n    }\n    return paths.map(normalizePathToUnix);\n};\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n    let str = string.replace(BACK_SLASH_RE, SLASH);\n    let prepend = false;\n    if (str.startsWith(SLASH_SLASH)) {\n        prepend = true;\n    }\n    while (str.match(DOUBLE_SLASH_RE)) {\n        str = str.replace(DOUBLE_SLASH_RE, SLASH);\n    }\n    if (prepend) {\n        str = SLASH + str;\n    }\n    return str;\n};\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n// TODO: refactor\nconst normalizeIgnored = (cwd = '') => (path) => {\n    if (typeof path === 'string') {\n        return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n    }\n    else {\n        return path;\n    }\n};\nconst getAbsolutePath = (path, cwd) => {\n    if (sysPath.isAbsolute(path)) {\n        return path;\n    }\n    return sysPath.join(cwd, path);\n};\nconst EMPTY_SET = Object.freeze(new Set());\n/**\n * Directory entry.\n */\nclass DirEntry {\n    constructor(dir, removeWatcher) {\n        this.path = dir;\n        this._removeWatcher = removeWatcher;\n        this.items = new Set();\n    }\n    add(item) {\n        const { items } = this;\n        if (!items)\n            return;\n        if (item !== ONE_DOT && item !== TWO_DOTS)\n            items.add(item);\n    }\n    async remove(item) {\n        const { items } = this;\n        if (!items)\n            return;\n        items.delete(item);\n        if (items.size > 0)\n            return;\n        const dir = this.path;\n        try {\n            await readdir(dir);\n        }\n        catch (err) {\n            if (this._removeWatcher) {\n                this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n            }\n        }\n    }\n    has(item) {\n        const { items } = this;\n        if (!items)\n            return;\n        return items.has(item);\n    }\n    getChildren() {\n        const { items } = this;\n        if (!items)\n            return [];\n        return [...items.values()];\n    }\n    dispose() {\n        this.items.clear();\n        this.path = '';\n        this._removeWatcher = EMPTY_FN;\n        this.items = EMPTY_SET;\n        Object.freeze(this);\n    }\n}\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nexport class WatchHelper {\n    constructor(path, follow, fsw) {\n        this.fsw = fsw;\n        const watchPath = path;\n        this.path = path = path.replace(REPLACER_RE, '');\n        this.watchPath = watchPath;\n        this.fullWatchPath = sysPath.resolve(watchPath);\n        this.dirParts = [];\n        this.dirParts.forEach((parts) => {\n            if (parts.length > 1)\n                parts.pop();\n        });\n        this.followSymlinks = follow;\n        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n    }\n    entryPath(entry) {\n        return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, entry.fullPath));\n    }\n    filterPath(entry) {\n        const { stats } = entry;\n        if (stats && stats.isSymbolicLink())\n            return this.filterDir(entry);\n        const resolvedPath = this.entryPath(entry);\n        // TODO: what if stats is undefined? remove !\n        return this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n    }\n    filterDir(entry) {\n        return this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n    }\n}\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nexport class FSWatcher extends EventEmitter {\n    // Not indenting methods for history sake; for now.\n    constructor(_opts = {}) {\n        super();\n        this.closed = false;\n        this._closers = new Map();\n        this._ignoredPaths = new Set();\n        this._throttled = new Map();\n        this._streams = new Set();\n        this._symlinkPaths = new Map();\n        this._watched = new Map();\n        this._pendingWrites = new Map();\n        this._pendingUnlinks = new Map();\n        this._readyCount = 0;\n        this._readyEmitted = false;\n        const awf = _opts.awaitWriteFinish;\n        const DEF_AWF = { stabilityThreshold: 2000, pollInterval: 100 };\n        const opts = {\n            // Defaults\n            persistent: true,\n            ignoreInitial: false,\n            ignorePermissionErrors: false,\n            interval: 100,\n            binaryInterval: 300,\n            followSymlinks: true,\n            usePolling: false,\n            // useAsync: false,\n            atomic: true, // NOTE: overwritten later (depends on usePolling)\n            ..._opts,\n            // Change format\n            ignored: _opts.ignored ? arrify(_opts.ignored) : arrify([]),\n            awaitWriteFinish: awf === true ? DEF_AWF : typeof awf === 'object' ? { ...DEF_AWF, ...awf } : false,\n        };\n        // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n        if (isIBMi)\n            opts.usePolling = true;\n        // Editor atomic write normalization enabled by default with fs.watch\n        if (opts.atomic === undefined)\n            opts.atomic = !opts.usePolling;\n        // opts.atomic = typeof _opts.atomic === 'number' ? _opts.atomic : 100;\n        // Global override. Useful for developers, who need to force polling for all\n        // instances of chokidar, regardless of usage / dependency depth\n        const envPoll = process.env.CHOKIDAR_USEPOLLING;\n        if (envPoll !== undefined) {\n            const envLower = envPoll.toLowerCase();\n            if (envLower === 'false' || envLower === '0')\n                opts.usePolling = false;\n            else if (envLower === 'true' || envLower === '1')\n                opts.usePolling = true;\n            else\n                opts.usePolling = !!envLower;\n        }\n        const envInterval = process.env.CHOKIDAR_INTERVAL;\n        if (envInterval)\n            opts.interval = Number.parseInt(envInterval, 10);\n        // This is done to emit ready only once, but each 'add' will increase that?\n        let readyCalls = 0;\n        this._emitReady = () => {\n            readyCalls++;\n            if (readyCalls >= this._readyCount) {\n                this._emitReady = EMPTY_FN;\n                this._readyEmitted = true;\n                // use process.nextTick to allow time for listener to be bound\n                process.nextTick(() => this.emit(EV.READY));\n            }\n        };\n        this._emitRaw = (...args) => this.emit(EV.RAW, ...args);\n        this._boundRemove = this._remove.bind(this);\n        this.options = opts;\n        this._nodeFsHandler = new NodeFsHandler(this);\n        // You’re frozen when your heart’s not open.\n        Object.freeze(opts);\n    }\n    _addIgnoredPath(matcher) {\n        if (isMatcherObject(matcher)) {\n            // return early if we already have a deeply equal matcher object\n            for (const ignored of this._ignoredPaths) {\n                if (isMatcherObject(ignored) &&\n                    ignored.path === matcher.path &&\n                    ignored.recursive === matcher.recursive) {\n                    return;\n                }\n            }\n        }\n        this._ignoredPaths.add(matcher);\n    }\n    _removeIgnoredPath(matcher) {\n        this._ignoredPaths.delete(matcher);\n        // now find any matcher objects with the matcher as path\n        if (typeof matcher === 'string') {\n            for (const ignored of this._ignoredPaths) {\n                // TODO (43081j): make this more efficient.\n                // probably just make a `this._ignoredDirectories` or some\n                // such thing.\n                if (isMatcherObject(ignored) && ignored.path === matcher) {\n                    this._ignoredPaths.delete(ignored);\n                }\n            }\n        }\n    }\n    // Public methods\n    /**\n     * Adds paths to be watched on an existing FSWatcher instance.\n     * @param paths_ file or file list. Other arguments are unused\n     */\n    add(paths_, _origAdd, _internal) {\n        const { cwd } = this.options;\n        this.closed = false;\n        this._closePromise = undefined;\n        let paths = unifyPaths(paths_);\n        if (cwd) {\n            paths = paths.map((path) => {\n                const absPath = getAbsolutePath(path, cwd);\n                // Check `path` instead of `absPath` because the cwd portion can't be a glob\n                return absPath;\n            });\n        }\n        paths.forEach((path) => {\n            this._removeIgnoredPath(path);\n        });\n        this._userIgnored = undefined;\n        if (!this._readyCount)\n            this._readyCount = 0;\n        this._readyCount += paths.length;\n        Promise.all(paths.map(async (path) => {\n            const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, undefined, 0, _origAdd);\n            if (res)\n                this._emitReady();\n            return res;\n        })).then((results) => {\n            if (this.closed)\n                return;\n            results.forEach((item) => {\n                if (item)\n                    this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n            });\n        });\n        return this;\n    }\n    /**\n     * Close watchers or start ignoring events from specified paths.\n     */\n    unwatch(paths_) {\n        if (this.closed)\n            return this;\n        const paths = unifyPaths(paths_);\n        const { cwd } = this.options;\n        paths.forEach((path) => {\n            // convert to absolute path unless relative path already matches\n            if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n                if (cwd)\n                    path = sysPath.join(cwd, path);\n                path = sysPath.resolve(path);\n            }\n            this._closePath(path);\n            this._addIgnoredPath(path);\n            if (this._watched.has(path)) {\n                this._addIgnoredPath({\n                    path,\n                    recursive: true,\n                });\n            }\n            // reset the cached userIgnored anymatch fn\n            // to make ignoredPaths changes effective\n            this._userIgnored = undefined;\n        });\n        return this;\n    }\n    /**\n     * Close watchers and remove all listeners from watched paths.\n     */\n    close() {\n        if (this._closePromise) {\n            return this._closePromise;\n        }\n        this.closed = true;\n        // Memory management.\n        this.removeAllListeners();\n        const closers = [];\n        this._closers.forEach((closerList) => closerList.forEach((closer) => {\n            const promise = closer();\n            if (promise instanceof Promise)\n                closers.push(promise);\n        }));\n        this._streams.forEach((stream) => stream.destroy());\n        this._userIgnored = undefined;\n        this._readyCount = 0;\n        this._readyEmitted = false;\n        this._watched.forEach((dirent) => dirent.dispose());\n        this._closers.clear();\n        this._watched.clear();\n        this._streams.clear();\n        this._symlinkPaths.clear();\n        this._throttled.clear();\n        this._closePromise = closers.length\n            ? Promise.all(closers).then(() => undefined)\n            : Promise.resolve();\n        return this._closePromise;\n    }\n    /**\n     * Expose list of watched paths\n     * @returns for chaining\n     */\n    getWatched() {\n        const watchList = {};\n        this._watched.forEach((entry, dir) => {\n            const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n            const index = key || ONE_DOT;\n            watchList[index] = entry.getChildren().sort();\n        });\n        return watchList;\n    }\n    emitWithAll(event, args) {\n        this.emit(event, ...args);\n        if (event !== EV.ERROR)\n            this.emit(EV.ALL, event, ...args);\n    }\n    // Common helpers\n    // --------------\n    /**\n     * Normalize and emit events.\n     * Calling _emit DOES NOT MEAN emit() would be called!\n     * @param event Type of event\n     * @param path File or directory path\n     * @param stats arguments to be passed with event\n     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n    async _emit(event, path, stats) {\n        if (this.closed)\n            return;\n        const opts = this.options;\n        if (isWindows)\n            path = sysPath.normalize(path);\n        if (opts.cwd)\n            path = sysPath.relative(opts.cwd, path);\n        const args = [path];\n        if (stats != null)\n            args.push(stats);\n        const awf = opts.awaitWriteFinish;\n        let pw;\n        if (awf && (pw = this._pendingWrites.get(path))) {\n            pw.lastChange = new Date();\n            return this;\n        }\n        if (opts.atomic) {\n            if (event === EV.UNLINK) {\n                this._pendingUnlinks.set(path, [event, ...args]);\n                setTimeout(() => {\n                    this._pendingUnlinks.forEach((entry, path) => {\n                        this.emit(...entry);\n                        this.emit(EV.ALL, ...entry);\n                        this._pendingUnlinks.delete(path);\n                    });\n                }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n                return this;\n            }\n            if (event === EV.ADD && this._pendingUnlinks.has(path)) {\n                event = EV.CHANGE;\n                this._pendingUnlinks.delete(path);\n            }\n        }\n        if (awf && (event === EV.ADD || event === EV.CHANGE) && this._readyEmitted) {\n            const awfEmit = (err, stats) => {\n                if (err) {\n                    event = EV.ERROR;\n                    args[0] = err;\n                    this.emitWithAll(event, args);\n                }\n                else if (stats) {\n                    // if stats doesn't exist the file must have been deleted\n                    if (args.length > 1) {\n                        args[1] = stats;\n                    }\n                    else {\n                        args.push(stats);\n                    }\n                    this.emitWithAll(event, args);\n                }\n            };\n            this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n            return this;\n        }\n        if (event === EV.CHANGE) {\n            const isThrottled = !this._throttle(EV.CHANGE, path, 50);\n            if (isThrottled)\n                return this;\n        }\n        if (opts.alwaysStat &&\n            stats === undefined &&\n            (event === EV.ADD || event === EV.ADD_DIR || event === EV.CHANGE)) {\n            const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n            let stats;\n            try {\n                stats = await stat(fullPath);\n            }\n            catch (err) {\n                // do nothing\n            }\n            // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n            if (!stats || this.closed)\n                return;\n            args.push(stats);\n        }\n        this.emitWithAll(event, args);\n        return this;\n    }\n    /**\n     * Common handler for errors\n     * @returns The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n    _handleError(error) {\n        const code = error && error.code;\n        if (error &&\n            code !== 'ENOENT' &&\n            code !== 'ENOTDIR' &&\n            (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))) {\n            this.emit(EV.ERROR, error);\n        }\n        return error || this.closed;\n    }\n    /**\n     * Helper utility for throttling\n     * @param actionType type being throttled\n     * @param path being acted upon\n     * @param timeout duration of time to suppress duplicate actions\n     * @returns tracking object or false if action should be suppressed\n     */\n    _throttle(actionType, path, timeout) {\n        if (!this._throttled.has(actionType)) {\n            this._throttled.set(actionType, new Map());\n        }\n        const action = this._throttled.get(actionType);\n        if (!action)\n            throw new Error('invalid throttle');\n        const actionPath = action.get(path);\n        if (actionPath) {\n            actionPath.count++;\n            return false;\n        }\n        // eslint-disable-next-line prefer-const\n        let timeoutObject;\n        const clear = () => {\n            const item = action.get(path);\n            const count = item ? item.count : 0;\n            action.delete(path);\n            clearTimeout(timeoutObject);\n            if (item)\n                clearTimeout(item.timeoutObject);\n            return count;\n        };\n        timeoutObject = setTimeout(clear, timeout);\n        const thr = { timeoutObject, clear, count: 0 };\n        action.set(path, thr);\n        return thr;\n    }\n    _incrReadyCount() {\n        return this._readyCount++;\n    }\n    /**\n     * Awaits write operation to finish.\n     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n     * @param path being acted upon\n     * @param threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n     * @param event\n     * @param awfEmit Callback to be called when ready for event to be emitted.\n     */\n    _awaitWriteFinish(path, threshold, event, awfEmit) {\n        const awf = this.options.awaitWriteFinish;\n        if (typeof awf !== 'object')\n            return;\n        const pollInterval = awf.pollInterval;\n        let timeoutHandler;\n        let fullPath = path;\n        if (this.options.cwd && !sysPath.isAbsolute(path)) {\n            fullPath = sysPath.join(this.options.cwd, path);\n        }\n        const now = new Date();\n        const writes = this._pendingWrites;\n        function awaitWriteFinishFn(prevStat) {\n            statcb(fullPath, (err, curStat) => {\n                if (err || !writes.has(path)) {\n                    if (err && err.code !== 'ENOENT')\n                        awfEmit(err);\n                    return;\n                }\n                const now = Number(new Date());\n                if (prevStat && curStat.size !== prevStat.size) {\n                    writes.get(path).lastChange = now;\n                }\n                const pw = writes.get(path);\n                const df = now - pw.lastChange;\n                if (df >= threshold) {\n                    writes.delete(path);\n                    awfEmit(undefined, curStat);\n                }\n                else {\n                    timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval, curStat);\n                }\n            });\n        }\n        if (!writes.has(path)) {\n            writes.set(path, {\n                lastChange: now,\n                cancelWait: () => {\n                    writes.delete(path);\n                    clearTimeout(timeoutHandler);\n                    return event;\n                },\n            });\n            timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval);\n        }\n    }\n    /**\n     * Determines whether user has asked to ignore this path.\n     */\n    _isIgnored(path, stats) {\n        if (this.options.atomic && DOT_RE.test(path))\n            return true;\n        if (!this._userIgnored) {\n            const { cwd } = this.options;\n            const ign = this.options.ignored;\n            const ignored = (ign || []).map(normalizeIgnored(cwd));\n            const ignoredPaths = [...this._ignoredPaths];\n            const list = [...ignoredPaths.map(normalizeIgnored(cwd)), ...ignored];\n            this._userIgnored = anymatch(list, undefined);\n        }\n        return this._userIgnored(path, stats);\n    }\n    _isntIgnored(path, stat) {\n        return !this._isIgnored(path, stat);\n    }\n    /**\n     * Provides a set of common helpers and properties relating to symlink handling.\n     * @param path file or directory pattern being watched\n     */\n    _getWatchHelpers(path) {\n        return new WatchHelper(path, this.options.followSymlinks, this);\n    }\n    // Directory helpers\n    // -----------------\n    /**\n     * Provides directory tracking objects\n     * @param directory path of the directory\n     */\n    _getWatchedDir(directory) {\n        const dir = sysPath.resolve(directory);\n        if (!this._watched.has(dir))\n            this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n        return this._watched.get(dir);\n    }\n    // File helpers\n    // ------------\n    /**\n     * Check for read permissions: https://stackoverflow.com/a/11781404/1358405\n     */\n    _hasReadPermissions(stats) {\n        if (this.options.ignorePermissionErrors)\n            return true;\n        return Boolean(Number(stats.mode) & 0o400);\n    }\n    /**\n     * Handles emitting unlink events for\n     * files and directories, and via recursion, for\n     * files and directories within directories that are unlinked\n     * @param directory within which the following item is located\n     * @param item      base path of item/directory\n     */\n    _remove(directory, item, isDirectory) {\n        // if what is being deleted is a directory, get that directory's paths\n        // for recursive deleting and cleaning of watched object\n        // if it is not a directory, nestedDirectoryChildren will be empty array\n        const path = sysPath.join(directory, item);\n        const fullPath = sysPath.resolve(path);\n        isDirectory =\n            isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);\n        // prevent duplicate handling in case of arriving here nearly simultaneously\n        // via multiple paths (such as _handleFile and _handleDir)\n        if (!this._throttle('remove', path, 100))\n            return;\n        // if the only watched file is removed, watch for its return\n        if (!isDirectory && this._watched.size === 1) {\n            this.add(directory, item, true);\n        }\n        // This will create a new entry in the watched object in either case\n        // so we got to do the directory check beforehand\n        const wp = this._getWatchedDir(path);\n        const nestedDirectoryChildren = wp.getChildren();\n        // Recursively remove children directories / files.\n        nestedDirectoryChildren.forEach((nested) => this._remove(path, nested));\n        // Check if item was on the watched list and remove it\n        const parent = this._getWatchedDir(directory);\n        const wasTracked = parent.has(item);\n        parent.remove(item);\n        // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n        // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n        // but never removed from the map in case the path was deleted.\n        // This leads to an incorrect state if the path was recreated:\n        // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n        if (this._symlinkPaths.has(fullPath)) {\n            this._symlinkPaths.delete(fullPath);\n        }\n        // If we wait for this file to be fully written, cancel the wait.\n        let relPath = path;\n        if (this.options.cwd)\n            relPath = sysPath.relative(this.options.cwd, path);\n        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n            const event = this._pendingWrites.get(relPath).cancelWait();\n            if (event === EV.ADD)\n                return;\n        }\n        // The Entry will either be a directory that just got removed\n        // or a bogus entry to a file, in either case we have to remove it\n        this._watched.delete(path);\n        this._watched.delete(fullPath);\n        const eventName = isDirectory ? EV.UNLINK_DIR : EV.UNLINK;\n        if (wasTracked && !this._isIgnored(path))\n            this._emit(eventName, path);\n        // Avoid conflicts if we later create another file with the same name\n        this._closePath(path);\n    }\n    /**\n     * Closes all watchers for a path\n     */\n    _closePath(path) {\n        this._closeFile(path);\n        const dir = sysPath.dirname(path);\n        this._getWatchedDir(dir).remove(sysPath.basename(path));\n    }\n    /**\n     * Closes only file-specific watchers\n     */\n    _closeFile(path) {\n        const closers = this._closers.get(path);\n        if (!closers)\n            return;\n        closers.forEach((closer) => closer());\n        this._closers.delete(path);\n    }\n    _addPathCloser(path, closer) {\n        if (!closer)\n            return;\n        let list = this._closers.get(path);\n        if (!list) {\n            list = [];\n            this._closers.set(path, list);\n        }\n        list.push(closer);\n    }\n    _readdirp(root, opts) {\n        if (this.closed)\n            return;\n        const options = { type: EV.ALL, alwaysStat: true, lstat: true, ...opts, depth: 0 };\n        let stream = readdirp(root, options);\n        this._streams.add(stream);\n        stream.once(STR_CLOSE, () => {\n            stream = undefined;\n        });\n        stream.once(STR_END, () => {\n            if (stream) {\n                this._streams.delete(stream);\n                stream = undefined;\n            }\n        });\n        return stream;\n    }\n}\n/**\n * Instantiates watcher with paths to be tracked.\n * @param paths file / directory paths\n * @param options opts, such as `atomic`, `awaitWriteFinish`, `ignored`, and others\n * @returns an instance of FSWatcher for chaining.\n * @example\n * const watcher = watch('.').on('all', (event, path) => { console.log(event, path); });\n * watch('.', { atomic: true, awaitWriteFinish: true, ignored: (f, stats) => stats?.isFile() && !f.endsWith('.js') })\n */\nexport function watch(paths, options = {}) {\n    const watcher = new FSWatcher(options);\n    watcher.add(paths);\n    return watcher;\n}\nexport default { watch, FSWatcher };\n","import { stat, lstat, readdir, realpath } from 'node:fs/promises';\nimport { Readable } from 'node:stream';\nimport { resolve as presolve, relative as prelative, join as pjoin, sep as psep } from 'node:path';\nexport const EntryTypes = {\n    FILE_TYPE: 'files',\n    DIR_TYPE: 'directories',\n    FILE_DIR_TYPE: 'files_directories',\n    EVERYTHING_TYPE: 'all',\n};\nconst defaultOptions = {\n    root: '.',\n    fileFilter: (_entryInfo) => true,\n    directoryFilter: (_entryInfo) => true,\n    type: EntryTypes.FILE_TYPE,\n    lstat: false,\n    depth: 2147483648,\n    alwaysStat: false,\n    highWaterMark: 4096,\n};\nObject.freeze(defaultOptions);\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst ALL_TYPES = [\n    EntryTypes.DIR_TYPE,\n    EntryTypes.EVERYTHING_TYPE,\n    EntryTypes.FILE_DIR_TYPE,\n    EntryTypes.FILE_TYPE,\n];\nconst DIR_TYPES = new Set([\n    EntryTypes.DIR_TYPE,\n    EntryTypes.EVERYTHING_TYPE,\n    EntryTypes.FILE_DIR_TYPE,\n]);\nconst FILE_TYPES = new Set([\n    EntryTypes.EVERYTHING_TYPE,\n    EntryTypes.FILE_DIR_TYPE,\n    EntryTypes.FILE_TYPE,\n]);\nconst isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);\nconst wantBigintFsStats = process.platform === 'win32';\nconst emptyFn = (_entryInfo) => true;\nconst normalizeFilter = (filter) => {\n    if (filter === undefined)\n        return emptyFn;\n    if (typeof filter === 'function')\n        return filter;\n    if (typeof filter === 'string') {\n        const fl = filter.trim();\n        return (entry) => entry.basename === fl;\n    }\n    if (Array.isArray(filter)) {\n        const trItems = filter.map((item) => item.trim());\n        return (entry) => trItems.some((f) => entry.basename === f);\n    }\n    return emptyFn;\n};\n/** Readable readdir stream, emitting new files as they're being listed. */\nexport class ReaddirpStream extends Readable {\n    constructor(options = {}) {\n        super({\n            objectMode: true,\n            autoDestroy: true,\n            highWaterMark: options.highWaterMark,\n        });\n        const opts = { ...defaultOptions, ...options };\n        const { root, type } = opts;\n        this._fileFilter = normalizeFilter(opts.fileFilter);\n        this._directoryFilter = normalizeFilter(opts.directoryFilter);\n        const statMethod = opts.lstat ? lstat : stat;\n        // Use bigint stats if it's windows and stat() supports options (node 10+).\n        if (wantBigintFsStats) {\n            this._stat = (path) => statMethod(path, { bigint: true });\n        }\n        else {\n            this._stat = statMethod;\n        }\n        this._maxDepth = opts.depth ?? defaultOptions.depth;\n        this._wantsDir = type ? DIR_TYPES.has(type) : false;\n        this._wantsFile = type ? FILE_TYPES.has(type) : false;\n        this._wantsEverything = type === EntryTypes.EVERYTHING_TYPE;\n        this._root = presolve(root);\n        this._isDirent = !opts.alwaysStat;\n        this._statsProp = this._isDirent ? 'dirent' : 'stats';\n        this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n        // Launch stream with one parent, the root dir.\n        this.parents = [this._exploreDir(root, 1)];\n        this.reading = false;\n        this.parent = undefined;\n    }\n    async _read(batch) {\n        if (this.reading)\n            return;\n        this.reading = true;\n        try {\n            while (!this.destroyed && batch > 0) {\n                const par = this.parent;\n                const fil = par && par.files;\n                if (fil && fil.length > 0) {\n                    const { path, depth } = par;\n                    const slice = fil.splice(0, batch).map((dirent) => this._formatEntry(dirent, path));\n                    const awaited = await Promise.all(slice);\n                    for (const entry of awaited) {\n                        if (!entry)\n                            continue;\n                        if (this.destroyed)\n                            return;\n                        const entryType = await this._getEntryType(entry);\n                        if (entryType === 'directory' && this._directoryFilter(entry)) {\n                            if (depth <= this._maxDepth) {\n                                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n                            }\n                            if (this._wantsDir) {\n                                this.push(entry);\n                                batch--;\n                            }\n                        }\n                        else if ((entryType === 'file' || this._includeAsFile(entry)) &&\n                            this._fileFilter(entry)) {\n                            if (this._wantsFile) {\n                                this.push(entry);\n                                batch--;\n                            }\n                        }\n                    }\n                }\n                else {\n                    const parent = this.parents.pop();\n                    if (!parent) {\n                        this.push(null);\n                        break;\n                    }\n                    this.parent = await parent;\n                    if (this.destroyed)\n                        return;\n                }\n            }\n        }\n        catch (error) {\n            this.destroy(error);\n        }\n        finally {\n            this.reading = false;\n        }\n    }\n    async _exploreDir(path, depth) {\n        let files;\n        try {\n            files = await readdir(path, this._rdOptions);\n        }\n        catch (error) {\n            this._onError(error);\n        }\n        return { files, depth, path };\n    }\n    async _formatEntry(dirent, path) {\n        let entry;\n        const basename = this._isDirent ? dirent.name : dirent;\n        try {\n            const fullPath = presolve(pjoin(path, basename));\n            entry = { path: prelative(this._root, fullPath), fullPath, basename };\n            entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n        }\n        catch (err) {\n            this._onError(err);\n            return;\n        }\n        return entry;\n    }\n    _onError(err) {\n        if (isNormalFlowError(err) && !this.destroyed) {\n            this.emit('warn', err);\n        }\n        else {\n            this.destroy(err);\n        }\n    }\n    async _getEntryType(entry) {\n        // entry may be undefined, because a warning or an error were emitted\n        // and the statsProp is undefined\n        if (!entry && this._statsProp in entry) {\n            return '';\n        }\n        const stats = entry[this._statsProp];\n        if (stats.isFile())\n            return 'file';\n        if (stats.isDirectory())\n            return 'directory';\n        if (stats && stats.isSymbolicLink()) {\n            const full = entry.fullPath;\n            try {\n                const entryRealPath = await realpath(full);\n                const entryRealPathStats = await lstat(entryRealPath);\n                if (entryRealPathStats.isFile()) {\n                    return 'file';\n                }\n                if (entryRealPathStats.isDirectory()) {\n                    const len = entryRealPath.length;\n                    if (full.startsWith(entryRealPath) && full.substr(len, 1) === psep) {\n                        const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n                        // @ts-ignore\n                        recursiveError.code = RECURSIVE_ERROR_CODE;\n                        return this._onError(recursiveError);\n                    }\n                    return 'directory';\n                }\n            }\n            catch (error) {\n                this._onError(error);\n                return '';\n            }\n        }\n    }\n    _includeAsFile(entry) {\n        const stats = entry && entry[this._statsProp];\n        return stats && this._wantsEverything && !stats.isDirectory();\n    }\n}\n/**\n * Streaming version: Reads all files and directories in given root recursively.\n * Consumes ~constant small amount of RAM.\n * @param root Root directory\n * @param options Options to specify root (start directory), filters and recursion depth\n */\nexport function readdirp(root, options = {}) {\n    // @ts-ignore\n    let type = options.entryType || options.type;\n    if (type === 'both')\n        type = EntryTypes.FILE_DIR_TYPE; // backwards-compatibility\n    if (type)\n        options.type = type;\n    if (!root) {\n        throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n    }\n    else if (typeof root !== 'string') {\n        throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n    }\n    else if (type && !ALL_TYPES.includes(type)) {\n        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n    }\n    options.root = root;\n    return new ReaddirpStream(options);\n}\n/**\n * Promise version: Reads all files and directories in given root recursively.\n * Compared to streaming version, will consume a lot of RAM e.g. when 1 million files are listed.\n * @returns array of paths and their entry infos\n */\nexport function readdirpPromise(root, options = {}) {\n    return new Promise((resolve, reject) => {\n        const files = [];\n        readdirp(root, options)\n            .on('data', (entry) => files.push(entry))\n            .on('end', () => resolve(files))\n            .on('error', (error) => reject(error));\n    });\n}\nexport default readdirp;\n","import { watchFile, unwatchFile, watch as fs_watch } from 'fs';\nimport { open, stat, lstat, realpath as fsrealpath } from 'fs/promises';\nimport * as sysPath from 'path';\nimport { type as osType } from 'os';\nexport const STR_DATA = 'data';\nexport const STR_END = 'end';\nexport const STR_CLOSE = 'close';\nexport const EMPTY_FN = () => { };\nexport const IDENTITY_FN = (val) => val;\nconst pl = process.platform;\nexport const isWindows = pl === 'win32';\nexport const isMacos = pl === 'darwin';\nexport const isLinux = pl === 'linux';\nexport const isFreeBSD = pl === 'freebsd';\nexport const isIBMi = osType() === 'OS400';\nexport const EVENTS = {\n    ALL: 'all',\n    READY: 'ready',\n    ADD: 'add',\n    CHANGE: 'change',\n    ADD_DIR: 'addDir',\n    UNLINK: 'unlink',\n    UNLINK_DIR: 'unlinkDir',\n    RAW: 'raw',\n    ERROR: 'error',\n};\nconst EV = EVENTS;\nconst THROTTLE_MODE_WATCH = 'watch';\nconst statMethods = { lstat, stat };\nconst KEY_LISTENERS = 'listeners';\nconst KEY_ERR = 'errHandlers';\nconst KEY_RAW = 'rawEmitters';\nconst HANDLER_KEYS = [KEY_LISTENERS, KEY_ERR, KEY_RAW];\n// prettier-ignore\nconst binaryExtensions = new Set([\n    '3dm', '3ds', '3g2', '3gp', '7z', 'a', 'aac', 'adp', 'afdesign', 'afphoto', 'afpub', 'ai',\n    'aif', 'aiff', 'alz', 'ape', 'apk', 'appimage', 'ar', 'arj', 'asf', 'au', 'avi',\n    'bak', 'baml', 'bh', 'bin', 'bk', 'bmp', 'btif', 'bz2', 'bzip2',\n    'cab', 'caf', 'cgm', 'class', 'cmx', 'cpio', 'cr2', 'cur', 'dat', 'dcm', 'deb', 'dex', 'djvu',\n    'dll', 'dmg', 'dng', 'doc', 'docm', 'docx', 'dot', 'dotm', 'dra', 'DS_Store', 'dsk', 'dts',\n    'dtshd', 'dvb', 'dwg', 'dxf',\n    'ecelp4800', 'ecelp7470', 'ecelp9600', 'egg', 'eol', 'eot', 'epub', 'exe',\n    'f4v', 'fbs', 'fh', 'fla', 'flac', 'flatpak', 'fli', 'flv', 'fpx', 'fst', 'fvt',\n    'g3', 'gh', 'gif', 'graffle', 'gz', 'gzip',\n    'h261', 'h263', 'h264', 'icns', 'ico', 'ief', 'img', 'ipa', 'iso',\n    'jar', 'jpeg', 'jpg', 'jpgv', 'jpm', 'jxr', 'key', 'ktx',\n    'lha', 'lib', 'lvp', 'lz', 'lzh', 'lzma', 'lzo',\n    'm3u', 'm4a', 'm4v', 'mar', 'mdi', 'mht', 'mid', 'midi', 'mj2', 'mka', 'mkv', 'mmr', 'mng',\n    'mobi', 'mov', 'movie', 'mp3',\n    'mp4', 'mp4a', 'mpeg', 'mpg', 'mpga', 'mxu',\n    'nef', 'npx', 'numbers', 'nupkg',\n    'o', 'odp', 'ods', 'odt', 'oga', 'ogg', 'ogv', 'otf', 'ott',\n    'pages', 'pbm', 'pcx', 'pdb', 'pdf', 'pea', 'pgm', 'pic', 'png', 'pnm', 'pot', 'potm',\n    'potx', 'ppa', 'ppam',\n    'ppm', 'pps', 'ppsm', 'ppsx', 'ppt', 'pptm', 'pptx', 'psd', 'pya', 'pyc', 'pyo', 'pyv',\n    'qt',\n    'rar', 'ras', 'raw', 'resources', 'rgb', 'rip', 'rlc', 'rmf', 'rmvb', 'rpm', 'rtf', 'rz',\n    's3m', 's7z', 'scpt', 'sgi', 'shar', 'snap', 'sil', 'sketch', 'slk', 'smv', 'snk', 'so',\n    'stl', 'suo', 'sub', 'swf',\n    'tar', 'tbz', 'tbz2', 'tga', 'tgz', 'thmx', 'tif', 'tiff', 'tlz', 'ttc', 'ttf', 'txz',\n    'udf', 'uvh', 'uvi', 'uvm', 'uvp', 'uvs', 'uvu',\n    'viv', 'vob',\n    'war', 'wav', 'wax', 'wbmp', 'wdp', 'weba', 'webm', 'webp', 'whl', 'wim', 'wm', 'wma',\n    'wmv', 'wmx', 'woff', 'woff2', 'wrm', 'wvx',\n    'xbm', 'xif', 'xla', 'xlam', 'xls', 'xlsb', 'xlsm', 'xlsx', 'xlt', 'xltm', 'xltx', 'xm',\n    'xmind', 'xpi', 'xpm', 'xwd', 'xz',\n    'z', 'zip', 'zipx',\n]);\nconst isBinaryPath = (filePath) => binaryExtensions.has(sysPath.extname(filePath).slice(1).toLowerCase());\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n    if (val instanceof Set) {\n        val.forEach(fn);\n    }\n    else {\n        fn(val);\n    }\n};\nconst addAndConvert = (main, prop, item) => {\n    let container = main[prop];\n    if (!(container instanceof Set)) {\n        main[prop] = container = new Set([container]);\n    }\n    container.add(item);\n};\nconst clearItem = (cont) => (key) => {\n    const set = cont[key];\n    if (set instanceof Set) {\n        set.clear();\n    }\n    else {\n        delete cont[key];\n    }\n};\nconst delFromSet = (main, prop, item) => {\n    const container = main[prop];\n    if (container instanceof Set) {\n        container.delete(item);\n    }\n    else if (container === item) {\n        delete main[prop];\n    }\n};\nconst isEmptySet = (val) => (val instanceof Set ? val.size === 0 : !val);\nconst FsWatchInstances = new Map();\n/**\n * Instantiates the fs_watch interface\n * @param path to be watched\n * @param options to be passed to fs_watch\n * @param listener main event handler\n * @param errHandler emits info about errors\n * @param emitRaw emits raw event data\n * @returns {NativeFsWatcher}\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n    const handleEvent = (rawEvent, evPath) => {\n        listener(path);\n        emitRaw(rawEvent, evPath, { watchedPath: path });\n        // emit based on events occurring for files from a directory's watcher in\n        // case the file's watcher misses it (and rely on throttling to de-dupe)\n        if (evPath && path !== evPath) {\n            fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));\n        }\n    };\n    try {\n        return fs_watch(path, {\n            persistent: options.persistent,\n        }, handleEvent);\n    }\n    catch (error) {\n        errHandler(error);\n        return undefined;\n    }\n}\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param fullPath absolute path bound to fs_watch instance\n */\nconst fsWatchBroadcast = (fullPath, listenerType, val1, val2, val3) => {\n    const cont = FsWatchInstances.get(fullPath);\n    if (!cont)\n        return;\n    foreach(cont[listenerType], (listener) => {\n        listener(val1, val2, val3);\n    });\n};\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param path\n * @param fullPath absolute path\n * @param options to be passed to fs_watch\n * @param handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n    const { listener, errHandler, rawEmitter } = handlers;\n    let cont = FsWatchInstances.get(fullPath);\n    let watcher;\n    if (!options.persistent) {\n        watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n        if (!watcher)\n            return;\n        return watcher.close.bind(watcher);\n    }\n    if (cont) {\n        addAndConvert(cont, KEY_LISTENERS, listener);\n        addAndConvert(cont, KEY_ERR, errHandler);\n        addAndConvert(cont, KEY_RAW, rawEmitter);\n    }\n    else {\n        watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here\n        fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n        if (!watcher)\n            return;\n        watcher.on(EV.ERROR, async (error) => {\n            const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n            if (cont)\n                cont.watcherUnusable = true; // documented since Node 10.4.1\n            // Workaround for https://github.com/joyent/node/issues/4337\n            if (isWindows && error.code === 'EPERM') {\n                try {\n                    const fd = await open(path, 'r');\n                    await fd.close();\n                    broadcastErr(error);\n                }\n                catch (err) {\n                    // do nothing\n                }\n            }\n            else {\n                broadcastErr(error);\n            }\n        });\n        cont = {\n            listeners: listener,\n            errHandlers: errHandler,\n            rawEmitters: rawEmitter,\n            watcher,\n        };\n        FsWatchInstances.set(fullPath, cont);\n    }\n    // const index = cont.listeners.indexOf(listener);\n    // removes this instance's listeners and closes the underlying fs_watch\n    // instance if there are no more listeners left\n    return () => {\n        delFromSet(cont, KEY_LISTENERS, listener);\n        delFromSet(cont, KEY_ERR, errHandler);\n        delFromSet(cont, KEY_RAW, rawEmitter);\n        if (isEmptySet(cont.listeners)) {\n            // Check to protect against issue gh-730.\n            // if (cont.watcherUnusable) {\n            cont.watcher.close();\n            // }\n            FsWatchInstances.delete(fullPath);\n            HANDLER_KEYS.forEach(clearItem(cont));\n            // @ts-ignore\n            cont.watcher = undefined;\n            Object.freeze(cont);\n        }\n    };\n};\n// fs_watchFile helpers\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param path to be watched\n * @param fullPath absolute path\n * @param options options to be passed to fs_watchFile\n * @param handlers container for event listener functions\n * @returns closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n    const { listener, rawEmitter } = handlers;\n    let cont = FsWatchFileInstances.get(fullPath);\n    // let listeners = new Set();\n    // let rawEmitters = new Set();\n    const copts = cont && cont.options;\n    if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n        // \"Upgrade\" the watcher to persistence or a quicker interval.\n        // This creates some unlikely edge case issues if the user mixes\n        // settings in a very weird way, but solving for those cases\n        // doesn't seem worthwhile for the added complexity.\n        // listeners = cont.listeners;\n        // rawEmitters = cont.rawEmitters;\n        unwatchFile(fullPath);\n        cont = undefined;\n    }\n    if (cont) {\n        addAndConvert(cont, KEY_LISTENERS, listener);\n        addAndConvert(cont, KEY_RAW, rawEmitter);\n    }\n    else {\n        // TODO\n        // listeners.add(listener);\n        // rawEmitters.add(rawEmitter);\n        cont = {\n            listeners: listener,\n            rawEmitters: rawEmitter,\n            options,\n            watcher: watchFile(fullPath, options, (curr, prev) => {\n                foreach(cont.rawEmitters, (rawEmitter) => {\n                    rawEmitter(EV.CHANGE, fullPath, { curr, prev });\n                });\n                const currmtime = curr.mtimeMs;\n                if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n                    foreach(cont.listeners, (listener) => listener(path, curr));\n                }\n            }),\n        };\n        FsWatchFileInstances.set(fullPath, cont);\n    }\n    // const index = cont.listeners.indexOf(listener);\n    // Removes this instance's listeners and closes the underlying fs_watchFile\n    // instance if there are no more listeners left.\n    return () => {\n        delFromSet(cont, KEY_LISTENERS, listener);\n        delFromSet(cont, KEY_RAW, rawEmitter);\n        if (isEmptySet(cont.listeners)) {\n            FsWatchFileInstances.delete(fullPath);\n            unwatchFile(fullPath);\n            cont.options = cont.watcher = undefined;\n            Object.freeze(cont);\n        }\n    };\n};\n/**\n * @mixin\n */\nexport class NodeFsHandler {\n    constructor(fsW) {\n        this.fsw = fsW;\n        this._boundHandleError = (error) => fsW._handleError(error);\n    }\n    /**\n     * Watch file for changes with fs_watchFile or fs_watch.\n     * @param path to file or dir\n     * @param listener on fs change\n     * @returns closer for the watcher instance\n     */\n    _watchWithNodeFs(path, listener) {\n        const opts = this.fsw.options;\n        const directory = sysPath.dirname(path);\n        const basename = sysPath.basename(path);\n        const parent = this.fsw._getWatchedDir(directory);\n        parent.add(basename);\n        const absolutePath = sysPath.resolve(path);\n        const options = {\n            persistent: opts.persistent,\n        };\n        if (!listener)\n            listener = EMPTY_FN;\n        let closer;\n        if (opts.usePolling) {\n            const enableBin = opts.interval !== opts.binaryInterval;\n            options.interval = enableBin && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n            closer = setFsWatchFileListener(path, absolutePath, options, {\n                listener,\n                rawEmitter: this.fsw._emitRaw,\n            });\n        }\n        else {\n            closer = setFsWatchListener(path, absolutePath, options, {\n                listener,\n                errHandler: this._boundHandleError,\n                rawEmitter: this.fsw._emitRaw,\n            });\n        }\n        return closer;\n    }\n    /**\n     * Watch a file and emit add event if warranted.\n     * @returns closer for the watcher instance\n     */\n    _handleFile(file, stats, initialAdd) {\n        if (this.fsw.closed) {\n            return;\n        }\n        const dirname = sysPath.dirname(file);\n        const basename = sysPath.basename(file);\n        const parent = this.fsw._getWatchedDir(dirname);\n        // stats is always present\n        let prevStats = stats;\n        // if the file is already being watched, do nothing\n        if (parent.has(basename))\n            return;\n        const listener = async (path, newStats) => {\n            if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))\n                return;\n            if (!newStats || newStats.mtimeMs === 0) {\n                try {\n                    const newStats = await stat(file);\n                    if (this.fsw.closed)\n                        return;\n                    // Check that change event was not fired because of changed only accessTime.\n                    const at = newStats.atimeMs;\n                    const mt = newStats.mtimeMs;\n                    if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n                        this.fsw._emit(EV.CHANGE, file, newStats);\n                    }\n                    if ((isMacos || isLinux || isFreeBSD) && prevStats.ino !== newStats.ino) {\n                        this.fsw._closeFile(path);\n                        prevStats = newStats;\n                        const closer = this._watchWithNodeFs(file, listener);\n                        if (closer)\n                            this.fsw._addPathCloser(path, closer);\n                    }\n                    else {\n                        prevStats = newStats;\n                    }\n                }\n                catch (error) {\n                    // Fix issues where mtime is null but file is still present\n                    this.fsw._remove(dirname, basename);\n                }\n                // add is about to be emitted if file not already tracked in parent\n            }\n            else if (parent.has(basename)) {\n                // Check that change event was not fired because of changed only accessTime.\n                const at = newStats.atimeMs;\n                const mt = newStats.mtimeMs;\n                if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n                    this.fsw._emit(EV.CHANGE, file, newStats);\n                }\n                prevStats = newStats;\n            }\n        };\n        // kick off the watcher\n        const closer = this._watchWithNodeFs(file, listener);\n        // emit an add event if we're supposed to\n        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n            if (!this.fsw._throttle(EV.ADD, file, 0))\n                return;\n            this.fsw._emit(EV.ADD, file, stats);\n        }\n        return closer;\n    }\n    /**\n     * Handle symlinks encountered while reading a dir.\n     * @param entry returned by readdirp\n     * @param directory path of dir being read\n     * @param path of this item\n     * @param item basename of this item\n     * @returns true if no more processing is needed for this entry.\n     */\n    async _handleSymlink(entry, directory, path, item) {\n        if (this.fsw.closed) {\n            return;\n        }\n        const full = entry.fullPath;\n        const dir = this.fsw._getWatchedDir(directory);\n        if (!this.fsw.options.followSymlinks) {\n            // watch symlink directly (don't follow) and detect changes\n            this.fsw._incrReadyCount();\n            let linkPath;\n            try {\n                linkPath = await fsrealpath(path);\n            }\n            catch (e) {\n                this.fsw._emitReady();\n                return true;\n            }\n            if (this.fsw.closed)\n                return;\n            if (dir.has(item)) {\n                if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n                    this.fsw._symlinkPaths.set(full, linkPath);\n                    this.fsw._emit(EV.CHANGE, path, entry.stats);\n                }\n            }\n            else {\n                dir.add(item);\n                this.fsw._symlinkPaths.set(full, linkPath);\n                this.fsw._emit(EV.ADD, path, entry.stats);\n            }\n            this.fsw._emitReady();\n            return true;\n        }\n        // don't follow the same symlink more than once\n        if (this.fsw._symlinkPaths.has(full)) {\n            return true;\n        }\n        this.fsw._symlinkPaths.set(full, true);\n    }\n    _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n        // Normalize the directory name on Windows\n        directory = sysPath.join(directory, '');\n        throttler = this.fsw._throttle('readdir', directory, 1000);\n        if (!throttler)\n            return;\n        const previous = this.fsw._getWatchedDir(wh.path);\n        const current = new Set();\n        let stream = this.fsw._readdirp(directory, {\n            fileFilter: (entry) => wh.filterPath(entry),\n            directoryFilter: (entry) => wh.filterDir(entry),\n        });\n        if (!stream)\n            return;\n        stream\n            .on(STR_DATA, async (entry) => {\n            if (this.fsw.closed) {\n                stream = undefined;\n                return;\n            }\n            const item = entry.path;\n            let path = sysPath.join(directory, item);\n            current.add(item);\n            if (entry.stats.isSymbolicLink() &&\n                (await this._handleSymlink(entry, directory, path, item))) {\n                return;\n            }\n            if (this.fsw.closed) {\n                stream = undefined;\n                return;\n            }\n            // Files that present in current directory snapshot\n            // but absent in previous are added to watch list and\n            // emit `add` event.\n            if (item === target || (!target && !previous.has(item))) {\n                this.fsw._incrReadyCount();\n                // ensure relativeness of path is preserved in case of watcher reuse\n                path = sysPath.join(dir, sysPath.relative(dir, path));\n                this._addToNodeFs(path, initialAdd, wh, depth + 1);\n            }\n        })\n            .on(EV.ERROR, this._boundHandleError);\n        return new Promise((resolve, reject) => {\n            if (!stream)\n                return reject();\n            stream.once(STR_END, () => {\n                if (this.fsw.closed) {\n                    stream = undefined;\n                    return;\n                }\n                const wasThrottled = throttler ? throttler.clear() : false;\n                resolve(undefined);\n                // Files that absent in current directory snapshot\n                // but present in previous emit `remove` event\n                // and are removed from @watched[directory].\n                previous\n                    .getChildren()\n                    .filter((item) => {\n                    return item !== directory && !current.has(item);\n                })\n                    .forEach((item) => {\n                    this.fsw._remove(directory, item);\n                });\n                stream = undefined;\n                // one more time for any missed in case changes came in extremely quickly\n                if (wasThrottled)\n                    this._handleRead(directory, false, wh, target, dir, depth, throttler);\n            });\n        });\n    }\n    /**\n     * Read directory to add / remove files from `@watched` list and re-read it on change.\n     * @param dir fs path\n     * @param stats\n     * @param initialAdd\n     * @param depth relative to user-supplied path\n     * @param target child path targeted for watch\n     * @param wh Common watch helpers for this path\n     * @param realpath\n     * @returns closer for the watcher instance.\n     */\n    async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n        const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n        const tracked = parentDir.has(sysPath.basename(dir));\n        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n            this.fsw._emit(EV.ADD_DIR, dir, stats);\n        }\n        // ensure dir is tracked (harmless if redundant)\n        parentDir.add(sysPath.basename(dir));\n        this.fsw._getWatchedDir(dir);\n        let throttler;\n        let closer;\n        const oDepth = this.fsw.options.depth;\n        if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n            if (!target) {\n                await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n                if (this.fsw.closed)\n                    return;\n            }\n            closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n                // if current directory is removed, do nothing\n                if (stats && stats.mtimeMs === 0)\n                    return;\n                this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n            });\n        }\n        return closer;\n    }\n    /**\n     * Handle added file, directory, or glob pattern.\n     * Delegates call to _handleFile / _handleDir after checks.\n     * @param path to file or ir\n     * @param initialAdd was the file added at watch instantiation?\n     * @param priorWh depth relative to user-supplied path\n     * @param depth Child path actually targeted for watch\n     * @param target Child path actually targeted for watch\n     */\n    async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n        const ready = this.fsw._emitReady;\n        if (this.fsw._isIgnored(path) || this.fsw.closed) {\n            ready();\n            return false;\n        }\n        const wh = this.fsw._getWatchHelpers(path);\n        if (priorWh) {\n            wh.filterPath = (entry) => priorWh.filterPath(entry);\n            wh.filterDir = (entry) => priorWh.filterDir(entry);\n        }\n        // evaluate what is at the path we're being asked to watch\n        try {\n            const stats = await statMethods[wh.statMethod](wh.watchPath);\n            if (this.fsw.closed)\n                return;\n            if (this.fsw._isIgnored(wh.watchPath, stats)) {\n                ready();\n                return false;\n            }\n            const follow = this.fsw.options.followSymlinks;\n            let closer;\n            if (stats.isDirectory()) {\n                const absPath = sysPath.resolve(path);\n                const targetPath = follow ? await fsrealpath(path) : path;\n                if (this.fsw.closed)\n                    return;\n                closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n                if (this.fsw.closed)\n                    return;\n                // preserve this symlink's target path\n                if (absPath !== targetPath && targetPath !== undefined) {\n                    this.fsw._symlinkPaths.set(absPath, targetPath);\n                }\n            }\n            else if (stats.isSymbolicLink()) {\n                const targetPath = follow ? await fsrealpath(path) : path;\n                if (this.fsw.closed)\n                    return;\n                const parent = sysPath.dirname(wh.watchPath);\n                this.fsw._getWatchedDir(parent).add(wh.watchPath);\n                this.fsw._emit(EV.ADD, wh.watchPath, stats);\n                closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n                if (this.fsw.closed)\n                    return;\n                // preserve this symlink's target path\n                if (targetPath !== undefined) {\n                    this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n                }\n            }\n            else {\n                closer = this._handleFile(wh.watchPath, stats, initialAdd);\n            }\n            ready();\n            if (closer)\n                this.fsw._addPathCloser(path, closer);\n            return false;\n        }\n        catch (error) {\n            if (this.fsw._handleError(error)) {\n                ready();\n                return path;\n            }\n        }\n    }\n}\n"],"mappings":"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","names":["stat","readdir","sysPath","basename","stat","lstat","lstat","stat","rawEmitter","listener","basename","dirname","newStats","closer","resolve","realpath","stats","relative","DOUBLE_SLASH_RE","testString","readdir","path","stats","stat","now"]}